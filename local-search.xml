<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>【技术】在 iOS 开发过程中的 MVC 和 MVP 架构</title>
    <link href="/posts/fd807deb.html"/>
    <url>/posts/fd807deb.html</url>
    
    <content type="html"><![CDATA[<div class="note note-success">            <p>年初写的文章，整理下发下博客。</p>          </div><h2 id="一、MVC"><a href="#一、MVC" class="headerlink" title="一、MVC"></a>一、MVC</h2><h3 id="1-1-历史"><a href="#1-1-历史" class="headerlink" title="1.1 历史"></a>1.1 历史</h3><p>MVC 模式最早由 Trygve Reenskaug 在 1978 年提出，距今已有接近 50 年的历史。MVC 最开始是为程序语言 Smalltalk 所设置的一种软件架构，得益于其所提供的编码便利，MVC 逐渐风靡 GUI 编程领域。</p><p>早期 Web 端网页开发（以 JSP 为代表）、桌面程序开发（以 MFC 为代表）以及移动端程序都对 MVC 有这良好的应用以及实践，MVC 也是苹果官方推荐的 App 开发框架。在 MVC 不断发展中，也逐渐衍生了许多 MVC 的变种，如 MVCS、MVA、MVP、MVVM。</p><h3 id="1-2-架构组成"><a href="#1-2-架构组成" class="headerlink" title="1.2 架构组成"></a>1.2 架构组成</h3><p>在<a href="https://en.wikipedia.org/wiki/Model%E2%80%93view%E2%80%93controller?useskin=vector">维基百科</a>的词条中，MVC 将一个 App 划分为三部分：</p><ul><li>Model：数据层，封装与业务逻辑相关的数据以及对数据的处理方法。拥有访问和调整数据的能力</li><li>View：视图层，封装数据的目的显示逻辑，与具体 UI 绘制有关，展现受到 M 数据层的影响</li><li>Controller：控制层，封装业务逻辑，是 M 和 V 的中间人角色，串联起 M 和 V，将 M 中的数据展现到 V 中，将 V 所产生的事件反映到 M 中</li></ul><p>MVC 三个层次的职责含义比较容易理解，比较容易产生异议的是三个层次之间的具体交互关系。MVC 并没有给出标准的层次交互关系，网上流传的诸多 MVC 架构图也是形态各异，无法指明哪种才是标准的 MVC 实现。这里给出几份流传度较大、接受度较大的说法。</p><h4 id="1-2-1-苹果官方推荐的-MVC-架构"><a href="#1-2-1-苹果官方推荐的-MVC-架构" class="headerlink" title="1.2.1 苹果官方推荐的 MVC 架构"></a>1.2.1 苹果官方推荐的 MVC 架构</h4><p>苹果官方所提供的 cocoa touch 一直遵循 MVC 开发模式，也提倡开发者沿用其开发模式。在<a href="https://developer.apple.com/library/archive/documentation/General/Conceptual/CocoaEncyclopedia/Model-View-Controller/Model-View-Controller.html">苹果开发者文档</a>中，苹果给出了 cocoa touch 眼中的 MVC 开发架构图。</p><p><img src="/image/MVCMVP/image1.png" alt="image"></p><p>可以很清晰地从图中看出，C 在整个架构中是属于中心主导角色的。用户在 UI 上（V 层）所进行的动作如点击、滑动，会传导 C 上，C 上针对不同的动作更新 M 以及 V，给予用户 UI 上的反馈。</p><p>在上图中，还可以清晰的看出，V 和 M 层是完全隔离的，V 不能直接操控 M，M 也不能直接触发 V 的更新。</p><p>本文也主要是基于苹果官方给出的 MVC 架构进行拓展解析。</p><h4 id="1-2-2-维基百科给出的-MVC-架构"><a href="#1-2-2-维基百科给出的-MVC-架构" class="headerlink" title="1.2.2 维基百科给出的 MVC 架构"></a>1.2.2 维基百科给出的 MVC 架构</h4><p>维基百科给出了和苹果不太一样的架构图：</p><p><img src="/../image/MVCMVP/image2.png" alt="image"></p><p>维基百科给出的架构图相对来说更加清晰，针对每一层级的的交互进行了解析：</p><ul><li>用户看到视图 View</li><li>用户操控 Controlloer</li><li>Controller 更新数据 Model</li><li>Model 数据更新视图 View</li></ul><p>对比上面的 MVC，读者可能会产生两个疑问：</p><ol><li>为什么用户控制的不是 View 而是 Controller？</li><li>为什么是数据 Model 更新 View 而不是 Controller 更新 View？</li></ol><p>遗憾的是，维基百科没有对这张图进行更进一步的解析，仅仅只是进行了列举。但是从其词条的其他描述，我们可以进行这样的脑补理解：这张图中的连接线并不是代表各个层级的具体交互动作，而是各个层级的交互内涵。</p><ul><li>用户操作 View，在 View 上的点击、滑动，最终是要落到 Controller 上的，在 Controller 上完成“用户动作” -&gt; “应用响应”的转变，所以用户本质上是通过 Controller 来管理到整个 App 的</li><li>同理，View 的更新，本质上是来源于 Model 的更新，也就是，图中 M -&gt; V 的“update”表示的是 V 和 M 的内在关系，不是表示真正的 update 操作，Model 并不会真的持有 View，也不会真去调动 View 的 UI 更新接口</li></ul><h4 id="1-2-3-大多数博客给出的-MVC-架构图"><a href="#1-2-3-大多数博客给出的-MVC-架构图" class="headerlink" title="1.2.3 大多数博客给出的 MVC 架构图"></a>1.2.3 大多数博客给出的 MVC 架构图</h4><p>大多数博客会给出下图所示的架构图：</p><p><img src="/image/MVCMVP/image3.png" alt="image"></p><p>这个也是最简陋的 MVC 架构图，图中只展示了几个对象和之间的箭头。对该图比较公认的解析是：Controlleer 负责对 Model 中的数据进行更新，而视图向模型中请求数据；当有用户的行为触发操作时，会有 Controller 更新 Model，并通知视图进行更新，在这时 View 向 Model 请求新的数据。</p><p>该图和苹果 MVC 架构图最主要的区别是，该图中的视图和模型是存在关联的。<a href="https://zh.wikipedia.org/wiki/ASP.NET_MVC_Framework?useskin=vector">ASP.Net</a> 实现的 MVC 是存在这种关联操作行为的，但是与之相对应的苹果官方所提倡的 MVC，却并不提倡这种关联操作。</p><h4 id="1-2-4-总结"><a href="#1-2-4-总结" class="headerlink" title="1.2.4 总结"></a>1.2.4 总结</h4><p>从这几份架构图可以看出，不同框架、不同领域，对于 MVC 架构的理解是不一样的。笔者的建议是不要被“标准答案”所干扰，关键目光要聚焦在数据 M、视图 V、逻辑 C 三个对象本身上，针对这三个对象在代码中形成清晰明确、便于维护阅读的结构，那就是好的 MVC 架构。</p><p>对于这个三个对象之间的关联关系，可以自取所需做点增删，根据项目所用工具所用语言，选择不同的实现就好。使用 MVC 架构是为了给项目做服务，只要一个项目内的各个模块保持统一的原则，做到高内聚低耦合，那就达到了 MVC 的目标。</p><h3 id="1-3-MVC-实现"><a href="#1-3-MVC-实现" class="headerlink" title="1.3 MVC 实现"></a>1.3 MVC 实现</h3><p>得益于Objective&#x2F;Swift提供的强大编程特性，不同项目在MVC的实现方式也会存在差异。以下以两个项目实例进行解析。</p><h4 id="1-3-1-Standford-CS193P-FaceIt"><a href="#1-3-1-Standford-CS193P-FaceIt" class="headerlink" title="1.3.1 Standford CS193P - FaceIt"></a>1.3.1 Standford CS193P - FaceIt</h4><p>斯坦福开设的 Standford CS193P 课程给出了在苹果官方 MVC 架构图上的 MVC 实现图，实现了一个<a href="https://github.com/MyColourfulLife/FaceIt">表情编辑项目</a>。实现图如下：</p><p><img src="/image/MVCMVP/image4.png" alt="image"></p><ul><li><p>Controller -&gt; View：Controller 可以完全知道视图的所有行为，具有完全控制权。这里提到了 outlet，outlet 是 OC 的一种特殊属性，用关键字 IBOutlet 声明。可以用 outlet 对象指向 IB 中的任何一个 button，通过 outlet 对象，就可以获得该 button 的相关属性<br><img src="/image/MVCMVP/image5.png" alt="image"></p></li><li><p>View -&gt; Controller：View 对具体 Controller 是一无所知的，所以 View 是不能直接调用 Controller 的。Objc 主要通过三种方法进行 View 到 Controller 的通信</p><ul><li><p>Target 方式：将位于 Controller 的目标方法（target），绑定到 View 的行为（action）。当 View 触发了对应行为，View 会发送消息给 Controller 的目标告诉有人对它进行了操作，进而让 Controller 做出响应</p><p>注意，结合 Mainstoryboard 方式进行开发，IBAction 属性相当于将 addtarget 方式进行简写，本文将其视作同一种方式</p><p><img src="/image/MVCMVP/image6.png" alt="image"></p><p><img src="/image/MVCMVP/image7.png" alt="image"></p></li><li><p>Delegate 方式：Controller 实现代理协议接口，当 View 触发了某一个行为，View 会发消息其所持有的 delegate 对象，让 delegate 对象通过协议代理方法去响应行为。View 对于 Controller 依旧是一无所知的，它只知道它本身持有了一个 delegate 对象，这个 delegate 对象可以辅助传递行为<br><img src="/image/MVCMVP/image8.png" alt="image"></p></li><li><p>DataSource 方式：View 不该持有它本身的视图 Model，否则会造成 View 和 Model 之间的耦合。数据应该位于 Model 中，有 UI 无关。所以 Controller 就必须告诉视图它有什么数据。DataSource 是一种特殊的代理，用来给 View 从 Controller 获取数据<br><img src="/image/MVCMVP/image9.png" alt="image"></p></li></ul></li><li><p>Controller -&gt; Model：Controller 同样可以完全控制 Model，可以知道 Model 中的一切；在示例中，表情数据并没有接入网络，仅仅只是手动写死在代码中，这也是一种完全控制的表现<br><img src="/image/MVCMVP/image10.png" alt="image"></p></li><li><p>Model -&gt; Controller：通常情况下，Model 是不会直接喝 Controller 直接通信的，也就是说 Model 不直接持有 Controller 对象。当 Model 中的数据更新时候，Model 可以通过消息通知或 KVO 两种方式告知 Controller，让 Controller 将数据变化反应到 View 中</p></li></ul><p>简单来说，就是 Controller 可以直接调用 View 和 Model，View 通过 Delegate 方式和 Target 方式“调用”Controller，Model 通过 KVO 方式或者消息通知方式“调用”Controller。</p><p>当然这只是提倡的做法，并不意味着一定要这样应用，在实现的时候，我们完全可以只选择其中一种方式完全应用。比如说 View 不通过 Delegate 方式与 Controller 通信，而是使用消息通知方式，再比如说 View 转而使用 block 方式……只要有清晰的脉络或分层，那也是无可厚非的。下面就介绍一个完全利用 KVO 方式实现 MVC 的框架。</p><h4 id="1-3-2-MBMVC"><a href="#1-3-2-MBMVC" class="headerlink" title="1.3.2 MBMVC"></a>1.3.2 MBMVC</h4><p><a href="https://github.com/southpeak/Minya">MBMVC</a> 是 Alibaba 开源的一套简单的 Objc 框架，基于 KVO 实现 MVC 模式。</p><p>这里不针对 MBMVC 框架进行详细解析，可以大致理解其基于 KVO 实现了 Controller、View、Model 之间的通信。示例 Demo 比较简单，界面中有一个按钮，点击按钮弹出弹窗，弹窗展示当前时间，数据源是时间，示例 Demo 架构如下，从图中可以看出，这里实现的是 1.2.3 的 MVC 架构：</p><p><img src="/image/MVCMVP/image11.png" alt="image"></p><p>首先 View 和 Controller 之间，通过数据 Bind 的方式达到完全解耦，Controller 不再直接持有 View。当然初始化 View 等工作，还是在 Controller 中做的。</p><p><img src="/image/MVCMVP/image12.png" alt="image"></p><p>View 对应操作触发时（点击“展示按钮”），更改 KVO 对象标志位。Controller 接收到 KVO 通知，并进行对应操作更新 Model。</p><p><img src="/image/MVCMVP/image13.png" alt="image"></p><p><img src="/image/MVCMVP/image14.png" alt="image"></p><p>这里关注一下 Controller 如何对 Model 进行操作。首先 Controller 不直接操控 Model，而是通过中间对象 Proxy。Proxy 是 Controller 以及 Model 之间关系的一种抽象，这里不去深究细节，大致理解成持有了 Controller 和 Model 的部分 handler 以及 block 即可。</p><p>Model 中直接获取当前日期作为业务数据，然后更新业务 KVO 对象，通知到 View 进行下一步操作（弹出日期弹窗）。注意，这里 Model 是直接通过 KVO 通知到 View 的</p><p><img src="/image/MVCMVP/image15.png" alt="image"></p><p><img src="/image/MVCMVP/image16.png" alt="image"></p><p>MBMVC 实现的较为复杂，导致在编写一个功能反而没有 FaceIt 那么简单，代码可读性也没有那么好。在实现功能的时候，还必须要引入一个业务层的 KVO 对象用以供各方绑定。demo 所涉及的数据变化不多，但是如果是一个存在复杂操作的页面的话，这个 KVO 对象想必会变得很臃肿。</p><p><img src="/image/MVCMVP/image17.png" alt="image"></p><p>这里也提供另外一个基于 KVO 实现的“MVC”模式简单框架–<a href="https://github.com/southpeak/Minya">Minya</a>。Minya 更“纯粹”一点，没有 MBMVC 中 proxy、拦截器等等概念，只有几个 KVO 绑定和更新的 sgar 方法，所以看起来可读性还更高一点。</p><p>Minya 实现的不是 MVC 模式而是 MVCS 模式。但是 MVCS 和 MVC 区别不大，忽略 S 数据存储部分，那它就和 MVC 基本一样了。简单介绍下 MVCS，MVCS 基于 MVC 简单衍生出来的一套架构方案，各个层次的含义基本含义基本相同。从概念上来说，它拆分的部分是 Model 部分，拆出来一 Store，用来专门负责数据存取（但从实际操作的角度来讲，它拆开的是 Controller）。</p><h4 id="1-3-3-总结"><a href="#1-3-3-总结" class="headerlink" title="1.3.3 总结"></a>1.3.3 总结</h4><p>MVC 的实现方式多种多样，即可以想 stanford 那样中规中矩进行编写，也可以接入 MBMVC 或者 Minya 利用 KVO 搞定，当然也可以自己写一些 sugar 方法，巧妙利用 KVO、block、notification 达到目标……各位也可以把目光放到其他领域，去了解一下 JSP、ASP.NET、Rails 等等知名 MVC 框架是怎么实现 MVC 的，比较一下异同，这里就不过多展开了。</p><p>不过纵观上诉例子，虽然实现方法大相径庭，但是还是没有偏离 MVC 三个层次的规则，代码之间的结构也还是比较清晰的，MVC 的目标还是基本达成了。</p><h2 id="二、MVP"><a href="#二、MVP" class="headerlink" title="二、MVP"></a>二、MVP</h2><h3 id="2-1-MVC-遇到的问题"><a href="#2-1-MVC-遇到的问题" class="headerlink" title="2.1 MVC 遇到的问题"></a>2.1 MVC 遇到的问题</h3><p>MVC 模式是一个非常经典且精简的设计模式，常见的 iOS 项目基本上都采用了这种模式进行开发。然而，随着项目规模的增长，MVC 模式已经无法很好地帮助我们解耦，构建一个易维护的项目变得愈发艰难。</p><h4 id="2-1-1-巨型-ViewController"><a href="#2-1-1-巨型-ViewController" class="headerlink" title="2.1.1 巨型 ViewController"></a>2.1.1 巨型 ViewController</h4><p>业务逻辑愈加复杂，导致项目的代码量剧增是最直接的原因。某个 View Controller  可能会有几千行代码，这样的项目代码易读性非常差，维护难度也会增大。厚重的 View Controller 很难维护（由于其庞大的规模）；包含几十个属性，使他们的状态难以管理；遵循许多协议（protocol），导致协议的响应代码和 controller 的逻辑代码混淆在一起……</p><p>巨型 Controller 一般包含以下内容：</p><ol><li>生命周期</li><li>UI 排版</li><li>UI 交互</li><li>数据管理</li><li>业务逻辑</li><li>数据上报</li><li>……</li></ol><p>由于 ViewController 在 MVC 架构中间是逻辑关系主要的承接方，因此 ViewController 随着业务的增加必定会持续增长变得臃肿。</p><p>也有一些给 ViewController“减肥”的措施，例如 objc 中借助分类将 ViewController 拆成多个部分，或者 Rails 中建议的 <a href="https://dev.to/kputra/rails-skinny-controller-skinny-model-5f2k#phase-2">Fat models, Skinny controllers</a> 尝试，但是这只是治标不治本的方法，Controller 依旧在膨胀。</p><h4 id="2-1-2-强耦合的-View-和-Controller"><a href="#2-1-2-强耦合的-View-和-Controller" class="headerlink" title="2.1.2 强耦合的 View 和 Controller"></a>2.1.2 强耦合的 View 和 Controller</h4><p>在 iOS 里面 MVC 的实现方式很难做到如 1.2.1 架构图的那样，因为由于 Apple 的规范，一个界面的呈现都需要构建一个 viewcontroller，而每个 viewcontroller 都带有一个根 view，这就导致 C 和 V 紧密耦合在一起构成了 iOS 里面的 C 层。</p><p><img src="/image/MVCMVP/image19.png" alt="image"></p><p>强耦合的 View 和 Controller，没有区分业务逻辑和业务展示，这对单元测试&amp;自动化测试并不是特别友好。为了测试业务逻辑（页面跳转、点赞、分享），我们必须先生成对应的 View，然后才能进行测试，显然这并不合理。业务逻辑最终改变的是 Model，我们关注点应该在 Controller 和 Model 上，而不是外在 View。</p><h4 id="2-1-3-难以放置的数据逻辑"><a href="#2-1-3-难以放置的数据逻辑" class="headerlink" title="2.1.3 难以放置的数据逻辑"></a>2.1.3 难以放置的数据逻辑</h4><p>按照苹果 MVC，所有对象可以被归类为一个 model，一个 view 或者一个 controller，就这些。那么和一个外部 API 通信（网络通信、数据库）的逻辑应该放到哪？</p><p>你可以放在 Model 中，但是网络调用&#x2F;外部调用，应该是需要异步进行的，这样如果一个网络请求比持有它的 Model 生命周期更长，事情将会变得复杂。那如果放在 Controller 中呢？这也不是一个合适的选择，因为这加剧了 Controller 的臃肿为题，而且还相当于将部分 Model 的概念移动到 Controller 中了，Model 和 Controller 强耦合起来了。</p><p>同理，还有数据格式化逻辑、数据处理逻辑等等一堆难以抉择的问题。</p><h3 id="2-2-MVC-到-MVP"><a href="#2-2-MVC-到-MVP" class="headerlink" title="2.2 MVC 到 MVP"></a>2.2 MVC 到 MVP</h3><p>针对以上 MVC 所带来的问题，IBM 子公司 Taligent 在 90 年代提出了 MVC 的衍生模式——MVP，MVP 进过不断的发展应用，逐渐成为了完善的 MVC 解决方案。MVP 的核心就是：让 M 和 V 完全解耦，通过 Presenter 统一调度管理。</p><h3 id="2-3-架构组成"><a href="#2-3-架构组成" class="headerlink" title="2.3 架构组成"></a>2.3 架构组成</h3><p>下图展示了 MVP 和 MVC 之前的架构区别。MVP 和 MVC 很类似，MVP 的三个层次与 MVC 三个层次基本相同，唯一区别是 Model 和 View 之间不进行通讯，完全是通过 Presenter 完成：</p><p><img src="/image/MVCMVP/image20.png" alt="image"></p><ul><li>Model：数据模型，和 MVC 中的 Model 一样</li><li>View：对应 UI 界面（包括 ViewController、所有视图），负责 View 的绘制以及与用户交互</li><li>Presenter：调度者，负责完成 View 和 Model 间的交互</li></ul><p>从字面意思来理解，MVP 即 Model View Presenter（模型 视图 协调器）。MVP 实现了 Cocoa 的 MVC 的愿景。MVP 的协调器 Presenter 并没有对 ViewController 的声明周期做任何改变，因此 View 可以很容易的被模拟出来。在 Presenter 中根本没有和布局有关的代码，但是它却负责更新 View 的数据和状态。</p><p>简单理解，将一个以 MVC 实现的 App 中 ViewController 的 UI 管理、UI 交互、生命周期逻辑剥离，剩下的 ViewController 就成为了 Presenter。当然 Presenter 一般不会持有所有的 View 对象，而是持有 ViewController 对象，ViewController 是 Presenter 和真正 UI 对象的中间人。为了 Presenter 的通用性，Presenter 一般也不直接持有实际 ViewController 对象并进行调用，而是通过协议接口对 ViewController 进行管理。</p><h3 id="2-4-MVP-实现"><a href="#2-4-MVP-实现" class="headerlink" title="2.4 MVP 实现"></a>2.4 MVP 实现</h3><p>和 MVC 一样，MVP 也有许多种实现方式，即可以使用通知方式实现三个层次之间的通信，也可以利用 KVO 达成目标，或者利用协议以及闭包方式。</p><p>这里以一个比较简单的例子 <a href="https://github.com/nandawperdana/ios-mvp-swift">ios-mvp-swift（邮箱通讯录）</a>进行以协议接口方式实现的 MVP 方案。</p><ul><li><p>Presenter -&gt; View：可以看到 Demo 中，仅包含了一个业务 Presenter。Presenter 首先定义了 View 所需要遵循的协议接口。同时 Presenter 持有一个 var 对象，用于后续绑定具体 ViewController。Presenter 不直接持有具体对象，这给 Presenter 的复用带来了极大的方便，而且也极大方便了 Presenter 的单元测试<br><img src="/image/MVCMVP/image21.png" alt="image"></p></li><li><p>View -&gt; Presenter：View 持有 presneter 对象，在生命周期中，View 也通过 presenter 提供的 attachView 方法进行绑定，建立 View 和 Presenter 的链接。一个 View 可以绑定多个 Presenter，这样一整个 App 就可以切成多个不同的业务点放置到不同 Presenter 中。同时 View 也实现 Presenter 所定义的视图接口，<br>  <img src="/image/MVCMVP/image22.png" alt="image"><br>  <img src="/image/MVCMVP/image23.png" alt="image"></p></li></ul><p>简单理解一下，即当 View 触发动作时，如页面加载完成，就会直接调用 presenter 所提供的数据获取方法。</p><p>在 demo 中，Presenter 通过 getPeople 方法实现了了 View 和 Model 的解耦，我们来看下是怎么做的。</p><p><img src="/image/MVCMVP/image24.png" alt="image"><br><img src="/image/MVCMVP/image25.png" alt="image"></p><ul><li>Presenter 通过调用 view 对象的 startLoading 接口，view 开始展示加载态</li><li>Presenter 调用 Service 的数据加载逻辑，Service 会加载网络数据并且通过回调形式返回 Model 对象</li><li>Presenter 在 Service 的请求闭包中，会根据 Model 内容控制 View 的展示，人数等于 0，View 展示空白态，否则展示具体内容。</li></ul><p>结合整个流程，View 和 Prensenter 通过协议接口建立联系，Presenter 和 Model 通过闭包方式建立联系。Model 全程不知道 View 的存在，View 也全程不知道 Model 的存在，两者隔离。</p><p><img src="/image/MVCMVP/image26.png" alt="image"></p><h3 id="2-5-总结"><a href="#2-5-总结" class="headerlink" title="2.5 总结"></a>2.5 总结</h3><p>对比使用 MVC，MVP 可以更好地为代码进行划分。在上面的例子中，如果使用 MVC，那么业务逻辑就会放置在 ViewController 中，简单的功能点还好，但是如果后续继续拓展起来就不好维护了。</p><p>当然 MVP 也存在一些劣势，比如接口和类数量的增加，但是对比起几千行的 ViewController 来说，这也是值得的。此外使用 MVP 也存在如何划分 Presenter 粒度的问题，粒度过小，presenter 数量膨胀，粒度过大，presenter 又会像 ViewController 一样臃肿，所以如何划分粒度也是值得去实践和考虑的。</p><h2 id="二、MVVM"><a href="#二、MVVM" class="headerlink" title="二、MVVM"></a>二、MVVM</h2><h3 id="3-1-历史"><a href="#3-1-历史" class="headerlink" title="3.1 历史"></a>3.1 历史</h3><p>MVVM 同样也是一个 MVC 改良型架构。MVVM 最早于 2005 年被微软的 WPF 和 Silverlight 的架构师 John Gossman 提出，并且应用在微软的软件开发中。</p><h3 id="3-2-架构组成"><a href="#3-2-架构组成" class="headerlink" title="3.2 架构组成"></a>3.2 架构组成</h3><p>下图是大多数博客以及文章介绍 MVVM 所使用的架构图：</p><p><img src="/image/MVCMVP/image27.png" alt="image"></p><p>从图中可以看出，MVVM 和 MVP 非常相似，MVVM 模式将 Presener 改名为 View Model，除此之外基本上与 MVP 模式完全一致。唯一的区别是，它采用双向绑定（data-binding）：View 的变动，自动反映在 ViewModel，反之亦然。</p><p>在阅读资料的时候，笔者比较倾向于将 MVVM 理解成 MVP 的技术进阶版，也就是在 MVP 基础上使用诸如 RAC、双向绑定的具体能力达到抽离 Controller 逻辑的目标。MVVM 不是一个纯的抽象概念，需要附以具体的框架来进行理解。从这个角度来说，MVVM &#x3D; MVP + 具体技术。</p><p>3.3 MVVM 实现</p><p>笔者暂时还没去深入学习过 MVVM 的实现，就不班门弄斧了。推荐读者自行搜索学习一下</p><h2 id="四、总结"><a href="#四、总结" class="headerlink" title="四、总结"></a>四、总结</h2><p>从代码角度上来说，MVC、MVP、MVVM 本质上没什么，侧重点在于将如何同类型的代码（UI、逻辑、数据）封装到不同的层次中，并且利用各种技术进行层次之间的解耦，方便开发和调试。</p><p>笔者看来，RAC 可以用在 MVP 上，消息通知也可以放在 MVC、MVVM 上，MVVM 上使用 block 和 delegate 也没有什么错误。关键是能不能准确清晰的表达自己的逻辑、UI、数据。能把这三部分切割分离，做到开发者可以清晰地感知各个部分的作用和能力，那在具体实现上也可以稍微搞点外门邪道。同时合适的架构并不一定意味着代码量的减少，有时候反而代码量和文件数会增加一些。但是采用新的架构的原则一定是这个架构可以让我们的项目结构变得清晰，维护成本大大降低。</p><p>当然，由于 MVC&#x2F;MVP&#x2F;MVVM 实现方式的侧重点不同，不同类型的项目还是存在模式选择差异的：</p><ul><li>如果项目比较简单，复杂性角度，迭代更改稍，那就可以不用管设计模式了，将每个模块封装好，方便调用就好</li><li>在上述基础上，如果只是存在部分复杂逻辑的情况，或者存在复用性要求，可以使用 MVC 来进一步强化项目的结构。MVC 也是 MVP、MVVM 的基础，在 MVC 基础上进行改进，最终也可能会演进成 MVP、MVVM</li><li>如果偏向展示型的项目，绝大多数业务逻辑都是后端负责处理，app 主要功能是展示数据和交互，可以考虑使用 MVVM</li><li>对于工具类或者本地存在比较多业务逻辑的项目，可以考虑 MVP 或 MVVM</li></ul><p>不管是哪种模式，只要使用得当，都可以达到想要的结果。</p>]]></content>
    
    
    <categories>
      
      <category>技术</category>
      
    </categories>
    
    
    <tags>
      
      <tag>架构</tag>
      
      <tag>MVC</tag>
      
      <tag>iOS 开发</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【笔记】图解HTTP（下）</title>
    <link href="/posts/cdaa17bd.html"/>
    <url>/posts/cdaa17bd.html</url>
    
    <content type="html"><![CDATA[<h2 id="第七章-确保Web安全的HTTPS"><a href="#第七章-确保Web安全的HTTPS" class="headerlink" title="第七章 确保Web安全的HTTPS"></a>第七章 确保Web安全的HTTPS</h2><h3 id="7-1-HTTP的缺点"><a href="#7-1-HTTP的缺点" class="headerlink" title="7.1 HTTP的缺点"></a>7.1 HTTP的缺点</h3><ul><li><p>HTTP主要有这些不足，例举如下（这些问题不仅在HTTP上出现，其他未加密的协议中也会存在这类问题）</p><ul><li><p>通信使用明文（不加密），内容可能会被窃听</p></li><li><p>不验证通信方的身份，因此有可能遭遇伪装</p></li><li><p>无法证明报文的完整性，所以有可能已遭篡改</p></li></ul></li><li><p>除此之外，HTTP本身还有很多缺点。而且，还有像某些特定的Web服务器和特定的Web浏览器在实际应用中存在的不足（也可以说成是脆弱性或安全漏洞），另外，用Java和PHP等编程语言开发的Web应用也可能存在安全漏洞</p></li></ul><h4 id="7-1-1-通信使用明文可能会被窃听"><a href="#7-1-1-通信使用明文可能会被窃听" class="headerlink" title="7.1.1 通信使用明文可能会被窃听"></a>7.1.1 通信使用明文可能会被窃听</h4><ul><li><p>由于HTTP本身不具备加密的功能，所以也无法做到对通信整体（使用HTTP协议通信的请求和响应的内容）进行加密。即，HTTP报文使用明文（指未经过加密的报文）方式发送</p></li><li><p>TCP&#x2F;IP是可能被窃听的网络</p><ul><li><p>如果要问为什么通信时不加密是一个缺点，这是因为，按TCP&#x2F;IP协议族的工作机制，通信内容在所有的通信线路上都有可能遭到窥视</p></li><li><p>所谓互联网，是由能连通到全世界的网络组成的。无论世界哪个角落的服务器在和客户端通信时，在此通信线路上的某些网络设备、光缆、计算机等都不可能是个人的私有物，所以不排除某个环节中会遭到恶意窥视行为</p></li><li><p>即使已经过加密处理的通信，也会被窥视到通信内容，这点和未加密的通信是相同的。只是说如果通信经过加密，就有可能让人无法破解报文信息的含义，但加密处理后的报文信息本身还是会被看到的</p></li><li><p>窃听相同段上的通信并非难事。只需要收集在互联网上流动的数据包（帧）就行了。对于收集来的数据包的解析工作，可交给那些抓包（Packet Capture）或嗅探器（Sniffer）工具</p></li></ul></li><li><p>加密处理可以防止被窃听，在目前大家正在研究的如何防止窃听保护信息的几种对策中，最为普及的就是加密技术。加密的对象可以有这么几个</p><ul><li><p>通信的加密</p><p><img src="/image/%E5%9B%BE%E8%A7%A3HTTP/cd1b66ee5dd195a2de74b236785127ee0bf4b899.jpeg" alt="epub_907764_163.jpeg"></p><ul><li>一种方式就是将通信加密</li><li>HTTP协议中没有加密机制，但可以通过和SSL（Secure Socket Layer，安全套接层）或TLS（Transport LayerSecurity，安全传输层协议）的组合使用，加密HTTP的通信内容。用SSL建立安全通信线路之后，就可以在这条线路上进行HTTP通信了</li><li>与SSL组合使用的HTTP被称为HTTPS（HTTP Secure，超文本传输安全协议）或HTTP over SSL</li></ul></li><li><p>内容的加密</p><p><img src="/image/%E5%9B%BE%E8%A7%A3HTTP/cb3ffdba1c9cf383c9c967819ee6e4a75fc5aacf.jpeg" alt="epub_907764_164.jpeg"></p><ul><li>还有一种将参与通信的内容本身加密的方式</li><li>由于HTTP协议中没有加密机制，那么就对HTTP协议传输的内容本身加密。即把HTTP报文里所含的内容进行加密处理</li><li>在这种情况下，客户端需要对HTTP报文进行加密处理后再发送请求</li><li>诚然，为了做到有效的内容加密，前提是要求客户端和服务器同时具备加密和解密机制</li><li>有一点必须引起注意，由于该方式不同于SSL或TLS将整个通信线路加密处理，所以内容仍有被篡改的风险。稍后我们会加以说明</li></ul></li></ul></li></ul><h4 id="7-1-2-不验证通信方的身份就可能遭遇伪装"><a href="#7-1-2-不验证通信方的身份就可能遭遇伪装" class="headerlink" title="7.1.2 不验证通信方的身份就可能遭遇伪装"></a>7.1.2 不验证通信方的身份就可能遭遇伪装</h4><ul><li><p>HTTP协议中的请求和响应不会对通信方进行确认。也就是说存在“服务器是否就是发送请求中URI真正指定的主机，返回的响应是否真的返回到实际提出请求的客户端”等类似问题</p></li><li><p>在HTTP协议通信时，由于不存在确认通信方的处理步骤，任何人都可以发起请求。另外，服务器只要接收到请求，不管对方是谁都会返回一个响应（但也仅限于发送端的IP地址和端口号没有被Web服务器设定限制访问的前提下）</p></li><li><p>HTTP协议的实现本身非常简单，不论是谁发送过来的请求都会返回响应，因此不确认通信方，会存在以下各种隐患</p><ul><li><p>无法确定请求发送至目标的Web服务器是否是按真实意图返回响应的那台服务器。有可能是已伪装的Web服务器</p></li><li><p>无法确定响应返回到的客户端是否是按真实意图接收响应的那个客户端。有可能是已伪装的客户端</p></li><li><p>无法确定正在通信的对方是否具备访问权限。因为某些Web服务器上保存着重要的信息，只想发给特定用户通信的权限</p></li><li><p>无法判定请求是来自何方、出自谁手</p></li><li><p>即使是无意义的请求也会照单全收。无法阻止海量请求下的DoS攻击（Denial of Service，拒绝服务攻击）</p></li></ul></li><li><p>查明对手的证书</p><ul><li><p>虽然使用HTTP协议无法确定通信方，但如果使用SSL则可以。SSL不仅提供加密处理，而且还使用了一种被称为证书的手段，可用于确定方</p></li><li><p>证书由值得信任的第三方机构颁发，用以证明服务器和客户端是实际存在的。另外，伪造证书从技术角度来说是异常困难的一件事。所以只要能够确认通信方（服务器或客户端）持有的证书，即可判断通信方的真实意图</p></li><li><p>通过使用证书，以证明通信方就是意料中的服务器。这对使用者个人来讲，也减少了个人信息泄露的危险性</p></li><li><p>另外，客户端持有证书即可完成个人身份的确认，也可用于对Web网站的认证环节</p></li></ul></li></ul><h4 id="7-1-3-无法证明报文完整性，可能已遭篡改"><a href="#7-1-3-无法证明报文完整性，可能已遭篡改" class="headerlink" title="7.1.3 无法证明报文完整性，可能已遭篡改"></a>7.1.3 无法证明报文完整性，可能已遭篡改</h4><ul><li><p>所谓完整性是指信息的准确度。若无法证明其完整性，通常也就意味着无法判断信息是否准确</p></li><li><p>接收到的内容可能有误</p><ul><li><p>由于HTTP协议无法证明通信的报文完整性，因此，在请求或响应送出之后直到对方接收之前的这段时间内，即使请求或响应的内容遭到篡改，也没有办法获悉</p></li><li><p>换句话说，没有任何办法确认，发出的请求&#x2F;响应和接收到的请求&#x2F;响应是前后相同的</p></li><li><p>比如，从某个Web网站上下载内容，是无法确定客户端下载的文件和服务器上存放的文件是否前后一致的。文件内容在传输途中可能已经被篡改为其他的内容。即使内容真的已改变，作为接收方的客户端也是觉察不到的</p></li><li><p>像这样，请求或响应在传输途中，遭攻击者拦截并篡改内容的攻击称为中间人攻击（Man-in-the-Middle attack,MITM）</p></li></ul></li><li><p>如何防止篡改</p><ul><li><p>虽然有使用HTTP协议确定报文完整性的方法，但事实上并不便捷、可靠。其中常用的是MD5和SHA-1等散列值校验的方法，以及用来确认文件的数字签名方法</p></li><li><p>提供文件下载服务的Web网站也会提供相应的以PGP（Pretty GoodPrivacy，完美隐私）创建的数字签名及MD5算法生成的散列值</p><ul><li><p>PGP是用来证明创建文件的数字签名，MD5是由单向函数生成的散列值</p></li><li><p>不论使用哪一种方法，都需要操纵客户端的用户本人亲自检查验证下载的文件是否就是原来服务器上的文件。浏览器无法自动帮用户检查</p></li></ul></li><li><p>可惜的是，用这些方法也依然无法百分百保证确认结果正确。因为PGP和MD5本身被改写的话，用户是没有办法意识到的</p></li></ul></li><li><p>为了有效防止这些弊端，有必要使用HTTPS。SSL提供认证和加密处理及摘要功能。仅靠HTTP确保完整性是非常困难的，因此通过和其他协议组合使用来实现这个目标</p></li></ul><h3 id="7-2-HTTP-加密-认证-完整性保护-x3D-HTTPS"><a href="#7-2-HTTP-加密-认证-完整性保护-x3D-HTTPS" class="headerlink" title="7.2 HTTP+加密+认证+完整性保护&#x3D;HTTPS"></a>7.2 HTTP+加密+认证+完整性保护&#x3D;HTTPS</h3><h4 id="7-2-1-HTTP加上加密处理和认证以及完整性保护后即是HTTPS"><a href="#7-2-1-HTTP加上加密处理和认证以及完整性保护后即是HTTPS" class="headerlink" title="7.2.1 HTTP加上加密处理和认证以及完整性保护后即是HTTPS"></a>7.2.1 HTTP加上加密处理和认证以及完整性保护后即是HTTPS</h4><ul><li><p>为了统一解决窃听和篡改这些问题，需要在HTTP上再加入加密处理和认证等机制。我们把添加了加密及认证机制的HTTP称为HTTPS（HTTP Secure）</p><ul><li><p>如果在HTTP协议通信过程中使用未经加密的明文，比如在Web页面中输入信用卡号，如果这条通信线路遭到窃听，那么信用卡号就暴露了</p></li><li><p>另外，对于HTTP来说，服务器也好，客户端也好，都是没有办法确认通信方的。因为很有可能并不是和原本预想的通信方在实际通信。并且还需要考虑到接收到的报文在通信途中已经遭到篡改这一可能性</p></li></ul></li><li><p>使用HTTPS通信时，不再用http:&#x2F;&#x2F;，而是改用https:&#x2F;&#x2F;。另外，当浏览器访问HTTPS通信有效的Web网站时，浏览器的地址栏内会出现一个带锁的标记。对HTTPS的显示方式会因浏览器的不同而有所改变</p></li></ul><h4 id="7-2-2-HTTPS是身披SSL外壳的HTTP"><a href="#7-2-2-HTTPS是身披SSL外壳的HTTP" class="headerlink" title="7.2.2 HTTPS是身披SSL外壳的HTTP"></a>7.2.2 HTTPS是身披SSL外壳的HTTP</h4><ul><li><p>HTTPS并非是应用层的一种新协议。只是HTTP通信接口部分用SSL（SecureSocket Layer）和TLS（Transport Layer Security）协议代替而已</p></li><li><p>通常，HTTP直接和TCP通信。当使用SSL时，则演变成先和SSL通信，再由SSL和TCP通信了。简言之，所谓HTTPS，其实就是身披SSL协议这层外壳的HTTP</p><p><img src="/image/%E5%9B%BE%E8%A7%A3HTTP/08ce162fc302af3d09cab6d774dee5072c6f0abe.jpeg" alt="epub_907764_172.jpeg"></p></li><li><p>在采用SSL后，HTTP就拥有了HTTPS的加密、证书和完整性保护这些功能</p></li><li><p>SSL是独立于HTTP的协议，所以不光是HTTP协议，其他运行在应用层的SMTP和Telnet等协议均可配合SSL协议使用。可以说SSL是当今世界上应用最为广泛的网络安全技术</p></li></ul><h4 id="7-2-3-相互交换密钥的公开密钥加密技术"><a href="#7-2-3-相互交换密钥的公开密钥加密技术" class="headerlink" title="7.2.3 相互交换密钥的公开密钥加密技术"></a>7.2.3 相互交换密钥的公开密钥加密技术</h4><ul><li><p>SSL采用一种叫做公开密钥加密（Public-key cryptography）的加密处理方式</p><ul><li><p>近代的加密方法中加密算法是公开的，而密钥却是保密的。通过这种方式得以保持加密方法的安全性</p></li><li><p>加密和解密都会用到密钥。没有密钥就无法对密码解密，反过来说，任何人只要持有密钥就能解密了。如果密钥被攻击者获得，那加密也就失去了意义</p></li></ul></li><li><p>共享密钥加密的困境</p><ul><li><p>加密和解密同用一个密钥的方式称为共享密钥加密（Common key cryptosystem），也被叫做对称密钥加密</p></li><li><p>以共享密钥方式加密时必须将密钥也发给对方。可究竟怎样才能安全地转交？在互联网上转发密钥时，如果通信被监听那么密钥就可会落入攻击者之手，同时也就失去了加密的意义。另外还得设法安全地保管接收到的密钥</p></li></ul></li><li><p>使用两把密钥的公开密钥加密</p><ul><li><p>公开密钥加密方式很好地解决了共享密钥加密的困难。公开密钥加密使用一对非对称的密钥。一把叫做私有密钥（private key），另一把叫做公开密钥（public key）。顾名思义，私有密钥不能让其他任何人知道，而公开密钥则可以随意发布，任何人都可以获得</p></li><li><p>使用公开密钥加密方式，发送密文的一方使用对方的公开密钥进行加密处理，对方收到被加密的信息后，再使用自己的私有密钥进行解密。利用这种方式，不需要发送用来解密的私有密钥，也不必担心密钥被攻击者窃听而盗走</p></li><li><p>另外，要想根据密文和公开密钥，恢复到信息原文是异常困难的，因为解密过程就是在对离散对数进行求值，这并非轻而易举就能办到。退一步讲，如果能对一个非常大的整数做到快速地因式分解，那么密码破解还是存在希望的。但就目前的技术来看是不太现实的</p></li></ul></li><li><p>HTTPS采用混合加密机制</p><ul><li><p>HTTPS采用共享密钥加密和公开密钥加密两者并用的混合加密机制</p><ul><li>若密钥能够实现安全交换，那么有可能会考虑仅使用公开密钥加密来通信。但是公开密钥加密与共享密钥加密相比，其处理速度要慢</li></ul></li><li><p>HTTPS充分利用两者各自的优势，将多种方法组合起来用于通信。在交换密钥环节使用公开密钥加密方式，之后的建立通信交换报文阶段则使用共享密钥加密方式</p></li><li><p>混合加密机制</p><p><img src="/image/%E5%9B%BE%E8%A7%A3HTTP/b1283b222cf4fb4e047be231871b8bab593b6a6d.jpeg" alt="epub_907764_176.jpeg"></p></li></ul></li></ul><h4 id="7-2-4-证明公开密钥正确性的证书"><a href="#7-2-4-证明公开密钥正确性的证书" class="headerlink" title="7.2.4 证明公开密钥正确性的证书"></a>7.2.4 证明公开密钥正确性的证书</h4><ul><li><p>遗憾的是，公开密钥加密方式还是存在一些问题的。那就是无法证明公开密钥本身就是货真价实的公开密钥</p><ul><li><p>比如，正准备和某台服务器建立公开密钥加密方式下的通信时，如何证明收到的公开密钥就是原本预想的那台服务器发行的公开密钥。或许在公开密钥传输途中，真正的公开密钥已经被攻击者替换掉了</p></li><li><p>为了解决上述问题，可以使用由数字证书认证机构（CA,CertificateAuthority）和其相关机关颁发的公开密钥证书</p></li></ul></li><li><p>数字证书认证机构处于客户端与服务器双方都可信赖的第三方机构的立场上。威瑞信（VeriSign）就是其中一家非常有名的数字证书认证机构</p></li><li><p>数字证书认证机构的业务流程</p><ul><li><p>首先，服务器的运营人员向数字证书认证机构提出公开密钥的申请</p></li><li><p>数字证书认证机构在判明提出申请者的身份之后，会对已申请的公开密钥做数字签名，然后分配这个已签名的公开密钥，并将该公开密钥放入公钥证书后绑定在一起</p></li><li><p>然后服务器会将这份由数字证书认证机构颁发的公钥证书发送给客户端，以进行公开密钥加密方式通信。公钥证书也可叫做数字证书或直接称为证书</p></li><li><p>接到证书的客户端可使用数字证书认证机构的公开密钥，对那张证书上的数字签名进行验证，一旦验证通过，客户端便可明确两件事</p><ul><li><p>一，认证服务器的公开密钥的是真实有效的数字证书认证机构</p></li><li><p>二，服务器的公开密钥是值得信赖的</p></li></ul></li><li><p>此处认证机关的公开密钥必须安全地转交给客户端。使用通信方式时，如何安全转交是一件很困难的事，因此，多数浏览器开发商发布版本时，会事先在内部植入常用认证机关的公开密钥</p></li></ul></li><li><p>数字证书认证机构的业务流程示意图</p><p><img src="/image/%E5%9B%BE%E8%A7%A3HTTP/328cb6a376336530bb68d7ee02a4e8034a47509e.jpeg" alt="epub_907764_177.jpeg"></p></li><li><p><a href="https://www.zhihu.com/question/25912483">RSA的公钥和私钥到底哪个才是用来加密和哪个用来解密？</a></p></li><li><p>可证明组织真实性的EV SSL证书</p><ul><li><p>证书的一个作用是用来证明作为通信一方的服务器是否规范，另外一个作用是可确认对方服务器背后运营的企业是否真实存在。拥有该特性的证书就是EVSSL证书（Extended Validation SSL Certificate）</p></li><li><p>EV SSL证书是基于国际标准的认证指导方针颁发的证书。其严格规定了对运营组织是否真实的确认方针，因此，通过认证的Web网站能够获得更高的认可度</p></li></ul></li><li><p>用以确认客户端的客户端证书</p><ul><li>HTTPS中还可以使用客户端证书。以客户端证书进行客户端认证，证明服务器正在通信的对方始终是预料之内的客户端，其作用跟服务器证书如出一辙</li></ul></li><li><p>客户端证书仍存在几处问题点</p><ul><li><p>其中的一个问题点是证书的获取及发布</p><ul><li><p>想获取证书时，用户得自行安装客户端证书。但由于客户端证书是要付费购买的，且每张证书对应到每位用户也就意味着需支付和用户数对等的费用</p></li><li><p>另外，要让知识层次不同的用户们自行安装证书，这件事本身也充满了各种挑战</p></li><li><p>现状是，安全性极高的认证机构可颁发客户端证书但仅用于特殊用途的业务。比如那些可支撑客户端证书支出费用的业务。例如，银行的网上银行就采用了客户端证书。在登录网银时不仅要求用户确认输入ID和密码，还会要求用户的客户端证书，以确认用户是否从特定的终端访问网银</p></li></ul></li><li><p>客户端证书存在的另一个问题点是，客户端证书毕竟只能用来证明客户端实际存在，而不能用来证明用户本人的真实有效性。也就是说，只要获得了安装有客户端证书的计算机的使用权限，也就意味着同时拥有了客户端证书的使用权限</p></li></ul></li><li><p>认证机构信誉第一</p><ul><li><p>SSL机制中介入认证机构之所以可行，是因为建立在其信用绝对可靠这一大前提下的</p><ul><li>然而，2011年7月，荷兰的一家名叫DigiNotar的认证机构曾遭黑客不法入侵，颁布了google.com和twitter.com等网站的伪造证书事件。这一事件从根本上撼动了SSL的可信度</li></ul></li><li><p>因为伪造证书上有正规认证机构的数字签名，所以浏览器会判定该证书是正当的。当伪造的证书被用做服务器伪装之时，用户根本无法察觉到</p></li><li><p>虽然存在可将证书无效化的证书吊销列表（Certificate RevocationList,CRL）机制，以及从客户端删除根证书颁发机构（Root CertificateAuthority,RCA）的对策，但是距离生效还需要一段时间，而在这段时间内，到底会有多少用户的利益蒙受损失就不得而知了</p></li></ul></li><li><p>由自认证机构颁发的证书称为自签名证书</p><ul><li><p>如果使用OpenSSL这套开源程序，每个人都可以构建一套属于自己的认证机构，从而自己给自己颁发服务器证书。但该服务器证书在互联网上不可作为证书使用，似乎没什么帮助</p></li><li><p>独立构建的认证机构叫做自认证机构，由自认证机构颁发的“无用”证书也被戏称为自签名证书</p></li><li><p>浏览器访问该服务器时，会显示“无法确认连接安全性”或“该网站的安全证书存在问题”等警告消息</p></li><li><p>由自认证机构颁发的服务器证书之所以不起作用，是因为它无法消除伪装的可能性。自认证机构能够产生的作用顶多也就是自己对外宣称“我是○○”的这种程度。即使采用自签名证书，通过SSL加密之后，可能偶尔还会看见通信处在安全状态的提示，可那也是有问题的。因为就算加密通信，也不能排除正在和已经过伪装的假服务器保持通信</p></li><li><p>值得信赖的第三方机构介入认证，才能让已植入在浏览器内的认证机构颁布的公开密钥发挥作用，并借此证明服务器的真实性</p></li><li><p>中级认证机构的证书可能会变成自认证证书</p><ul><li><p>多数浏览器内预先已植入备受信赖的认证机构的证书，但也有一小部分浏览器会植入中级认证机构的证书</p></li><li><p>对于中级认证机构颁发的服务器证书，某些浏览器会以正规的证书来对待，可有的浏览器会当作自签名证书</p></li></ul></li></ul></li></ul><h4 id="7-2-5-HTTPS的安全通信机制"><a href="#7-2-5-HTTPS的安全通信机制" class="headerlink" title="7.2.5 HTTPS的安全通信机制"></a>7.2.5 HTTPS的安全通信机制</h4><ul><li><p>HTTPS的通信步骤示意图</p><p><img src="/image/%E5%9B%BE%E8%A7%A3HTTP/8a54ed4c911a400389078b93383040f467703a4f.jpeg" alt="epub_907764_181.jpeg"></p></li><li><p>HTTPS的通信步骤</p><ul><li><p>步骤1：客户端通过发送Client Hello报文开始SSL通信。报文中包含客户端支持的SSL的指定版本、加密组件（Cipher Suite）列表（所使用的加密算法及密钥长度等）</p></li><li><p>步骤2：服务器可进行SSL通信时，会以Server Hello报文作为应答。和客户端一样，在报文中包含SSL版本以及加密组件。服务器的加密组件内容是从接收到的客户端加密组件内筛选出来的</p></li><li><p>步骤3：之后服务器发送Certificate报文。报文中包含公开密钥证书</p></li><li><p>步骤4：最后服务器发送Server Hello Done报文通知客户端，最初阶段的SSL握手协商部分结束</p></li><li><p>步骤5：SSL第一次握手结束之后，客户端以Client Key Exchange报文作为回应。报文中包含通信加密中使用的一种被称为Pre-master secret的随机密码串。该报文已用步骤3中的公开密钥进行加密</p></li><li><p>步骤6：接着客户端继续发送Change Cipher Spec报文。该报文会提示服务器，在此报文之后的通信会采用Pre-master secret密钥加密</p></li><li><p>步骤7：客户端发送Finished报文。该报文包含连接至今全部报文的整体校验值。这次握手协商是否能够成功，要以服务器是否能够正确解密该报文作为判定标准</p></li><li><p>步骤8：服务器同样发送Change Cipher Spec报文</p></li><li><p>步骤9：服务器同样发送Finished报文</p></li><li><p>步骤10：服务器和客户端的Finished报文交换完毕之后，SSL连接就算建立完成。当然，通信会受到SSL的保护。从此处开始进行应用层协议的通信，即发送HTTP请求</p></li><li><p>步骤11：应用层协议通信，即发送HTTP响应</p></li><li><p>步骤12：最后由客户端断开连接。断开连接时，发送close_notify报文。上图做了一些省略，这步之后再发送TCP FIN报文来关闭与TCP的通信</p></li></ul></li><li><p>在以上流程中，应用层发送数据时会附加一种叫做MAC（MessageAuthentication Code）的报文摘要。MAC能够查知报文是否遭到篡改，从而保护报文的完整性</p></li><li><p>下面是对整个流程的图解。图中说明了从仅使用服务器端的公开密钥证书（服务器证书）建立HTTPS通信的整个过程</p><p><img src="/image/%E5%9B%BE%E8%A7%A3HTTP/8fe626de0c86d600f3132156f627b0bb10224468.jpeg" alt="epub_907764_182.jpeg"></p><ul><li>CBC模式（Cipher Block Chaining）又名密码分组链接模式。在此模式下，将前一个明文块加密处理后和下一个明文块做XOR运算，使之重叠，然后再对运算结果做加密处理。对第一个明文块做加密时，要么使用前一段密文的最后一块，要么利用外部生成的初始向量（initial vector,IV）。——译者注</li></ul></li><li><p>SSL和TLS</p><ul><li><p>HTTPS使用SSL（Secure Socket Layer）和TLS（Transport LayerSecurity）这两个协议</p></li><li><p>SSL技术最初是由浏览器开发商网景通信公司率先倡导的，开发过SSL3.0之前的版本。目前主导权已转移到IETF（Internet Engineering TaskForce,Internet工程任务组）的手中</p></li><li><p>IETF以SSL3.0为基准，后又制定了TLS1.0、TLS1.1和TLS1.2。TSL是以SSL为原型开发的协议，有时会统一称该协议为SSL。当前主流的版本是SSL3.0和TLS1.0</p></li><li><p>由于SSL1.0协议在设计之初被发现出了问题，就没有实际投入使用。SSL2.0也被发现存在问题，所以很多浏览器直接废除了该协议版本</p></li></ul></li><li><p>HTTPS也存在一些问题，那就是当使用SSL时，它的处理速度会变慢</p><ul><li><p>SSL的慢分两种。一种是指通信慢。另一种是指由于大量消耗CPU及内存等资源，导致处理速度变慢</p></li><li><p>和使用HTTP相比，网络负载可能会变慢2到100倍。除去和TCP连接、发送HTTP请求&#x2F;响应以外，还必须进行SSL通信，因此整体上处理通信量不可避免会增加</p></li><li><p>另一点是SSL必须进行加密处理。在服务器和客户端都需要进行加密和解密的运算处理。因此从结果上讲，比起HTTP会更多地消耗服务器和客户端的硬件资源，导致负载增强</p></li><li><p>针对速度变慢这一问题，并没有根本性的解决方案，我们会使用SSL加速器这种（专用服务器）硬件来改善该问题。该硬件为SSL通信专用硬件，相对软件来讲，能够提高数倍SSL的计算速度。仅在SSL处理时发挥SSL加速器的功效，以分担负载</p></li></ul></li><li><p>既然HTTPS那么安全可靠，那为何所有的Web网站不一直使用HTTPS？</p><ul><li><p>其中一个原因是，因为与纯文本通信相比，加密通信会消耗更多的CPU及内存资源</p><ul><li><p>如果每次通信都加密，会消耗相当多的资源，平摊到一台计算机上时，能够处理的请求数量必定也会随之减少</p></li><li><p>因此，如果是非敏感信息则使用HTTP通信，只有在包含个人信息等敏感数据时，才利用HTTPS加密通信</p></li><li><p>特别是每当那些访问量较多的Web网站在进行加密处理时，它们所承担着的负载不容小觑</p></li><li><p>在进行加密处理时，并非对所有内容都进行加密处理，而是仅在那些需要信息隐藏时才会加密，以节约资源</p></li></ul></li><li><p>除此之外，想要节约购买证书的开销也是原因之一</p><ul><li><p>要进行HTTPS通信，证书是必不可少的。而使用的证书必须向认证机构（CA）购买。证书价格可能会根据不同的认证机构略有不同</p></li><li><p>那些购买证书并不合算的服务以及一些个人网站，可能只会选择采用HTTP的通信方式</p></li></ul></li></ul></li></ul><h2 id="第八章-确认访问用户身份的认证"><a href="#第八章-确认访问用户身份的认证" class="headerlink" title="第八章 确认访问用户身份的认证"></a>第八章 确认访问用户身份的认证</h2><h3 id="8-1-何为认证"><a href="#8-1-何为认证" class="headerlink" title="8.1 何为认证"></a>8.1 何为认证</h3><ul><li><p>计算机本身无法判断坐在显示器前的使用者的身份。进一步说，也无法确认网络的那头究竟有谁。可见，为了弄清究竟是谁在访问服务器，就得让对方的客户端自报家门</p></li><li><p>可是，就算正在访问服务器的对方声称自己是ueno，身份是否属实这点却也无从谈起。为确认ueno本人是否真的具有访问系统的权限，就需要核对“登录者本人才知道的信息”、“登录者本人才会有的信息”</p></li><li><p>核对的信息通常是指以下这些</p><ul><li><p>密码：只有本人才会知道的字符串信息</p></li><li><p>动态令牌：仅限本人持有的设备内显示的一次性密码</p></li><li><p>数字证书：仅限本人（终端）持有的信息</p></li><li><p>生物认证：指纹和虹膜等本人的生理信息</p></li><li><p>IC卡等：仅限本人持有的信息</p></li></ul></li><li><p>但是，即便对方是假冒的用户，只要能通过用户验证，那么计算机就会默认是出自本人的行为。因此，掌控机密信息的密码绝不能让他人得到，更不能轻易地就被破解出来</p></li><li><p>HTTP&#x2F;1.1使用的认证方式如下所示</p><ul><li><p>BASIC认证（基本认证）</p></li><li><p>DIGEST认证（摘要认证）</p></li><li><p>SSL客户端认证</p></li><li><p>FormBase认证（基于表单认证）</p></li></ul></li><li><p>此外，还有Windows统一认证（Keberos认证、NTLM认证），但本书不作讲解</p></li></ul><h4 id="8-2-BASIC认证"><a href="#8-2-BASIC认证" class="headerlink" title="8.2 BASIC认证"></a>8.2 BASIC认证</h4><ul><li><p>BASIC认证（基本认证）是从HTTP&#x2F;1.0就定义的认证方式。即便是现在仍有一部分的网站会使用这种认证方式。是Web服务器与通信客户端之间进行的认证方式</p></li><li><p>BASIC认证的认证步骤示意图</p><p><img src="/image/%E5%9B%BE%E8%A7%A3HTTP/a046dd02432af0a827e6bcfbd55eaf27f7432c76.jpeg" alt="epub_907764_187.jpeg"></p></li><li><p>BASIC认证的认证步骤</p><ul><li><p>步骤1：当请求的资源需要BASIC认证时，服务器会随状态码401Authorization Required，返回带WWW-Authenticate首部字段的响应。该字段内包含认证的方式（BASIC）及Request-URI安全域字符串（realm）</p></li><li><p>步骤2：接收到状态码401的客户端为了通过BASIC认证，需要将用户ID及密码发送给服务器。发送的字符串内容是由用户ID和密码构成，两者中间以冒号（:）连接后，再经过Base64编码处理</p></li><li><p>步骤3：接收到包含首部字段Authorization请求的服务器，会对认证信息的正确性进行验证。如验证通过，则返回一条包含Request-URI资源的响应</p></li></ul></li><li><p>BASIC认证虽然采用Base64编码方式，但这不是加密处理。不需要任何附加信息即可对其解码。换言之，由于明文解码后就是用户ID和密码，在HTTP等非加密通信的线路上进行BASIC认证的过程中，如果被人窃听，被盗的可能性极高</p></li><li><p>另外，除此之外想再进行一次BASIC认证时，一般的浏览器却无法实现认证注销操作，这也是问题之一</p></li><li><p>BASIC认证使用上不够便捷灵活，且达不到多数Web网站期望的安全性等级，因此它并不常用</p></li></ul><h3 id="8-3-DIGEST认证"><a href="#8-3-DIGEST认证" class="headerlink" title="8.3 DIGEST认证"></a>8.3 DIGEST认证</h3><ul><li><p>为弥补BASIC认证存在的弱点，从HTTP&#x2F;1.1起就有了DIGEST认证。DIGEST认证同样使用质询&#x2F;响应的方式（challenge&#x2F;response），但不会像BASIC认证那样直接发送明文密码</p></li><li><p>所谓质询响应方式是指，一开始一方会先发送认证要求给另一方，接着使用从另一方那接收到的质询码计算生成响应码。最后将响应码返回给对方进行认证的方式。因为发送给对方的只是响应摘要及由质询码产生的计算结果，所以比起BASIC认证，密码泄露的可能性就降低了</p></li><li><p>DIGEST认证的认证步骤示意图</p><p><img src="/image/%E5%9B%BE%E8%A7%A3HTTP/0335941db02beca1a1ea8bc27355c27bce8ee66b.jpeg" alt="epub_907764_190.jpeg"></p></li><li><p>DIGEST认证的认证步骤</p><ul><li><p>步骤1：请求需认证的资源时，服务器会随着状态码401 AuthorizationRequired，返回带WWW-Authenticate首部字段的响应</p><ul><li><p>该字段内包含质问响应方式认证所需的临时质询码（随机数，nonce）</p></li><li><p>首部字段WWW-Authenticate内必须包含realm和nonce这两个字段的信息。客户端就是依靠向服务器回送这两个值进行认证的</p></li><li><p>nonce是一种每次随返回的401响应生成的任意随机字符串。该字符串通常推荐由Base64编码的十六进制数的组成形式，但实际内容依赖服务器的具体实现</p></li></ul></li><li><p>步骤2： 接收到401状态码的客户端，返回的响应中包含DIGEST认证必须的首部字段Authorization信息</p><ul><li><p>首部字段Authorization内必须包含username、realm、nonce、uri和response的字段信息</p></li><li><p>其中，realm和nonce就是之前从服务器接收到的响应中的字段。username是realm限定范围内可进行认证的用户名</p></li><li><p>uri（digest-uri）即Request-URI的值，但考虑到经代理转发后Request-URI的值可能被修改，因此事先会复制一份副本保存在uri内</p></li><li><p>response也可叫做Request-Digest，存放经过MD5运算后的密码字符串，形成响应码</p></li><li><p>响应中其他的实体请参见第6章的请求首部字段Authorization。另外，有关Request-Digest的计算规则较复杂，有兴趣的读者不妨深入学习一下RFC2617</p></li></ul></li><li><p>步骤3：接收到包含首部字段Authorization请求的服务器，会确认认证信息的正确性。认证通过后则返回包含Request-URI资源的响应。并且这时会在首部字段Authentication-Info写入一些认证成功的相关信息</p></li></ul></li><li><p>DIGEST认证提供了高于BASIC认证的安全等级，但是和HTTPS的客户端认证相比仍旧很弱。DIGEST认证提供防止密码被窃听的保护机制，但并不存在防止用户伪装的保护机制。DIGEST认证和BASIC认证一样，使用上不那么便捷灵活，且仍达不到多数Web网站对高度安全等级的追求标准。因此它的适用范围也有所受限</p></li></ul><h3 id="8-4-SSL客户端认证"><a href="#8-4-SSL客户端认证" class="headerlink" title="8.4 SSL客户端认证"></a>8.4 SSL客户端认证</h3><ul><li><p>从使用用户ID和密码的认证方式方面来讲，只要二者的内容正确，即可认证是本人的行为。但如果用户ID和密码被盗，就很有可能被第三者冒充。利用SSL客户端认证则可以避免该情况的发生</p></li><li><p>SSL客户端认证是借由HTTPS的客户端证书完成认证的方式。凭借客户端证书（在HTTPS一章已讲解）认证，服务器可确认访问是否来自已登录的客户端</p></li><li><p>SSL客户端认证的认证步骤</p><ul><li><p>为达到SSL客户端认证的目的，需要事先将客户端证书分发给客户端，且客户端必须安装此证书</p></li><li><p>步骤1：接收到需要认证资源的请求，服务器会发送Certificate Request报文，要求客户端提供客户端证书</p></li><li><p>步骤2：用户选择将发送的客户端证书后，客户端会把客户端证书信息以Client Certificate报文方式发送给服务器</p></li><li><p>步骤3：服务器验证客户端证书验证通过后方可领取证书内客户端的公开密钥，然后开始HTTPS加密通信</p></li></ul></li><li><p>SSL客户端认证采用双因素认证</p><ul><li><p>在多数情况下，SSL客户端认证不会仅依靠证书完成认证，一般会和基于表单认证（稍后讲解）组合形成一种双因素认证（Two-factor authentication）来使用</p></li><li><p>所谓双因素认证就是指，认证过程中不仅需要密码这一个因素，还需要申请认证者提供其他持有信息，从而作为另一个因素，与其组合使用的认证方式</p></li><li><p>换言之，第一个认证因素的SSL客户端证书用来认证客户端计算机，另一个认证因素的密码则用来确定这是用户本人的行为</p></li><li><p>通过双因素认证后，就可以确认是用户本人正在使用匹配正确的计算机访问服务器</p></li></ul></li><li><p>SSL客户端认证必要的费用</p><ul><li><p>使用SSL客户端认证需要用到客户端证书。而客户端证书需要支付一定费用才能使用</p></li><li><p>这里提到的费用是指，从认证机构购买客户端证书的费用，以及服务器运营者为保证自己搭建的认证机构安全运营所产生的费用</p></li><li><p>每个认证机构颁发客户端证书的费用不尽相同，平摊到一张证书上，一年费用约几万至十几万日元。服务器运营者也可以自己搭建认证机构，但要维持安全运行就会产生相应的费用</p></li></ul></li></ul><h3 id="8-5-基于表单认证"><a href="#8-5-基于表单认证" class="headerlink" title="8.5 基于表单认证"></a>8.5 基于表单认证</h3><ul><li><p>基于表单的认证方法并不是在HTTP协议中定义的。客户端会向服务器上的Web应用程序发送登录信息（Credential），按登录信息的验证结果认证</p></li><li><p>根据Web应用程序的实际安装，提供的用户界面及认证方式也各不相同。多数情况下，输入已事先登录的用户ID（通常是任意字符串或邮件地址）和密码等登录信息后，发送给Web应用程序，基于认证结果来决定认证是否成功</p></li></ul><h4 id="8-5-1-认证多半为基于表单认证"><a href="#8-5-1-认证多半为基于表单认证" class="headerlink" title="8.5.1 认证多半为基于表单认证"></a>8.5.1 认证多半为基于表单认证</h4><ul><li><p>由于使用上的便利性及安全性问题，HTTP协议标准提供的BASIC认证和DIGEST认证几乎不怎么使用。另外，SSL客户端认证虽然具有高度的安全等级，但因为导入及维持费用等问题，还尚未普及</p></li><li><p>比如SSH和FTP协议，服务器与客户端之间的认证是合乎标准规范的，并且满足了最基本的功能需求上的安全使用级别，因此这些协议的认证可以拿来直接使用。但是对于Web网站的认证功能，能够满足其安全使用级别的标准规范并不存在，所以只好使用由Web应用程序各自实现基于表单的认证方式</p></li><li><p>不具备共同标准规范的表单认证，在每个Web网站上都会有各不相同的实现方式。如果是全面考虑过安全性能而实现的表单认证，那么就能够具备高度的安全等级。但在表单认证的实现中存在问题的Web网站也是屡见不鲜</p></li></ul><h4 id="8-5-2-Session管理及Cookie应用"><a href="#8-5-2-Session管理及Cookie应用" class="headerlink" title="8.5.2 Session管理及Cookie应用"></a>8.5.2 Session管理及Cookie应用</h4><ul><li><p>基于表单认证的标准规范尚未有定论，一般会使用Cookie来管理Session（会话）</p></li><li><p>基于表单认证本身是通过服务器端的Web应用，将客户端发送过来的用户ID和密码与之前登录过的信息做匹配来进行认证的。但鉴于HTTP是无状态协议，之前已认证成功的用户状态无法通过协议层面保存下来。即，无法实现状态管理，因此即使当该用户下一次继续访问，也无法区分他与其他的用户。于是我们会使用Cookie来管理Session，以弥补HTTP协议中不存在的状态管理功能</p></li><li><p>Session管理及Cookie状态管理示意图</p><p><img src="/image/%E5%9B%BE%E8%A7%A3HTTP/5e55b586420671e8aef78c33cbb15d2bf66884ab.jpeg" alt="epub_907764_193.jpeg"></p></li><li><p>Session管理及Cookie状态管理</p><ul><li><p>步骤1：客户端把用户ID和密码等登录信息放入报文的实体部分，通常是以POST方法把请求发送给服务器。而这时，会使用HTTPS通信来进行HTML表单画面的显示和用户输入数据的发送</p></li><li><p>步骤2：服务器会发放用以识别用户的Session ID。通过验证从客户端发送过来的登录信息进行身份认证，然后把用户的认证状态与Session ID绑定后记录在服务器端</p><ul><li><p>向客户端返回响应时，会在首部字段Set-Cookie内写入SessionID（如PHPSESSID&#x3D;028a8c…）</p></li><li><p>你可以把Session ID想象成一种用以区分不同用户的等位号。然而，如果Session ID被第三方盗走，对方就可以伪装成你的身份进行恶意操作了。因此必须防止Session ID被盗，或被猜出。为了做到这点，Session ID应使用难以推测的字符串，且服务器端也需要进行有效期的管理，保证其安全性</p></li><li><p>另外，为减轻跨站脚本攻击（XSS）造成的损失，建议事先在Cookie内加上httponly属性</p></li></ul></li><li><p>步骤3：客户端接收到从服务器端发来的Session ID后，会将其作为Cookie保存在本地。下次向服务器发送请求时，浏览器会自动发送Cookie，所以Session ID也随之发送到服务器。服务器端可通过验证接收到的Session ID识别用户和其认证状态</p></li></ul></li><li><p>另外，不仅基于表单认证的登录信息及认证过程都无标准化的方法，服务器端应如何保存用户提交的密码等登录信息等也没有标准化</p><ul><li>通常，一种安全的保存方法是，先利用给密码加盐（salt）[插图]的方式增加额外信息，再使用散列（hash）函数计算出散列值后保存。但是我们也经常看到直接保存明文密码的做法，而这样的做法具有导致密码泄露的风险</li><li>salt其实就是由服务器随机生成的一个字符串，但是要保证长度足够长，并且是真正随机生成的。然后把它和密码字符串相连接（前后都可以）生成散列值。当两个用户使用了同一个密码时，由于随机生成的salt值不同，对应的散列值也将是不同的。这样一来，很大程度上减少了密码特征，攻击者也就很难利用自己手中的密码特征库进行破解。——译者注</li></ul></li></ul><h2 id="第九章-基于HTTP的功能追加协议"><a href="#第九章-基于HTTP的功能追加协议" class="headerlink" title="第九章 基于HTTP的功能追加协议"></a>第九章 基于HTTP的功能追加协议</h2><ul><li><p>为何HTTP协议受众如此广泛？本章讲解了几个与HTTP相关联的协议使用案例。为什么HTTP协议受众能够如此广泛呢？</p><ul><li><p>过去，新编写接入互联网的系统或软件时，还需要同时编写实现与必要功能对应的新协议。但最近，使用HTTP的系统和软件占了绝大多数</p></li><li><p>这有着诸多原因，其中与企业或组织的防火墙设定有着莫大的关系。防火墙的基本功能就是禁止非指定的协议和端口号的数据包通过。因此如果使用新协议或端口号则必须修改防火墙设置</p></li><li><p>互联网上，使用率最高的当属Web。不管是否具备访问FTP和SSH的权限，一般公司都会开放对Web的访问。Web是基于HTTP协议运作的，因此在构建Web服务器或访问Web站点时，需事先设置防火墙HTTP（80&#x2F;tcp）和HTTPS（443&#x2F;tcp）的权限</p></li><li><p>许多公司或组织已设定权限将HTTP作为通信环境，因此无须再修改防火墙的设定。可见HTTP具有导入简单这一大优势。而这也是基于HTTP服务或内容不断增加的原因之一</p></li><li><p>还有一些其他原因，比如，作为HTTP客户端的浏览器已相当普遍，HTTP服务器的数量已颇具规模，HTTP本身就是优异的应用等</p></li></ul></li></ul><h3 id="9-1-基于HTTP的协议"><a href="#9-1-基于HTTP的协议" class="headerlink" title="9.1 基于HTTP的协议"></a>9.1 基于HTTP的协议</h3><ul><li><p>在建立HTTP标准规范时，制订者主要想把HTTP当作传输HTML文档的协议。随着时代的发展，Web的用途更具多样性，比如演化成在线购物网站、SNS（Social Networking Service，社交网络服务）、企业或组织内部的各种管理工具，等等</p></li><li><p>而这些网站所追求的功能可通过Web应用和脚本程序实现。即使这些功能已经满足需求，在性能上却未必最优，这是因为HTTP协议上的限制以及自身性能有限</p></li><li><p>HTTP功能上的不足可通过创建一套全新的协议来弥补。可是目前基于HTTP的Web浏览器的使用环境已遍布全球，因此无法完全抛弃HTTP。有一些新协议的规则是基于HTTP的，并在此基础上添加了新的功能</p></li></ul><h4 id="9-2-消除HTTP瓶颈的SPDY"><a href="#9-2-消除HTTP瓶颈的SPDY" class="headerlink" title="9.2 消除HTTP瓶颈的SPDY"></a>9.2 消除HTTP瓶颈的SPDY</h4><ul><li>Google在2010年发布了SPDY（取自SPeeDY，发音同speedy），其开发目标旨在解决HTTP的性能瓶颈，缩短Web页面的加载时间（50%）</li></ul><h4 id="9-2-1-HTTP的瓶颈"><a href="#9-2-1-HTTP的瓶颈" class="headerlink" title="9.2.1 HTTP的瓶颈"></a>9.2.1 HTTP的瓶颈</h4><ul><li><p>对于Facebook等社交网站，为了尽可能实时地显示更新的内容，服务器上一有内容更新，就需要直接把那些内容反馈到客户端的界面上。虽然看起来挺简单的，但HTTP却无法妥善地处理好这项任务</p></li><li><p>使用HTTP协议探知服务器上是否有内容更新，就必须频繁地从客户端到服务器端进行确认。如果服务器上没有内容更新，那么就会产生徒劳的通信</p></li><li><p>若想在现有Web实现所需的功能，以下这些HTTP标准就会成为瓶颈</p><ul><li><p>一条连接上只可发送一个请求</p></li><li><p>请求只能从客户端开始。客户端不可以接收除响应以外的指令</p></li><li><p>请求&#x2F;响应首部未经压缩就发送。首部信息越多延迟越大</p></li><li><p>发送冗长的首部。每次互相发送相同的首部造成的浪费较多</p></li><li><p>可任意选择数据压缩格式。非强制压缩发送</p></li></ul></li><li><p>Ajax的解决方法</p><ul><li><p>Ajax（Asynchronous JavaScript and XML，异步JavaScript与XML技术）是一种有效利用JavaScript和DOM（Document Object Model，文档对象模型）的操作，以达到局部Web页面替换加载的异步通信手段。和以前的同步通信相比，由于它只更新一部分页面，响应中传输的数据量会因此而减少，这一优点显而易见</p></li><li><p>Ajax的核心技术是名为XMLHttpRequest的API，通过JavaScript脚本语言的调用就能和服务器进行HTTP通信。借由这种手段，就能从已加载完毕的Web页面上发起请求，只更新局部页面</p></li><li><p>而利用Ajax实时地从服务器获取内容，有可能会导致大量请求产生。另外，Ajax仍未解决HTTP协议本身存在的问题</p></li></ul></li><li><p>Comet的解决方法</p><ul><li><p>一旦服务器端有内容更新了，Comet不会让请求等待，而是直接给客户端返回响应。这是一种通过延迟应答，模拟实现服务器端向客户端推送（ServerPush）的功能</p></li><li><p>通常，服务器端接收到请求，在处理完毕后就会立即返回响应，但为了实现推送功能，Comet会先将响应置于挂起状态，当服务器端有内容更新时，再返回该响应。因此，服务器端一旦有更新，就可以立即反馈给客户端</p></li><li><p>内容上虽然可以做到实时更新，但为了保留响应，一次连接的持续时间也变长了。期间，为了维持连接会消耗更多的资源。另外，Comet也仍未解决HTTP协议本身存在的问题</p></li></ul></li><li><p>SPDY</p><ul><li>陆续出现的Ajax和Comet等提高易用性的技术，一定程度上使HTTP得到了改善，但HTTP协议本身的限制也令人有些束手无策。为了进行根本性的改善，需要有一些协议层面上的改动。SPDY协议，正是为了在协议级别消除HTTP所遭遇的瓶颈</li></ul></li></ul><h4 id="9-2-2-SPDY的设计与功能"><a href="#9-2-2-SPDY的设计与功能" class="headerlink" title="9.2.2 SPDY的设计与功能"></a>9.2.2 SPDY的设计与功能</h4><ul><li><p>SPDY没有完全改写HTTP协议，而是在TCP&#x2F;IP的应用层与传输层之间通过新加会话层的形式运作。同时，考虑到安全性问题，SPDY规定通信中使用SSL</p></li><li><p>SPDY以会话层的形式加入，控制对数据的流动，但还是采用HTTP建立通信连接。因此，可照常使用HTTP的GET和POST等方法、Cookie以及HTTP报文等</p></li><li><p>SPDY的设计</p><p><img src="/image/%E5%9B%BE%E8%A7%A3HTTP/ee15244af05cbebc845dd43b455d7e629a6b6c19.jpeg" alt="epub_907764_199.jpeg"></p></li><li><p>使用SPDY后，HTTP协议额外获得以下功能</p><ul><li><p>多路复用流：通过单一的TCP连接，可以无限制处理多个HTTP请求。所有请求的处理都在一条TCP连接上完成，因此TCP的处理效率得到提高</p></li><li><p>赋予请求优先级：SPDY不仅可以无限制地并发处理请求，还可以给请求逐个分配优先级顺序。这样主要是为了在发送多个请求时，解决因带宽低而导致响应变慢的问题</p></li><li><p>压缩HTTP首部压缩：HTTP请求和响应的首部。这样一来，通信产生的数据包数量和发送的字节数就更少了</p></li><li><p>推送功能：支持服务器主动向客户端推送数据的功能。这样，服务器可直接发送数据，而不必等待客户端的请求</p></li><li><p>服务器提示功能：服务器可以主动提示客户端请求所需的资源。由于在客户端发现资源之前就可以获知资源的存在，因此在资源已缓存等情况下，可以避免发送不必要的请求</p></li></ul></li></ul><h4 id="9-2-3-SPDY消除Web瓶颈了吗"><a href="#9-2-3-SPDY消除Web瓶颈了吗" class="headerlink" title="9.2.3 SPDY消除Web瓶颈了吗"></a>9.2.3 SPDY消除Web瓶颈了吗</h4><ul><li><p>希望使用SPDY时，Web的内容端不必做什么特别改动，而Web浏览器及Web服务器都要为对应SPDY做出一定程度上的改动。有好几家Web浏览器已经针对SPDY做出了相应的调整。另外，Web服务器也进行了实验性质的应用，但把该技术导入实际的Web网站却进展不佳</p></li><li><p>因为SPDY基本上只是将单个域名（IP地址）的通信多路复用，所以当一个Web网站上使用多个域名下的资源，改善效果就会受到限制</p></li><li><p>SPDY的确是一种可有效消除HTTP瓶颈的技术，但很多Web网站存在的问题并非仅仅是由HTTP瓶颈所导致。对Web本身的速度提升，还应该从其他可细致钻研的地方入手，比如改善Web内容的编写方式等</p></li></ul><h3 id="9-3-使用浏览器进行全双工通信的WebSocket"><a href="#9-3-使用浏览器进行全双工通信的WebSocket" class="headerlink" title="9.3 使用浏览器进行全双工通信的WebSocket"></a>9.3 使用浏览器进行全双工通信的WebSocket</h3><ul><li><p>利用Ajax和Comet技术进行通信可以提升Web的浏览速度。但问题在于通信若使用HTTP协议，就无法彻底解决瓶颈问题。WebSocket网络技术正是为解决这些问题而实现的一套新协议及API</p></li><li><p>当时筹划将WebSocket作为HTML5标准的一部分，而现在它却逐渐变成了独立的协议标准。WebSocket通信协议在2011年12月11日，被RFC 6455- TheWebSocket Protocol定为标准</p></li></ul><h4 id="9-3-1-WebSocket的设计与功能"><a href="#9-3-1-WebSocket的设计与功能" class="headerlink" title="9.3.1 WebSocket的设计与功能"></a>9.3.1 WebSocket的设计与功能</h4><ul><li><p>WebSocket，即Web浏览器与Web服务器之间全双工通信标准。其中，WebSocket协议由IETF定为标准，WebSocket API由W3C定为标准</p></li><li><p>仍在开发中的WebSocket技术主要是为了解决Ajax和Comet里XMLHttpRequest附带的缺陷所引起的问题</p></li></ul><h4 id="9-3-2-WebSocket协议"><a href="#9-3-2-WebSocket协议" class="headerlink" title="9.3.2 WebSocket协议"></a>9.3.2 WebSocket协议</h4><ul><li><p>一旦Web服务器与客户端之间建立起WebSocket协议的通信连接，之后所有的通信都依靠这个专用协议进行。通信过程中可互相发送JSON、XML、HTML或图片等任意格式的数据</p></li><li><p>由于是建立在HTTP基础上的协议，因此连接的发起方仍是客户端，而一旦确立WebSocket通信连接，不论服务器还是客户端，任意一方都可直接向对方发送报文</p></li><li><p>下面我们列举一下WebSocket协议的主要特点</p><ul><li><p>推送功能：支持由服务器向客户端推送数据的推送功能。这样，服务器可直接发送数据，而不必等待客户端的请求</p></li><li><p>减少通信量：只要建立起WebSocket连接，就希望一直保持连接状态。和HTTP相比，不但每次连接时的总开销减少，而且由于WebSocket的首部信息很小，通信量也相应减少了</p></li></ul></li><li><p>为了实现WebSocket通信，在HTTP连接建立之后，需要完成一次“握手”（Handshaking）的步骤</p></li><li><p>为了实现WebSocket通信，需要用到HTTP的Upgrade首部字段，告知服务器通信协议发生改变，以达到握手的目的，同时还有其他的一些首部字段</p><ul><li><p>示例</p><figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs http"><span class="hljs-attribute">UPgrade</span><span class="hljs-punctuation">: </span>websocket<br></code></pre></td></tr></table></figure></li><li><p>Sec-WebSocket-Key字段内记录着握手过程中必不可少的键值。Sec-WebSocket-Protocol字段内记录使用的子协议。子协议按WebSocket协议标准在连接分开使用时，定义那些连接的名称</p></li></ul></li><li><p>对于之前的请求，返回状态码101 Switching Protocols的响应确定建立websocket链接，同时还有其他的一些首部字段</p><ul><li>Sec-WebSocket-Accept的字段值是由握手请求中的Sec-WebSocket-Key的字段值生成的</li></ul></li><li><p>成功握手确立WebSocket连接之后，通信时不再使用HTTP的数据帧，而采用WebSocket独立的数据帧</p></li><li><p>WebSocket通信</p><p><img src="/image/%E5%9B%BE%E8%A7%A3HTTP/ad9c361a867be1b497edb59b21712c8d5a44b7ad.jpeg" alt="epub_907764_200.jpeg"></p></li><li><p>JavaScript可调用“The WebSocket API”（<a href="http://www.w3.org/TR/websockets/%EF%BC%8C%E7%94%B1W3C%E6%A0%87%E5%87%86%E5%88%B6%E5%AE%9A%EF%BC%89%E5%86%85%E6%8F%90%E4%BE%9B%E7%9A%84WebSocket%E7%A8%8B%E5%BA%8F%E6%8E%A5%E5%8F%A3%EF%BC%8C%E4%BB%A5%E5%AE%9E%E7%8E%B0WebSocket%E5%8D%8F%E8%AE%AE%E4%B8%8B%E5%85%A8%E5%8F%8C%E5%B7%A5%E9%80%9A%E4%BF%A1">http://www.w3.org/TR/websockets/，由W3C标准制定）内提供的WebSocket程序接口，以实现WebSocket协议下全双工通信</a></p></li></ul><h3 id="9-4-期盼已久的HTTP-x2F-2-0"><a href="#9-4-期盼已久的HTTP-x2F-2-0" class="headerlink" title="9.4 期盼已久的HTTP&#x2F;2.0"></a>9.4 期盼已久的HTTP&#x2F;2.0</h3><ul><li><p>目前主流的HTTP&#x2F;1.1标准，自1999年发布的RFC2616之后再未进行过改订。SPDY和WebSocket等技术纷纷出现，很难断言HTTP&#x2F;1.1仍是适用于当下的Web的协议</p></li><li><p>负责互联网技术标准的IETF（Internet Engineering Task Force，互联网工程任务组）创立httpbis（Hypertext Transfer ProtocolBis,<a href="http://datatracker.ietf.org/wg/httpbis/%EF%BC%89%E5%B7%A5%E4%BD%9C%E7%BB%84%EF%BC%8C%E5%85%B6%E7%9B%AE%E6%A0%87%E6%98%AF%E6%8E%A8%E8%BF%9B%E4%B8%8B%E4%B8%80%E4%BB%A3HTTP%E2%80%94%E2%80%94HTTP/2.0%E5%9C%A82014%E5%B9%B411%E6%9C%88%E5%AE%9E%E7%8E%B0%E6%A0%87%E5%87%86%E5%8C%96">http://datatracker.ietf.org/wg/httpbis/）工作组，其目标是推进下一代HTTP——HTTP/2.0在2014年11月实现标准化</a></p></li><li><p>HTTP&#x2F;2.0的目标是改善用户在使用Web时的速度体验。由于基本上都会先通过HTTP&#x2F;1.1与TCP连接，现在我们以下面的这些协议为基础，探讨一下它们的实现方法</p><ul><li><p>SPDY</p></li><li><p>HTTP Speed+Mobility：HTTP Speed+Mobility由微软公司起草，是用于改善并提高移动端通信时的通信速度和性能的标准。它建立在Google公司提出的SPDY与WebSocket的基础之上</p></li><li><p>Network-Friendly HTTP Upgrade：Network-Friendly HTTP Upgrade主要是在移动端通信时改善HTTP性能的标准</p></li></ul></li><li><p>HTTP&#x2F;2.0围绕着主要的7项技术进行讨论，现阶段（2012年8月13日），大都倾向于采用以下协议的技术。但是，讨论仍在持续，所以不能排除会发生重大改变的可能性</p><p><img src="/image/%E5%9B%BE%E8%A7%A3HTTP/d7b718ae32b718d2a3bf42fb1b4ac31f95948bc9.jpeg" alt="epub_907764_201.jpeg"></p></li></ul><h3 id="9-5-Web服务器管理文件的WebDAV"><a href="#9-5-Web服务器管理文件的WebDAV" class="headerlink" title="9.5 Web服务器管理文件的WebDAV"></a>9.5 Web服务器管理文件的WebDAV</h3><ul><li><p>WebDAV（Web-based Distributed Authoring and Versioning，基于万维网的分布式创作和版本控制）是一个可对Web服务器上的内容直接进行文件复制、编辑等操作的分布式文件系统。它作为扩展HTTP&#x2F;1.1的协议定义在RFC4918</p></li><li><p>除了创建、删除文件等基本功能，它还具备文件创建者管理、文件编辑过程中禁止其他用户内容覆盖的加锁功能，以及对文件内容修改的版本控制功能</p></li><li><p>使用HTTP&#x2F;1.1的PUT方法和DELETE方法，就可以对Web服务器上的文件进行创建和删除操作。可是出于安全性及便捷性等考虑，一般不使用</p></li><li><p>WebDAV</p><p><img src="/image/%E5%9B%BE%E8%A7%A3HTTP/d96943ef4ab4725a7172a892f575779053d6edbd.jpeg" alt="epub_907764_202.jpeg"></p></li></ul><h4 id="9-5-1-扩展HTTP-x2F-1-1的WebDAV"><a href="#9-5-1-扩展HTTP-x2F-1-1的WebDAV" class="headerlink" title="9.5.1 扩展HTTP&#x2F;1.1的WebDAV"></a>9.5.1 扩展HTTP&#x2F;1.1的WebDAV</h4><ul><li><p>针对服务器上的资源，WebDAV新增加了一些概念，如下所示</p><ul><li><p>集合（Co lection）：是一种统一管理多个资源的概念。以集合为单位可进行各种操作。也可实现类似集合的集合这样的叠加</p></li><li><p>资源（Resource）：把文件或集合称为资源</p></li><li><p>属性（Property）：定义资源的属性。定义以“名称&#x3D;值”的格式执行</p></li><li><p>锁（Lock）：把文件设置成无法编辑状态。多人同时编辑时，可防止在同一时间进行内容写入</p></li></ul></li></ul><h4 id="9-5-2-WebDAV内新增的方法及状态码"><a href="#9-5-2-WebDAV内新增的方法及状态码" class="headerlink" title="9.5.2 WebDAV内新增的方法及状态码"></a>9.5.2 WebDAV内新增的方法及状态码</h4><ul><li><p>WebDAV为实现远程文件管理，向HTTP&#x2F;1.1中追加了以下这些方法</p><ul><li><p>PROPFIND：获取属性</p></li><li><p>PROPPATCH：修改属性</p></li><li><p>MKCOL：创建集合</p></li><li><p>COPY：复制资源及属性</p></li><li><p>MOVE：移动资源</p></li><li><p>LOCK：资源加锁</p></li><li><p>UNLOCK：资源解锁</p></li></ul></li><li><p>为配合扩展的方法，状态码也随之扩展</p><ul><li><p>102 Processing：可正常处理请求，但目前是处理中状态</p></li><li><p>207 Multi-Status：存在多种状态</p></li><li><p>422 Unprocessible Entity：格式正确，内容有误</p></li><li><p>423 Locked：资源已被加锁</p></li><li><p>424 Failed Dependency：处理与某请求关联的请求失败，因此不再维持依赖关系</p></li><li><p>507 Insufficient Storage：保存空间不足</p></li></ul></li></ul><h2 id="第十章-构建Web内容的技术"><a href="#第十章-构建Web内容的技术" class="headerlink" title="第十章 构建Web内容的技术"></a>第十章 构建Web内容的技术</h2><h3 id="10-1-HTML"><a href="#10-1-HTML" class="headerlink" title="10.1 HTML"></a>10.1 HTML</h3><h4 id="10-1-1-Web页面几乎全由HTML构建"><a href="#10-1-1-Web页面几乎全由HTML构建" class="headerlink" title="10.1.1 Web页面几乎全由HTML构建"></a>10.1.1 Web页面几乎全由HTML构建</h4><ul><li>HTML（HyperText Markup Language，超文本标记语言）是为了发送Web上的超文本（Hypertext）而开发的标记语言<ul><li>超文本是一种文档系统，可将文档中任意位置的信息与其他信息（文本或图片等）建立关联，即超链接文本</li><li>标记语言是指通过在文档的某部分穿插特别的字符串标签，用来修饰文档的语言。我们把出现在HTML文档内的这种特殊字符串叫做HTML标签（Tag）</li></ul></li><li>平时我们浏览的Web页面几乎全是使用HTML写成的。由HTML构成的文档经过浏览器的解析、渲染后，呈现出来的结果就是Web页面</li></ul><h4 id="10-1-2-HTML的版本"><a href="#10-1-2-HTML的版本" class="headerlink" title="10.1.2 HTML的版本"></a>10.1.2 HTML的版本</h4><ul><li><p>Tim Berners-Lee提出HTTP概念的同时，还提出了HTML原型。1993年在伊利诺伊大学的NCSA（The National Center for SupercomputingApplications，国家超级计算机应用中心）发布了Mosaic浏览器（世界首个图形界面浏览器程序），而能够被Mosaic解析的HTML，统一标准后即作为HTML 1.0发布</p></li><li><p>目前的最新版本是HTML4.01标准（2013年），1999年12月W3C（World Wide WebConsortium）组织推荐使用这一版本。下一个版本，预计会在2014年左右正式推荐使用HTML5标准</p></li><li><p>HTML5标准不仅解决了浏览器之间的兼容性问题，并且可把文本作为数据对待，更容易复用，动画等效果也变得更生动</p></li><li><p>时至今日，HTML仍存在较多悬而未决问题。有些浏览器未遵循HTML标准实现，或扩展自用标签等，这都反映了HTML的标准实际上尚未统一这一现状</p></li></ul><h4 id="10-1-3-设计应用CSS"><a href="#10-1-3-设计应用CSS" class="headerlink" title="10.1.3 设计应用CSS"></a>10.1.3 设计应用CSS</h4><ul><li>CSS（Cascading Style Sheets，层叠样式表）可以指定如何展现HTML内的各种元素，属于样式表标准之一。即使是相同的HTML文档，通过改变应用的CSS，用浏览器看到的页面外观也会随之改变。CSS的理念就是让文档的结构和设计分离，达到解耦的目的</li></ul><h3 id="10-2-动态HTML"><a href="#10-2-动态HTML" class="headerlink" title="10.2 动态HTML"></a>10.2 动态HTML</h3><h4 id="10-2-1-让Web页面动起来的动态HTML"><a href="#10-2-1-让Web页面动起来的动态HTML" class="headerlink" title="10.2.1 让Web页面动起来的动态HTML"></a>10.2.1 让Web页面动起来的动态HTML</h4><ul><li><p>所谓动态HTML（Dynamic HTML），是指使用客户端脚本语言将静态的HTML内容变成动态的技术的总称。鼠标单击点开的新闻、Google Maps等可滚动的地图就用到了动态HTML</p></li><li><p>动态HTML技术是通过调用客户端脚本语言JavaScript，实现对HTML的Web页面的动态改造。利用DOM（Document Object Model，文档对象模型）可指定欲发生动态变化的HTML元素</p></li></ul><h4 id="10-2-2-更易控制HTML的DOM"><a href="#10-2-2-更易控制HTML的DOM" class="headerlink" title="10.2.2 更易控制HTML的DOM"></a>10.2.2 更易控制HTML的DOM</h4><ul><li><p>DOM是用以操作HTML文档和XML文档的API（Application ProgrammingInterface，应用编程接口）。使用DOM可以将HTML内的元素当作对象操作，如取出元素内的字符串、改变那个CSS的属性等，使页面的设计发生改变</p></li><li><p>通过调用JavaScript等脚本语言对DOM的操作，可以以更为简单的方式控制HTML的改变</p></li></ul><h3 id="10-3-Web应用"><a href="#10-3-Web应用" class="headerlink" title="10.3 Web应用"></a>10.3 Web应用</h3><h4 id="10-3-1-通过Web提供功能的Web应用"><a href="#10-3-1-通过Web提供功能的Web应用" class="headerlink" title="10.3.1 通过Web提供功能的Web应用"></a>10.3.1 通过Web提供功能的Web应用</h4><ul><li><p>Web应用是指通过Web功能提供的应用程序。比如购物网站、网上银行、SNS、BBS、搜索引擎和e-learning等。互联网（Internet）或企业内网（Intranet）上遍布各式各样的Web应用</p></li><li><p>原本应用HTTP协议的Web的机制就是对客户端发来的请求，返回事前准备好的内容。可随着Web越来越普及，仅靠这样的做法已不足以应对所有的需求，更需要引入由程序创建HTML内容的做法</p></li><li><p>类似这种由程序创建的内容称为动态内容，而事先准备好的内容称为静态内容。Web应用则作用于动态内容之上</p></li></ul><h4 id="10-3-2-与Web服务器及程序协作的CGI"><a href="#10-3-2-与Web服务器及程序协作的CGI" class="headerlink" title="10.3.2 与Web服务器及程序协作的CGI"></a>10.3.2 与Web服务器及程序协作的CGI</h4><ul><li><p>CGI（Common Gateway Interface，通用网关接口）是指Web服务器在接收到客户端发送过来的请求后转发给程序的一组机制。在CGI的作用下，程序会对请求内容做出相应的动作，比如创建HTML等动态内容</p></li><li><p>使用CGI的程序叫做CGI程序，通常是用Perl、PHP、Ruby和C等编程语言编写而成</p></li><li><p>有关CGI更为翔实的内容请参考RFC3875“The Common Gateway Interface(CGI) Version 1.1”</p></li><li><p>CGI</p><p><img src="/image/%E5%9B%BE%E8%A7%A3HTTP/d980b9d122d22a4b84357deedbec1e15d785dad9.jpeg" alt="epub_907764_207.jpeg"></p></li></ul><h4 id="10-3-3-因Java而普及的Servlet"><a href="#10-3-3-因Java而普及的Servlet" class="headerlink" title="10.3.3 因Java而普及的Servlet"></a>10.3.3 因Java而普及的Servlet</h4><ul><li><p>Servlet是一种能在服务器上创建动态内容的程序。Servlet是用Java语言实现的一个接口，属于面向企业级Java（JavaEE,Java Enterprise Edition）的一部分</p></li><li><p>之前提及的CGI，由于每次接到请求，程序都要跟着启动一次。因此一旦访问量过大，Web服务器要承担相当大的负载。而Servlet运行在与Web服务器相同的进程中，因此受到的负载较小。Servlet的运行环境叫做Web容器或Servlet容器</p></li><li><p>Servlet作为解决CGI问题的对抗技术，随Java一起得到了普及</p><p><img src="/image/%E5%9B%BE%E8%A7%A3HTTP/7e181f8984b4466d7c7d860c7648d5b5c9b7d2d9.jpeg" alt="epub_907764_211.jpeg"></p></li><li><p>随着CGI的普及，每次请求都要启动新CGI程序的CGI运行机制逐渐变成了性能瓶颈，所以之后Servlet和mod_perl等可直接在Web服务器上运行的程序才得以开发、普及</p></li></ul><h3 id="10-4-数据发布的格式及语言"><a href="#10-4-数据发布的格式及语言" class="headerlink" title="10.4 数据发布的格式及语言"></a>10.4 数据发布的格式及语言</h3><h4 id="10-4-1-可扩展标记语言"><a href="#10-4-1-可扩展标记语言" class="headerlink" title="10.4.1 可扩展标记语言"></a>10.4.1 可扩展标记语言</h4><ul><li><p>XML（eXtensible Markup Language，可扩展标记语言）是一种可按应用目标进行扩展的通用标记语言。旨在通过使用XML，使互联网数据共享变得更容易</p></li><li><p>XML和HTML都是从标准通用标记语言SGML（Standard Generalized MarkupLanguage）简化而成。与HTML相比，它对数据的记录方式做了特殊处理</p></li><li><p>XML和HTML一样，使用标签构成树形结构，并且可自定义扩展标签。从XML文档中读取数据比起HTML更为简单。由于XML的结构基本上都是用标签分割而成的树形结构，因此通过语法分析器（Parser）的解析功能解析XML结构并取出数据元素，可更容易地对数据进行读取</p></li><li><p>更容易地复用数据使得XML在互联网上被广泛接受。比如，可用在2个不同的应用之间的交换数据格式化</p></li></ul><h4 id="10-4-2-发布更新信息的RSS-x2F-Atom"><a href="#10-4-2-发布更新信息的RSS-x2F-Atom" class="headerlink" title="10.4.2 发布更新信息的RSS&#x2F;Atom"></a>10.4.2 发布更新信息的RSS&#x2F;Atom</h4><ul><li><p>RSS（简易信息聚合，也叫聚合内容）和Atom都是发布新闻或博客日志等更新信息文档的格式的总称。两者都用到了XML</p></li><li><p>RSS有以下版本，名称和编写方式也不相同</p><ul><li><p>RSS 0.9（RDF Site Summary）：最初的RSS版本。1999年3月由网景通信公司自行开发用于其门户网站。基础构图创建在初期的RDF规格上</p></li><li><p>RSS 0.91（Rich Site Summary）：在RSS0.9的基础上扩展元素，于1999年7月开发完毕。非RDF规格，使用XML方式编写</p></li><li><p>RSS 1.0（RDF Site Summary）:RSS规格正处于混乱状态。2000年12月由RSS-DEV工作组再次采用RSS0.9中使用的RDF规格发布</p></li><li><p>RSS2.0（Really Simple Syndication）：非RSS1.0发展路线。增加支持RSS0.91的兼容性，2000年12月由UserLand Software公司开发完成</p></li></ul></li><li><p>Atom具有以下两种标准</p><ul><li><p>Atom供稿格式（Atom Syndication Format）：为发布内容而制定的网站消息来源格式，单讲Atom时，就是指此标准</p></li><li><p>Atom出版协定（Atom Publishing Protocol）：为Web上内容的新增或修改而制定的协议</p></li></ul></li><li><p>用于订阅博客更新信息的RSS阅读器，这种应用几乎支持RSS的所有版本以及Atom</p></li></ul><h4 id="10-4-3-JavaScript衍生的轻量级易用JSON"><a href="#10-4-3-JavaScript衍生的轻量级易用JSON" class="headerlink" title="10.4.3 JavaScript衍生的轻量级易用JSON"></a>10.4.3 JavaScript衍生的轻量级易用JSON</h4><ul><li><p>JSON（JavaScript Object Notation）是一种以JavaScript（ECMAScript）的对象表示法为基础的轻量级数据标记语言。能够处理的数据类型有false&#x2F;null&#x2F;true&#x2F;对象&#x2F;数组&#x2F;数字&#x2F;字符串，这7种类型</p></li><li><p>JSON让数据更轻更纯粹，并且JSON的字符串形式可被JavaScript轻易地读入。当初配合XML使用的Ajax技术也让JSON的应用变得更为广泛。另外，其他各种编程语言也提供丰富的库类，以达到轻便操作JSON的目的</p></li></ul><h2 id="第十一章-Web的攻击技术"><a href="#第十一章-Web的攻击技术" class="headerlink" title="第十一章 Web的攻击技术"></a>第十一章 Web的攻击技术</h2><ul><li>简单的HTTP协议本身并不存在安全性问题，因此协议本身几乎不会成为攻击的对象。应用HTTP协议的服务器和客户端，以及运行在服务器上的Web应用等资源才是攻击目标</li></ul><h4 id="11-1-1-HTTP不具备必要的安全功能"><a href="#11-1-1-HTTP不具备必要的安全功能" class="headerlink" title="11.1.1 HTTP不具备必要的安全功能"></a>11.1.1 HTTP不具备必要的安全功能</h4><ul><li><p>与最初的设计相比，现今的Web网站应用的HTTP协议的使用方式已发生了翻天覆地的变化。几乎现今所有的Web网站都会使用会话（session）管理、加密处理等安全性方面的功能，而HTTP协议内并不具备这些功能</p></li><li><p>从整体上看，HTTP就是一个通用的单纯协议机制。因此它具备较多优势，但是在安全性方面则呈劣势</p></li><li><p>就拿远程登录时会用到的SSH协议来说，SSH具备协议级别的认证及会话管理等功能，HTTP协议则没有。另外在架设SSH服务方面，任何人都可以轻易地创建安全等级高的服务，而HTTP即使已架设好服务器，但若想提供服务器基础上的Web应用，很多情况下都需要重新开发</p></li><li><p>因此，开发者需要自行设计并开发认证及会话管理功能来满足Web应用的安全。而自行设计就意味着会出现各种形形色色的实现。结果，安全等级并不完备，可仍在运作的Web应用背后却隐藏着各种容易被攻击者滥用的安全漏洞的Bug</p></li></ul><h4 id="11-1-2-在客户端即可篡改请求"><a href="#11-1-2-在客户端即可篡改请求" class="headerlink" title="11.1.2 在客户端即可篡改请求"></a>11.1.2 在客户端即可篡改请求</h4><ul><li><p>在Web应用中，从浏览器那接收到的HTTP请求的全部内容，都可以在客户端自由地变更、篡改。所以Web应用可能会接收到与预期数据不相同的内容</p></li><li><p>在HTTP请求报文内加载攻击代码，就能发起对Web应用的攻击。通过URL查询字段或表单、HTTP首部、Cookie等途径把攻击代码传入，若这时Web应用存在安全漏洞，那内部信息就会遭到窃取，或被攻击者拿到管理权限</p></li></ul><h4 id="11-1-3-针对Web应用的攻击模式"><a href="#11-1-3-针对Web应用的攻击模式" class="headerlink" title="11.1.3 针对Web应用的攻击模式"></a>11.1.3 针对Web应用的攻击模式</h4><ul><li><p>对Web应用的攻击模式有以下两种</p><ul><li><p>主动攻击</p></li><li><p>被动攻击</p></li></ul></li><li><p>以服务器为目标的主动攻击</p><ul><li><p>主动攻击（active attack）是指攻击者通过直接访问Web应用，把攻击代码传入的攻击模式。由于该模式是直接针对服务器上的资源进行攻击，因此攻击者需要能够访问到那些资源</p></li><li><p>主动攻击模式里具有代表性的攻击是SQL注入攻击和OS命令注入攻击</p></li></ul></li><li><p>以服务器为目标的被动攻击</p><ul><li><p>被动攻击（passive attack）是指利用圈套策略执行攻击代码的攻击模式。在被动攻击过程中，攻击者不直接对目标Web应用访问发起攻击</p></li><li><p>被动攻击通常的攻击模式如下所示</p><ul><li><p>步骤1： 攻击者诱使用户触发已设置好的陷阱，而陷阱会启动发送已嵌入攻击代码的HTTP请求</p></li><li><p>步骤2： 当用户不知不觉中招之后，用户的浏览器或邮件客户端就会触发这个陷阱</p></li><li><p>步骤3： 中招后的用户浏览器会把含有攻击代码的HTTP请求发送给作为攻击目标的Web应用，运行攻击代码</p></li><li><p>步骤4： 执行完攻击代码，存在安全漏洞的Web应用会成为攻击者的跳板，可能导致用户所持的Cookie等个人信息被窃取，登录状态中的用户权限遭恶意滥用等后果</p></li></ul></li></ul></li><li><p>利用被动攻击，可发起对原本从互联网上无法直接访问的企业内网等网络的攻击。只要用户踏入攻击者预先设好的陷阱，在用户能够访问到的网络范围内，即使是企业内网也同样会受到攻击</p></li></ul><h3 id="11-2-因输出值转义不完全引发的安全漏洞"><a href="#11-2-因输出值转义不完全引发的安全漏洞" class="headerlink" title="11.2 因输出值转义不完全引发的安全漏洞"></a>11.2 因输出值转义不完全引发的安全漏洞</h3><ul><li><p>实施Web应用的安全对策可大致分为以下两部分</p><ul><li><p>客户端的验证</p></li><li><p>Web应用端（服务器端）的验证</p></li></ul></li><li><p>验证数据的几个地方</p><p><img src="/image/%E5%9B%BE%E8%A7%A3HTTP/51553b4aa2206040b099bf95b4bcdfbf05b26c15.jpeg" alt="epub_907764_218.jpeg"></p></li><li><p>多数情况下采用JavaScript在客户端验证数据。可是在客户端允许篡改数据或关闭JavaScript，不适合将JavaScript验证作为安全的防范对策。保留客户端验证只是为了尽早地辨识输入错误，起到提高UI体验的作用</p></li><li><p>Web应用端的输入值验证按Web应用内的处理则有可能被误认为是具有攻击性意义的代码。输入值验证通常是指检查是否是符合系统业务逻辑的数值或检查字符编码等预防对策</p></li><li><p>从数据库或文件系统、HTML、邮件等输出Web应用处理的数据之际，针对输出做值转义处理是一项至关重要的安全策略。当输出值转义不完全时，会因触发攻击者传入的攻击代码，而给输出对象带来损害</p></li></ul><h4 id="11-2-1-跨站脚本攻击"><a href="#11-2-1-跨站脚本攻击" class="headerlink" title="11.2.1 跨站脚本攻击"></a>11.2.1 跨站脚本攻击</h4><ul><li><p>跨站脚本攻击（Cross-Site Scripting,XSS）是指通过存在安全漏洞的Web网站注册用户的浏览器内运行非法的HTML标签或JavaScript进行的一种攻击。动态创建的HTML部分有可能隐藏着安全漏洞。就这样，攻击者编写脚本设下陷阱，用户在自己的浏览器上运行时，一不小心就会受到被动攻击</p></li><li><p>跨站脚本攻击有可能造成以下影响</p><ul><li><p>利用虚假输入表单骗取用户个人信息</p></li><li><p>利用脚本窃取用户的Cookie值，被害者在不知情的情况下，帮助攻击者发送恶意请求</p></li><li><p>显示伪造的文章或图片</p></li></ul></li></ul><h4 id="11-2-2-SQL注入攻击"><a href="#11-2-2-SQL注入攻击" class="headerlink" title="11.2.2 SQL注入攻击"></a>11.2.2 SQL注入攻击</h4><ul><li><p>SQL注入（SQL Injection）是指针对Web应用使用的数据库，通过运行非法的SQL而产生的攻击。该安全隐患有可能引发极大的威胁，有时会直接导致个人信息及机密信息的泄露</p></li><li><p>Web应用通常都会用到数据库，当需要对数据库表内的数据进行检索或添加、删除等操作时，会使用SQL语句连接数据库进行特定的操作。如果在调用SQL语句的方式上存在疏漏，就有可能执行被恶意注入（Injection）非法SQL语句</p></li><li><p>SQL注入攻击有可能会造成以下等影响</p><ul><li><p>非法查看或篡改数据库内的数据</p></li><li><p>规避认证</p></li><li><p>执行和数据库服务器业务关联的程序等</p></li></ul></li></ul><h4 id="11-2-3-OS命令注入攻击"><a href="#11-2-3-OS命令注入攻击" class="headerlink" title="11.2.3 OS命令注入攻击"></a>11.2.3 OS命令注入攻击</h4><ul><li><p>OS命令注入攻击（OS Command Injection）是指通过Web应用，执行非法的操作系统命令达到攻击的目的。只要在能调用Shell函数的地方就有存在被攻击的风险</p></li><li><p>可以从Web应用中通过Shell来调用操作系统命令。倘若调用Shell时存在疏漏，就可以执行插入的非法OS命令</p></li><li><p>OS命令注入攻击可以向Shell发送命令，让Windows或Linux操作系统的命令行启动程序。也就是说，通过OS注入攻击可执行OS上安装着的各种程序</p></li></ul><h4 id="11-2-4-HTTP首部注入攻击"><a href="#11-2-4-HTTP首部注入攻击" class="headerlink" title="11.2.4 HTTP首部注入攻击"></a>11.2.4 HTTP首部注入攻击</h4><ul><li><p>HTTP首部注入攻击（HTTP Header Injection）是指攻击者通过在响应首部字段内插入换行，添加任意响应首部或主体的一种攻击。属于被动攻击模式</p></li><li><p>向首部主体内添加内容的攻击称为HTTP响应截断攻击（HTTP ResponseSplitting Attack）</p></li><li><p>HTTP首部注入攻击有可能会造成以下一些影响</p><ul><li><p>设置任何Cookie信息</p></li><li><p>重定向至任意URL</p></li><li><p>显示任意的主体（HTTP响应截断攻击）</p></li></ul></li><li><p>HTTP响应截断攻击是用在HTTP首部注入的一种攻击。攻击顺序相同，但是要将两个%0D%0A%0D%0A并排插入字符串后发送。利用这两个连续的换行就可作出HTTP首部与主体分隔所需的空行了，这样就能显示伪造的主体，达到攻击目的。这样的攻击叫做HTTP响应截断攻击</p></li><li><p>另外，滥用HTTP&#x2F;1.1中汇集多响应返回功能，会导致缓存服务器对任意内容进行缓存操作。这种攻击称为缓存污染。使用该缓存服务器的用户，在浏览遭受攻击的网站时，会不断地浏览被替换掉的Web网页</p></li></ul><h4 id="11-2-5-邮件首部注入攻击"><a href="#11-2-5-邮件首部注入攻击" class="headerlink" title="11.2.5 邮件首部注入攻击"></a>11.2.5 邮件首部注入攻击</h4><ul><li>邮件首部注入（Mail Header Injection）是指Web应用中的邮件发送功能，攻击者通过向邮件首部To或Subject内任意添加非法内容发起的攻击。利用存在安全漏洞的Web网站，可对任意邮件地址发送广告邮件或病毒邮件</li></ul><h4 id="11-2-6-目录遍历攻击"><a href="#11-2-6-目录遍历攻击" class="headerlink" title="11.2.6 目录遍历攻击"></a>11.2.6 目录遍历攻击</h4><ul><li><p>目录遍历（Directory Traversal）攻击是指对本无意公开的文件目录，通过非法截断其目录路径后，达成访问目的的一种攻击。这种攻击有时也称为路径遍历（Path Traversal）攻击</p></li><li><p>通过Web应用对文件处理操作时，在由外部指定文件名的处理存在疏漏的情况下，用户可使用．..&#x2F;等相对路径定位到&#x2F;etc&#x2F;passed等绝对路径上，因此服务器上任意的文件或文件目录皆有可能被访问到。这样一来，就有可能非法浏览、篡改或删除Web服务器上的文件</p></li><li><p>固然存在输出值转义的问题，但更应该关闭指定对任意文件名的访问权限</p></li></ul><h4 id="11-2-7-远程文件包含漏洞"><a href="#11-2-7-远程文件包含漏洞" class="headerlink" title="11.2.7 远程文件包含漏洞"></a>11.2.7 远程文件包含漏洞</h4><ul><li><p>远程文件包含漏洞（Remote File Inclusion）是指当部分脚本内容需要从其他文件读入时，攻击者利用指定外部服务器的URL充当依赖文件，让脚本读取之后，就可运行任意脚本的一种攻击</p></li><li><p>这主要是PHP存在的安全漏洞，对PHP的include或require来说，这是一种可通过设定，指定外部服务器的URL作为文件名的功能。但是，该功能太危险，PHP5.2.0之后默认设定此功能无效</p></li><li><p>固然存在输出值转义的问题，但更应控制对任意文件名的指定</p></li></ul><h3 id="11-3-因设置或设计上的缺陷引发的安全漏洞"><a href="#11-3-因设置或设计上的缺陷引发的安全漏洞" class="headerlink" title="11.3 因设置或设计上的缺陷引发的安全漏洞"></a>11.3 因设置或设计上的缺陷引发的安全漏洞</h3><ul><li>因设置或设计上的缺陷引发的安全漏洞是指，错误设置Web服务器，或是由设计上的一些问题引起的安全漏洞</li></ul><h4 id="11-3-1-强制浏览"><a href="#11-3-1-强制浏览" class="headerlink" title="11.3.1 强制浏览"></a>11.3.1 强制浏览</h4><ul><li><p>强制浏览（Forced Browsing）安全漏洞是指，从安置在Web服务器的公开目录下的文件中，浏览那些原本非自愿公开的文件</p></li><li><p>强制浏览有可能会造成以下一些影响</p><ul><li><p>泄露顾客的个人信息等重要情报</p></li><li><p>泄露原本需要具有访问权限的用户才可查阅的信息内容</p></li><li><p>泄露未外连到外界的文件</p></li></ul></li><li><p>对那些原本不愿公开的文件，为了保证安全会隐蔽其URL。可一旦知道了那些URL，也就意味着可浏览URL对应的文件。直接显示容易推测的文件名或文件目录索引时，通过某些方法可能会使URL产生泄露</p></li><li><p>示例</p><ul><li><p>文件目录一览：</p><ul><li><p><a href="http://www.example.com/log/">http://www.example.com/log/</a></p></li><li><p>通过指定文件目录名称，即可在文件一览中看到显示的文件名</p></li></ul></li><li><p>容易被推测的文件名及目录名</p><ul><li><p><a href="http://www.example.com/entry/entry_081202.log">http://www.example.com/entry/entry_081202.log</a></p></li><li><p>文件名称容易推测（按上面的情况，可推出下一个文件是entry_081203.log）</p></li></ul></li><li><p>备份文件</p><ul><li><p><a href="http://www.example.com/cgi-bin/entry.cgi%EF%BC%88%E5%8E%9F%E5%A7%8B%E6%96%87%E4%BB%B6%EF%BC%89">http://www.example.com/cgi-bin/entry.cgi（原始文件）</a></p></li><li><p><a href="http://www.example.com/cgi-bin/entry.cgi%EF%BD%9E%EF%BC%88%E5%A4%87%E4%BB%BD%E6%96%87%E4%BB%B6%EF%BC%89">http://www.example.com/cgi-bin/entry.cgi～（备份文件）</a></p></li><li><p><a href="http://www.example.com/cgi-bin/entry.bak%EF%BC%88%E5%A4%87%E4%BB%BD%E6%96%87%E4%BB%B6%EF%BC%89">http://www.example.com/cgi-bin/entry.bak（备份文件）</a></p></li></ul></li></ul></li></ul><h4 id="11-3-2-不正确的错误消息处理"><a href="#11-3-2-不正确的错误消息处理" class="headerlink" title="11.3.2 不正确的错误消息处理"></a>11.3.2 不正确的错误消息处理</h4><ul><li><p>不正确的错误消息处理（Error Handling Vulnerability）的安全漏洞是指，Web应用的错误信息内包含对攻击者有用的信息。与Web应用有关的主要错误信息如下所示</p><ul><li><p>Web应用抛出的错误消息</p></li><li><p>数据库等系统抛出的错误消息</p></li></ul></li><li><p>Web应用不必在用户的浏览画面上展现详细的错误消息。对攻击者来说，详细的错误消息有可能给他们下一次攻击以提示</p></li><li><p>系统抛出的错误主要集中在以下几个方面</p><ul><li><p>PHP或ASP等脚本错误</p></li><li><p>数据库或中间件的错误</p></li><li><p>Web服务器的错误</p></li></ul></li><li><p>各系统应对详细的错误消息进行抑制设定，或使用自定义错误消息，以避免某些错误信息给攻击者以启发</p></li></ul><h4 id="11-3-3-开放重定向"><a href="#11-3-3-开放重定向" class="headerlink" title="11.3.3 开放重定向"></a>11.3.3 开放重定向</h4><ul><li>开放重定向（Open Redirect）是一种对指定的任意URL作重定向跳转的功能。而与此功能相关联的安全漏洞是指，假如指定的重定向URL到某个具有恶意的Web网站，那么用户就会被诱导至那个Web网站</li></ul><h3 id="11-4-因会话管理疏忽引发的安全漏洞"><a href="#11-4-因会话管理疏忽引发的安全漏洞" class="headerlink" title="11.4 因会话管理疏忽引发的安全漏洞"></a>11.4 因会话管理疏忽引发的安全漏洞</h3><ul><li>会话管理是用来管理用户状态的必备功能，但是如果在会话管理上有所疏忽，就会导致用户的认证状态被窃取等后果</li></ul><h4 id="11-4-1-会话劫持"><a href="#11-4-1-会话劫持" class="headerlink" title="11.4.1 会话劫持"></a>11.4.1 会话劫持</h4><ul><li><p>会话劫持（Session Hijack）是指攻击者通过某种手段拿到了用户的会话ID，并非法使用此会话ID伪装成用户，达到攻击的目的</p></li><li><p>具备认证功能的Web应用，使用会话ID的会话管理机制，作为管理认证状态的主流方式。会话ID中记录客户端的Cookie等信息，服务器端将会话ID与认证状态进行一对一匹配管理</p></li><li><p>下面列举了几种攻击者可获得会话ID的途径。</p><ul><li><p>通过非正规的生成方法推测会话ID</p></li><li><p>通过窃听或XSS攻击盗取会话ID</p></li><li><p>通过会话固定攻击（Session Fixation）强行获取会话ID</p></li></ul></li></ul><h4 id="11-4-2-会话固定攻击"><a href="#11-4-2-会话固定攻击" class="headerlink" title="11.4.2 会话固定攻击"></a>11.4.2 会话固定攻击</h4><ul><li><p>对以窃取目标会话ID为主动攻击手段的会话劫持而言，会话固定攻击（Session Fixation）攻击会强制用户使用攻击者指定的会话ID，属于被动攻击</p></li><li><p>会话固定攻击案例</p><p><img src="/image/%E5%9B%BE%E8%A7%A3HTTP/d35e443ae990b38548d76802771da4e0245ffad8.jpeg" alt="epub_907764_241.jpeg"></p></li><li><p>Session Adoption是指PHP或ASP.NET能够接收处理未知会话ID的功能。恶意使用该功能便可跳过会话固定攻击的准备阶段，从Web网站获得发行的会话ID的步骤。即，攻击者可私自创建会话ID构成陷阱，中间件却会误以为该会话ID是未知会话ID而接受</p></li></ul><h4 id="11-4-3-跨站点请求伪造"><a href="#11-4-3-跨站点请求伪造" class="headerlink" title="11.4.3 跨站点请求伪造"></a>11.4.3 跨站点请求伪造</h4><ul><li><p>跨站点请求伪造（Cross-Site Request Forgeries,CSRF）攻击是指攻击者通过设置好的陷阱，强制对已完成认证的用户进行非预期的个人信息或设定信息等某些状态更新，属于被动攻击</p></li><li><p>跨站点请求伪造有可能会造成以下等影响</p><ul><li><p>利用已通过认证的用户权限更新设定信息等</p></li><li><p>利用已通过认证的用户权限购买商品</p></li><li><p>利用已通过认证的用户权限在留言板上发表言论</p></li></ul></li></ul><h3 id="11-5-其他安全漏洞"><a href="#11-5-其他安全漏洞" class="headerlink" title="11.5 其他安全漏洞"></a>11.5 其他安全漏洞</h3><h4 id="11-5-1-密码破解"><a href="#11-5-1-密码破解" class="headerlink" title="11.5.1 密码破解"></a>11.5.1 密码破解</h4><ul><li><p>密码破解攻击（Password Cracking）即算出密码，突破认证。攻击不仅限于Web应用，还包括其他的系统（如FTP或SSH等）</p></li><li><p>密码破解有以下两种手段</p><ul><li><p>通过网络的密码试错</p></li><li><p>对已加密密码的破解（指攻击者入侵系统，已获得加密或散列处理的密码数据的情况）</p></li></ul></li><li><p>除去突破认证的攻击手段，还有SQL注入攻击逃避认证，跨站脚本攻击窃取密码信息等方法</p></li><li><p>通过网络进行密码试错：对Web应用提供的认证功能，通过网络尝试候选密码进行的一种攻击。主要有以下两种方式</p><ul><li><p>穷举法</p><ul><li><p>穷举法（Brute-force Attack，又称暴力破解法）是指对所有密钥集合构成的密钥空间（Keyspace）进行穷举。即，用所有可行的候选密码对目标的密码系统试错，用以突破验证的一种攻击</p></li><li><p>因为穷举法会尝试所有的候选密码，所以是一种必然能够破解密码的攻击。但是，当密钥空间很庞大时，解密可能需要花费数年，甚至千年的时间，因此从现实角度考量，攻击是失败的</p></li></ul></li><li><p>字典攻击</p><ul><li><p>字典攻击是指利用事先收集好的候选密码（经过各种组合方式后存入字典），枚举字典中的密码，尝试通过认证的一种攻击手法</p></li><li><p>与穷举法相比，由于需要尝试的候选密码较少，意味着攻击耗费的时间比较短。但是，如果字典中没有正确的密码，那就无法破解成功。因此攻击的成败取决于字典的内容</p></li></ul></li></ul></li><li><p>对已加密密码的破解：Web应用在保存密码时，一般不会直接以明文的方式保存，通过散列函数做散列处理或加salt的手段对要保存的密码本身加密。那即使攻击者使用某些手段窃取密码数据，如果想要真正使用这些密码，则必须先通过解码等手段，把加密处理的密码还原成明文形式。从加密过的数据中导出明文通常有以下几种方法</p><ul><li><p>通过穷举法+字典攻击进行类推</p><ul><li>针对密码使用散列函数进行加密处理的情况，采用和穷举法或字典攻击相同的手法，尝试调用相同的散列函数加密候选密码，然后把计算出的散列值与目标散列值匹配，类推出密码</li></ul></li><li><p>彩虹表</p><ul><li>彩虹表（Rainbow Table）是由明文密码及与之对应的散列值构成的一张数据库表，是一种通过事先制作庞大的彩虹表，可在穷举法+字典攻击等实际破解过程中缩短消耗时间的技巧。从彩虹表内搜索散列值就可以推导出对应的明文密码</li></ul></li><li><p>拿到密钥</p><ul><li>使用共享密钥加密方式对密码数据进行加密处理的情况下，如果能通过某种手段拿到加密使用的密钥，也就可以对密码数据解密了</li></ul></li><li><p>加密算法的漏洞</p><ul><li>考虑到加密算法本身可能存在的漏洞，利用该漏洞尝试解密也是一种可行的方法。但是要找到那些已广泛使用的加密算法的漏洞，又谈何容易，因此困难极大，不易成功。而Web应用开发者独立实现的加密算法，想必尚未经过充分的验证，还是很有可能存在漏洞的</li></ul></li></ul></li></ul><h4 id="11-5-2-点击劫持"><a href="#11-5-2-点击劫持" class="headerlink" title="11.5.2 点击劫持"></a>11.5.2 点击劫持</h4><ul><li><p>点击劫持（Clickjacking）是指利用透明的按钮或链接做成陷阱，覆盖在Web页面之上。然后诱使用户在不知情的情况下，点击那个链接访问内容的一种攻击手段。这种行为又称为界面伪装（UI Redressing）</p></li><li><p>已设置陷阱的Web页面，表面上内容并无不妥，但早已埋入想让用户点击的链接。当用户点击到透明的按钮时，实际上是点击了已指定透明属性元素的iframe页面</p></li></ul><h4 id="11-5-3-DoS攻击"><a href="#11-5-3-DoS攻击" class="headerlink" title="11.5.3 DoS攻击"></a>11.5.3 DoS攻击</h4><ul><li><p>DoS攻击（Denial of Service attack）是一种让运行中的服务呈停止状态的攻击。有时也叫做服务停止攻击或拒绝服务攻击。DoS攻击的对象不仅限于Web网站，还包括网络设备及服务器等</p></li><li><p>主要有以下两种DoS攻击方式</p><ul><li><p>集中利用访问请求造成资源过载，资源用尽的同时，实际上服务也就呈停止状态</p><ul><li>其中，集中利用访问请求的DoS攻击，单纯来讲就是发送大量的合法请求。服务器很难分辨何为正常请求，何为攻击请求，因此很难防止DoS攻击</li></ul></li><li><p>通过攻击安全漏洞使服务停止</p></li></ul></li><li><p>多台计算机发起的DoS攻击称为DDoS攻击（Distributed Denial of Serviceattack）。DDoS攻击通常利用那些感染病毒的计算机作为攻击者的攻击跳板</p></li></ul><h4 id="11-5-4-后门程序"><a href="#11-5-4-后门程序" class="headerlink" title="11.5.4 后门程序"></a>11.5.4 后门程序</h4><ul><li><p>后门程序（Backdoor）是指开发设置的隐藏入口，可不按正常步骤使用受限功能。利用后门程序就能够使用原本受限制的功能</p></li><li><p>通常的后门程序分为以下3种类型</p><ul><li><p>开发阶段作为Debug调用的后门程序</p></li><li><p>开发者为了自身利益植入的后门程序</p></li><li><p>攻击者通过某种方法设置的后门程序</p></li></ul></li><li><p>可通过监视进程和通信的状态发现被植入的后门程序。但设定在Web应用中的后门程序，由于和正常使用时区别不大，通常很难发现</p></li></ul>]]></content>
    
    
    <categories>
      
      <category>笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>基础体系</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【笔记】图解HTTP（中）</title>
    <link href="/posts/48f3e75f.html"/>
    <url>/posts/48f3e75f.html</url>
    
    <content type="html"><![CDATA[<h2 id="第六章-HTTP首部"><a href="#第六章-HTTP首部" class="headerlink" title="第六章 HTTP首部"></a>第六章 HTTP首部</h2><h3 id="6-1-HTTP报文首部"><a href="#6-1-HTTP报文首部" class="headerlink" title="6.1 HTTP报文首部"></a>6.1 HTTP报文首部</h3><ul><li><p>HTTP报文的结构</p><p><img src="/image/%E5%9B%BE%E8%A7%A3HTTP/fa00a84f49d9ec68d183faa56b606339d1507dac.jpeg" alt="epub_907764_90.jpeg"></p></li><li><p>HTTP协议的请求和响应报文中必定包含HTTP首部。首部内容为客户端和服务器分别处理请求和响应提供所需要的信息。对于客户端用户来说，这些信息中的大部分内容都无须亲自查看</p></li><li><p>在报文众多的字段当中，HTTP首部字段包含的信息最为丰富。首部字段同时存在于请求和响应报文内，并涵盖HTTP报文相关的内容信息。因HTTP版本或扩展规范的变化，首部字段可支持的字段内容略有不同。本书主要涉及HTTP&#x2F;1.1及常用的首部字段</p></li></ul><h3 id="6-2-HTTP首部字段"><a href="#6-2-HTTP首部字段" class="headerlink" title="6.2 HTTP首部字段"></a>6.2 HTTP首部字段</h3><h4 id="6-2-1-HTTP首部字段传递重要信息"><a href="#6-2-1-HTTP首部字段传递重要信息" class="headerlink" title="6.2.1 HTTP首部字段传递重要信息"></a>6.2.1 HTTP首部字段传递重要信息</h4><ul><li><p>HTTP首部字段是构成HTTP报文的要素之一</p><ul><li>在客户端与服务器之间以HTTP协议进行通信的过程中，无论是请求还是响应都会使用首部字段，它能起到传递额外重要信息的作用</li></ul></li><li><p>使用首部字段是为了给浏览器和服务器提供报文主体大小、所使用的语言、认证信息等内容</p></li></ul><h4 id="6-2-2-HTTP首部字段结构"><a href="#6-2-2-HTTP首部字段结构" class="headerlink" title="6.2.2 HTTP首部字段结构"></a>6.2.2 HTTP首部字段结构</h4><ul><li><p>HTTP首部字段是由首部字段名和字段值构成的，中间用冒号“:”分隔</p><figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs http">首部字段名: 字段值<br></code></pre></td></tr></table></figure></li><li><p>另外，字段值对应单个HTTP首部字段可以有多个值，如下所示</p><figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs http"><span class="hljs-attribute">Keep-Alive</span><span class="hljs-punctuation">: </span>timeout=15, max=100<br></code></pre></td></tr></table></figure></li><li><p>若HTTP首部字段重复了会如何</p><ul><li>当HTTP报文首部中出现了两个或两个以上具有相同首部字段名时会怎么样？这种情况在规范内尚未明确，根据浏览器内部处理逻辑的不同，结果可能并不一致。有些浏览器会优先处理第一次出现的首部字段，而有些则会优先处理最后出现的首部字段</li></ul></li></ul><h4 id="6-2-3-4种HTTP首部字段类型"><a href="#6-2-3-4种HTTP首部字段类型" class="headerlink" title="6.2.3 4种HTTP首部字段类型"></a>6.2.3 4种HTTP首部字段类型</h4><ul><li><p>HTTP首部字段根据实际用途被分为以下4种类型</p><ul><li><p>通用首部字段（General Header Fields）：请求报文和响应报文两方都会使用的首部</p></li><li><p>请求首部字段（Request Header Fields）：从客户端向服务器端发送请求报文时使用的首部。补充了请求的附加内容、客户端信息、响应内容相关优先级等信息</p></li><li><p>响应首部字段（Response Header Fields）：从服务器端向客户端返回响应报文时使用的首部。补充了响应的附加内容，也会要求客户端附加额外的内容信息</p></li><li><p>实体首部字段（Entity Header Fields）：针对请求报文和响应报文的实体部分使用的首部。补充了资源内容更新时间等与实体有关的信息</p></li></ul></li></ul><h4 id="6-2-4-HTTP-x2F-1-1-首部字段一览"><a href="#6-2-4-HTTP-x2F-1-1-首部字段一览" class="headerlink" title="6.2.4 HTTP&#x2F;1.1 首部字段一览"></a>6.2.4 HTTP&#x2F;1.1 首部字段一览</h4><ul><li><p>HTTP&#x2F;1.1规范定义了如下47种首部字段</p></li><li><p>通用首部字段</p><p><img src="/image/%E5%9B%BE%E8%A7%A3HTTP/c3b0ce1302b3a30953191f363c8e9300399099dd.jpeg" alt="epub_907764_94.jpeg"></p></li><li><p>请求首部字段</p><p><img src="/image/%E5%9B%BE%E8%A7%A3HTTP/62040cd129ed235bd71914386d1d0b8d57a6fc37.jpeg" alt="epub_907764_95.jpeg"></p></li><li><p>响应首部字段</p><p><img src="/image/%E5%9B%BE%E8%A7%A3HTTP/361adb2fc90c6ef5f97327f581c78d66b5ab3d8d.jpeg" alt="epub_907764_96.jpeg"></p></li><li><p>实体首部字段</p><p><img src="/image/%E5%9B%BE%E8%A7%A3HTTP/6ba0cf3db954e78eed595c5001c1cb09f92455a9.jpeg" alt="epub_907764_97.jpeg"></p></li></ul><h4 id="6-2-5-非HTTP-x2F-1-1首部字段"><a href="#6-2-5-非HTTP-x2F-1-1首部字段" class="headerlink" title="6.2.5 非HTTP&#x2F;1.1首部字段"></a>6.2.5 非HTTP&#x2F;1.1首部字段</h4><ul><li>在HTTP协议通信交互中使用到的首部字段，不限于RFC2616中定义的47种首部字段。还有Cookie、Set-Cookie和Content-Disposition等在其他RFC中定义的首部字段，它们的使用频率也很高。这些非正式的首部字段统一归纳在RFC4229 HTTP Header FieldRegistrations中</li></ul><h4 id="6-2-6-End-to-end首部和Hop-by-hop首部"><a href="#6-2-6-End-to-end首部和Hop-by-hop首部" class="headerlink" title="6.2.6 End-to-end首部和Hop-by-hop首部"></a>6.2.6 End-to-end首部和Hop-by-hop首部</h4><ul><li><p>HTTP首部字段将定义成缓存代理和非缓存代理的行为，分成2种类型</p><ul><li><p>端到端首部（End-to-end Header）</p><ul><li>分在此类别中的首部会转发给请求&#x2F;响应对应的最终接收目标，且必须保存在由缓存生成的响应中，另外规定它必须被转发</li></ul></li><li><p>逐跳首部（Hop-by-hop Header）</p><ul><li><p>分在此类别中的首部只对单次转发有效，会因通过缓存或代理而不再转发</p></li><li><p>HTTP&#x2F;1.1和之后版本中，如果要使用hop-by-hop首部，需提供Connection首部字段</p></li></ul></li></ul></li><li><p>下面列举了HTTP&#x2F;1.1中的逐跳首部字段。除这8个首部字段之外，其他所有字段都属于端到端首部</p><ul><li><p>Connection</p></li><li><p>Keep-Alive</p></li><li><p>Proxy-Authenticate</p></li><li><p>Proxy-Authorization</p></li><li><p>Trailer</p></li><li><p>TE</p></li><li><p>Transfer-Encoding</p></li><li><p>Upgrade</p></li></ul></li></ul><h3 id="6-3-HTTP-x2F-1-1-通用首部字段"><a href="#6-3-HTTP-x2F-1-1-通用首部字段" class="headerlink" title="6.3 HTTP&#x2F;1.1 通用首部字段"></a>6.3 HTTP&#x2F;1.1 通用首部字段</h3><ul><li>通用首部字段是指，请求报文和响应报文双方都会使用的首部</li></ul><h4 id="6-3-1-Cache-Control"><a href="#6-3-1-Cache-Control" class="headerlink" title="6.3.1 Cache-Control"></a>6.3.1 Cache-Control</h4><ul><li><p>通过指定首部字段Cache-Control的指令，就能操作缓存的工作机制。指令的参数是可选的，多个指令之间通过“,”分隔。首部字段Cache-Control的指令可用于请求及响应时</p><figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs http"><span class="hljs-attribute">Cache-Control</span><span class="hljs-punctuation">: </span>private, max-age=0, no-cache<br></code></pre></td></tr></table></figure></li><li><p>可用的指令按请求和响应分类如下所示</p><ul><li><p>缓存请求指令</p><p><img src="/image/%E5%9B%BE%E8%A7%A3HTTP/75a0bd1ceabb3f1e2db5b3f2ef286c8f7b1728e1.jpeg" alt="epub_907764_99.jpeg"></p></li><li><p>缓存响应指令</p><p><img src="/image/%E5%9B%BE%E8%A7%A3HTTP/0ef8797565900d0bcb18f5b321d15e4980d714bf.jpeg" alt="epub_907764_100.jpeg"></p></li></ul></li><li><p>表示是否能缓存的指令</p><ul><li><p>public指令</p><ul><li>当指定使用public指令时，则明确表明其他用户也可利用缓存</li></ul></li><li><p>private指令</p><ul><li><p>当指定private指令后，响应只以特定的用户作为对象，这与public指令的行为相反</p></li><li><p>缓存服务器会对该特定用户提供资源缓存的服务，对于其他用户发送过来的请求，代理服务器则不会返回缓存</p></li></ul></li><li><p>no-cache指令</p><ul><li><p>使用no-cache指令的目的是为了防止从缓存中返回过期的资源</p></li><li><p>在浏览器使用缓存前，会往返对比 ETag，如果 ETag 没变，返回 304，则使用缓存； 使用no-cache的目的就是为了防止从缓存中获取过期的资源</p></li><li><p>客户端发送的请求中如果包含no-cache指令，则表示客户端将不会接收缓存过的响应。于是，“中间”的缓存服务器必须把客户端请求转发给源服务器</p></li><li><p>如果服务器返回的响应中包含no-cache指令，那么缓存服务器不能对资源进行缓存。源服务器以后也将不再对缓存服务器请求中提出的资源有效性进行确认，且禁止其对响应资源进行缓存操作</p></li><li><p>由服务器返回的响应中，若报文首部字段Cache-Control中对no-cache字段名具体指定参数值，那么客户端在接收到这个被指定参数值的首部字段对应的响应报文后，就不能使用缓存。换言之，无参数值的首部字段可以使用缓存。只能在响应指令中指定该参数</p><figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs http"><span class="hljs-attribute">Cache-Control</span><span class="hljs-punctuation">: </span>no-cache=Location<br></code></pre></td></tr></table></figure></li></ul></li></ul></li><li><p>控制可执行缓存的对象的指令</p><ul><li><p>no-store指令</p><ul><li><p>当使用no-store指令时，暗示请求（和对应的响应）或响应中包含机密信息。因此，该指令规定缓存不能在本地存储请求或响应的任一部分</p></li><li><p>从字面意思上很容易把no-cache误解成为不缓存，但事实上no-cache代表不缓存过期的资源，缓存会向源服务器进行有效期确认后处理资源，也许称为do-not-serve-from-cache-without-revalidation更合适。no-store才是真正地不进行缓存，请读者注意区别理解。——译者注</p></li></ul></li></ul></li><li><p>指定缓存期限和认证的指令</p><ul><li><p>s-maxage指令</p><ul><li><p>s-maxage指令的功能和max-age指令的相同，它们的不同点是s-maxage指令只适用于供多位用户使用的公共缓存服务器（这里一般指代理）。也就是说，对于向同一用户重复返回响应的服务器来说，这个指令没有任何作用</p></li><li><p>另外，当使用s-maxage指令后，则直接忽略对Expires首部字段及max-age指令的处理</p></li></ul></li><li><p>max-age指令</p><ul><li><p>当客户端发送的请求中包含max-age指令时，如果判定缓存资源的缓存时间数值比指定时间的数值更小，那么客户端就接收缓存的资源。另外，当指定max-age值为0，那么缓存服务器通常需要将请求转发给源服务器</p></li><li><p>当服务器返回的响应中包含max-age指令时，缓存服务器将不对资源的有效性再作确认，而max-age数值代表资源保存为缓存的最长时间</p></li><li><p>应用HTTP&#x2F;1.1版本的缓存服务器遇到同时存在Expires首部字段的情况时，会优先处理max-age指令，而忽略掉Expires首部字段。而HTTP&#x2F;1.0版本的缓存服务器的情况却相反，max-age指令会被忽略掉</p></li></ul></li><li><p>min-fresh指令</p><ul><li>min-fresh指令要求缓存服务器返回至少还未过指定时间的缓存资源。比如，当指定min-fresh为60秒后，在这60秒以内如果有超过有效期限的资源都无法作为响应返回了</li></ul></li><li><p>max-stale指令</p><ul><li><p>使用max-stale可指示缓存资源，即使过期也照常接收</p></li><li><p>如果指令未指定参数值，那么无论经过多久，客户端都会接收响应</p></li><li><p>如果指令中指定了具体数值，那么即使过期，只要仍处于max-stale指定的时间内，仍旧会被客户端接收</p></li></ul></li><li><p>only-if-cached指令</p><ul><li><p>使用max-stale可指示缓存资源，即使过期也照常接收</p></li><li><p>如果指令未指定参数值，那么无论经过多久，客户端都会接收响应</p></li><li><p>如果指令中指定了具体数值，那么即使过期，只要仍处于max-stale指定的时间内，仍旧会被客户端接收</p></li></ul></li><li><p>must-revalidate指令</p><ul><li><p>使用must-revalidate指令，代理会向源服务器再次验证即将返回的响应缓存目前是否仍然有效</p></li><li><p>若代理无法连通源服务器再次获取有效资源的话，缓存必须给客户端一条504（Gateway Timeout）状态码</p></li><li><p>另外，使用must-revalidate指令会忽略请求的max-stale指令（即使已经在首部使用了max-stale，也不会再有效果）</p></li></ul></li><li><p>proxy-revalidate指令</p><ul><li>proxy-revalidate指令要求所有的缓存服务器在接收到客户端带有该指令的请求返回响应之前，必须再次验证缓存的有效性</li></ul></li><li><p>no-transform指令</p><ul><li>使用no-transform指令规定无论是在请求还是响应中，缓存都不能改变实体主体的媒体类型。这样做可防止缓存或代理压缩图片等类似操作</li></ul></li></ul></li><li><p>Cache-Control扩展</p><ul><li><p>cache-extension token</p><ul><li><p>通过cache-extension标记（token），可以扩展Cache-Control首部字段内的指令</p></li><li><p>如下例，Cache-Control首部字段本身没有community这个指令。借助extension tokens实现了该指令的添加。如果缓存服务器不能理解community这个新指令，就会直接忽略。因此，extension tokens仅对能理解它的缓存服务器来说是有意义的</p><figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs http"><span class="hljs-attribute">Cache-Control</span><span class="hljs-punctuation">: </span>private, community=&quot;UCI&quot;<br></code></pre></td></tr></table></figure></li></ul></li></ul></li></ul><h4 id="6-3-2-Connection"><a href="#6-3-2-Connection" class="headerlink" title="6.3.2 Connection"></a>6.3.2 Connection</h4><ul><li><p>Connection首部字段具备如下两个作用</p><ul><li><p>控制不再转发给代理的首部字段</p></li><li><p>管理持久连接</p></li></ul></li><li><p>控制不再转发给代理的首部字段</p><ul><li><p>格式</p><p><img src="/image/%E5%9B%BE%E8%A7%A3HTTP/9fcf8054806948be9652841e87a92b0ac0d2c3ef.jpeg" alt="epub_907764_107.jpeg"></p><figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs http"><span class="hljs-attribute">Connection</span><span class="hljs-punctuation">: </span>不再转发的字段<br></code></pre></td></tr></table></figure></li><li><p>在客户端发送请求和服务器返回响应内，使用Connection首部字段，可控制不再转发给代理的首部字段（即Hop-by-hop首部）</p></li></ul></li><li><p>管理持久连接</p><ul><li><p>格式</p><p><img src="/image/%E5%9B%BE%E8%A7%A3HTTP/3680aeb5455af9b22a99303caee9818f4586ee88.jpeg" alt="epub_907764_108.jpeg"></p><p><img src="/image/%E5%9B%BE%E8%A7%A3HTTP/25d3e5607ac023961120cd36d3429887ea20cab6.jpeg" alt="epub_907764_109.jpeg"></p><figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs http"><span class="hljs-attribute">Connection</span><span class="hljs-punctuation">: </span>close<br><span class="hljs-attribute">Connection</span><span class="hljs-punctuation">: </span>Keep-Alive<br></code></pre></td></tr></table></figure></li><li><p>HTTP&#x2F;1.1版本的默认连接都是持久连接。为此，客户端会在持久连接上连续发送请求。当服务器端想明确断开连接时，则指定Connection首部字段的值为Close</p></li><li><p>HTTP&#x2F;1.1之前的HTTP版本的默认连接都是非持久连接。为此，如果想在旧版本的HTTP协议上维持持续连接，则需要指定Connection首部字段的值为Keep-Alive</p></li></ul></li></ul><h4 id="6-3-3-Date"><a href="#6-3-3-Date" class="headerlink" title="6.3.3 Date"></a>6.3.3 Date</h4><ul><li><p>首部字段Date表明创建HTTP报文的日期和时间</p></li><li><p>HTTP&#x2F;1.1协议使用在RFC1123中规定的日期时间的格式，如下示例</p><figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs http"><span class="hljs-attribute">Date</span><span class="hljs-punctuation">: </span>Tue, 03 Jul 2012 04:40:59 GMT<br></code></pre></td></tr></table></figure></li><li><p>之前的HTTP协议版本中使用在RFC850中定义的格式，如下所示</p><figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs http"><span class="hljs-attribute">Date</span><span class="hljs-punctuation">: </span>Tue, 03-Jul-12 04:40:59 gmt<br></code></pre></td></tr></table></figure></li><li><p>除此之外，还有一种格式。它与C标准库内的asctime()函数的输出格式一致</p><figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs http"><span class="hljs-attribute">Date</span><span class="hljs-punctuation">: </span>Tue Jul 03 04:40:59 2012<br></code></pre></td></tr></table></figure></li></ul><h4 id="6-3-4-Pragma"><a href="#6-3-4-Pragma" class="headerlink" title="6.3.4 Pragma"></a>6.3.4 Pragma</h4><ul><li><p>Pragma是HTTP&#x2F;1.1之前版本的历史遗留字段，仅作为与HTTP&#x2F;1.0的向后兼容而定义。规范定义的形式唯一，如下所示</p><figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs http"><span class="hljs-attribute">Pragma</span><span class="hljs-punctuation">: </span>no-cache<br></code></pre></td></tr></table></figure></li><li><p>该首部字段属于通用首部字段，但只用在客户端发送的请求中。客户端会要求所有的中间服务器不返回缓存的资源</p></li><li><p>所有的中间服务器如果都能以HTTP&#x2F;1.1为基准，那直接采用Cache-Control:no-cache指定缓存的处理方式是最为理想的。但要整体掌握全部中间服务器使用的HTTP协议版本却是不现实的。因此，发送的请求会同时含有下面两个首部字段</p><figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs http"><span class="hljs-attribute">Cache-Control</span><span class="hljs-punctuation">: </span>no-cache<br><span class="hljs-attribute">Pragma</span><span class="hljs-punctuation">: </span>no-cache<br></code></pre></td></tr></table></figure></li></ul><h4 id="6-3-5-Trailer"><a href="#6-3-5-Trailer" class="headerlink" title="6.3.5 Trailer"></a>6.3.5 Trailer</h4><ul><li><p>首部字段Trailer会事先说明在报文主体后记录了哪些首部字段。该首部字段可应用在HTTP&#x2F;1.1版本分块传输编码时</p></li><li><p>以下用例中，指定首部字段Trailer的值为Expires，在报文主体之后（分块长度0之后）出现了首部字段Expires</p><figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs http"><span class="hljs-meta">HTTP/1.1</span> <span class="hljs-number">200</span> OK<br><span class="hljs-attribute">Date</span><span class="hljs-punctuation">: </span>Tue, 03 Jul 2012 04:40:56 GMT<br><span class="hljs-attribute">Content-Type</span><span class="hljs-punctuation">: </span>text/html<br>...<br><span class="hljs-attribute">Transfer-Encoding</span><span class="hljs-punctuation">: </span>chunked<br><span class="hljs-attribute">Trailer</span><span class="hljs-punctuation">: </span>Expires<br>...(报文主体)..<br>0<br><span class="hljs-attribute">Expires</span><span class="hljs-punctuation">: </span>Tue, 28 Sep 2004 23:59:59 GMT<br></code></pre></td></tr></table></figure></li></ul><h4 id="6-3-6-Transfer-Encoding"><a href="#6-3-6-Transfer-Encoding" class="headerlink" title="6.3.6 Transfer-Encoding"></a>6.3.6 Transfer-Encoding</h4><ul><li><p>首部字段Transfer-Encoding规定了传输报文主体时采用的编码方式。HTTP&#x2F;1.1的传输编码方式仅对分块传输编码有效</p></li><li><p>以下用例中，正如在首部字段Transfer-Encoding中指定的那样，有效使用分块传输编码，且分别被分成3312字节和914字节大小的分块数据</p><figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs http"><span class="hljs-meta">HTTP/1.1</span> <span class="hljs-number">200</span> OK<br><span class="hljs-attribute">Date</span><span class="hljs-punctuation">: </span>Tue, 03 Jul 2012 04:40:56 GMT<br><span class="hljs-attribute">Cache-Control</span><span class="hljs-punctuation">: </span>public, max-age=604800<br><span class="hljs-attribute">Content-Type</span><span class="hljs-punctuation">: </span>text/javascript; charset=utf-8<br><span class="hljs-attribute">Expires</span><span class="hljs-punctuation">: </span>Tue, 10 Jul 2012 04:40:56 GMT<br><span class="hljs-attribute">X-Frame-Options</span><span class="hljs-punctuation">: </span>DENY<br><span class="hljs-attribute">X-XSS-Protection</span><span class="hljs-punctuation">: </span>1; mode=block<br><span class="hljs-attribute">Content-Encoding</span><span class="hljs-punctuation">: </span>gzip<br><span class="hljs-attribute">Transfer-Encoding</span><span class="hljs-punctuation">: </span>chunked<br><span class="hljs-attribute">Connection</span><span class="hljs-punctuation">: </span>keep-alive<br>cf0    ←16进制(10进制为3312)<br>...3312字节分块数据．..<br>392    ←16进制(10进制为914)<br>...914字节分块数据．..<br>0<br></code></pre></td></tr></table></figure></li></ul><h4 id="6-3-7-Upgrade"><a href="#6-3-7-Upgrade" class="headerlink" title="6.3.7 Upgrade"></a>6.3.7 Upgrade</h4><ul><li><p>首部字段Upgrade用于检测HTTP协议及其他协议是否可使用更高的版本进行通信，其参数值可以用来指定一个完全不同的通信协议</p></li><li><p>下图用例中，首部字段Upgrade指定的值为TLS&#x2F;1.0。请注意此处两个字段首部字段的对应关系，Connection的值被指定为Upgrade。Upgrade首部字段产生作用的Upgrade对象仅限于客户端和邻接服务器之间。因此，使用首部字段Upgrade时，还需要额外指定Connection:Upgrade</p><p><img src="/image/%E5%9B%BE%E8%A7%A3HTTP/14814180d2e2754ec2aedcad4128e643f32a51cb.jpeg" alt="epub_907764_114.jpeg"></p></li><li><p>对于附有首部字段Upgrade的请求，服务器可用101 Switching Protocols状态码作为响应返回</p></li></ul><h4 id="6-3-8-Via"><a href="#6-3-8-Via" class="headerlink" title="6.3.8 Via"></a>6.3.8 Via</h4><ul><li><p>使用首部字段Via是为了追踪客户端与服务器之间的请求和响应报文的传输路径</p></li><li><p>报文经过代理或网关时，会先在首部字段Via中附加该服务器的信息，然后再进行转发。这个做法和traceroute及电子邮件的Received首部的工作机制很类似</p></li><li><p>首部字段Via不仅用于追踪报文的转发，还可避免请求回环的发生。所以必须在经过代理时附加该首部字段内容</p></li><li><p>下图用例中，在经过代理服务器A时，Via首部附加了“1.0 gw. hackr.jp(Squid&#x2F;3.1)”这样的字符串值。行头的1.0是指接收请求的服务器上应用的HTTP协议版本。接下来经过代理服务器B时亦是如此，在Via首部附加服务器信息，也可增加1个新的Via首部写入服务器信息</p><p><img src="/image/%E5%9B%BE%E8%A7%A3HTTP/34ef3d2255a9998268a6a0a58f746766fd0c32aa.jpeg" alt="epub_907764_115.jpeg"></p></li><li><p>Via首部是为了追踪传输路径，所以经常会和TRACE方法一起使用。比如，代理服务器接收到由TRACE方法发送过来的请求（其中Max-Forwards: 0）时，代理服务器就不能再转发该请求了。这种情况下，代理服务器会将自身的信息附加到Via首部后，返回该请求的响应</p></li></ul><h4 id="6-3-9-Warning"><a href="#6-3-9-Warning" class="headerlink" title="6.3.9 Warning"></a>6.3.9 Warning</h4><ul><li><p>HTTP&#x2F;1.1的Warning首部是从HTTP&#x2F;1.0的响应首部（Retry-After）演变过来的。该首部通常会告知用户一些与缓存相关的问题的警告</p></li><li><p>Warning首部的格式如下。最后的日期时间部分可省略。</p><figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs http"><span class="hljs-attribute">Warning</span><span class="hljs-punctuation">: </span>[警告码][警告的主机: 端口号]&quot;[警告内容]&quot;([日期时间])<br></code></pre></td></tr></table></figure></li><li><p>示例</p><figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs http"><span class="hljs-attribute">Waring</span><span class="hljs-punctuation">: </span>113 gw.hackr.jp:8080 &quot;Heuristic expiration&quot; Tue, 03 Jul 2012 05:09:44 GMT<br></code></pre></td></tr></table></figure></li><li><p>HTTP&#x2F;1.1中定义了7种警告。警告码对应的警告内容仅推荐参考。另外，警告码具备扩展性，今后有可能追加新的警告码</p><p><img src="/image/%E5%9B%BE%E8%A7%A3HTTP/172b25b5d73ca9459fd2dafcda33b729be709d0b.jpeg" alt="epub_907764_116.jpeg"></p></li></ul><h3 id="6-4-请求首部字段"><a href="#6-4-请求首部字段" class="headerlink" title="6.4 请求首部字段"></a>6.4 请求首部字段</h3><ul><li>请求首部字段是从客户端往服务器端发送请求报文中所使用的字段，用于补充请求的附加信息、客户端信息、对响应内容相关的优先级等内容</li></ul><h4 id="6-4-1-Accept"><a href="#6-4-1-Accept" class="headerlink" title="6.4.1 Accept"></a>6.4.1 Accept</h4><ul><li><p>Accept首部字段可通知服务器，用户代理能够处理的媒体类型及媒体类型的相对优先级。可使用type&#x2F;subtype这种形式，一次指定多种媒体类型</p></li><li><p>下面我们试举几个媒体类型的例子</p><ul><li><p>文本文件：</p><ul><li><p>text&#x2F;html，text&#x2F;plain，text&#x2F;css……</p></li><li><p>application&#x2F;xhtml+xml，application&#x2F;xml……</p></li></ul></li><li><p>图片文件：image&#x2F;jpeg，image&#x2F;gif，image&#x2F;png……</p></li><li><p>视频文件：video&#x2F;mpeg，video&#x2F;quicktime……</p></li><li><p>应用程序使用的二进制文件：application&#x2F;octet-stream，application&#x2F;zip……</p></li></ul></li><li><p>如果浏览器不支持PNG图片的显示，那Accept就不指定image&#x2F;png，而指定可处理的image&#x2F;gif和image&#x2F;jpeg等图片类型</p></li><li><p>若想要给显示的媒体类型增加优先级，则使用q&#x3D;来额外表示权重值，用分号（;）进行分隔</p><ul><li><p>权重值q的范围是0～1（可精确到小数点后3位），且1为最大值。不指定权重q值时，默认权重为q&#x3D;1.0</p></li><li><p>当服务器提供多种内容时，将会首先返回权重值最高的媒体类型</p></li><li><p>原文是“品質係数”。在RFC2616定义中，此处的q是指qvalue，即quality factor。直译的话就是质量数，但经过综合考虑理解记忆的便利性后，似乎采用权重值更为稳妥。——译者注</p></li></ul></li><li><p>示例</p><figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs http"><span class="hljs-attribute">Accept</span><span class="hljs-punctuation">: </span>text/html,application/xhtml+xml,application/xml;q=0.9, */*;q=0.8<br></code></pre></td></tr></table></figure></li></ul><h4 id="6-4-2-Accept-Charset"><a href="#6-4-2-Accept-Charset" class="headerlink" title="6.4.2 Accept-Charset"></a>6.4.2 Accept-Charset</h4><ul><li><p>Accept-Charset首部字段可用来通知服务器用户代理支持的字符集及字符集的相对优先顺序。另外，可一次性指定多种字符集。与首部字段Accept相同的是可用权重q值来表示相对优先级</p></li><li><p>该首部字段应用于内容协商机制的服务器驱动协商</p></li><li><p>示例</p><figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs http"><span class="hljs-attribute">Accept-Charset</span><span class="hljs-punctuation">: </span>iso-8859-5, unicode-1-1;q=0.8, zh;q=.0.9<br></code></pre></td></tr></table></figure></li></ul><h4 id="6-4-3-Accept-Encoding"><a href="#6-4-3-Accept-Encoding" class="headerlink" title="6.4.3 Accept-Encoding"></a>6.4.3 Accept-Encoding</h4><ul><li><p>Accept-Encoding首部字段用来告知服务器用户代理支持的内容编码及内容编码的优先级顺序。可一次性指定多种内容编码</p></li><li><p>下面试举出几个内容编码的例子</p><ul><li><p>gzip：由文件压缩程序gzip（GNU zip）生成的编码格式（RFC1952），采用Lempel-Ziv算法（LZ77）及32位循环冗余校验（CyclicRedundancy Check，通称CRC）</p></li><li><p>compress：由UNIX文件压缩程序compress生成的编码格式，采用Lempel-Ziv-Welch算法（LZW）</p></li><li><p>deflate：组合使用zlib格式（RFC1950）及由deflate压缩算法（RFC1951）生成的编码格式</p></li><li><p>identity：不执行压缩或不会变化的默认编码格式</p></li></ul></li><li><p>采用权重q值来表示相对优先级，这点与首部字段Accept相同。另外，也可使用星号（*）作为通配符，指定任意的编码格式</p></li><li><p>示例</p><figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs http"><span class="hljs-attribute">Accept-Encoding</span><span class="hljs-punctuation">: </span>gzip, deflate<br></code></pre></td></tr></table></figure></li></ul><h4 id="6-4-4-Accept-Language"><a href="#6-4-4-Accept-Language" class="headerlink" title="6.4.4 Accept-Language"></a>6.4.4 Accept-Language</h4><ul><li><p>首部字段Accept-Language用来告知服务器用户代理能够处理的自然语言集（指中文或英文等），以及自然语言集的相对优先级。可一次指定多种自然语言集</p></li><li><p>和Accept首部字段一样，按权重值q来表示相对优先级</p></li><li><p>示例</p><figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs http"><span class="hljs-attribute">Accept-Language</span><span class="hljs-punctuation">: </span>zh-cn,zh;q=0.7, en-us,en;1=0.3<br></code></pre></td></tr></table></figure></li></ul><h4 id="6-4-5-Authorization"><a href="#6-4-5-Authorization" class="headerlink" title="6.4.5 Authorization"></a>6.4.5 Authorization</h4><ul><li><p>首部字段Authorization是用来告知服务器，用户代理的认证信息（证书值）</p><ul><li><p>通常，想要通过服务器认证的用户代理会在接收到返回的401状态码响应后，把首部字段Authorization加入请求中</p></li><li><p>共用缓存在接收到含有Authorization首部字段的请求时的操作处理会略有差异</p></li></ul></li><li><p>示例</p><figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs http"><span class="hljs-attribute">Authorization</span><span class="hljs-punctuation">: </span>Basic abcdefghijk==<br></code></pre></td></tr></table></figure></li></ul><h4 id="6-4-6-Expect"><a href="#6-4-6-Expect" class="headerlink" title="6.4.6 Expect"></a>6.4.6 Expect</h4><ul><li><p>客户端使用首部字段Expect来告知服务器，期望出现的某种特定行为。因服务器无法理解客户端的期望作出回应而发生错误时，会返回状态码417Expectation Failed</p></li><li><p>客户端可以利用该首部字段，写明所期望的扩展。虽然HTTP&#x2F;1.1规范只定义了100-continue（状态码100 Continue之意）</p></li><li><p>等待状态码100响应的客户端在发生请求时，需要指定Expect:100-continue</p><figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs http"><span class="hljs-attribute">Expect</span><span class="hljs-punctuation">: </span>100-continue<br></code></pre></td></tr></table></figure></li></ul><h4 id="6-4-7-From"><a href="#6-4-7-From" class="headerlink" title="6.4.7 From"></a>6.4.7 From</h4><ul><li><p>首部字段From用来告知服务器使用用户代理的用户的电子邮件地址</p><ul><li><p>通常，其使用目的就是为了显示搜索引擎等用户代理的负责人的电子邮件联系方式</p></li><li><p>使用代理时，应尽可能包含From首部字段（但可能会因代理不同，将电子邮件地址记录在User-Agent首部字段内）</p></li></ul></li></ul><h4 id="6-4-8-Host"><a href="#6-4-8-Host" class="headerlink" title="6.4.8 Host"></a>6.4.8 Host</h4><ul><li><p>首部字段Host会告知服务器，请求的资源所处的互联网主机名和端口号</p></li><li><p>Host首部字段在HTTP&#x2F;1.1规范内是唯一一个必须被包含在请求内的首部字段</p></li><li><p>首部字段Host和以单台服务器分配多个域名的虚拟主机的工作机制有很密切的关联，这是首部字段Host必须存在的意义</p></li><li><p>请求被发送至服务器时，请求中的主机名会用IP地址直接替换解决。但如果这时，相同的IP地址下部署运行着多个域名，那么服务器就会无法理解究竟是哪个域名对应的请求。因此，就需要使用首部字段Host来明确指出请求的主机名</p><figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs http"><span class="hljs-attribute">Host</span><span class="hljs-punctuation">: </span>www.hackr.jp<br></code></pre></td></tr></table></figure></li><li><p>若服务器未设定主机名，那直接发送一个空值即可</p><figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs http">Host:<br></code></pre></td></tr></table></figure></li></ul><h4 id="6-4-9-If-Match"><a href="#6-4-9-If-Match" class="headerlink" title="6.4.9 If-Match"></a>6.4.9 If-Match</h4><ul><li><p>形如If-xxx这种样式的请求首部字段，都可称为条件请求。服务器接收到附带条件的请求后，只有判断指定条件为真时，才会执行请求</p></li><li><p>只有当If-Match的字段值跟ETag值匹配一致时，服务器才会接受请求</p><p><img src="/image/%E5%9B%BE%E8%A7%A3HTTP/e27aa789d32f23889a325b2ae0814ba9b59f60a6.jpeg" alt="epub_907764_128.jpeg"></p></li><li><p>首部字段If-Match，属附带条件之一，它会告知服务器匹配资源所用的实体标记（ETag）值。这时的服务器无法使用弱ETag值。（请参照本章有关首部字段ETag的说明）</p></li><li><p>服务器会比对If-Match的字段值和资源的ETag值，仅当两者一致时，才会执行请求。反之，则返回状态码412 Precondition Failed的响应</p></li><li><p>还可以使用星号（*）指定If-Match的字段值。针对这种情况，服务器将会忽略ETag的值，只要资源存在就处理请求</p></li></ul><h4 id="6-4-10-If-Modified-Since"><a href="#6-4-10-If-Modified-Since" class="headerlink" title="6.4.10 If-Modified-Since"></a>6.4.10 If-Modified-Since</h4><ul><li><p>如果在If-Modified-Since字段指定的日期时间后，资源发生了更新，服务器会接受请求</p><p><img src="/image/%E5%9B%BE%E8%A7%A3HTTP/558272f25f291d12bae79ffa36f4a1024b6216ee.jpeg" alt="epub_907764_129.jpeg"></p></li><li><p>首部字段If-Modified-Since，属附带条件之一，它会告知服务器若If-Modified-Since字段值早于资源的更新时间，则希望能处理该请求。而在指定If-Modified-Since字段值的日期时间之后，如果请求的资源都没有过更新，则返回状态码304 Not Modified的响应</p></li><li><p>If-Modified-Since用于确认代理或客户端拥有的本地资源的有效性。获取资源的更新日期时间，可通过确认首部字段Last-Modified来确定</p></li></ul><h4 id="6-4-11-If-None-Match"><a href="#6-4-11-If-None-Match" class="headerlink" title="6.4.11 If-None-Match"></a>6.4.11 If-None-Match</h4><ul><li><p>只有在If-None-Match的字段值与ETag值不一致时，可处理该请求。与If-Match首部字段的作用相反</p></li><li><p>首部字段If-None-Match属于附带条件之一。它和首部字段If-Match作用相反。用于指定If-None-Match字段值的实体标记（ETag）值与请求资源的ETag不一致时，它就告知服务器处理该请求</p></li><li><p>在GET或HEAD方法中使用首部字段If-None-Match可获取最新的资源。因此，这与使用首部字段If-Modified-Since时有些类似</p></li></ul><h4 id="6-4-12-If-Range"><a href="#6-4-12-If-Range" class="headerlink" title="6.4.12 If-Range"></a>6.4.12 If-Range</h4><ul><li><p>首部字段If-Range属于附带条件之一。它告知服务器若指定的If-Range字段值（ETag值或者时间）和请求资源的ETag值或时间相一致时，则作为范围请求处理。反之，则返回全体资源</p><p><img src="/image/%E5%9B%BE%E8%A7%A3HTTP/5bf8bf98ecbe9a541383edebb564ce38ed74be6b.jpeg" alt="epub_907764_131.jpeg"></p></li><li><p>下面我们思考一下不使用首部字段If-Range发送请求的情况。服务器端的资源如果更新，那客户端持有资源中的一部分也会随之无效，当然，范围请求作为前提是无效的。这时，服务器会暂且以状态码412 Precondition Failed作为响应返回，其目的是催促客户端再次发送请求。这样一来，与使用首部字段If-Range比起来，就需要花费两倍的功夫</p><p><img src="/image/%E5%9B%BE%E8%A7%A3HTTP/20ad1b71eb41bc54b1b99ccfb6fea3b828e81d9f.jpeg" alt="epub_907764_132.jpeg"></p></li></ul><h4 id="6-4-13-If-Unmodified-Since"><a href="#6-4-13-If-Unmodified-Since" class="headerlink" title="6.4.13 If-Unmodified-Since"></a>6.4.13 If-Unmodified-Since</h4><ul><li>首部字段If-Unmodified-Since和首部字段If-Modified-Since的作用相反。它的作用的是告知服务器，指定的请求资源只有在字段值内指定的日期时间之后，未发生更新的情况下，才能处理请求。如果在指定日期时间后发生了更新，则以状态码412 Precondition Failed作为响应返回</li></ul><h4 id="6-4-14-Max-Forwards"><a href="#6-4-14-Max-Forwards" class="headerlink" title="6.4.14 Max-Forwards"></a>6.4.14 Max-Forwards</h4><ul><li><p>通过TRACE方法或OPTIONS方法，发送包含首部字段Max-Forwards的请求时，该字段以十进制整数形式指定可经过的服务器最大数目。服务器在往下一个服务器转发请求之前，会将Max-Forwards的值减1后重新赋值。当服务器接收到Max-Forwards值为0的请求时，则不再进行转发，而是直接返回响应</p></li><li><p>使用HTTP协议通信时，请求可能会经过代理等多台服务器。途中，如果代理服务器由于某些原因导致请求转发失败，客户端也就等不到服务器返回的响应了。对此，我们无从可知。可以灵活使用首部字段Max-Forwards，针对以上问题产生的原因展开调查。由于当Max-Forwards字段值为0时，服务器就会立即返回响应，由此我们至少可以对以那台服务器为终点的传输路径的通信状况有所把握</p></li></ul><h4 id="6-4-15-Proxy-Authorization"><a href="#6-4-15-Proxy-Authorization" class="headerlink" title="6.4.15 Proxy-Authorization"></a>6.4.15 Proxy-Authorization</h4><ul><li><p>接收到从代理服务器发来的认证质询时，客户端会发送包含首部字段Proxy-Authorization的请求，以告知服务器认证所需要的信息</p></li><li><p>这个行为是与客户端和服务器之间的HTTP访问认证相类似的，不同之处在于，认证行为发生在客户端与代理之间。客户端与服务器之间的认证，使用首部字段Authorization可起到相同作用。有关HTTP访问认证，后面的章节会作详尽阐述</p></li></ul><h4 id="6-4-16-Range"><a href="#6-4-16-Range" class="headerlink" title="6.4.16 Range"></a>6.4.16 Range</h4><ul><li><p>对于只需获取部分资源的范围请求，包含首部字段Range即可告知服务器资源的指定范围</p><figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs http"><span class="hljs-attribute">Range</span><span class="hljs-punctuation">: </span>bytes=5001-10000<br></code></pre></td></tr></table></figure></li><li><p>接收到附带Range首部字段请求的服务器，会在处理请求之后返回状态码为206 Partial Content的响应。无法处理该范围请求时，则会返回状态码200OK的响应及全部资源</p></li></ul><h4 id="6-4-17-Referer"><a href="#6-4-17-Referer" class="headerlink" title="6.4.17 Referer"></a>6.4.17 Referer</h4><ul><li><p>首部字段Referer会告知服务器请求的原始资源的URI</p></li><li><p>客户端一般都会发送Referer首部字段给服务器。但当直接在浏览器的地址栏输入URI，或出于安全性的考虑时，也可以不发送该首部字段。因为原始资源的URI中的查询字符串可能含有ID和密码等保密信息，要是写进Referer转发给其他服务器，则有可能导致保密信息的泄露</p></li><li><p>另外，Referer的正确的拼写应该是Referrer，但不知为何，大家一直沿用这个错误的拼写</p></li></ul><h4 id="6-4-18-TE"><a href="#6-4-18-TE" class="headerlink" title="6.4.18 TE"></a>6.4.18 TE</h4><ul><li><p>首部字段TE会告知服务器客户端能够处理响应的传输编码方式及相对优先级。它和首部字段Accept-Encoding的功能很相像，但是用于传输编码</p><figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs http"><span class="hljs-attribute">TE</span><span class="hljs-punctuation">: </span>gzip, deflate;q=0.5<br></code></pre></td></tr></table></figure></li><li><p>首部字段TE除指定传输编码之外，还可以指定伴随trailer字段的分块传输编码的方式。应用后者时，只需把trailers赋值给该字段值</p><figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs http"><span class="hljs-attribute">TE</span><span class="hljs-punctuation">: </span>trailers<br></code></pre></td></tr></table></figure></li><li><p>HTTP 1.1 协议在 header 中引入了 Transfer-Encoding，历史上 Transfer-Encoding 可以有多种取值，为此还引入了一个名为 TE 的头部用来协商采用何种传输编码</p></li></ul><h4 id="6-4-19-User-Agent"><a href="#6-4-19-User-Agent" class="headerlink" title="6.4.19 User-Agent"></a>6.4.19 User-Agent</h4><ul><li><p>首部字段User-Agent会将创建请求的浏览器和用户代理名称等信息传达给服务器</p></li><li><p>由网络爬虫发起请求时，有可能会在字段内添加爬虫作者的电子邮件地址。此外，如果请求经过代理，那么中间也很可能被添加上代理服务器的名称</p></li></ul><h3 id="6-5-响应首部字段"><a href="#6-5-响应首部字段" class="headerlink" title="6.5 响应首部字段"></a>6.5 响应首部字段</h3><ul><li>响应首部字段是由服务器端向客户端返回响应报文中所使用的字段，用于补充响应的附加信息、服务器信息，以及对客户端的附加要求等信息</li></ul><h4 id="6-5-1-Accept-Ranges"><a href="#6-5-1-Accept-Ranges" class="headerlink" title="6.5.1 Accept-Ranges"></a>6.5.1 Accept-Ranges</h4><ul><li><p>首部字段Accept-Ranges是用来告知客户端服务器是否能处理范围请求，以指定获取服务器端某个部分的资源</p></li><li><p>可指定的字段值有两种，可处理范围请求时指定其为bytes，反之则指定其为none</p></li></ul><h4 id="6-5-2-Age"><a href="#6-5-2-Age" class="headerlink" title="6.5.2 Age"></a>6.5.2 Age</h4><ul><li><p>首部字段Age能告知客户端，源服务器在多久前创建了响应。字段值的单位为秒</p></li><li><p>若创建该响应的服务器是缓存服务器，Age值是指缓存后的响应再次发起认证到认证完成的时间值。代理创建响应时必须加上首部字段Age</p></li><li><p>Age 消息头里包含对象在缓存代理中存贮的时长，以秒为单位。Age的值通常接近于0。表示此对象刚刚从原始服务器获取不久；其他的值则是表示代理服务器当前的系统时间与此应答中的通用头Date的值之差</p></li></ul><h4 id="6-5-3-ETag"><a href="#6-5-3-ETag" class="headerlink" title="6.5.3 ETag"></a>6.5.3 ETag</h4><ul><li><p>首部字段ETag能告知客户端实体标识。它是一种可将资源以字符串形式做唯一性标识的方式。服务器会为每份资源分配对应的ETag值</p></li><li><p>另外，当资源更新时，ETag值也需要更新。生成ETag值时，并没有统一的算法规则，而仅仅是由服务器来分配</p></li><li><p>资源被缓存时，就会被分配唯一性标识。例如，当使用中文版的浏览器访问<a href="http://www.google.com/%E6%97%B6%EF%BC%8C%E5%B0%B1%E4%BC%9A%E8%BF%94%E5%9B%9E%E4%B8%AD%E6%96%87%E7%89%88%E5%AF%B9%E5%BA%94%E7%9A%84%E8%B5%84%E6%BA%90%EF%BC%8C%E8%80%8C%E4%BD%BF%E7%94%A8%E8%8B%B1%E6%96%87%E7%89%88%E7%9A%84%E6%B5%8F%E8%A7%88%E5%99%A8%E8%AE%BF%E9%97%AE%E6%97%B6%EF%BC%8C%E5%88%99%E4%BC%9A%E8%BF%94%E5%9B%9E%E8%8B%B1%E6%96%87%E7%89%88%E5%AF%B9%E5%BA%94%E7%9A%84%E8%B5%84%E6%BA%90%E3%80%82%E4%B8%A4%E8%80%85%E7%9A%84URI%E6%98%AF%E7%9B%B8%E5%90%8C%E7%9A%84%EF%BC%8C%E6%89%80%E4%BB%A5%E4%BB%85%E5%87%ADURI%E6%8C%87%E5%AE%9A%E7%BC%93%E5%AD%98%E7%9A%84%E8%B5%84%E6%BA%90%E6%98%AF%E7%9B%B8%E5%BD%93%E5%9B%B0%E9%9A%BE%E7%9A%84%E3%80%82%E8%8B%A5%E5%9C%A8%E4%B8%8B%E8%BD%BD%E8%BF%87%E7%A8%8B%E4%B8%AD%E5%87%BA%E7%8E%B0%E8%BF%9E%E6%8E%A5%E4%B8%AD%E6%96%AD%E3%80%81%E5%86%8D%E8%BF%9E%E6%8E%A5%E7%9A%84%E6%83%85%E5%86%B5%EF%BC%8C%E9%83%BD%E4%BC%9A%E4%BE%9D%E7%85%A7ETag%E5%80%BC%E6%9D%A5%E6%8C%87%E5%AE%9A%E8%B5%84%E6%BA%90">http://www.google.com/时，就会返回中文版对应的资源，而使用英文版的浏览器访问时，则会返回英文版对应的资源。两者的URI是相同的，所以仅凭URI指定缓存的资源是相当困难的。若在下载过程中出现连接中断、再连接的情况，都会依照ETag值来指定资源</a></p></li><li><p>强ETag值和弱Tag值：ETag中有强ETag值和弱ETag值之分。</p><ul><li><p>强ETag值：不论实体发生多么细微的变化都会改变其值</p></li><li><p>弱ETag值：只用于提示资源是否相同。只有资源发生了根本改变，产生差异时才会改变ETag值。这时，会在字段值最开始处附加W&#x2F;</p></li></ul></li></ul><h4 id="6-5-4-Location"><a href="#6-5-4-Location" class="headerlink" title="6.5.4 Location"></a>6.5.4 Location</h4><ul><li><p>使用首部字段Location可以将响应接收方引导至某个与请求URI位置不同的资源</p></li><li><p>基本上，该字段会配合3xx:Redirection的响应，提供重定向的URI</p></li><li><p>几乎所有的浏览器在接收到包含首部字段Location的响应后，都会强制性地尝试对已提示的重定向资源的访问</p></li></ul><h4 id="6-5-5-Proxy-Authenticate"><a href="#6-5-5-Proxy-Authenticate" class="headerlink" title="6.5.5 Proxy-Authenticate"></a>6.5.5 Proxy-Authenticate</h4><ul><li><p>首部字段Proxy-Authenticate会把由代理服务器所要求的认证信息发送给客户端</p></li><li><p>它与客户端和服务器之间的HTTP访问认证的行为相似，不同之处在于其认证行为是在客户端与代理之间进行的。而客户端与服务器之间进行认证时，首部字段WWW-Authorization有着相同的作用。有关HTTP访问认证，后面的章节会再进行详尽阐述</p></li></ul><h4 id="6-5-6-Retry-After"><a href="#6-5-6-Retry-After" class="headerlink" title="6.5.6 Retry-After"></a>6.5.6 Retry-After</h4><ul><li><p>首部字段Retry-After告知客户端应该在多久之后再次发送请求。主要配合状态码503 Service Unavailable响应，或3xx Redirect响应一起使用</p></li><li><p>字段值可以指定为具体的日期时间（Wed, 04 Jul 2012 06:34:24 GMT等格式），也可以是创建响应后的秒数</p></li></ul><h4 id="6-5-7-Server"><a href="#6-5-7-Server" class="headerlink" title="6.5.7 Server"></a>6.5.7 Server</h4><ul><li>首部字段Server告知客户端当前服务器上安装的HTTP服务器应用程序的信息。不单单会标出服务器上的软件应用名称，还有可能包括版本号和安装时启用的可选项</li></ul><h4 id="6-5-8-Vary"><a href="#6-5-8-Vary" class="headerlink" title="6.5.8 Vary"></a>6.5.8 Vary</h4><ul><li><p>示例：当代理服务器接收到带有Vary首部字段指定获取资源的请求时，如果使用的Accept-Language字段的值相同，那么就直接从缓存返回响应。反之，则需要先从源服务器端获取资源后才能作为响应返回</p><p><img src="/image/%E5%9B%BE%E8%A7%A3HTTP/7202b7270dc5a1d446b6757a52f4bc4b23356c82.jpeg" alt="epub_907764_146.jpeg"></p></li><li><p>首部字段Vary可对缓存进行控制。源服务器会向代理服务器传达关于本地缓存使用方法的命令</p></li><li><p>从代理服务器接收到源服务器返回包含Vary指定项的响应之后，若再要进行缓存，仅对请求中含有相同Vary指定首部字段的请求返回缓存。即使对相同资源发起请求，但由于Vary指定的首部字段不相同，因此必须要从源服务器重新获取资源</p></li></ul><h4 id="6-5-9-WWW-Authenticate"><a href="#6-5-9-WWW-Authenticate" class="headerlink" title="6.5.9 WWW-Authenticate"></a>6.5.9 WWW-Authenticate</h4><ul><li><p>首部字段WWW-Authenticate用于HTTP访问认证。它会告知客户端适用于访问请求URI所指定资源的认证方案（Basic或是Digest）和带参数提示的质询（challenge）</p></li><li><p>状态码401 Unauthorized响应中，肯定带有首部字段WWW-Authenticate</p></li></ul><h3 id="6-6-实体首部字段"><a href="#6-6-实体首部字段" class="headerlink" title="6.6 实体首部字段"></a>6.6 实体首部字段</h3><ul><li>实体首部字段是包含在请求报文和响应报文中的实体部分所使用的首部，用于补充内容的更新时间等与实体相关的信息</li></ul><h4 id="6-6-1-Allow"><a href="#6-6-1-Allow" class="headerlink" title="6.6.1 Allow"></a>6.6.1 Allow</h4><ul><li><p>首部字段Allow用于通知客户端能够支持Request-URI指定资源的所有HTTP方法</p></li><li><p>当服务器接收到不支持的HTTP方法时，会以状态码405 Method NotAllowed作为响应返回。与此同时，还会把所有能支持的HTTP方法写入首部字段Allow后返回</p></li></ul><h4 id="6-6-2-Content-Encoding"><a href="#6-6-2-Content-Encoding" class="headerlink" title="6.6.2 Content-Encoding"></a>6.6.2 Content-Encoding</h4><ul><li><p>首部字段Content-Encoding会告知客户端服务器对实体的主体部分选用的内容编码方式。内容编码是指在不丢失实体信息的前提下所进行的压缩</p></li><li><p>主要采用以下4种内容编码的方式。（各方式的说明请参考6.4.3节Accept-Encoding首部字段）</p><ul><li><p>gzip</p></li><li><p>compress</p></li><li><p>deflate</p></li><li><p>identity</p></li></ul></li></ul><h4 id="6-6-3-Content-Language"><a href="#6-6-3-Content-Language" class="headerlink" title="6.6.3 Content-Language"></a>6.6.3 Content-Language</h4><ul><li>首部字段Content-Language会告知客户端，实体主体使用的自然语言（指中文或英文等语言）</li></ul><h4 id="6-6-4-Content-Length"><a href="#6-6-4-Content-Length" class="headerlink" title="6.6.4 Content-Length"></a>6.6.4 Content-Length</h4><ul><li><p>首部字段Content-Length表明了实体主体部分的大小（单位是字节）</p></li><li><p>对实体主体进行内容编码传输时，不能再使用Content-Length首部字段</p></li><li><p>由于实体主体大小的计算方法略微复杂，所以在此不再展开。读者若想一探究竟，可参考RFC2616的4.4</p></li></ul><h4 id="6-6-5-Content-Location"><a href="#6-6-5-Content-Location" class="headerlink" title="6.6.5 Content-Location"></a>6.6.5 Content-Location</h4><ul><li><p>首部字段Content-Location给出与报文主体部分相对应的URI。和首部字段Location不同，Content-Location表示的是报文主体返回资源对应的URI</p></li><li><p>比如，对于使用首部字段Accept-Language的服务器驱动型请求，当返回的页面内容与实际请求的对象不同时，首部字段Content-Location内会写明URI。（访问<a href="http://www.hackr.jp/%E8%BF%94%E5%9B%9E%E7%9A%84%E5%AF%B9%E8%B1%A1%E5%8D%B4%E6%98%AFhttp://www.hackr.jp/index-ja.html%E7%AD%89%E7%B1%BB%E4%BC%BC%E6%83%85%E5%86%B5%EF%BC%89">http://www.hackr.jp/返回的对象却是http://www.hackr.jp/index-ja.html等类似情况）</a></p></li></ul><h4 id="6-6-6-Content-MD5"><a href="#6-6-6-Content-MD5" class="headerlink" title="6.6.6 Content-MD5"></a>6.6.6 Content-MD5</h4><ul><li><p>客户端会对接收的报文主体执行相同的MD5算法，然后与首部字段Content-MD5的字段值比较</p><p><img src="/image/%E5%9B%BE%E8%A7%A3HTTP/b20f93ef872657b86004cd93b82562036c3c337c.jpeg" alt="epub_907764_152.jpeg"></p></li><li><p>首部字段Content-MD5是一串由MD5算法生成的值，其目的在于检查报文主体在传输过程中是否保持完整，以及确认传输到达</p></li><li><p>对报文主体执行MD5算法获得的128位二进制数，再通过Base64编码后将结果写入Content-MD5字段值。由于HTTP首部无法记录二进制值，所以要通过Base64编码处理。为确保报文的有效性，作为接收方的客户端会对报文主体再执行一次相同的MD5算法。计算出的值与字段值作比较后，即可判断出报文主体的准确性</p></li><li><p>采用这种方法，对内容上的偶发性改变是无从查证的，也无法检测出恶意篡改。其中一个原因在于，内容如果能够被篡改，那么同时意味着Content-MD5也可重新计算然后被篡改。所以处在接收阶段的客户端是无法意识到报文主体以及首部字段Content-MD5是已经被篡改过的</p></li></ul><h4 id="6-6-7-Content-Range"><a href="#6-6-7-Content-Range" class="headerlink" title="6.6.7 Content-Range"></a>6.6.7 Content-Range</h4><ul><li>针对范围请求，返回响应时使用的首部字段Content-Range，能告知客户端作为响应返回的实体的哪个部分符合范围请求。字段值以字节为单位，表示当前发送部分及整个实体大小</li></ul><h4 id="6-6-8-Content-Type"><a href="#6-6-8-Content-Type" class="headerlink" title="6.6.8 Content-Type"></a>6.6.8 Content-Type</h4><ul><li><p>首部字段Content-Type说明了实体主体内对象的媒体类型。和首部字段Accept一样，字段值用type&#x2F;subtype形式赋值。参数charset使用iso-8859-1或euc-jp等字符集进行赋值</p></li><li><p>示例</p><figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs http"><span class="hljs-attribute">Content-Type</span><span class="hljs-punctuation">: </span>text/html; charset=UTF-8<br></code></pre></td></tr></table></figure></li></ul><h4 id="6-6-9-Expires"><a href="#6-6-9-Expires" class="headerlink" title="6.6.9 Expires"></a>6.6.9 Expires</h4><ul><li><p>首部字段Expires会将资源失效的日期告知客户端。缓存服务器在接收到含有首部字段Expires的响应后，会以缓存来应答请求，在Expires字段值指定的时间之前，响应的副本会一直被保存。当超过指定的时间后，缓存服务器在请求发送过来时，会转向源服务器请求资源</p></li><li><p>源服务器不希望缓存服务器对资源缓存时，最好在Expires字段内写入与首部字段Date相同的时间值</p></li><li><p>当首部字段Cache-Control有指定max-age指令时，比起首部字段Expires，会优先处理max-age指令</p></li></ul><h4 id="6-6-10-Last-Modified"><a href="#6-6-10-Last-Modified" class="headerlink" title="6.6.10 Last-Modified"></a>6.6.10 Last-Modified</h4><ul><li>首部字段Last-Modified指明资源最终修改的时间。一般来说，这个值就是Request-URI指定资源被修改的时间。但类似使用CGI脚本进行动态数据处理时，该值有可能会变成数据最终修改时的时间</li></ul><h3 id="6-7-为Cookie服务的首部字段"><a href="#6-7-为Cookie服务的首部字段" class="headerlink" title="6.7 为Cookie服务的首部字段"></a>6.7 为Cookie服务的首部字段</h3><ul><li><p>管理服务器与客户端之间状态的Cookie，虽然没有被编入标准化HTTP&#x2F;1.1的RFC2616中，但在Web网站方面得到了广泛的应用</p></li><li><p>Cookie的工作机制是用户识别及状态管理。Web网站为了管理用户的状态会通过Web浏览器，把一些数据临时写入用户的计算机内。接着当用户访问该Web网站时，可通过通信方式取回之前存放的Cookie</p></li><li><p>调用Cookie时，由于可校验Cookie的有效期，以及发送方的域、路径、协议等信息，所以正规发布的Cookie内的数据不会因来自其他Web站点和攻击者的攻击而泄露</p></li><li><p>至2013年5月，Cookie的规格标准文档有以下4种</p><ul><li><p>由网景公司颁布的规格标准</p><ul><li><p>网景通信公司设计并开发了Cookie，并制定相关的规格标准</p></li><li><p>1994年前后，Cookie正式应用在网景浏览器中</p></li><li><p>目前最为普及的Cookie方式也是以此为基准的</p></li></ul></li><li><p>RFC2109</p><ul><li><p>某企业尝试以独立技术对Cookie规格进行标准化统筹</p></li><li><p>原本的意图是想和网景公司制定的标准交互应用，可惜发生了微妙的差异。现在该标准已淡出了人们的视线</p></li></ul></li><li><p>RFC2965</p><ul><li>为终结Internet Explorer浏览器与Netscape Navigator的标准差异而导致的浏览器战争，RFC2965内定义了新的HTTP首部Set-Cookie2和Cookie2。可事实上，它们几乎没怎么投入使用</li></ul></li><li><p>RFC6265</p><ul><li>将网景公司制定的标准作为业界事实标准（De facto standard），重新定义Cookie标准后的产物</li></ul></li></ul></li><li><p>目前使用最广泛的Cookie标准却不是RFC中定义的任何一个。而是在网景公司制定的标准上进行扩展后的产物。本节接下来就对目前使用最为广泛普及的标准进行说明</p></li><li><p>为Cookie服务的首部字段</p><p><img src="/image/%E5%9B%BE%E8%A7%A3HTTP/72292f0d3a4a07c5579dc32ce2f3a495a6414863.jpeg" alt="epub_907764_156.jpeg"></p></li></ul><h4 id="6-7-1-Set-Cookie"><a href="#6-7-1-Set-Cookie" class="headerlink" title="6.7.1 Set-Cookie"></a>6.7.1 Set-Cookie</h4><ul><li><p>当服务器准备开始管理客户端的状态时，会事先告知各种信息</p></li><li><p>示例</p><figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs http"><span class="hljs-attribute">Set-Cookie</span><span class="hljs-punctuation">: </span>status=enable; expires=Tue, 05 Jul 2011 07:26:31 GMT; path=/; domain=.hackr.jp;<br></code></pre></td></tr></table></figure></li><li><p>Set-Cookie字段的属性</p><p><img src="/image/%E5%9B%BE%E8%A7%A3HTTP/7071b77531d8d3bc166433d23a6c36fa92b8092b.jpeg" alt="epub_907764_158.jpeg"></p></li><li><p>expires属性</p><ul><li><p>Cookie的expires属性指定浏览器可发送Cookie的有效期</p></li><li><p>当省略expires属性时，其有效期仅限于维持浏览器会话（Session）时间段内。这通常限于浏览器应用程序被关闭之前</p></li><li><p>另外，一旦Cookie从服务器端发送至客户端，服务器端就不存在可以显式删除Cookie的方法。但可通过覆盖已过期的Cookie，实现对客户端Cookie的实质性删除操作</p></li></ul></li><li><p>path属性</p><ul><li>Cookie的path属性可用于限制指定Cookie的发送范围的文件目录。不过另有办法可避开这项限制，看来对其作为安全机制的效果不能抱有期待</li></ul></li><li><p>domain属性</p><ul><li><p>通过Cookie的domain属性指定的域名可做到与结尾匹配一致。比如，当指定example.com后，除example.com以外，<a href="http://www.example.com或www2.example.com等都可以发送cookie/">www.example.com或www2.example.com等都可以发送Cookie</a></p></li><li><p>因此，除了针对具体指定的多个域名发送Cookie之外，不指定domain属性显得更安全</p></li></ul></li><li><p>secure属性</p><ul><li><p>Cookie的secure属性用于限制Web页面仅在HTTPS安全连接时，才可以发送Cookie</p></li><li><p>发送Cookie时，指定secure属性的方法如下所示</p><figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs http"><span class="hljs-attribute">Set-Cookie</span><span class="hljs-punctuation">: </span>name=value; secure<br></code></pre></td></tr></table></figure></li><li><p>以上例子仅当在<a href="https://www.example.com/%EF%BC%88HTTPS%EF%BC%89%E5%AE%89%E5%85%A8%E8%BF%9E%E6%8E%A5%E7%9A%84%E6%83%85%E5%86%B5%E4%B8%8B%E6%89%8D%E4%BC%9A%E8%BF%9B%E8%A1%8CCookie%E7%9A%84%E5%9B%9E%E6%94%B6%E3%80%82%E4%B9%9F%E5%B0%B1%E6%98%AF%E8%AF%B4%EF%BC%8C%E5%8D%B3%E4%BD%BF%E5%9F%9F%E5%90%8D%E7%9B%B8%E5%90%8C%EF%BC%8Chttp://www.example.com/%EF%BC%88HTTP%EF%BC%89%E4%B9%9F%E4%B8%8D%E4%BC%9A%E5%8F%91%E7%94%9FCookie%E5%9B%9E%E6%94%B6%E8%A1%8C%E4%B8%BA">https://www.example.com/（HTTPS）安全连接的情况下才会进行Cookie的回收。也就是说，即使域名相同，http://www.example.com/（HTTP）也不会发生Cookie回收行为</a></p></li><li><p>当省略secure属性时，不论HTTP还是HTTPS，都会对Cookie进行回收</p></li></ul></li><li><p>HttpOnly属性</p><ul><li><p>Cookie的HttpOnly属性是Cookie的扩展功能，它使JavaScript脚本无法获得Cookie</p></li><li><p>其主要目的为防止跨站脚本攻击（Cross-site scripting,XSS）对Cookie的信息窃取</p></li><li><p>发送指定HttpOnly属性的Cookie的方法如下所示</p><figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs http"><span class="hljs-attribute">Set-Cookie</span><span class="hljs-punctuation">: </span>name=value; secure<br></code></pre></td></tr></table></figure></li><li><p>通过上述设置，通常从Web页面内还可以对Cookie进行读取操作。但使用JavaScript的document.cookie就无法读取附加HttpOnly属性后的Cookie的内容了。因此，也就无法在XSS中利用JavaScript劫持Cookie了</p></li><li><p>虽然是独立的扩展功能，但Internet Explorer 6 SP1以上版本等当下的主流浏览器都已经支持该扩展了。另外顺带一提，该扩展并非是为了防止XSS而开发的</p></li></ul></li></ul><h4 id="6-7-2-Cookie"><a href="#6-7-2-Cookie" class="headerlink" title="6.7.2 Cookie"></a>6.7.2 Cookie</h4><ul><li><p>首部字段Cookie会告知服务器，当客户端想获得HTTP状态 管理支持时，就会在请求中包含从服务器接收到的Cookie。接收到多个Cookie时，同样可以以多个Cookie形式发送</p></li><li><p>示例</p><figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs http"><span class="hljs-attribute">Cookie</span><span class="hljs-punctuation">: </span>name1=value1; name2=value2; ...<br></code></pre></td></tr></table></figure></li></ul><h3 id="6-8-其他首部字段"><a href="#6-8-其他首部字段" class="headerlink" title="6.8 其他首部字段"></a>6.8 其他首部字段</h3><ul><li><p>HTTP首部字段是可以自行扩展的。所以在Web服务器和浏览器的应用上，会出现各种非标准的首部字段。接下来，我们就一些最为常用的首部字段进行说明</p><ul><li><p>X-Frame-Options</p></li><li><p>X-XSS-Protection</p></li><li><p>DNT</p></li><li><p>P3P</p></li></ul></li><li><p>协议中对X-前缀的废除</p><ul><li><p>在HTTP等多种协议中，通过给非标准参数加上前缀X-，来区别于标准参数，并使那些非标准的参数作为扩展变成可能</p></li><li><p>但是这种简单粗暴的做法有百害而无一益，因此在“RFC 6648- Deprecating the “X-“ Prefix andSimilar Constructs in Application Protocols”中提议停止该做法</p></li><li><p>然而，对已经在使用中的X-前缀来说，不应该要求其变更</p></li></ul></li></ul><h4 id="6-8-1-X-Frame-Options"><a href="#6-8-1-X-Frame-Options" class="headerlink" title="6.8.1 X-Frame-Options"></a>6.8.1 X-Frame-Options</h4><ul><li><p>首部字段X-Frame-Options属于HTTP响应首部，用于控制网站内容在其他Web网站的Frame标签内的显示问题。其主要目的是为了防止点击劫持（clickjacking）攻击</p></li><li><p>首部字段X-Frame-Options有以下两个可指定的字段值</p><ul><li><p>DENY：拒绝</p></li><li><p>SAMEORIGIN：仅同源域名下的页面（Top-level-browsing-context）匹配时许可</p><ul><li>比如，当指定<a href="http://hackr.jp/sample.html%E9%A1%B5%E9%9D%A2%E4%B8%BASAMEORIGIN%E6%97%B6%EF%BC%8C%E9%82%A3%E4%B9%88hackr.jp%E4%B8%8A%E6%89%80%E6%9C%89%E9%A1%B5%E9%9D%A2%E7%9A%84frame%E9%83%BD%E8%A2%AB%E5%85%81%E8%AE%B8%E5%8F%AF%E5%8A%A0%E8%BD%BD%E8%AF%A5%E9%A1%B5%E9%9D%A2%EF%BC%8C%E8%80%8Cexample.com%E7%AD%89%E5%85%B6%E4%BB%96%E5%9F%9F%E5%90%8D%E7%9A%84%E9%A1%B5%E9%9D%A2%E5%B0%B1%E4%B8%8D%E8%A1%8C%E4%BA%86">http://hackr.jp/sample.html页面为SAMEORIGIN时，那么hackr.jp上所有页面的frame都被允许可加载该页面，而example.com等其他域名的页面就不行了</a></li></ul></li></ul></li><li><p>现在主流的浏览器都已经支持</p></li><li><p>能在所有的Web服务器端预先设定好X-Frame-Options字段值是最理想的状态</p></li></ul><h4 id="6-8-2-X-XSS-Protection"><a href="#6-8-2-X-XSS-Protection" class="headerlink" title="6.8.2 X-XSS-Protection"></a>6.8.2 X-XSS-Protection</h4><ul><li><p>首部字段X-XSS-Protection属于HTTP响应首部，它是针对跨站脚本攻击（XSS）的一种对策，用于控制浏览器XSS防护机制的开关</p></li><li><p>首部字段X-XSS-Protection可指定的字段值如下</p><ul><li><p>0 ：将XSS过滤设置成无效状态</p></li><li><p>1 ：将XSS过滤设置成有效状态</p></li></ul></li></ul><h4 id="6-8-3-DNT"><a href="#6-8-3-DNT" class="headerlink" title="6.8.3 DNT"></a>6.8.3 DNT</h4><ul><li><p>首部字段DNT属于HTTP请求首部，其中DNT是Do Not Track的简称，意为拒绝个人信息被收集，是表示拒绝被精准广告追踪的一种方法</p></li><li><p>首部字段DNT可指定的字段值如下</p><ul><li><p>0：同意被追踪</p></li><li><p>1：拒绝被追踪</p></li></ul></li><li><p>由于首部字段DNT的功能具备有效性，所以Web服务器需要对DNT做对应的支持</p></li></ul><h4 id="6-8-4-P3P"><a href="#6-8-4-P3P" class="headerlink" title="6.8.4 P3P"></a>6.8.4 P3P</h4><ul><li><p>首部字段P3P属于HTTP响应首部，通过利用P3P（The Platform for PrivacyPreferences，在线隐私偏好平台）技术，可以让Web网站上的个人隐私变成一种仅供程序可理解的形式，以达到保护用户隐私的目的</p></li><li><p>要进行P3P的设定，需按以下操作步骤进行</p><ul><li><p>步骤1：创建P3P隐私</p></li><li><p>步骤2：创建P3P隐私对照文件后，保存命名在&#x2F;w3c&#x2F;p3p.xml</p></li><li><p>步骤3：从P3P隐私中新建Compact policies后，输出到HTTP响应中</p></li></ul></li></ul>]]></content>
    
    
    <categories>
      
      <category>笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>基础体系</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【笔记】图解HTTP（上）</title>
    <link href="/posts/751670d8.html"/>
    <url>/posts/751670d8.html</url>
    
    <content type="html"><![CDATA[<div class="note note-success">            <p>《图解HTTP》出版于2013年，至今已有将近十年的时光。如果你在网上搜索一下《图解HTTP》，便会发现本书的讨论热度依旧不减，依然是不少论坛博客推荐的HTTP学习材料，笔记摘录也是一抓一大堆（比如我）。我想，一本技术类的书籍能够享有如此长时间的关注，这和它本身的写作手法、文章布局以及内容层面是息息相关的。</p><p>2013年，http在移动互联网领域再领风骚，https后发先至引人注目，http2.0正在提上日程即将发力。对于开发过程来说，则更凸现了开发者对计算机网络了解的重要性。不说深入到内部细节，但起码要整体认识。正如其书译者序中写到，“在我的印象中，讲解网络协议的书仅有两本。一本是《HTTP权威指南》，但其厚度令人望而生畏；另一本是《TCP&#x2F;IP详解，卷1》，内容艰涩难懂，学习难度较大。这两本书都是被读者们奉为“圣经”的经典之作，大师们的授道自然无可挑剔，但关键是它们对初学者都不那么友好，大家的学习信心很容易受到打击，阅读中途或将束之高阁。本书的出现及时缓解了该问题。”，于是《图解HTTP》应运而生。实际上，如果想要在专业技术道路上走得更坚实，绝对不能绕开学习HTTP协议这一环节。</p><p>那么如何学习http呢？固然有些大佬可以对着RFC标准直接上手开啃，但是对于我们普通人来说，还是得要有个循序渐进的过程，首先先学习具象的表面内容，再学习抽象的深层知识比较合适。我们在后端开发、前端开发、爬虫使用、服务器使用等等环节中早已积累了很多第一手的http实践知识，比如如何发送请求、如何处理响应、不同的状态怎么判断，不同错误如何解决……这些朴素的http实践知识弥足珍贵，因为它代表着我们对http的第一印象，但是还不够，得加料。那么《图解HTTP》的作用就凸现出来了，它可以让你用一个比较轻松的方式切入http协议的内部，知其然知其所以然。对于操作中的一些疑问，它可以提供解答，对于实践中的一些现象，它可以给出原理。</p><p>本书知识密度也很密集，经常大段大段的知识点连在一起，连读不缀，所以我笔记也是大段大段地摘抄下来。不用担心看的头疼，作者和译者的功力深厚，读者只要对前面的内容弄懂弄通了，“新”知识点也就和喝水一般水到渠成进入脑子，再加点自己的小小实践融会贯通，perfect！</p><p>本书稍难一点的章节也就是第六章“HTTP首部”，主要是因为该章节出现很多首部及其解析，读者一时半会可能分不清，而且有些首部也没怎么接触过，难以形成记忆。至于其他章节，难度水平波动不大，相对来说都是挺易懂的。</p><p>本书名字前缀带有“图解”，所以书中自然也插入了很多用于解析的图片了。对于这部分图片的作用，那么见仁见智了。从我自己的角度来看，图片有点多了，而且也不是所有图片都是必要的，文字内容已经足够清晰了，再加上一张照片就显得略有累赘。不过我也理解这种情况，毕竟一千个人眼中有一千个哈姆雷特，不同人对图片的看法肯定不一样，说不定这处我觉得很精妙的图片，在另外一个人看来就是画蛇添足。</p><p>在看这本书的时候，读者最好可以通过nginx&#x2F;Apache来搭建一个简单的Web服务器，然后利用postman等api测试工具进行手动收发请求响应作为辅助的http实验，这样会对书中内容有更直观的认识。本书极少上手实验的内容，一是难以提供统一的实验环境，即使是作者自己搭建一个Web服务器让我们测试，估计也很难维持个十多年，说不定由于内容绑定了具体环境，反而会落得和《xx天学会http协议》这类书籍一样短命；二是添加实验内容会导致本书极度膨胀，毕竟http协议细节繁多，知识点也多，再加上一点实验操作的话，页数翻倍也不是不可能。所以读者就自行解决动手操作这一个难题吧。</p>          </div><p>剩下的笔记：</p><blockquote><p><a href="48f3e75f">【笔记】图解HTTP（中）</a><br><a href="cdaa17bd">【笔记】图解HTTP（下）</a></p></blockquote><h2 id="第一章-了解Web及网络基础"><a href="#第一章-了解Web及网络基础" class="headerlink" title="第一章 了解Web及网络基础"></a>第一章 了解Web及网络基础</h2><h3 id="1-1-使用HTTP协议访问Web"><a href="#1-1-使用HTTP协议访问Web" class="headerlink" title="1.1 使用HTTP协议访问Web"></a>1.1 使用HTTP协议访问Web</h3><ul><li><p>Web浏览器根据地址栏中指定的URL，从Web服务器端获取文件资源（resource）等信息，从而显示出Web页面</p><ul><li>像这种通过发送请求获取服务器资源的Web浏览器等，都可称为客户端（client）</li></ul></li><li><p>Web使用一种名为HTTP（HyperText Transfer Protocol，超文本传输协议）的协议作为规范，完成从客户端到服务器端等一系列运作流程</p><ul><li><p>HTTP通常被译为超文本传输协议，但这种译法并不严谨。严谨的译名应该为“超文本转移协议”。但是前一译法已约定俗成，本书将会沿用</p></li><li><p>协议是指规则的约定。可以说，Web是建立在HTTP协议上通信的</p></li></ul></li></ul><h3 id="1-2-HTTP的诞生"><a href="#1-2-HTTP的诞生" class="headerlink" title="1.2 HTTP的诞生"></a>1.2 HTTP的诞生</h3><h4 id="1-2-1-为知识共享而规划Web"><a href="#1-2-1-为知识共享而规划Web" class="headerlink" title="1.2.1 为知识共享而规划Web"></a>1.2.1 为知识共享而规划Web</h4><ul><li><p>1989年3月，互联网还只属于少数人。CERN（欧洲核子研究组织）的蒂姆·伯纳斯-李（Tim Berners-Lee）博士提出了一种能让远隔两地的研究者们共享知识的设想。最初设想的基本理念是：借助多文档之间相互关联形成的超文本（HyperText），连成可相互参阅的WWW（World Wide Web，万维网）</p></li><li><p>现在已提出了3项WWW构建技术，分别是：把SGML（Standard GeneralizedMarkup Language，标准通用标记语言）作为页面的文本标记语言的HTML（HyperText Markup Language，超文本标记语言）；作为文档传递协议的HTTP；指定文档所在地址的URL（Uniform Resource Locator，统一资源定位符）</p></li><li><p>WWW这一名称，是Web浏览器当年用来浏览超文本的客户端应用程序时的名称。现在则用来表示这一系列的集合，也可简称为Web</p></li></ul><h4 id="1-2-2-Web成长时代"><a href="#1-2-2-Web成长时代" class="headerlink" title="1.2.2 Web成长时代"></a>1.2.2 Web成长时代</h4><ul><li><p>1990年11月，CERN成功研发了世界上第一台Web服务器和Web浏览器</p></li><li><p>1990年，大家针对HTML 1.0草案进行了讨论，因HTML 1.0中存在多处模糊不清的部分，草案被直接废弃了</p></li><li><p>1993年1月，现代浏览器的祖先NCSA（National Center for SupercomputerApplications，美国国家超级计算机应用中心）研发的Mosaic问世了。它以in-line（内联）等形式显示HTML的图像，在图像方面出色的表现使它迅速在世界范围内流行开来。同年秋天，Mosaic的Windows版和Macintosh版面世。使用CGI技术的NCSAWeb服务器、NCSA HTTPd 1.0也差不多是在这个时期出现的</p></li><li><p>1994年的12月，网景通信公司发布了Netscape Navigator 1.0, 1995年微软公司发布Internet Explorer 1.0和2.0</p></li><li><p>紧随其后的是现在已然成为Web服务器标准之一的Apache，当时它以Apache0.2的姿态出现在世人眼前。而HTML也发布了2.0版本。那一年，Web技术的发展突飞猛进</p></li><li><p>时光流转，从1995年左右起，微软公司与网景通信公司之间爆发的浏览器大战愈演愈烈。两家公司都各自对HTML做了扩展，于是导致在写HTML页面时，必须考虑兼容他们两家公司的浏览器。时至今日，这个问题仍令那些写前端页面的工程师感到棘手</p><ul><li>在这场浏览器供应商之间的竞争中，他们不仅对当时发展中的各种Web标准化视而不见，还屡次出现新增功能没有对应说明文档的情况</li></ul></li><li><p>2000年前后，这场浏览器战争随着网景通信公司的衰落而暂告一段落。但就在2004年，Mozilla基金会发布了Firefox浏览器，第二次浏览器大战随即爆发</p></li><li><p>Internet Explorer浏览器的版本从6升到7前后花费了5年时间。之后接连不断地发布了8、9、10版本。另外，Chrome、Opera、Safari等浏览器也纷纷抢占市场份额</p></li></ul><h4 id="1-2-3-驻足不前的HTTP"><a href="#1-2-3-驻足不前的HTTP" class="headerlink" title="1.2.3 驻足不前的HTTP"></a>1.2.3 驻足不前的HTTP</h4><ul><li><p>HTTP&#x2F;0.9</p><ul><li>HTTP于1990年问世。那时的HTTP并没有作为正式的标准被建立。这时的HTTP其实含有HTTP&#x2F;1.0之前版本的意思，因此被称为HTTP&#x2F;0.9</li></ul></li><li><p>HTTP&#x2F;1.0</p><ul><li>HTTP正式作为标准被公布是在1996年的5月，版本被命名为HTTP&#x2F;1.0，并记载于RFC1945。虽说是初期标准，但该协议标准至今仍被广泛使用在服务器端</li></ul></li><li><p>HTTP&#x2F;1.1</p><ul><li>1997年1月公布的HTTP&#x2F;1.1是目前主流的HTTP协议版本。当初的标准是RFC2068，之后发布的修订版RFC2616就是当前的最新版本</li></ul></li><li><p>HTTP&#x2F;2 （原名HTTP&#x2F;2.0）</p><ul><li><p>即超文本传输协议 2.0，是下一代HTTP协议。是由互联网工程任务组（IETF）的Hypertext Transfer Protocol Bis (httpbis)工作小组进行开发。是自1999年http1.1发布后的首个更新</p></li><li><p>HTTP 2.0在2013年8月进行首次合作共事性测试。在开放互联网上HTTP 2.0将只用于https:&#x2F;&#x2F;网址，而 http:&#x2F;&#x2F;网址将继续使用HTTP&#x2F;1，目的是在开放互联网上增加使用加密技术，以提供强有力的保护去遏制主动攻击</p></li></ul></li><li><p>可见，作为Web文档传输协议的HTTP，它的版本几乎没有更新</p></li><li><p>当年HTTP协议的出现主要是为了解决文本传输的难题。由于协议本身非常简单，于是在此基础上设想了很多应用方法并投入了实际使用。现在HTTP协议已经超出了Web这个框架的局限，被运用到了各种场景里</p></li></ul><h3 id="1-3-网络基础TCP-x2F-IP"><a href="#1-3-网络基础TCP-x2F-IP" class="headerlink" title="1.3 网络基础TCP&#x2F;IP"></a>1.3 网络基础TCP&#x2F;IP</h3><ul><li>通常使用的网络（包括互联网）是在TCP&#x2F;IP协议族的基础上运作的。而HTTP属于它内部的一个子集</li></ul><h4 id="1-3-1-TCP-x2F-IP协议族"><a href="#1-3-1-TCP-x2F-IP协议族" class="headerlink" title="1.3.1 TCP&#x2F;IP协议族"></a>1.3.1 TCP&#x2F;IP协议族</h4><ul><li><p>计算机与网络设备要相互通信，双方就必须基于相同的方法。比如，如何探测到通信目标、由哪一边先发起通信、使用哪种语言进行通信、怎样结束通信等规则都需要事先确定。不同的硬件、操作系统之间的通信，所有的这一切都需要一种规则。而我们就把这种规则称为协议（protocol）</p></li><li><p>TCP&#x2F;IP是互联网相关的各类协议族的总称，以下是部分常见的协议：ICMP、IP、TCP、UDP、DNS、PPPoE、SNMP、FTP、HTTP、FDDI、IEEE 802.3</p></li><li><p>协议中存在各式各样的内容。从电缆的规格到IP地址的选定方法、寻找异地用户的方法、双方建立通信的顺序，以及Web页面显示需要处理的步骤，等等</p></li></ul><h4 id="1-3-2-TCP-x2F-IP的分层管理"><a href="#1-3-2-TCP-x2F-IP的分层管理" class="headerlink" title="1.3.2 TCP&#x2F;IP的分层管理"></a>1.3.2 TCP&#x2F;IP的分层管理</h4><ul><li><p>TCP&#x2F;IP协议族里重要的一点就是分层。TCP&#x2F;IP协议族按层次分别分为以下4层：应用层、传输层、网络层和数据链路层</p></li><li><p>把TCP&#x2F;IP层次化是有好处的</p><ul><li><p>比如，如果互联网只由一个协议统筹，某个地方需要改变设计时，就必须把所有部分整体替换掉。而分层之后只需把变动的层替换掉即可。把各层之间的接口部分规划好之后，每个层次内部的设计就能够自由改动了</p></li><li><p>层次化之后，设计也变得相对简单了。处于应用层上的应用可以只考虑分派给自己的任务，而不需要弄清对方在地球上哪个地方、对方的传输路线是怎样的、是否能确保传输送达等问题</p></li></ul></li><li><p>TCP&#x2F;IP协议族各层的作用如下</p><ul><li><p>应用层</p><ul><li><p>应用层决定了向用户提供应用服务时通信的活动</p></li><li><p>TCP&#x2F;IP协议族内预存了各类通用的应用服务。比如，FTP（File TransferProtocol，文件传输协议）和DNS（Domain Name System，域名系统）服务就是其中两类</p></li><li><p>HTTP协议也处于该层</p></li></ul></li><li><p>传输层</p><ul><li><p>传输层对上层应用层，提供处于网络连接中的两台计算机之间的数据传输</p></li><li><p>在传输层有两个性质不同的协议：TCP（Transmission ControlProtocol，传输控制协议）和UDP（User Data Protocol，用户数据报协议）</p></li></ul></li><li><p>网络层（又名网络互连层）</p><ul><li><p>网络层用来处理在网络上流动的数据包。数据包是网络传输的最小数据单位。该层规定了通过怎样的路径（所谓的传输路线）到达对方计算机，并把数据包传送给对方</p></li><li><p>与对方计算机之间通过多台计算机或网络设备进行传输时，网络层所起的作用就是在众多的选项内选择一条传输路线</p></li></ul></li><li><p>链路层（又名数据链路层，网络接口层）</p><ul><li><p>用来处理连接网络的硬件部分。包括控制操作系统、硬件的设备驱动、NIC（Network Interface Card，网络适配器，即网卡），及光纤等物理可见部分（还包括连接器等一切传输媒介）</p></li><li><p>硬件上的范畴均在链路层的作用范围之内</p></li></ul></li></ul></li><li><p>利用TCP&#x2F;IP协议族进行网络通信时，会通过分层顺序与对方进行通信。发送端从应用层往下走，接收端则往应用层往上走</p></li><li><p>用HTTP举例来说明</p><p><img src="/image/%E5%9B%BE%E8%A7%A3HTTP/c85cfc9a6d3f3ecf628c9e8b89803f3830785086.jpeg" alt="epub_907764_9.jpeg"></p><ul><li><p>首先作为发送端的客户端在应用层（HTTP协议）发出一个想看某个Web页面的HTTP请求</p></li><li><p>接着，为了传输方便，在传输层（TCP协议）把从应用层处收到的数据（HTTP请求报文）进行分割，并在各个报文上打上标记序号及端口号后转发给网络层</p></li><li><p>在网络层（IP协议），增加作为通信目的地的MAC地址后转发给链路层。这样一来，发往网络的通信请求就准备齐全了</p></li><li><p>接收端的服务器在链路层接收到数据，按序往上层发送，一直到应用层。当传输到应用层，才能算真正接收到由客户端发送过来的HTTP请求</p></li></ul></li><li><p>发送端在层与层之间传输数据时，每经过一层时必定会被打上一个该层所属的首部信息。反之，接收端在层与层传输数据时，每经过一层时会把对应的首部消去。这种把数据信息包装起来的做法称为封装（encapsulate）</p></li></ul><h3 id="1-4-与HTTP关系密切的协议：IP、TCP和DNS"><a href="#1-4-与HTTP关系密切的协议：IP、TCP和DNS" class="headerlink" title="1.4 与HTTP关系密切的协议：IP、TCP和DNS"></a>1.4 与HTTP关系密切的协议：IP、TCP和DNS</h3><h4 id="1-4-1-负责传输的IP协议"><a href="#1-4-1-负责传输的IP协议" class="headerlink" title="1.4.1 负责传输的IP协议"></a>1.4.1 负责传输的IP协议</h4><ul><li><p>按层次分，IP（Internet Protocol）网际协议位于网络层</p><ul><li><p>几乎所有使用网络的系统都会用到IP协议</p></li><li><p>TCP&#x2F;IP协议族中的IP指的就是网际协议</p></li><li><p>可能有人会把“IP”和“IP地址”搞混，“IP”其实是一种协议的名称</p></li></ul></li><li><p>IP协议的作用是把各种数据包传送给对方。而要保证确实传送到对方那里，则需要满足各类条件。其中两个重要的条件是IP地址和MAC地址（Media AccessControl Address）</p><ul><li><p>IP地址指明了节点被分配到的地址，MAC地址是指网卡所属的固定地址</p></li><li><p>IP地址可以和MAC地址进行配对</p></li><li><p>IP地址可变换，但MAC地址基本上不会更改</p></li></ul></li><li><p>使用ARP协议凭借MAC地址进行通信</p><ul><li><p>IP间的通信依赖MAC地址</p></li><li><p>在网络上，通信的双方在同一局域网（LAN）内的情况是很少的，通常是经过多台计算机和网络设备中转才能连接到对方。而在进行中转时，会利用下一站中转设备的MAC地址来搜索下一个中转目标。这时，会采用ARP协议（Address Resolution Protocol）</p></li><li><p>ARP是一种用以解析地址的协议，根据通信方的IP地址就可以反查出对应的MAC地址</p></li></ul></li><li><p>没有人能够全面掌握互联网中的传输状况</p><ul><li><p>在到达通信目标前的中转过程中，那些计算机和路由器等网络设备只能获悉很粗略的传输路线</p></li><li><p>这种机制称为路由选择（routing），有点像快递公司的送货过程。想要寄快递的人，只要将自己的货物送到集散中心，就可以知道快递公司是否肯收件发货，该快递公司的集散中心检查货物的送达地址，明确下站该送往哪个区域的集散中心。接着，那个区域的集散中心自会判断是否能送到对方的家中</p></li><li><p>无论哪台计算机、哪台网络设备，它们都无法全面掌握互联网中的细节</p></li></ul></li></ul><h4 id="1-4-2-确保可靠性的TCP协议"><a href="#1-4-2-确保可靠性的TCP协议" class="headerlink" title="1.4.2 确保可靠性的TCP协议"></a>1.4.2 确保可靠性的TCP协议</h4><ul><li><p>按层次分，TCP位于传输层，提供可靠的字节流服务</p><ul><li><p>所谓的字节流服务（Byte Stream Service）是指，为了方便传输，将大块数据分割成以报文段（segment）为单位的数据包进行管理</p></li><li><p>而可靠的传输服务是指，能够把数据准确可靠地传给对方</p></li><li><p>一言以蔽之，TCP协议为了更容易传送大数据才把数据分割，而且TCP协议能够确认数据最终是否送达到对方</p></li></ul></li><li><p>确保数据能到达目标</p><ul><li><p>为了准确无误地将数据送达目标处，TCP协议采用了三次握手（three-wayhandshaking）策略</p><ul><li><p>用TCP协议把数据包送出去后，TCP不会对传送后的情况置之不理，它一定会向对方确认是否成功送达</p></li><li><p>握手过程中使用了TCP的标志（flag）——SYN（synchronize）和ACK（acknowledgement）</p></li><li><p>发送端首先发送一个带SYN标志的数据包给对方。接收端收到后，回传一个带有SYN&#x2F;ACK标志的数据包以示传达确认信息。最后，发送端再回传一个带ACK标志的数据包，代表“握手”结束</p></li></ul></li><li><p>若在握手过程中某个阶段莫名中断，TCP协议会再次以相同的顺序发送相同的数据包</p></li></ul></li></ul><h4 id="1-5-负责域名解析的DNS服务"><a href="#1-5-负责域名解析的DNS服务" class="headerlink" title="1.5 负责域名解析的DNS服务"></a>1.5 负责域名解析的DNS服务</h4><ul><li><p>DNS（Domain Name System）服务是和HTTP协议一样位于应用层的协议。它提供域名到IP地址之间的解析服务</p></li><li><p>DNS服务出现的原因：</p><ul><li><p>计算机既可以被赋予IP地址，也可以被赋予主机名和域名</p></li><li><p>用户通常使用主机名或域名来访问对方的计算机，而不是直接通过IP地址访问。因为与IP地址的一组纯数字相比，用字母配合数字的表示形式来指定计算机名更符合人类的记忆习惯</p></li><li><p>但要让计算机去理解名称，相对而言就变得困难了。因为计算机更擅长处理一长串数字</p></li></ul></li><li><p>DNS协议提供通过域名查找IP地址，或逆向从IP地址反查域名的服务</p></li></ul><h4 id="1-6-各种协议与HTTP协议的关系"><a href="#1-6-各种协议与HTTP协议的关系" class="headerlink" title="1.6 各种协议与HTTP协议的关系"></a>1.6 各种协议与HTTP协议的关系</h4><ul><li><p>各种协议在通信过程中发挥的作用</p><p><img src="/image/%E5%9B%BE%E8%A7%A3HTTP/4f110dda11ee37a6d87d92b9287c385c198f1336.jpeg" alt="epub_907764_13.jpeg"></p></li></ul><h3 id="1-7-URI和URL"><a href="#1-7-URI和URL" class="headerlink" title="1.7 URI和URL"></a>1.7 URI和URL</h3><ul><li>与URI（统一资源标识符）相比，我们更熟悉URL（Uniform ResourceLocator，统一资源定位符）。URL正是使用Web浏览器等访问Web页面时需要输入的网页地址</li></ul><h4 id="1-7-1-统一资源标识符"><a href="#1-7-1-统一资源标识符" class="headerlink" title="1.7.1 统一资源标识符"></a>1.7.1 统一资源标识符</h4><ul><li><p>URI是Uniform Resource Identifier的缩写。RFC2396分别对这3个单词进行了如下定义</p><ul><li><p>Uniform：规定统一的格式可方便处理多种不同类型的资源，而不用根据上下文环境来识别资源指定的访问方式。另外，加入新增的协议方案（如http：或ftp:）也更容易</p></li><li><p>Resource：资源的定义是“可标识的任何东西”。不仅是文档文件，图像或服务（例如当天的天气预报）等能够区别于其他类型的，全都可作为资源。另外，资源不仅可以是单一的，也可以是多数的集合体</p></li><li><p>Identifier：表示可标识的对象。也称为标识符</p></li></ul></li><li><p>综上所述，URI就是由某个协议方案表示的资源的定位标识符。协议方案是指访问资源所使用的协议类型名称</p><ul><li><p>采用HTTP协议时，协议方案就是http</p></li><li><p>除此之外，还有ftp、mailto、telnet、file等</p></li></ul></li><li><p>标准的URI协议方案有30种左右，由隶属于国际互联网资源管理的非营利社团ICANN（Internet Corporation for Assigned Names andNumbers，互联网名称与数字地址分配机构）的IANA（Internet AssignedNumbers Authority，互联网号码分配局）管理颁布</p></li><li><p>URI用字符串标识某一互联网资源，而URL表示资源的地点（互联网上所处的位置）。可见URL是URI的子集</p></li><li><p>“RFC3986：统一资源标识符（URI）通用语法”中列举了几种URI例子，如下所示</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">http</span>://www.ietf.org/rfc/rfc2396.txt<br><span class="hljs-attribute">ldap</span>://[<span class="hljs-number">2001</span>:db8::<span class="hljs-number">7</span>]/c=GB?objectClass?one<br><span class="hljs-attribute">mailto</span>:John.Doe@example.com<br><span class="hljs-attribute">news</span>:comp.infosystems.www.servers.unix<br><span class="hljs-attribute">tel</span>:+<span class="hljs-number">1</span>-<span class="hljs-number">816</span>-<span class="hljs-number">555</span>-<span class="hljs-number">1212</span><br><span class="hljs-attribute">telnet</span>://<span class="hljs-number">192.0.2.16:80</span>/<br><span class="hljs-attribute">urn</span>:oasis:names:specification:docbook:dtd:xml:<span class="hljs-number">4</span>.<span class="hljs-number">1</span>.<span class="hljs-number">2</span><br></code></pre></td></tr></table></figure></li></ul><h4 id="1-7-2-URI格式"><a href="#1-7-2-URI格式" class="headerlink" title="1.7.2 URI格式"></a>1.7.2 URI格式</h4><ul><li><p>表示指定的URI，要使用涵盖全部必要信息的绝对URI、绝对URL以及相对URL</p><ul><li>相对URL，是指从浏览器中基本URI处指定的URL，形如 &#x2F;image&#x2F;logo.gif</li></ul></li><li><p>绝对URI的格式：</p><p><img src="/image/%E5%9B%BE%E8%A7%A3HTTP/b22bc2fe1a598316338814ec6e207782d37904c0.jpeg" alt="epub_907764_15.jpeg"></p><ul><li><p>使用http:或https:等协议方案名获取访问资源时要指定协议类型。不区分字母大小写，最后附一个冒号（:）。也可使用data:或javascript:这类指定数据或脚本程序的方案名</p></li><li><p>登录信息（认证）：指定用户名和密码作为从服务器端获取资源时必要的登录信息（身份认证）。此项是可选项</p></li><li><p>服务器地址：使用绝对URI必须指定待访问的服务器地址。地址可以是类似hackr.jp这种DNS可解析的名称，或是192.168.1.1这类IPv4地址名，还可以是[:0:0:0:0:0:0:1]这样用方括号括起来的IPv6地址名</p></li><li><p>服务器端口号：指定服务器连接的网络端口号。此项也是可选项，若用户省略则自动使用默认端口号</p></li><li><p>带层次的文件路径：指定服务器上的文件路径来定位特指的资源。这与UNIX系统的文件目录结构相似</p></li><li><p>查询字符串：针对已指定的文件路径内的资源，可以使用查询字符串传入任意参数。此项可选</p></li><li><p>片段标识符：使用片段标识符通常可标记出已获取资源中的子资源（文档内的某个位置）。但在RFC中并没有明确规定其使用方法。该项也为可选项</p></li></ul></li><li><p>并不是所有的应用程序都符合RFC</p><ul><li><p>有一些用来制定HTTP协议技术标准的文档，它们被称为RFC（Requestfor Comments，征求修正意见书）</p></li><li><p>通常，应用程序会遵照由RFC确定的标准实现。可以说，RFC是互联网的设计文档，要是不按照RFC标准执行，就有可能导致无法通信的状况。比如，有一台Web服务器内的应用服务没有遵照RFC的标准实现，那Web浏览器就很可能无法访问这台服务器了</p></li><li><p>由于不遵照RFC标准实现就无法进行HTTP协议通信，所以基本上客户端和服务器端都会以RFC为标准来实现HTTP协议。但也存在某些应用程序因客户端或服务器端的不同，而未遵照RFC标准，反而将自成一套的“标准”扩展的情况</p></li><li><p>不按RFC标准来实现，当然也不必劳心费力让自己的“标准”符合其他所有的客户端和服务器端。但设想一下，如果这款应用程序的使用者非常多，那会发生什么情况？不难想象，其他的客户端或服务器端必然都不得不去配合它</p></li><li><p>实际在互联网上，已经实现了HTTP协议的一些服务器端和客户端里就存在上述情况。说不定它们会与本书介绍的HTTP协议的实现情况不一样</p></li><li><p>本书接下来要介绍的HTTP协议内容，除去部分例外，基本上都以RFC的标准为准</p></li></ul></li><li><p>URL和URI的区别</p><ul><li><p><a href="https://www.javatpoint.com/uri-vs-url">URI vs URL | Difference between URI and URL</a></p></li><li><p><a href="https://www.cnblogs.com/blknemo/p/13198506.html">【Web思考】URI和URL的区别？以及URL的结构</a></p><ul><li><p>我们要找一个人——张三，我们可以通过他的唯一的标识来找，比如说<strong>身份证</strong>，那么这个身份证就唯一的标识了一个人，这个身份证就是一个 URI；</p></li><li><p>而要找到张三，我们不一定要用身份证去找，我们还可以根据地址去找，如 在清华大学18号宿舍楼的404房间第一个床铺的张三，我们也可以唯一确定一个张三，<code>动物住址协议://地球/中国/北京市/清华大学/18号宿舍楼/404号寝/张三.人</code>。而这个地址就是我们用于标识和定位的 URL</p></li><li><p>我们从上面可以很明显的看出，URI 通过任何方法标识一个人即可，而 URL 虽然也可以标识一个人，但是它主要是通过定位地址的方法标识一个人，所以 URL 其实是 URI 的一个子集，即 URL 是靠标识定位地址的一个 URI</p></li></ul></li><li><p>简单来说，URI是标识某一资源，但是不一定能定位到，而URL除了标识某一资源，还可以定位到这一资源</p></li></ul></li></ul><h2 id="第二章-简单的HTTP协议"><a href="#第二章-简单的HTTP协议" class="headerlink" title="第二章 简单的HTTP协议"></a>第二章 简单的HTTP协议</h2><h3 id="2-1-HTTP协议用于客户端和服务器端之间的通信"><a href="#2-1-HTTP协议用于客户端和服务器端之间的通信" class="headerlink" title="2.1 HTTP协议用于客户端和服务器端之间的通信"></a>2.1 HTTP协议用于客户端和服务器端之间的通信</h3><ul><li><p>HTTP协议和TCP&#x2F;IP协议族内的其他众多的协议相同，用于客户端和服务器之间的通信</p></li><li><p>请求访问文本或图像等资源的一端称为客户端，而提供资源响应的一端称为服务器端</p></li><li><p>应用HTTP协议时，必定是一端担任客户端角色，另一端担任服务器端角色</p></li><li><p>有时候，按实际情况，两台计算机作为客户端和服务器端的角色有可能会互换。但就仅从一条通信路线来说，服务器端和客户端的角色是确定的，而用HTTP协议能够明确区分哪端是客户端，哪端是服务器端</p></li></ul><h3 id="2-2-通过请求和响应的交换达成通信"><a href="#2-2-通过请求和响应的交换达成通信" class="headerlink" title="2.2 通过请求和响应的交换达成通信"></a>2.2 通过请求和响应的交换达成通信</h3><ul><li><p>HTTP协议规定，请求从客户端发出，最后服务器端响应该请求并返回。换句话说，肯定是先从客户端开始建立通信的，服务器端在没有接收到请求之前不会发送响应</p></li><li><p>HTTP通信示例</p><p><img src="/image/%E5%9B%BE%E8%A7%A3HTTP/b652df550c08be444515045970281cc186897d16.jpeg" alt="epub_907764_19.jpeg"></p></li><li><p>从客户端发送给某个HTTP服务器端的请求报文中的内容示例</p><figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs http"><span class="hljs-keyword">GET</span> <span class="hljs-string">/index.html</span> <span class="hljs-meta">HTTP/1.1</span><br><span class="hljs-attribute">Host</span><span class="hljs-punctuation">: </span>hackr.jp<br></code></pre></td></tr></table></figure><ul><li><p>起始行开头的GET表示请求访问服务器的类型，称为方法（method）</p></li><li><p>随后的字符串&#x2F;index.htm指明了请求访问的资源对象，也叫做请求URI（request-URI）</p></li><li><p>最后的HTTP&#x2F;1.1，即HTTP的版本号，用来提示客户端使用的HTTP协议功能</p></li><li><p>综合来看，这段请求内容的意思是：请求访问某台HTTP服务器上的&#x2F;index.htm页面资源</p></li></ul></li><li><p>请求报文是由请求方法、请求URI、协议版本、可选的请求首部字段和内容实体构成的。首部字段和内容实体之间以空行为间隔</p><p><img src="/image/%E5%9B%BE%E8%A7%A3HTTP/4b0bfee1e36d0a852f518bb38f2fd663a607fd57.jpeg" alt="epub_907764_20.jpeg"></p></li><li><p>接收到请求的服务器，会将请求内容的处理结果以响应的形式返回</p><figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs http"><span class="hljs-meta">HTTP/1.1</span> <span class="hljs-number">200</span> OK<br><span class="hljs-attribute">Date</span><span class="hljs-punctuation">: </span>Tue, 10 Jul 2012 06:50:15 GMT<br><span class="hljs-attribute">Cotent-Length</span><span class="hljs-punctuation">: </span>362<br><span class="hljs-attribute">Content-Type</span><span class="hljs-punctuation">: </span>text/html<br><br><span class="language-lasso">&lt;html&gt;</span><br><span class="language-lasso"><span class="hljs-params">...</span><span class="hljs-params">...</span></span><br></code></pre></td></tr></table></figure><ul><li><p>在起始行开头的HTTP&#x2F;1.1表示服务器对应的HTTP版本</p></li><li><p>紧挨着的200 OK表示请求的处理结果的状态码（status code）和原因短语（reason-phrase）</p></li><li><p>下一行显示了创建响应的日期时间，是首部字段（header field）内的一个属性</p></li><li><p>接着以一空行分隔，之后的内容称为资源实体的主体（entity body）</p></li></ul></li><li><p>响应报文基本上由协议版本、状态码（表示请求成功或失败的数字代码）、用以解释状态码的原因短语、可选的响应首部字段以及实体主体构成</p><p><img src="/image/%E5%9B%BE%E8%A7%A3HTTP/63a1ed37ca819a9f09b4faec46eb3a3f9e7b30fb.jpeg" alt="epub_907764_21.jpeg"></p></li></ul><h3 id="2-3-HTTP是不保存状态的协议"><a href="#2-3-HTTP是不保存状态的协议" class="headerlink" title="2.3 HTTP是不保存状态的协议"></a>2.3 HTTP是不保存状态的协议</h3><ul><li><p>HTTP是一种不保存状态，即无状态（stateless）协议。HTTP协议自身不对请求和响应之间的通信状态进行保存。也就是说在HTTP这个级别，协议对于发送过的请求或响应都不做持久化处理</p></li><li><p>使用HTTP协议，每当有新的请求发送时，就会有对应的新响应产生。协议本身并不保留之前一切的请求或响应报文的信息。这是为了更快地处理大量事务，确保协议的可伸缩性，而特意把HTTP协议设计成如此简单的</p></li><li><p>可是，随着Web的不断发展，因无状态而导致业务处理变得棘手的情况增多了。比如，用户登录到一家购物网站，即使他跳转到该站的其他页面后，也需要能继续保持登录状态。针对这个实例，网站为了能够掌握是谁送出的请求，需要保存用户的状态</p></li><li><p>HTTP&#x2F;1.1虽然是无状态协议，但为了实现期望的保持状态功能，于是引入了Cookie技术。有了Cookie再用HTTP协议通信，就可以管理状态了</p></li></ul><h3 id="2-4-请求URI定位资源"><a href="#2-4-请求URI定位资源" class="headerlink" title="2.4 请求URI定位资源"></a>2.4 请求URI定位资源</h3><ul><li><p>HTTP协议使用URI定位互联网上的资源。正是因为URI的特定功能，在互联网上任意位置的资源都能访问到</p></li><li><p>当客户端请求访问资源而发送请求时，URI需要将作为请求报文中的请求URI包含在内。指定请求URI的方式有很多</p><ul><li><p>URI为完整的请求URI</p><figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs http"><span class="hljs-keyword">GET</span> <span class="hljs-string">http://hackr.jp/index.html</span> <span class="hljs-meta">HTTP/1.1</span><br></code></pre></td></tr></table></figure></li><li><p>在首部字段Host中写明网络域名或IP地址</p><figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs http"><span class="hljs-keyword">GET</span> <span class="hljs-string">/index.html</span> <span class="hljs-meta">HTTP/1.1</span><br><span class="hljs-attribute">Host</span><span class="hljs-punctuation">: </span>hackr.jp<br></code></pre></td></tr></table></figure></li></ul></li><li><p>如果不是访问特定资源而是对服务器本身发起请求，可以用一个*来代替请求URI。下述例子用于查询HTTP服务器端支持的HTTP方法种类</p><figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs http"><span class="hljs-keyword">OPTIONS</span> <span class="hljs-string">*</span> <span class="hljs-meta">HTTP/1.1</span><br></code></pre></td></tr></table></figure></li></ul><h3 id="2-5-告知服务器意图的HTTP方法"><a href="#2-5-告知服务器意图的HTTP方法" class="headerlink" title="2.5 告知服务器意图的HTTP方法"></a>2.5 告知服务器意图的HTTP方法</h3><ul><li><p>GET：获取资源</p><ul><li><p>GET方法用来请求访问已被URI识别的资源。指定的资源经服务器端解析后返回响应内容</p></li><li><p>也就是说，如果请求的资源是文本，那就保持原样返回；如果是像CGI（Common Gateway Interface，通用网关接口）那样的程序，则返回经过执行后的输出结果</p></li></ul></li><li><p>POST：传输实体主体</p><ul><li><p>POST方法用来传输实体的主体</p></li><li><p>虽然用GET方法也可以传输实体的主体，但一般不用GET方法进行传输，而是用POST方法</p></li><li><p>虽说POST的功能与GET很相似，但POST的主要目的并不是获取响应的主体内容</p></li></ul></li><li><p>PUT：传输文件</p><ul><li><p>PUT方法用来传输文件。就像FTP协议的文件上传一样，要求在请求报文的主体中包含文件内容，然后保存到请求URI指定的位置</p></li><li><p>但是，鉴于HTTP&#x2F;1.1的PUT方法自身不带验证机制，任何人都可以上传文件，存在安全性问题，因此一般的Web网站不使用该方法。若配合Web应用程序的验证机制，或架构设计采用REST（Representational State Transfer，表征状态转移）标准的同类Web网站，就可能会开放使用PUT方法</p></li></ul></li><li><p>HEAD：获得报文首部</p><ul><li>HEAD方法和GET方法一样，只是不返回报文主体部分。用于确认URI的有效性及资源更新的日期时间等</li></ul></li><li><p>DELETE：删除文件</p><ul><li><p>DELETE方法用来删除文件，是与PUT相反的方法。DELETE方法按请求URI删除指定的资源</p></li><li><p>但是，HTTP&#x2F;1.1的DELETE方法本身和PUT方法一样不带验证机制，所以一般的Web网站也不使用DELETE方法。当配合Web应用程序的验证机制，或遵守REST标准时还是有可能会开放使用的</p></li></ul></li><li><p>OPTIONS：询问支持的方法</p><ul><li>OPTIONS方法用来查询针对请求URI指定的资源支持的方法</li></ul></li><li><p>TRACE：追踪路径</p><ul><li><p>TRACE方法是让Web服务器端将之前的请求通信环回给客户端的方法</p></li><li><p>发送请求时，在Max-Forwards首部字段中填入数值，每经过一个服务器端就将该数字减1，当数值刚好减到0时，就停止继续传输，最后接收到请求的服务器端则返回状态码200 OK的响应</p></li><li><p>客户端通过TRACE方法可以查询发送出去的请求是怎样被加工修改&#x2F;篡改的。这是因为，请求想要连接到源目标服务器可能会通过代理中转，TRACE方法就是用来确认连接过程中发生的一系列操作</p></li><li><p>但是，TRACE方法本来就不怎么常用，再加上它容易引发XST（Cross-SiteTracing，跨站追踪）攻击，通常就更不会用到了</p></li></ul></li><li><p>CONNECT：要求用隧道协议连接代理</p><ul><li><p>CONNECT方法要求在与代理服务器通信时建立隧道，实现用隧道协议进行TCP通信。主要使用SSL（Secure Sockets Layer，安全套接层）和TLS（Transport Layer Security，传输层安全）协议把通信内容加密后经网络隧道传输</p></li><li><p>CONNECT方法的格式如下所示</p><figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs http">CONNECT 代理服务器:端口号 HTTP版本<br></code></pre></td></tr></table></figure></li></ul></li></ul><h2 id="第三章-HTTP报文内的HTTP消息"><a href="#第三章-HTTP报文内的HTTP消息" class="headerlink" title="第三章 HTTP报文内的HTTP消息"></a>第三章 HTTP报文内的HTTP消息</h2><h3 id="3-1-HTTP报文"><a href="#3-1-HTTP报文" class="headerlink" title="3.1 HTTP报文"></a>3.1 HTTP报文</h3><ul><li><p>用于HTTP协议交互的信息被称为HTTP报文</p><ul><li><p>请求端（客户端）的HTTP报文叫做请求报文，响应端（服务器端）的叫做响应报文</p></li><li><p>HTTP报文本身是由多行（用CR+LF作换行符）数据构成的字符串文本</p></li></ul></li><li><p>HTTP报文大致可分为报文首部和报文主体两块。两者由最初出现的空行（CR+LF）来划分。通常，并不一定要有报文主体</p><p><img src="/image/%E5%9B%BE%E8%A7%A3HTTP/3d2ef9e09f5c724acbdc2eb468948efcf2b91eb5.jpeg" alt="epub_907764_52.jpeg"></p></li></ul><h3 id="3-2-请求报文及响应报文的结构"><a href="#3-2-请求报文及响应报文的结构" class="headerlink" title="3.2 请求报文及响应报文的结构"></a>3.2 请求报文及响应报文的结构</h3><ul><li><p>请求报文和响应报文的结构</p><p><img src="/image/%E5%9B%BE%E8%A7%A3HTTP/2c7241ff7035e12c4181b673d43943c3f440d404.jpeg" alt="epub_907764_53.jpeg"></p></li><li><p>请求报文和响应报文的实例</p><p><img src="/image/%E5%9B%BE%E8%A7%A3HTTP/55a496ad131973ea835bdd4f1e65da7f625942ad.jpeg" alt="epub_907764_54.jpeg"></p></li><li><p>请求报文和响应报文的首部内容由以下数据组成</p><ul><li><p>请求行：包含用于请求的方法，请求URI和HTTP版本</p></li><li><p>状态行：包含表明响应结果的状态码，原因短语和HTTP版本</p></li><li><p>首部字段：包含表示请求和响应的各种条件和属性的各类首部</p><ul><li>一般有4种首部，分别是：通用首部、请求首部、响应首部和实体首部</li></ul></li><li><p>其他：可能包含HTTP的RFC里未定义的首部（Cookie等）</p></li></ul></li></ul><h3 id="3-3-编码提升传输速率"><a href="#3-3-编码提升传输速率" class="headerlink" title="3.3 编码提升传输速率"></a>3.3 编码提升传输速率</h3><ul><li>HTTP在传输数据时可以按照数据原貌直接传输，但也可以在传输过程中通过编码提升传输速率。通过在传输时编码，能有效地处理大量的访问请求。但是，编码的操作需要计算机来完成，因此会消耗更多的CPU等资源</li></ul><h4 id="3-3-1-报文主体和实体主体的差异"><a href="#3-3-1-报文主体和实体主体的差异" class="headerlink" title="3.3.1 报文主体和实体主体的差异"></a>3.3.1 报文主体和实体主体的差异</h4><ul><li><p>报文（message）是HTTP通信中的基本单位，由8位组字节流（octet sequence，其中octet为8个比特）组成，通过HTTP通信传输</p></li><li><p>实体（entity）作为请求或响应的有效载荷数据（补充项）被传输，其内容由实体首部和实体主体组成</p></li><li><p>HTTP报文的主体用于传输请求或响应的实体主体。通常，报文主体等于实体主体。只有当传输中进行编码操作时，实体主体的内容发生变化，才导致它和报文主体产生差异</p><ul><li><p><a href="https://www.zhihu.com/question/263752229">http报文和实体的差别？</a></p></li><li><p>实体主体指的是，HTTP报文在网络上传输的过程中，载荷的真实模样</p></li><li><p>报文主体指的是，使用HTTP通信的一方想要发送给另一方的消息的模样</p></li><li><p>如果没有经过编码，那实体主体就是报文主体。如果经过编码，那实体主体就是编码前的报文主体</p></li></ul></li></ul><h4 id="3-3-2-压缩传输的内容编码"><a href="#3-3-2-压缩传输的内容编码" class="headerlink" title="3.3.2 压缩传输的内容编码"></a>3.3.2 压缩传输的内容编码</h4><ul><li><p>向待发送邮件内增加附件时，为了使邮件容量变小，我们会先用ZIP压缩文件之后再添加附件发送。HTTP协议中有一种被称为内容编码的功能也能进行类似的操作</p></li><li><p>内容编码指明应用在实体内容上的编码格式，并保持实体信息原样压缩。内容编码后的实体由客户端接收并负责解码</p></li><li><p>常用的内容编码有以下几种</p><ul><li><p>gzip（GNU zip）</p></li><li><p>compress（UNIX系统的标准压缩）</p></li><li><p>deflate（zlib）</p></li><li><p>identity（不进行编码）</p></li></ul></li></ul><h4 id="3-3-3-分割发送的分块传输编码"><a href="#3-3-3-分割发送的分块传输编码" class="headerlink" title="3.3.3 分割发送的分块传输编码"></a>3.3.3 分割发送的分块传输编码</h4><ul><li><p>在HTTP通信过程中，请求的编码实体资源尚未全部传输完成之前，浏览器无法显示请求页面。在传输大容量数据时，通过把数据分割成多块，能够让浏览器逐步显示页面。这种把实体主体分块的功能称为分块传输编码（Chunked TransferCoding）</p></li><li><p>分块传输编码会将实体主体分成多个部分（块）。每一块都会用十六进制来标记块的大小，而实体主体的最后一块会使用“0(CR+LF)”来标记</p></li><li><p>使用分块传输编码的实体主体会由接收的客户端负责解码，恢复到编码前的实体主体</p></li><li><p>HTTP&#x2F;1.1中存在一种称为传输编码（Transfer Coding）的机制，它可以在通信时按某种编码方式传输，但只定义作用于分块传输编码中</p></li><li><p>内容编码和分块传输编码的区别</p><ul><li><p>内容编码是为了压缩内容，减少体积</p></li><li><p>传输编码是为了切割发送的内容，它不但不会减少实体内容传输大小，甚至还会使传输变大</p></li></ul></li></ul><h3 id="3-4-发送多种数据的多部分对象集合"><a href="#3-4-发送多种数据的多部分对象集合" class="headerlink" title="3.4 发送多种数据的多部分对象集合"></a>3.4 发送多种数据的多部分对象集合</h3><ul><li><p>发送邮件时，我们可以在邮件里写入文字并添加多份附件。这是因为采用了MIME（Multipurpose Internet Mail Extensions，多用途因特网邮件扩展）机制，它允许邮件处理文本、图片、视频等多个不同类型的数据</p><ul><li><p>例如，图片等二进制数据以ASCII码字符串编码的方式指明，就是利用MIME来描述标记数据类型</p></li><li><p>MIME扩展中会使用一种称为多部分对象集合（Multipart）的方法，使得邮件容纳多份不同类型的数据</p></li></ul></li><li><p>HTTP协议中也采纳了多部分对象集合，发送的一份报文主体内可含有多类型实体。通常是在图片或文本文件等上传时使用</p></li><li><p>多部分对象集合包含的对象如下</p><ul><li><p>multipart&#x2F;form-data：在Web表单文件上传时使用</p></li><li><p>multipart&#x2F;byteranges：状态码206（Partial Content，部分内容）响应报文包含了多个范围的内容时使用</p></li></ul></li><li><p>multipart&#x2F;form-data示例</p><figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs http"><span class="hljs-keyword">POST</span> <span class="hljs-string">http://localhost/file</span> <span class="hljs-meta">HTTP/1.1</span><br><span class="hljs-attribute">Content-Type</span><span class="hljs-punctuation">: </span>multipart/form-data; boundary=AaB03x<br><br><span class="language-fortran">--AaB03x</span><br><span class="language-fortran">Content-Disposition: <span class="hljs-keyword">form</span>-<span class="hljs-keyword">data</span>; <span class="hljs-keyword">name</span>=<span class="hljs-string">&quot;field1&quot;</span></span><br><span class="language-fortran"></span><br><span class="language-fortran">Hello</span><br><span class="language-fortran">--AaB03x</span><br><span class="language-fortran">Content-Disposition: <span class="hljs-keyword">form</span>-<span class="hljs-keyword">data</span>; <span class="hljs-keyword">name</span>=<span class="hljs-string">&quot;file&quot;</span>; filename=<span class="hljs-string">&quot;index.txt&quot;</span></span><br><span class="language-fortran">Content-<span class="hljs-keyword">Type</span>: text/plain</span><br><span class="language-fortran"></span><br><span class="language-fortran">...(<span class="hljs-built_in">index</span>.txt content)</span><br><span class="language-fortran">--AaB03x--</span><br></code></pre></td></tr></table></figure></li><li><p>multipart&#x2F;byteranges示例</p><figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs http"><span class="hljs-meta">HTTP/1.1</span> <span class="hljs-number">206</span> Partial Content<br><span class="hljs-attribute">Date</span><span class="hljs-punctuation">: </span>Fri, 13 Jul 2012 02:45:26 GMT<br><span class="hljs-attribute">Last-Modified</span><span class="hljs-punctuation">: </span>Fri, 31 Aug 2007 02:02:20 GMT<br><span class="hljs-attribute">Content-Type</span><span class="hljs-punctuation">: </span>multipart/byteranges; boundary=THIS_STRING_SEPARATES<br>--THIS_STRING_SEPARATES<br><span class="hljs-attribute">Content-Type</span><span class="hljs-punctuation">: </span>application/pdf<br><span class="hljs-attribute">Content-Range</span><span class="hljs-punctuation">: </span>bytes 500-999/8000<br>...（范围指定的数据）...<br>--THIS_STRING_SEPARATES<br><span class="hljs-attribute">Content-Type</span><span class="hljs-punctuation">: </span>application/pdf<br><span class="hljs-attribute">Content-Range</span><span class="hljs-punctuation">: </span>bytes 7000-7999/8000<br>...（范围指定的数据）...<br>--THIS_STRING_SEPARATES--<br></code></pre></td></tr></table></figure></li><li><p>在HTTP报文中使用多部分对象集合时，需要在首部字段里加上Content-type。有关这个首部字段，我们稍后讲解</p></li><li><p>使用boundary字符串来划分多部分对象集合指明的各类实体。在boundary字符串指定的各个实体的起始行之前插入“–”标记（例如：–AaB03x、–THIS_STRING_SEPARATES），而在多部分对象集合对应的字符串的最后插入“–”标记（例如：–AaB03x–、–THIS_STRING_SEPARATES–）作为结束</p></li><li><p>多部分对象集合的每个部分类型中，都可以含有首部字段。另外，可以在某个部分中嵌套使用多部分对象集合。有关多部分对象集合更详细的解释，请参考RFC2046</p></li></ul><h3 id="3-5-获取部分内容的范围请求"><a href="#3-5-获取部分内容的范围请求" class="headerlink" title="3.5 获取部分内容的范围请求"></a>3.5 获取部分内容的范围请求</h3><ul><li><p>为了解决低带宽下载大文件容易中断而重头开始的情况，Http传输需要一种可恢复的机制。所谓恢复是指能从之前下载中断处恢复下载</p></li><li><p>要实现该功能需要指定下载的实体范围。像这样，指定范围发送的请求叫做范围请求（Range Request）</p></li><li><p>执行范围请求时，会用到首部字段Range来指定资源的byte范围。byte范围的指定形式如下</p><figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs http"><span class="hljs-attribute">Range</span><span class="hljs-punctuation">: </span>bytes=5001-10000<br><span class="hljs-attribute">Range</span><span class="hljs-punctuation">: </span>bytes=5001-<br><span class="hljs-attribute">Range</span><span class="hljs-punctuation">: </span>bytes=-3000, 5000-7000<br></code></pre></td></tr></table></figure></li><li><p>针对范围请求，响应会返回状态码为206 Partial Content的响应报文。另外，对于多重范围的范围请求，响应会在首部字段Content-Type标明multipart&#x2F;byteranges后返回响应报文</p></li><li><p>如果服务器端无法响应范围请求，则会返回状态码200 OK和完整的实体内容</p></li></ul><h3 id="3-6-内容协商返回最合适的内容"><a href="#3-6-内容协商返回最合适的内容" class="headerlink" title="3.6 内容协商返回最合适的内容"></a>3.6 内容协商返回最合适的内容</h3><ul><li><p>同一个Web网站有可能存在着多份相同内容的页面。比如英语版和中文版的Web页面，它们内容上虽相同，但使用的语言却不同。当浏览器的默认语言为英语或中文，访问相同URI的Web页面时，则会显示对应的英语版或中文版的Web页面。这样的机制称为内容协商（ContentNegotiation）</p></li><li><p>内容协商机制是指客户端和服务器端就响应的资源内容进行交涉，然后提供给客户端最为适合的资源。内容协商会以响应资源的语言、字符集、编码方式等作为判断的基准</p></li><li><p>包含在请求报文中的某些首部字段（如下）就是判断的基准</p><ul><li><p>Accept</p></li><li><p>Accept-Charset</p></li><li><p>Accept-Encoding</p></li><li><p>Accept-Language</p></li><li><p>Content-Language</p></li></ul></li><li><p>内容协商技术</p><ul><li><p>服务器驱动协商（Server-driven Negotiation）</p><ul><li><p>由服务器端进行内容协商</p></li><li><p>以请求的首部字段为参考，在服务器端自动处理</p></li><li><p>但对用户来说，以浏览器发送的信息作为判定的依据，并不一定能筛选出最优内容</p></li></ul></li><li><p>客户端驱动协商（Agent-driven Negotiation）</p><ul><li><p>由客户端进行内容协商的方式</p></li><li><p>用户从浏览器显示的可选项列表中手动选择。还可以利用JavaScript脚本在Web页面上自动进行上述选择。比如按OS的类型或浏览器类型，自行切换成PC版页面或手机版页面</p></li></ul></li><li><p>透明协商（Transparent Negotiation）</p><ul><li>是服务器驱动和客户端驱动的结合体，是由服务器端和客户端各自进行内容协商的一种方法</li></ul></li></ul></li></ul><h2 id="第四章-返回结果的HTTP状态码"><a href="#第四章-返回结果的HTTP状态码" class="headerlink" title="第四章 返回结果的HTTP状态码"></a>第四章 返回结果的HTTP状态码</h2><h3 id="4-1-状态码告知从服务器端返回的请求结果"><a href="#4-1-状态码告知从服务器端返回的请求结果" class="headerlink" title="4.1 状态码告知从服务器端返回的请求结果"></a>4.1 状态码告知从服务器端返回的请求结果</h3><ul><li><p>状态码的职责是当客户端向服务器端发送请求时，描述返回的请求结果。借助状态码，用户可以知道服务器端是正常处理了请求，还是出现了错误</p></li><li><p>状态码如200 OK，以3位数字和原因短语组成。数字中的第一位指定了响应类别，后两位无分类</p></li><li><p>响应类别有以下5种</p><p><img src="/image/%E5%9B%BE%E8%A7%A3HTTP/28387e95d3944882418b800289b70afb79a64d8d.jpeg" alt="epub_907764_62.jpeg"></p></li><li><p>仅记录在RFC2616上的HTTP状态码就达40种，若再加上WebDAV（Web-based Distributed Authoring and Versioning，基于万维网的分布式创作和版本控制）（RFC4918、5842）和附加HTTP状态码（RFC6585）等扩展，数量就达60余种。别看种类繁多，实际上经常使用的大概只有14种</p></li><li><p>只要遵守状态码类别的定义，即使改变RFC2616中定义的状态码，或服务器端自行创建状态码都没问题</p></li></ul><h3 id="4-2-2XX成功"><a href="#4-2-2XX成功" class="headerlink" title="4.2 2XX成功"></a>4.2 2XX成功</h3><ul><li><p>2XX的响应结果表明请求被正常处理</p></li><li><p>200 OK</p><ul><li><p>表示从客户端发来的请求在服务器端被正常处理了</p></li><li><p>在响应报文内，随状态码一起返回的信息会因方法的不同而发生改变</p><ul><li><p>比如，使用GET方法时，对应请求资源的实体会作为响应返回</p></li><li><p>而使用HEAD方法时，对应请求资源的实体主体不随报文首部作为响应返回（即在响应中只返回首部，不会返回实体的主体部分）</p></li></ul></li></ul></li><li><p>204 No Content</p><ul><li><p>该状态码代表服务器接收的请求已成功处理，但在返回的响应报文中不含实体的主体部分。另外，也不允许返回任何实体的主体</p><ul><li>比如，当从浏览器发出请求处理后，返回204响应，那么浏览器显示的页面不发生更新</li></ul></li><li><p>一般在只需要从客户端往服务器发送信息，而对客户端不需要发送新信息内容的情况下使用</p></li></ul></li><li><p>206 Partial Content</p><ul><li>该状态码表示客户端进行了范围请求，而服务器成功执行了这部分的GET请求。响应报文中包含由Content-Range指定范围的实体内容</li></ul></li></ul><h3 id="4-3-3XX重定向"><a href="#4-3-3XX重定向" class="headerlink" title="4.3 3XX重定向"></a>4.3 3XX重定向</h3><ul><li><p>3XX响应结果表明浏览器需要执行某些特殊的处理以正确处理请求</p></li><li><p>301 Moved Permanently</p><ul><li><p>永久性重定向。该状态码表示请求的资源已被分配了新的URI，以后应使用资源现在所指的URI</p><ul><li>也就是说，如果已经把资源对应的URI保存为书签了，这时应该按Location首部字段提示的URI重新保存</li></ul></li></ul></li><li><p>302 Found</p><ul><li><p>临时性重定向。该状态码表示请求的资源已被分配了新的URI，希望用户（本次）能使用新的URI访问</p></li><li><p>和301 Moved Permanently状态码相似，但302状态码代表的资源不是被永久移动，只是临时性质的</p><ul><li><p>换句话说，已移动的资源对应的URI将来还有可能发生改变</p></li><li><p>比如，用户把URI保存成书签，但不会像301状态码出现时那样去更新书签，而是仍旧保留返回302状态码的页面对应的URI</p></li></ul></li></ul></li><li><p>303 See Other</p><ul><li><p>该状态码表示由于请求对应的资源存在着另一个URI，应使用GET方法定向获取请求的资源</p></li><li><p>303状态码和302 Found状态码有着相同的功能，但303状态码明确表示客户端应当采用GET方法获取资源，这点与302状态码有区别</p></li><li><p>比如，当使用POST方法访问CGI程序，其执行后的处理结果是希望客户端能以GET方法重定向到另一个URI上去时，返回303状态码。虽然302 Found状态码也可以实现相同的功能，但这里使用303状态码是最理想的</p></li><li><p>本书采用的是HTTP&#x2F;1.1，而许多HTTP&#x2F;1.1版以前的浏览器不能正确理解303状态码。虽然RFC 1945和RFC 2068规范不允许客户端在重定向时改变请求的方法，但是很多现存的浏览器将302响应视为303响应，并且使用GET方式访问在Location中规定的URI，而无视原先请求的方法。所以作者说这里使用303是最理想的。——译者注</p></li></ul></li><li><p>当301、302、303响应状态码返回时，几乎所有的浏览器都会把POST改成GET，并删除请求报文内的主体，之后请求会自动再次发送。301、302标准是禁止将POST方法改变成GET方法的，但实际使用时大家都会这么做</p></li><li><p>304 Not Modified</p><ul><li><p>该状态码表示客户端发送附带条件的请求时，服务器端允许请求访问资源，但因发生请求未满足条件的情况后，直接返回304 Not Modified（服务器端资源未改变，可直接使用客户端未过期的缓存）</p></li><li><p>304状态码返回时，不包含任何响应的主体部分。304虽然被划分在3XX类别中，但是和重定向没有关系</p></li><li><p>附带条件的请求是指采用GET方法的请求报文中包含If-Match,If-Modified-Since,If-None-Match,If-Range,If-Unmodified-Since中任一首部</p></li></ul></li><li><p>307 Temporary Redirect</p><ul><li><p>临时重定向。该状态码与302 Found有着相同的含义。尽管302标准禁止POST变换成GET，但实际使用时大家并不遵守。307会遵照浏览器标准，不会从POST变成GET</p></li><li><p>但是，对于处理响应时的行为，每种浏览器有可能出现不同的情况</p></li></ul></li></ul><h3 id="4-4-4XX客户端错误"><a href="#4-4-4XX客户端错误" class="headerlink" title="4.4 4XX客户端错误"></a>4.4 4XX客户端错误</h3><ul><li><p>4XX的响应结果表明客户端是发生错误的原因所在</p></li><li><p>400 Bad Request</p><ul><li>该状态码表示请求报文中存在语法错误。当错误发生时，需修改请求的内容后再次发送请求。另外，浏览器会像200 OK一样对待该状态码</li></ul></li><li><p>401 Unauthorized</p><ul><li><p>该状态码表示发送的请求需要有通过HTTP认证（BASIC认证、DIGEST认证）的认证信息。另外若之前已进行过1次请求，则表示用户认证失败</p></li><li><p>返回含有401的响应必须包含一个适用于被请求资源的WWW-Authenticate首部用以质询（challenge）用户信息。当浏览器初次接收到401响应，会弹出认证用的对话窗口</p></li></ul></li><li><p>403 Forbidden</p><ul><li><p>该状态码表明对请求资源的访问被服务器拒绝了。服务器端没有必要给出拒绝的详细理由，但如果想作说明的话，可以在实体的主体部分对原因进行描述，这样就能让用户看到了</p></li><li><p>未获得文件系统的访问授权，访问权限出现某些问题（从未授权的发送源IP地址试图访问）等列举的情况都可能是发生403的原因</p></li></ul></li><li><p>404 Not Found</p><ul><li>该状态码表明服务器上无法找到请求的资源。除此之外，也可以在服务器端拒绝请求且不想说明理由时使用</li></ul></li></ul><h3 id="5XX服务器错误"><a href="#5XX服务器错误" class="headerlink" title="5XX服务器错误"></a>5XX服务器错误</h3><ul><li><p>5XX的响应结果表明服务器本身发生错误</p></li><li><p>500 Internal Server Error</p><ul><li>该状态码表明服务器端在执行请求时发生了错误。也有可能是Web应用存在的bug或某些临时的故障</li></ul></li><li><p>503 Service Unavailable</p><ul><li>该状态码表明服务器暂时处于超负载或正在进行停机维护，现在无法处理请求。如果事先得知解除以上状况需要的时间，最好写入Retry-After首部字段再返回给客户端</li></ul></li><li><p>不少返回的状态码响应都是错误的，但是用户可能察觉不到这点。比如Web应用程序内部发生错误，状态码依然返回200 OK，这种情况也经常遇到</p></li></ul><h3 id="第五章-与HTTP协作的Web服务器"><a href="#第五章-与HTTP协作的Web服务器" class="headerlink" title="第五章 与HTTP协作的Web服务器"></a>第五章 与HTTP协作的Web服务器</h3><h3 id="5-1-用单台虚拟主机实现多个域名"><a href="#5-1-用单台虚拟主机实现多个域名" class="headerlink" title="5.1 用单台虚拟主机实现多个域名"></a>5.1 用单台虚拟主机实现多个域名</h3><ul><li><p>HTTP&#x2F;1.1规范允许一台HTTP服务器搭建多个Web站点。比如，提供Web托管服务（Web Hosting Service）的供应商，可以用一台服务器为多位客户服务，也可以以每位客户持有的域名运行各自不同的网站。这是因为利用了虚拟主机（Virtual Host，又称虚拟服务器）的功能</p></li><li><p>即使物理层面只有一台服务器，但只要使用虚拟主机的功能，则可以假想已具有多台服务器</p></li><li><p>在相同的IP地址下，由于虚拟主机可以寄存多个不同主机名和域名的Web网站，因此在发送HTTP请求时，必须在Host首部内完整指定主机名或域名的URI</p><ul><li>客户端使用HTTP协议访问服务器时，会经常采用类似<a href="http://www.hackr.jp这样的主机名和域名.在互联网上,域名通过dns服务映射到ip地址(域名解析)之后访问目标网站.可见,当请求发送到服务器时,已经是以ip地址形式访问了.所以,如果一台服务器内托管了www.tricorder.jp和www.hackr.jp这两个域名,当收到请求时就需要弄清楚究竟要访问哪个域名/">www.hackr.jp这样的主机名和域名。在互联网上，域名通过DNS服务映射到IP地址（域名解析）之后访问目标网站。可见，当请求发送到服务器时，已经是以IP地址形式访问了。所以，如果一台服务器内托管了www.tricorder.jp和www.hackr.jp这两个域名，当收到请求时就需要弄清楚究竟要访问哪个域名</a></li></ul></li></ul><h3 id="5-2-通信数据转发程序：代理、网关、隧道"><a href="#5-2-通信数据转发程序：代理、网关、隧道" class="headerlink" title="5.2 通信数据转发程序：代理、网关、隧道"></a>5.2 通信数据转发程序：代理、网关、隧道</h3><ul><li><p>HTTP通信时，除客户端和服务器以外，还有一些用于通信数据转发的应用程序，例如代理、网关和隧道。它们可以配合服务器工作。这些应用程序和服务器可以将请求转发给通信线路上的下一站服务器，并且能接收从那台服务器发送的响应再转发给客户端</p></li><li><p>代理：代理是一种有转发功能的应用程序，它扮演了位于服务器和客户端“中间人”的角色，接收由客户端发送的请求并转发给服务器，同时也接收服务器返回的响应并转发给客户端</p></li><li><p>网关：网关是转发其他服务器通信数据的服务器，接收从客户端发送来的请求时，它就像自己拥有资源的源服务器一样对请求进行处理。有时客户端可能都不会察觉，自己的通信目标是一个网关</p></li><li><p>隧道隧道是在相隔甚远的客户端和服务器两者之间进行中转，并保持双方通信连接的应用程序</p></li></ul><h4 id="5-2-1-代理"><a href="#5-2-1-代理" class="headerlink" title="5.2.1 代理"></a>5.2.1 代理</h4><ul><li><p>代理服务器的基本行为就是接收客户端发送的请求后转发给其他服务器。代理不改变请求URI，会直接发送给前方持有资源的目标服务器</p></li><li><p>持有资源实体的服务器被称为源服务器。从源服务器返回的响应经过代理服务器后再传给客户端</p></li><li><p>在HTTP通信过程中，可级联多台代理服务器。请求和响应的转发会经过数台类似锁链一样连接起来的代理服务器。转发时，需要附加Via首部字段以标记出经过的主机信息</p></li><li><p>每次通过代理服务器转发请求或响应时，会追加写入Via首部信息</p><p><img src="/image/%E5%9B%BE%E8%A7%A3HTTP/0bcecc352ffd1823bd40139f08c2607d9ac0d2cb.jpeg" alt="epub_907764_82.jpeg"></p></li><li><p>使用代理服务器的理由有：利用缓存技术（稍后讲解）减少网络带宽的流量，组织内部针对特定网站的访问控制，以获取访问日志为主要目的，等等</p></li><li><p>代理有多种使用方法，按两种基准分类。一种是是否使用缓存，另一种是是否会修改报文</p><ul><li><p>缓存代理</p><ul><li><p>代理转发响应时，缓存代理（Caching Proxy）会预先将资源的副本（缓存）保存在代理服务器上</p></li><li><p>当代理再次接收到对相同资源的请求时，就可以不从源服务器那里获取资源，而是将之前缓存的资源作为响应返回</p></li></ul></li><li><p>透明代理</p><ul><li><p>转发请求或响应时，不对报文做任何加工的代理类型被称为透明代理（Transparent Proxy）</p></li><li><p>反之，对报文内容进行加工的代理被称为非透明代理</p></li></ul></li></ul></li></ul><h4 id="5-2-2-网关"><a href="#5-2-2-网关" class="headerlink" title="5.2.2 网关"></a>5.2.2 网关</h4><ul><li><p>网关的工作机制和代理十分相似。而网关能使通信线路上的服务器提供非HTTP协议服务</p></li><li><p>利用网关能提高通信的安全性，因为可以在客户端与网关之间的通信线路上加密以确保连接的安全。比如，网关可以连接数据库，使用SQL语句查询数据。另外，在Web购物网站上进行信用卡结算时，网关可以和信用卡结算系统联动</p></li><li><p>利用网关可以由HTTP请求转化为其他协议通信</p><p><img src="/image/%E5%9B%BE%E8%A7%A3HTTP/0ad9b96be273bfb906eab58a39eb8a858fd7db1c.jpeg" alt="epub_907764_84.jpeg"></p></li></ul><h4 id="5-2-3-隧道"><a href="#5-2-3-隧道" class="headerlink" title="5.2.3 隧道"></a>5.2.3 隧道</h4><ul><li><p>隧道可按要求建立起一条与其他服务器的通信线路，届时使用SSL等加密手段进行通信。隧道的目的是确保客户端能与服务器进行安全的通信</p></li><li><p>隧道本身不会去解析HTTP请求。也就是说，请求保持原样中转给之后的服务器。隧道会在通信双方断开连接时结束</p></li><li><p>通过隧道的传输，可以和远距离的服务器安全通信。隧道本身是透明的，客户端不用在意隧道的存在</p><p><img src="/image/%E5%9B%BE%E8%A7%A3HTTP/3341e84011144464ac3467060e3d95aa48449b55.jpeg" alt="epub_907764_85.jpeg"></p></li></ul><h3 id="5-3-保存资源的缓存"><a href="#5-3-保存资源的缓存" class="headerlink" title="5.3 保存资源的缓存"></a>5.3 保存资源的缓存</h3><ul><li><p>缓存是指代理服务器或客户端本地磁盘内保存的资源副本。利用缓存可减少对源服务器的访问，因此也就节省了通信流量和通信时间</p></li><li><p>缓存服务器是代理服务器的一种，并归类在缓存代理类型中。换句话说，当代理转发从服务器返回的响应时，代理服务器将会保存一份资源的副本</p></li><li><p>缓存服务器的优势在于利用缓存可避免多次从源服务器转发资源。因此客户端可就近从缓存服务器上获取资源，而源服务器也不必多次处理相同的请求了</p></li></ul><h4 id="5-3-1-缓存的有效期限"><a href="#5-3-1-缓存的有效期限" class="headerlink" title="5.3.1 缓存的有效期限"></a>5.3.1 缓存的有效期限</h4><ul><li><p>即便缓存服务器内有缓存，也不能保证每次都会返回对同资源的请求。因为这关系到被缓存资源的有效性问题</p><ul><li><p>当遇上源服务器上的资源更新时，如果还是使用不变的缓存，那就会演变成返回更新前的“旧”资源了</p></li><li><p>即使存在缓存，也会因为客户端的要求、缓存的有效期等因素，向源服务器确认资源的有效性</p></li><li><p>若判断缓存失效，缓存服务器将会再次从源服务器上获取“新”资源</p></li></ul></li></ul><h4 id="5-3-2-客户端的缓存"><a href="#5-3-2-客户端的缓存" class="headerlink" title="5.3.2 客户端的缓存"></a>5.3.2 客户端的缓存</h4><ul><li><p>缓存不仅可以存在于缓存服务器内，还可以存在客户端浏览器中</p><ul><li><p>以InternetExplorer程序为例，把客户端缓存称为临时网络文件（Temporary InternetFile）</p></li><li><p>浏览器缓存如果有效，就不必再向服务器请求相同的资源了，可以直接从本地磁盘内读取</p></li><li><p>另外，和缓存服务器相同的一点是，当判定缓存过期后，会向源服务器确认资源的有效性。若判断浏览器缓存失效，浏览器会再次请求新资源</p></li></ul></li></ul>]]></content>
    
    
    <categories>
      
      <category>笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>基础体系</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【笔记】计算机是怎样跑起来的</title>
    <link href="/posts/5ab5fb1f.html"/>
    <url>/posts/5ab5fb1f.html</url>
    
    <content type="html"><![CDATA[<div class="note note-success">            <p>《计算机是怎样跑起来的》是日本作家矢泽久雄的另外一本CS入门书。</p><p>这本书出版较早，所以很多涉及到编程技术内容的章节都多多少少有些过时，例如第十一章节大篇幅介绍了 XML 的使用，但是现在 XML 的使用是远远不及 json 以及其他配置格式的。不过，计算机或者说 CS 界，越底层的东西越是稳定，所以这本书中也有很多知识现在也是毫不过时的，例如第二章计算机体系结构、第三章汇编原理、第八章数据库基础等等内容。</p><p>我摘抄了全书的笔记，但是觉得并不是很有必要全放上来。在我看来，本书的精华部分在于前面一二三章节，第二章教我们如何从芯片级搭建起一个“微型计算机”，第三章引导我们对汇编这一过程进行细致学习。两章节都很直观地让我们对计算机体系结构、汇编原理进行一个入门链接，化抽象为具象。建议大家感兴趣的可以去看看这两章原文，相信会得到不少的好处。</p>          </div><h2 id="第一章-计算机的三大原则"><a href="#第一章-计算机的三大原则" class="headerlink" title="第一章 计算机的三大原则"></a>第一章 计算机的三大原则</h2><h3 id="1-1-计算机的三个根本性基础"><a href="#1-1-计算机的三个根本性基础" class="headerlink" title="1.1 计算机的三个根本性基础"></a>1.1 计算机的三个根本性基础</h3><ul><li><p>计算机的三大原则</p><ul><li><p>计算机是执行输入、运算、输出的机器</p></li><li><p>程序是指令和数据的集合</p></li><li><p>计算机的处理方式有时与人们的思维习惯不同</p></li></ul></li><li><p>计算机是由硬件和软件组成的</p></li></ul><h3 id="1-2-输入、运算、输出是硬件的基础"><a href="#1-2-输入、运算、输出是硬件的基础" class="headerlink" title="1.2 输入、运算、输出是硬件的基础"></a>1.2 输入、运算、输出是硬件的基础</h3><ul><li><p>从硬件上来看，可以说计算机是执行输入、运算、输出三种操作的机器</p><ul><li><p>计算机的硬件由大量的 IC（Integrated Circuit，集成电路）组成。每块 IC 上都带有许多引脚</p></li><li><p>IC 引脚有的用于输入，有的用于输出</p></li><li><p>IC 会在其内部对外部输入的信息进行运算，并把运算结果输出到外部</p></li><li><p>运算这个词听起来也许有些难以理解，但实际上就是计算的意思</p></li></ul></li><li><p>输入、运算、输出三者必须成套出现，缺一不可。这样说的原因有几点</p><ul><li><p>首先，现在的计算机还没有发展到能通过自发的思考创造出信息的地步。因此不输入信息，计算机就不能工作。所以，输入是必不可少的</p></li><li><p>其次，计算机不可能不执行任何运算。如果只是使输入的信息绕过运算环节直接输出，那么这就是电线而不是计算机了。可以说不进行运算，计算机也就没有什么存在的意义</p></li><li><p>最后，输入的信息如果经过了运算，那么运算结果就必然要输出。如果不输出结果，那么这也不是计算机而只是堆积信息的垃圾箱了。因此，输出也必不可少</p></li></ul></li></ul><h3 id="1-3-软件是指令和数据的集合"><a href="#1-3-软件是指令和数据的集合" class="headerlink" title="1.3 软件是指令和数据的集合"></a>1.3 软件是指令和数据的集合</h3><ul><li><p>程序是指令和数据的集合</p><ul><li><p>所谓指令，就是控制计算机进行输入、运算、输出的命令</p></li><li><p>程序中的数据分为两类，一类是作为指令执行对象的输入数据，一类是从指令的执行结果得到的输出数据</p></li></ul></li><li><p>在程序设计中，会为一组指令赋予一个名字，可以称之为“函数”“语句”“方法”“子例程”“子程序”等</p></li><li><p>在编程时程序员会为数据赋予名字，称其为“变量”</p></li></ul><h3 id="1-4-对计算机来说什么都是数字"><a href="#1-4-对计算机来说什么都是数字" class="headerlink" title="1.4 对计算机来说什么都是数字"></a>1.4 对计算机来说什么都是数字</h3><ul><li><p>计算机本身只不过是为我们处理特定工作的机器</p></li><li><p>迄今为止，使用计算机的目的就是为了提高手工作业的效率</p><ul><li><p>例如，文字处理软件可以提高编写文档的效率；电子邮件可以提高传统邮件寄送的效率</p></li><li><p>总之，作为可以提高工作效率的工具，有些靠手工作业完成的业务可以直接交给计算机处理</p></li><li><p>但是也有很多手工作业无法直接由计算机处理。也就是说，在用计算机替代手工作业的过程中，要想顺应计算机的处理方法，有时就要违背人们的思维习惯</p></li></ul></li><li><p>用数字表示所有信息，这就是一个很具有代表性的计算机式的处理方法，这一点也正是和人类的思维习惯最不一样的地方</p><ul><li><p>例如，人们会用“蓝色”“红色”之类的词语描述有关颜色的信息。可是换作计算机的话，就不得不用数字表示颜色信息。例如，用“0,0,255”表示蓝色，用“255,0,0”表示红色，用“255,0,255”表示由蓝色和红色混合而成的紫色</p></li><li><p>不光是颜色，计算机对文字的处理也是如此</p></li><li><p>计算机内部会先把文字转换成相应的数字再做处理，这样的数字叫作“字符编码”</p></li></ul></li></ul><h2 id="第二章-试着制造一台计算机吧"><a href="#第二章-试着制造一台计算机吧" class="headerlink" title="第二章 试着制造一台计算机吧"></a>第二章 试着制造一台计算机吧</h2><ul><li>这一章节很有意思，可以去看看原文，该章节笔记主要为实操性笔记</li></ul><h3 id="2-1-制作微型计算机所必需的元件"><a href="#2-1-制作微型计算机所必需的元件" class="headerlink" title="2.1 制作微型计算机所必需的元件"></a>2.1 制作微型计算机所必需的元件</h3><ul><li><p>制作微型计算机所需的基础元件只有 3 个，CPU、内存和 I&#x2F;O，每种元件都是作为一块独立的 IC 在市场上出售的</p><ul><li><p>CPU 是计算机的大脑，负责解释、执行程序</p></li><li><p>内存负责存储程序和数据</p></li><li><p>I&#x2F;O 是 Input&#x2F;Output（输入&#x2F;输出）的缩写，负责将计算机和外部设备（周边设备）连接在一起</p></li></ul></li><li><p>为了制作微型计算机，除了 CPU、内存和 I&#x2F;O，还需要若干辅助元件</p></li><li><p>为了驱动 CPU 运转，称为“时钟信号”的电信号必不可少</p><ul><li><p>这种电信号就好像带有一个时钟，滴答滴答地每隔一定时间就变换一次电压的高低</p></li><li><p>输出时钟信号的元件叫作“时钟发生器”</p></li><li><p>时钟发生器中带有晶振，根据其自身的频率（振动的次数）产生时钟信号。时钟信号的频率可以衡量 CPU 的运转速度</p></li></ul></li><li><p>用于输入程序的装置也是必不可少的</p><ul><li><p>对于实验性质，可以用指拨开关来输入程序，指拨开关是一种由 8 个开关并排连在一起构成的元件</p></li><li><p>输出程序执行结果的装置是 8 个 LED（发光二极管）</p></li></ul></li><li><p>这里我们使用 Z80 CPU 作为微型计算机的 CPU、TC5517 作为内存、Z80 PIO 作为 I&#x2F;O</p><ul><li><p>Z80 CPU 是一款古老的 CPU，在 NEC 的 PC-8801、SHARP 的 MZ-80 等 8 比特计算机广泛应用的时代，曾以爆炸般的速度普及过</p></li><li><p>TC5517 是可以存储 2K 的 8 比特数据的内存。在计算机的世界里，K 表示 210&#x3D; 1024。TC5517 的容量是 8 比特×2×1024 &#x3D; 16384 比特，即 2K 字节。虽然这点容量与诸位所使用的个人计算机比起来相差悬殊，但是对于用于学习的微型计算机来说是绰绰有余了</p></li><li><p>Z80 PIO 作为 I&#x2F;O，经常与 Z80 CPU 一起使用。正如其名，PIO（Parallel I&#x2F;O，并行输入&#x2F;输出）可以在微型计算机和外部设备之间并行地（一排一排地）输入输出 8 比特的数据</p></li></ul></li><li><p>布线连接图</p><p><img src="/image/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%98%AF%E6%80%8E%E6%A0%B7%E8%B7%91%E8%B5%B7%E6%9D%A5%E7%9A%84/1e7ba2d863c891478fc3363cb5aaa567c2e55bd1.png" alt="20200208165842722.png"></p></li></ul><h3 id="2-2-电路图的读法"><a href="#2-2-电路图的读法" class="headerlink" title="2.2 电路图的读法"></a>2.2 电路图的读法</h3><ul><li><p>电路中有些地方有交叉，但若只是交叉在一起的话，并不表示电路在交叉处构成通路。只有在交叉处再画上一个小黑点才表示构成通路</p></li><li><p>IC 的引脚（所谓引脚就是 IC 边缘露出的像蜈蚣腿一样的部分）按照逆时针方向依次带有一个从 1 开始递增的序号。数引脚序号时，要先把表示正方向的标志，比如半圆形的缺口，朝向左侧</p></li><li><p>如果按照引脚序号的排列顺序来画 IC 的电路图符号，那么标示如何布线时就会很不方便。所以通常所绘制的电路图都不受引脚实际排布的限制。画图时，在引脚的旁边写上引脚的序号，在表示 IC 的矩形符号中写上表明该引脚作用的代号。代号就是像 RD（Read）表示执行读取操作，WR（Write）表示执行写入操作这样的代表了某种操作的符号</p></li></ul><h3 id="2-3-连接电源、数据和地址总线"><a href="#2-3-连接电源、数据和地址总线" class="headerlink" title="2.3 连接电源、数据和地址总线"></a>2.3 连接电源、数据和地址总线</h3><ul><li><p>通常将 1 个二进制数（也就是数字 IC 上 1 个引脚所能表示的 0 或者 1）所表示的信息称作“1 比特”，将 8 个二进制数（也就是 8 比特）称作“1 字节”。比特是信息的最小单位，字节是信息的基本单位</p></li><li><p>计算机以 CPU 为中心运转。CPU 可以与内存或 I&#x2F;O 进行数据的输入输出</p><ul><li><p>为了指定输入输出数据时的源头或目的地，CPU 上备有“地址总线引脚”</p></li><li><p>Z80 CPU 的地址总线引脚共有 16 个，用代号 A0～A15 表示，其中的 A 表示 Address（地址）。后面的数字 0～15 表示一个 16 位的二进制数中各个数字的位置，0 对应最后一位、15 对应第一位</p></li><li><p>16 个地址总线引脚所能指定的地址共有 65536 个，用二进制数表示的话就是 0000000000000000～1111111111111111。因此 Z80 CPU 可以指定 65536 个数据存取单元（内存存储单元或 I&#x2F;O 地址），进行信息的输入输出</p></li></ul></li><li><p>一旦指定了存取数据的地址，就可以使用数据总线引脚进行数据的输入输出了</p><ul><li><p>Z80 CPU 的数据总线引脚共有 8 个，用代号 D0～D7 表示。其中的 D 表示 Data（数据），后面的数字 0～7 与地址总线引脚代号的规则相同，也表示二进制数中各个数字的位置</p></li><li><p>Z80 CPU 可以一次性地输入输出 8 比特的数据，这就意味着如果想要输入输出位数（比特数）大于 8 比特的数据，就要以 8 比特为单位切分这个数据</p></li></ul></li><li><p>作为内存的 TC5517 上也有地址总线引脚（A0～A10）和数据总线引脚（D0～D7）。这些引脚需要同 Z80 CPU 上带有相同代号的引脚相连</p></li><li><p>由于用于输入程序的指拨开关是以 8 比特为一个单位指定内存地址的，所以我们只使用 TC5517 上的 A0～A7 这 8 个引脚，并把剩余的 A8～A10 引脚连接到 0V 上（这些引脚上的值永远是 0）。虽然总共有 2048 个存储单元，最终却只能使用其中的 256 个，稍微有些浪费</p></li></ul><h3 id="2-4-连接-I-x2F-O"><a href="#2-4-连接-I-x2F-O" class="headerlink" title="2.4 连接 I&#x2F;O"></a>2.4 连接 I&#x2F;O</h3><ul><li><p>寄存器是位于 CPU 和 I&#x2F;O 中的数据存储器</p><ul><li><p>Z80 PIO 上共有 4 个寄存器。2 个用于设定 PIO 本身的功能，2 个用于存储与外部设备进行输入输出的数据</p></li><li><p>这 4 个寄存器分别叫作端口 A 控制、端口 A 数据、端口 B 控制和端口 B 数据</p></li><li><p>所谓端口就是 I&#x2F;O 与外部设备之间输入输出数据的场所，可以把端口（Port）想象成是轮船装卸货物的港口</p></li><li><p>Z80 PIO 有 2 个端口，端口 A 和端口 B，最多可以连接 2 个用于输入输出 8 比特数据的外部设备</p></li></ul></li><li><p>ZIO 内部寄存器构造</p><p><img src="/image/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%98%AF%E6%80%8E%E6%A0%B7%E8%B7%91%E8%B5%B7%E6%9D%A5%E7%9A%84/63f2ad5ca2e456294054ddeeed9b6526019ff54d.jpeg" alt="epub_907760_18.jpeg"></p></li><li><p>既然已经大体上了解了 Z80 PIO 的结构，下面就开始布线吧。因为 Z80 PIO 上也有 D0～D7 的数据总线引脚，所以先把它们和 Z80 CPU 中带有同样代号的引脚连接起来。这样 CPU 和 PIO 就能使用这 8 个引脚交换数据了</p></li><li><p>接下来要把 Z80 PIO 的 B&#x2F;~A 和 C&#x2F;~D 引脚分别连接到 Z80 CPU 的地址总线引脚 A0 和 A1 上</p><ul><li><p>若表示 IC 引脚作用的代号上划有横线，则表示通过赋予该引脚 0（0V）可使之有效，反之若没有横线，则表示通过赋予该引脚 1（+5V）可使之有效</p></li><li><p>因此若赋予 B&#x2F;~A 和 C&#x2F;~D 引脚 1 则表示选中 B，反之赋予 0 则表示选中 A。同样地，若赋予 C&#x2F;D 引脚 1 则表示选中的是 C（C 即 Control，表示控制模式）；反之赋予 0 则表示选中的是 D（D 即 Data，表示数据模式）</p></li></ul></li><li><p>通过 Z80 CPU 的 A0～A7（00000000～11111111 共 256 个地址）地址总线引脚可以选择内存（TC5517）中的存储单元。同样地，使用 Z80 CPU 的 A0～A1（00～11 共 4 个地址）地址总线引脚也可以选择 I&#x2F;O（Z80 PIO）中的寄存器</p></li><li><p>Z80 CPU 的 A8～A15 地址总线引脚尚未使用，所以什么都不连接。在电路图中可以用代号 NC（NoConnection，未连接）表示引脚什么都不连接</p></li><li><p>IC 上的引脚有些只用于输出，有些只用于输入，还有些是输入输出两用的。对于只用于输出的引脚，不需要使用时的处理方法是这个引脚什么都不连接；而对于只用于输入或输入输出两用的引脚，不需要使用时的处理方法则是把这个引脚上的电压固定成是 +5V 或 0V</p></li></ul><h3 id="2-5-连接时钟信号"><a href="#2-5-连接时钟信号" class="headerlink" title="2.5 连接时钟信号"></a>2.5 连接时钟信号</h3><ul><li><p>正如前文所述，Z80 CPU 和 Z80 PIO 的运转离不开时钟信号</p><ul><li><p>为了传输时钟信号，就需要把时钟发生器的 8 号引脚和 Z80 CPU 的 CLK（CLK 即 Clock，时钟）引脚、Z80 PIO 的 CLK 引脚分别连接起来</p></li><li><p>时钟发生器的 8 号引脚与 +5V 之间的电阻用于清理时钟信号</p></li></ul></li></ul><h3 id="2-6-连接用于区分读写对象是内存还是-I-x2F-O-的引脚"><a href="#2-6-连接用于区分读写对象是内存还是-I-x2F-O-的引脚" class="headerlink" title="2.6 连接用于区分读写对象是内存还是 I&#x2F;O 的引脚"></a>2.6 连接用于区分读写对象是内存还是 I&#x2F;O 的引脚</h3><ul><li><p>至此，我们已经先后把 Z80 CPU 连接到了 TC5517 和 Z80 PIO 上，这两次连接都使用了地址总线引脚 A0 和 A1。如果仅仅这样连接，就会导致一个问题，当地址的最后两位是 00、01、10 和 11 时，CPU 就无法区分访问的是 TC5517 中的存储单元，还是 Z80 PIO 中的寄存器了</p></li><li><p>Z80 CPU 上的~MREQ（即 Memory Request，内存请求）引脚和~iorq（即 I&#x2F;O Request, I&#x2F;O 请求）引脚解决了这个问题</p><ul><li><p>当 Z80 CPU 和内存之间有数据输入输出时，~MREQ 引脚上的值是 0，反之则是 1</p></li><li><p>当 Z80 CPU 和 I&#x2F;O 之间有数据输入输出时，~IORQ 引脚上的值是 0，反之则是 1</p></li></ul></li><li><p>若把 TC5517 的~CE（即 Chip Enable，选通芯片）引脚设成 0，则 TC5517 在电路中被激活，若设成 1 则从电路中隔离，因为此时 TC5517 进入了高阻抗状态，所以即便它上面的引脚已经接入了电路也不会接收任何电信号</p></li><li><p>在 Z80 PIO 中，则是通过将~CE 引脚和~IORQ 引脚同时设为 0 或 1，来达到与 TC5517 的~CE 引脚相同的效果。若同时设为 0，则 Z80 PIO 在电路中被激活，若同时设为 1 则从电路中隔离（之所以使用两个引脚是因为这样更适合使用了多个 I&#x2F;O 的情况）</p></li><li><p>按照上面的讲解，下面需要把 Z80 CPU 的~MREQ 引脚连接到 TC5517 的~CE 引脚上。然后把 Z80 CPU 的~IORQ 引脚连接到 Z80 PIO 的~CE 引脚和~IORQ 引脚上</p></li><li><p>对内存和 I&#x2F;O 而言，还必须要分清 CPU 是要输入数据还是输出数据</p><ul><li><p>为此就要用到 Z80 CPU 的~RD 引脚（即 Read，表示输入，为 0 时执行输入操作）和~WR 引脚（即 Write，表示输出，为 0 时执行输出操作）了。请把这两个引脚与 TC5517 上同名的引脚连接起来</p></li><li><p>Z80 PIO 虽然只有~RD 引脚，但由于数字 IC 引脚上的值要么是 0 要么是 1，所以只用 1 个~RD 引脚也能区分是输入还是输出，0 的话是输入，1 的话就是输出</p></li></ul></li><li><p>与读写内存、I&#x2F;O 相关的引脚上的值</p><p><img src="/image/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%98%AF%E6%80%8E%E6%A0%B7%E8%B7%91%E8%B5%B7%E6%9D%A5%E7%9A%84/277c66b6604c70020d71685a3e74e85f7e6ad1fd.jpeg" alt="epub_907760_39.jpeg"></p></li></ul><h3 id="2-7-连接剩余的控制引脚"><a href="#2-7-连接剩余的控制引脚" class="headerlink" title="2.7 连接剩余的控制引脚"></a>2.7 连接剩余的控制引脚</h3><ul><li><p>CPU、内存、I&#x2F;O 中不但有地址总线引脚、数据总线引脚，还有其他引脚，通常把这些引脚统称为“控制引脚”。之所以这样命名是因为这些引脚上输入输出的电信号具有控制 IC 的功能</p></li><li><p>首先把 Z80 CPU 的~M1 引脚（即 Machine Cycle 1，机器周期 1）和~INT 引脚（即 Interrupt，中断）与 Z80 PIO 上标有相同代号的引脚连接起来</p><ul><li><p>~M1INT 是用于同步的引脚，~INT 引脚是用于从 Z80 PIO 向 Z80CPU 发出中断请求的引脚</p></li><li><p>所谓中断就是让 CPU 根据外部输入的数据执行特定的程序</p></li></ul></li><li><p>一旦把 Z80 CPU 的~RESET 引脚（即 Reset，重置）上的值先设成 0 再还原成 1, CPU 就会被重置，重新从内存 0 号地址上的指令开始顺序往下执行</p></li><li><p>重置 CPU 可以通过按键开关完成。按键开关需要经过电阻接在 +5V 和 0V 之间。电阻是为了防止短路而加入的，否则一旦按下了按键开关，+5V 和 0V 就会直接接到一起发生短路。像这样通过加入电阻把 +5V 和 0V 连接起来的方法在电路图中随处可见</p><p><img src="/image/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%98%AF%E6%80%8E%E6%A0%B7%E8%B7%91%E8%B5%B7%E6%9D%A5%E7%9A%84/201b6adc51e540c69397f49d0b35fb0077694733.jpeg" alt="epub_907760_47.jpeg"></p></li><li><p>连接在~RESET 引脚上的电容，用于在电路接通电源时自动重置 CPU。电容就好像一个充电电池，具有储存电荷的功能。在通电后的一刹那，由于电容正在充电，所以~RESET 引脚上的电压并不会立刻上升到 +5V。而完成充电后，~RESET 引脚的电压会变为 +5V，这样就相当于~RESET 引脚上的值从 0 变成了 1，重置了一次 CPU</p></li><li><p>总线是连接到 CPU 中数据引脚、地址引脚、控制引脚上的电路的统称。使用快动开关可以使 Z80 CPU 的~BUSRQ 引脚（即 Bus Request，总线请求）上的值在 0 和 1 之间切换</p><ul><li><p>若将~BUSRQ 引脚的值设为 0，则 Z80 CPU 从电路中隔离。当处于这种隔离状态时，就可以不通过 CPU，手动地向内存写入程序了</p></li><li><p>像这样不经过 CPU 而直接从外部设备读写内存的行为叫作 DMA（Direct Memory Access，直接存储器访问）</p></li></ul></li><li><p>当 Z80 CPU 从电路中隔离后，~BUSAK 引脚（即 Bus Acknowledge，响应总线请求）上的值就会变成 0。也就是说，~BUSRQ 引脚上的值设成 0 以后，还要确认~BUSQK 引脚上的值已经变成了 0，然后才能进行 DMA</p><ul><li>请把~BUSAK 引脚分别连接到 4 个 74367 的 G1 和 G2 引脚上，有关 74367 的作用将在后面说明</li></ul></li><li><p>Z80 CPU 的其他控制引脚并未使用。所以要把~WAIT 引脚和~NMI 引脚上的值设为 1，即连接到 +5V 上。之所以在连接时加入电阻，是为了便于今后加入开关等元件。剩下的~HALT 引脚和~ASTB 引脚什么都不连接</p><ul><li>上拉（Pull-up），指的就是像这样通过加入电阻把元件的引脚和 +5V 连接起来</li></ul></li><li><p>Z80 PIO 的 PA0～PA7（PA 表示 Port A）以及 PB0～PB7（PB 表示 Port B）用于与外部设备进行输入输出，所以稍后要把它们分别连接到指拨开关和 LED 上</p></li><li><p>对于 Z80 PIO 剩下的几个引脚可以这样处理：将 IEI 引脚上拉，IEO 引脚、~ASTB 引脚、ARDY 引脚、~BSTB 引脚和 BRDY 引脚则什么都不连接</p></li><li><p>到此为止，Z80 CPU、TC5517、Z80 PIO 以及时钟发生器上要用到的引脚就都接入电路了。这意味着计算机主机系统的功能完成了</p></li><li><p>其实计算机的工作原理非常简单。CPU 在时钟信号的控制下解释、执行内存中存储的程序，按照程序中的指令从内存或 I&#x2F;O 中把数据输入到 CPU 中，在 CPU 内部进行运算，再把运算结果输出到内存或 I&#x2F;O 中。无论是小型的微型计算机，还是高性能的个人计算机，其工作原理都是相同的</p></li><li><p>CPU、TC5517、Z80 PIO 的引脚作用以及输入输出方向</p><p><img src="/image/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%98%AF%E6%80%8E%E6%A0%B7%E8%B7%91%E8%B5%B7%E6%9D%A5%E7%9A%84/b8b1c68c87558378de17c941626dd765ffc6b64a.jpeg" alt="epub_907760_64.jpeg"></p></li></ul><h3 id="2-8-连接外部设备，通过-DMA-输入程序"><a href="#2-8-连接外部设备，通过-DMA-输入程序" class="headerlink" title="2.8 连接外部设备，通过 DMA 输入程序"></a>2.8 连接外部设备，通过 DMA 输入程序</h3><ul><li><p>我们要使用 2 个指拨开关和 1 个按键开关，向地址总线引脚和数据总线引脚发送电信号，然后通过 DMA 将数据总线上的数据存储到内存</p><ul><li><p>首先将右侧最上方的一个指拨开关连接到作为内存的 TC5517 的数据总线引脚 D0～D7 上</p></li><li><p>再将它下面紧挨着它的指拨开关连接到 TC5517 的地址总线引脚 A0～A7 上</p></li><li><p>接下来将用于控制内存写入的按键开关连接到 TC5517 的~WE 引脚上</p></li><li><p>为了写入数据，还要将 TC5517 的~RD 引脚上拉起来，连接到 +5V 上，然后把~CE 引脚连接到 0V 上</p></li><li><p>把这些元件都连接起来以后，就可以拨动指拨开关，用二进制数设定地址总线引脚和数据总线引脚上的数据了</p></li><li><p>设定完后按下按键开关，数据就会被写入 TC5517 中</p></li><li><p>在 2 个指拨开关下方还有一个指拨开关，它通过电阻接到 +5V 以上，这样拨动这个指拨开关就可以输入 +5V 或 0V 的信号了</p></li></ul></li><li><p>但是如果这些开关直接连接到了 TC5517 的各个引脚上，在程序执行时，开关的状态就会对电路产生影响。因此要使用 74367，在程序执行时把开关从电路中隔离出来</p><ul><li><p>74367 是一种叫作“三态总线缓冲器”的 IC</p></li><li><p>在这个 IC 的电路图符号中，有用三角形标志代表的缓冲器，表示使电信号从右向左直接通过</p></li><li><p>但是，只有在 74367 的~G1 引脚和~G2 引脚同时为 0 的时候，电信号才能通过。而当~G1 引脚和~G2 引脚同时为 1 时，74367 就会与电路隔离</p></li></ul></li><li><p>一旦打开了 Z80 CPU 的~BUSRQ 引脚连接着的开关，就可以通过~BUSAK 引脚输出 0 得知 CPU 进入了 DMA 状态。因此只要把~BUSAK 引脚连接到 4 个 74367 的~G1 引脚和~G2 引脚上，就可以实现通过 DMA 向内存写入数据了</p></li></ul><h3 id="2-9-连接用于输入输出的外部设备"><a href="#2-9-连接用于输入输出的外部设备" class="headerlink" title="2.9 连接用于输入输出的外部设备"></a>2.9 连接用于输入输出的外部设备</h3><ul><li><p>下面该轮到把最下方用于输入数据的指拨开关和 LED 连接到 Z80 PIO 上了。当微型计算机运行起来后，指拨开关可用于从外部输入数据，LED 可用于向外部输出数据</p></li><li><p>用于输入数据的指拨开关，要连接到 Z80 PIO 的 PA0～PA7 引脚上。连接时没有使用 74367 是为了在程序运行中可以通过 Z80 PIO 从指拨开关获得输入的数据</p></li><li><p>表示输出数据的 LED 要通过电阻连接到 +5V 上</p><ul><li><p>这里的布线方法依据惯例，输入 0V 点亮 LED</p></li><li><p>LED 要通过 7404 这样的 IC 连接到 Z80 PIO 的 PB0～PB7 引脚上</p></li><li><p>在 7404 的电路图符号中，末端带有一个小圆圈的三角形符号表示反相器，作用是将左侧输入的电信号反转后（即 0 变 1、1 变 0）输出到右侧</p></li><li><p>通过这样的设计，当 Z80 PIO 的 PB0～PB7 引脚上的值为 0 时 LED 就会熄灭，为 1 时 LED 就会点亮</p></li></ul></li><li><p>点亮 LED 的方法</p><p><img src="/image/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%98%AF%E6%80%8E%E6%A0%B7%E8%B7%91%E8%B5%B7%E6%9D%A5%E7%9A%84/dd6a824f3f9f755c8573bcf01f53d923440da897.jpeg" alt="epub_907760_77.jpeg"></p></li></ul><h2 id="第三章-体验一次手工汇编"><a href="#第三章-体验一次手工汇编" class="headerlink" title="第三章 体验一次手工汇编"></a>第三章 体验一次手工汇编</h2><ul><li><p>实现把由指拨开关输入的数据输入 CPU，然后 CPU 再把这些数据原封不动地输出到 LED 功能的程序</p><figure class="highlight dns"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs dns">地址             机器语言<br><span class="hljs-number">00000000</span>        <span class="hljs-number">00111110</span><br><span class="hljs-number">00000001</span>        <span class="hljs-number">11001111</span><br><span class="hljs-number">00000010</span>        <span class="hljs-number">11010011</span><br><span class="hljs-number">00000011</span>        <span class="hljs-number">00000010</span><br><span class="hljs-number">00000100</span>        <span class="hljs-number">00111110</span><br><span class="hljs-number">00000101</span>        <span class="hljs-number">11111111</span><br><span class="hljs-number">00000110</span>        <span class="hljs-number">11010011</span><br><span class="hljs-number">00000111</span>        <span class="hljs-number">00000010</span><br><span class="hljs-number">00001000</span>        <span class="hljs-number">00111110</span><br><span class="hljs-number">00001001</span>        <span class="hljs-number">11001111</span><br><span class="hljs-number">00001010</span>        <span class="hljs-number">11010011</span><br><span class="hljs-number">00001011</span>        <span class="hljs-number">00000011</span><br><span class="hljs-number">00001100</span>        <span class="hljs-number">00111110</span><br><span class="hljs-number">00001101</span>        <span class="hljs-number">00000000</span><br><span class="hljs-number">00001110</span>        <span class="hljs-number">11010011</span><br><span class="hljs-number">00001111</span>        <span class="hljs-number">00000011</span><br><span class="hljs-number">00010000</span>        <span class="hljs-number">11011011</span><br><span class="hljs-number">00010001</span>        <span class="hljs-number">00000000</span><br><span class="hljs-number">00010010</span>        <span class="hljs-number">11010011</span><br><span class="hljs-number">00010011</span>        <span class="hljs-number">00000001</span><br><span class="hljs-number">00010100</span>        <span class="hljs-number">11000011</span><br><span class="hljs-number">00010101</span>        <span class="hljs-number">00010000</span><br><span class="hljs-number">00010110</span>        <span class="hljs-number">00000000</span><br></code></pre></td></tr></table></figure></li><li><p>对应汇编代码</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs nasm">        LD  A,      207<br>        OUT (2),    A<br>        LD  A,      255<br>        OUT (2),    A<br>        LD  A,      207<br>        OUT (3),    A<br>        LD  A,      0<br>        OUT (3),    A<br>LOOP:   IN  A,      (0)<br>        OUT (1),    A<br>        JP  LOOP<br></code></pre></td></tr></table></figure></li></ul><h3 id="3-1-从程序员的角度看硬件"><a href="#3-1-从程序员的角度看硬件" class="headerlink" title="3.1 从程序员的角度看硬件"></a>3.1 从程序员的角度看硬件</h3><ul><li><p>因为程序的作用是驱动硬件工作，所以在编写程序之前必须要先了解微型计算机的硬件信息。然而真正需要了解的硬件信息只有以下 7 种，所以没有必要在编程时还总是盯着详细的电路图看</p><p>-【CPU（处理器）信息】</p><ul><li><p>CPU 的种类</p></li><li><p>时钟信号的频率</p></li></ul><p>-【内存信息】</p><ul><li><p>地址空间</p></li><li><p>每个地址中可以存储多少比特的信息</p></li></ul><p>-【I&#x2F;O 信息】</p><ul><li><p>I&#x2F;O 的种类</p></li><li><p>地址空间</p></li><li><p>连接着何种周边设备</p></li></ul></li><li><p>顾名思义，机器语言就是处理器可以直接理解（与生俱来就能理解）的编程语言</p><ul><li><p>可以使用哪种机器语言取决于 CPU（也称作处理器）的种类</p></li><li><p>即便是相同的机器语言，例如 01010011，只要 CPU 的种类不同，对它的解释也就不同。有的 CPU 会把它解释成是执行加法运算，有的 CPU 会把它解释成是向 I&#x2F;O 输出</p></li><li><p>机器语言有时也叫作原生代码（Native Code）</p></li></ul></li><li><p>所谓时钟信号的频率，就是由时钟发生器发送给 CPU 的电信号的频率</p><ul><li><p>表示时钟信号频率的单位是 MHz（兆赫兹 &#x3D; 100 万回&#x2F;秒）</p></li><li><p>时钟信号是在 0 和 1 两个数之间反复变换的电信号，就像滴答滴答左右摆动的钟摆一样</p></li><li><p>通常把发出一次滴答的时间称作一个时钟周期</p></li></ul></li><li><p>在机器语言当中，指令执行时所需要的时钟周期数取决于指令的类型。程序员不但可以通过累加时钟周期数估算程序执行的时间，还可以仅在特定的时间执行点亮 LED（发光二极管）等操作</p></li><li><p>每个地址都标示着一个内存中的数据存储单元，而这些地址所构成的范围就是内存的地址空间</p><ul><li>在我们的微型计算机中，地址空间为 0～255，每一个地址中可以存储 8 比特（1 字节）的指令或数据</li></ul></li><li><p>连接着的 I&#x2F;O 的种类，就是指连接着微型计算机和周边设备的 I&#x2F;O 的种类</p><ul><li>在微型计算机中，只安装了一个 I&#x2F;O，即上面带有 4 个 8 比特寄存器的 Z80 PIO。只要用 CPU 控制 I&#x2F;O 的寄存器，就可以设定 I&#x2F;O 的功能，与周边设备进行数据的输入输出</li></ul></li><li><p>所谓 I&#x2F;O 的地址空间，是指用于指定 I&#x2F;O 寄存器的地址范围</p><ul><li><p>在内存中，每个地址的功能都一样，既可用于存储指令又可用于存储数据。而 I&#x2F;O 则不同，地址编号不同（即寄存器的类型不同），功能也就不同</p></li><li><p>在 Z80 PIO 上，地址空间为 0～3，每一个地址对应一个寄存器</p></li><li><p>在微型计算机中，是这样分配 Z80 PIO 上的寄存器的</p><ul><li><p>端口 A 数据寄存器对应 0 号地址</p></li><li><p>端口 B 数据寄存器对应 1 号地址</p></li><li><p>端口 A 控制寄存器对应 2 号地址</p></li><li><p>端口 B 控制寄存器对应 3 号地址</p></li></ul></li><li><p>端口 A 数据寄存器和端口 B 数据寄存器存储的是与周边设备进行输入输出时所需的数据。其中，端口 A 连接用于输入数据的指拨开关，端口 B 连接用于输出数据的 LED。而端口 A 控制寄存器和端口 B 控制寄存器则存储的是用于设定 Z80 PIO 功能的参数</p></li></ul></li></ul><h3 id="3-2-机器语言和汇编语言"><a href="#3-2-机器语言和汇编语言" class="headerlink" title="3.2 机器语言和汇编语言"></a>3.2 机器语言和汇编语言</h3><ul><li><p>在机器语言程序中，每个 0 和 1 组合都是有特定含义的指令或数据。对人来说，机器语言难以阅读。可以将表示指令功能的英语单词起一个相似的昵称，并将这个昵称赋予给 0 和 1 的组合。这种类似英语单词的昵称叫作“助记符”，使用助记符的编程语言叫作“汇编语言”</p></li><li><p>无论是使用机器语言还是汇编语言，所实现的功能都是一样的，区别只在于程序是用数字表示，还是用助记符表示</p></li><li><p>汇编语言的语法十分简单，以至于语法只有一个，即把“标签”“操作码（指令）”和“操作数（指令的对象）”并排写在一行上，仅此而已</p></li><li><p>标签的作用是为该行代码对应的内存地址起一个名字</p><ul><li><p>编程时如果总要考虑“这一行的内存地址是什么来着？”就会很不方便，所以在汇编语言中用标签来代替地址</p></li><li><p>用汇编语言编程时可以在任何需要标签的地方“贴上”名称任意的标签</p></li></ul></li><li><p>操作码就是表示“做什么”的指令</p><ul><li><p>因为用助记符表示的指令是英语单词的缩写，比如 LD 是 Load（加载）的缩写，所以多多少少能猜出其中的含义</p></li><li><p>汇编语言中提供了多少种助记符，CPU 就有多少种功能</p></li><li><p>Z80 CPU 的指令全部加起来有 70 条左右。按功能这些指令可以分成运算、与内存的输入输出和与 I&#x2F;O 的输入输出三类。这是因为计算机能做的事也只有输入、运算、输出这三种了</p><p><img src="/image/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%98%AF%E6%80%8E%E6%A0%B7%E8%B7%91%E8%B5%B7%E6%9D%A5%E7%9A%84/b5a8b275c4dd06d59082cbf2bbcd02971886db5c.jpeg" alt="epub_907760_84.jpeg"></p></li></ul></li><li><p>操作数表示的是指令执行的对象</p><ul><li><p>CPU 的寄存器、内存地址、I&#x2F;O 地址或者直接给出的数字都可以作为操作数</p></li><li><p>如果某条指令需要多个操作数，那么它们之间就要用逗号分割</p></li><li><p>操作数的个数取决于指令的种类</p></li><li><p>也有不需要操作数的指令，比如用于停止 CPU 运转的 HALT 指令</p></li></ul></li><li><p>构成机器语言的是二进制数，而在汇编语言中，则使用十进制数和十六进制数记录数据</p><ul><li>若仅仅写出 123 这样的数字，表示的就是十进制数；而像 123H 这样在数字末尾加上了一个 H（H 表示 Hexadecimal，即十六进制数），表示的就是十六进制数</li></ul></li><li><p>在第 2 章中介绍过，Z80 CPU 的~MREQ 引脚和~IORQ 引脚实现了一种能区分输入输出对象的机制，可以区分出使用着相同内存地址的内存和 I&#x2F;O。在汇编语言中，读写内存的指令不同于读写 I&#x2F;O 的指令</p><ul><li><p>一旦执行了读写内存的指令，比如 LD 指令，~MREQ 引脚上的值就会变为 0，于是内存被选为输入输出的对象</p></li><li><p>而一旦执行了读写 I&#x2F;O 的指令，比如 IN 或 OUT 指令，~IORQ 引脚上的值就会变为 0，于是 I&#x2F;O（这里用的是 Z80 PIO）被选为输入输出的对象</p></li></ul></li></ul><h3 id="3-3-Z80-CPU-的寄存器结构"><a href="#3-3-Z80-CPU-的寄存器结构" class="headerlink" title="3.3 Z80 CPU 的寄存器结构"></a>3.3 Z80 CPU 的寄存器结构</h3><ul><li><p>既然数据的运算是在 CPU 中进行的，那么在 CPU 内部就应该有存储数据的地方。这种存储数据的地方叫作“寄存器”。虽然也叫寄存器，但是与 I&#x2F;O 的寄存器不同，CPU 的寄存器不仅能存储数据，还具备对数据进行运算的能力</p></li><li><p>CPU 带有什么样的寄存器取决于 CPU 的种类</p></li><li><p>Z80 CPU 的寄存器种类</p><p><img src="/image/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%98%AF%E6%80%8E%E6%A0%B7%E8%B7%91%E8%B5%B7%E6%9D%A5%E7%9A%84/4448b8d2c27e1779248523ae6574f63b4dc0ba4a.jpeg" alt="epub_907760_86.jpeg"></p><ul><li><p>A、B、C、D 等字母是寄存器的名字。在汇编语言当中，可以将寄存器的名字指定为操作数</p></li><li><p>IX、IY、SP、PC 这 4 个寄存器的大小是 16 比特，其余寄存器的大小都是 8 比特。寄存器的用途取决于它的类型。有的指令只能将特定的寄存器指定为操作数</p></li></ul></li><li><p>Z80 CPU 的寄存器用途</p><ul><li><p>A 寄存器也叫作“累加器”，是运算的核心。所以连接到它上面的导线也一定会比其他寄存器的多</p></li><li><p>F 寄存器也叫作“标志寄存器”，用于存储运算结果的状态，比如是否发生了进位，数字大小的比较结果等</p></li><li><p>PC 寄存器也叫作“程序指针”，存储着指向 CPU 接下来要执行的指令的地址</p></li><li><p>PC 寄存器的值会随着滴答滴答的时钟信号自动更新，可以说程序就是依靠不断变化的 PC 寄存器的值运行起来的</p></li><li><p>SP 寄存器也叫作“栈顶指针”，用于在内存中创建出一块称为“栈”的临时数据存储区域</p></li></ul></li><li><p>Z80 PIO 带有两个端口（端口 A 和端口 B），用于与周边设备输入输出数据。首先必须为每个端口设定输入输出模式。这里端口 A 用于接收由指拨开关输入的数据，为了实现这个功能，需要如下的代码</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs nasm">LD  A,      207<br>OUT (2),    A<br>LD  A,      255<br>OUT (2),    A<br></code></pre></td></tr></table></figure><ul><li><p>这里的 207 和 255 是连续向 Z80 PIO 的端口 A 控制寄存器（对应该 I&#x2F;O 的地址编号为 2）写入的两个数据</p></li><li><p>虽然使用 OUT 指令可以向 I&#x2F;O 写入数据，但是不能直接把 207、255 这样的数字作为 OUT 指令的操作数。操作数必须是已存储在 CPU 寄存器中的数字，这是汇编语言的规定</p></li><li><p>于是，先通过指令“LD A, 207”把数字 207 读入到寄存器 A 中，再通过指令“OUT (2), A”把寄存器 A 中的数据写入到 I&#x2F;O 地址所对应的寄存器中。像“(2)”这样用括号括起来的数字，表示的是地址编号。端口 A 控制寄存器的 I&#x2F;O 地址是 2 号</p></li><li><p>一旦把 207 写入到端口 A 控制寄存器，Z80 PIO 就明白了：“哦，想要设定端口 A 的输入输出模式啊。”而通过接下来写入的 255, Z80 PIO 就又知道：“哦，要把端口 A 设定为输入模式啊。”</p></li></ul></li><li><p>同样地，通过下面的程序可以将端口 B 设定为输出模式</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs nasm">LD  A,      207<br>OUT (3),    A<br>LD  A,      0<br>OUT (3),    A<br></code></pre></td></tr></table></figure><ul><li><p>先把 207 写入到端口 B 控制寄存器（对应的 I&#x2F;O 地址为 3 号），然后写入 0。这个 0 表示要把端口 B 设定为输出模式</p></li><li><p>应该使用什么样的数字设定端口，在 Z80 PIO 的资料上都有说明。用 207、255、0 这样的数字来表示功能设定参数，这也是为了适应计算机的处理方式</p></li></ul></li><li><p>完成了 Z80 PIO 的设定后，就进入了一段死循环处理，用于把由指拨开关输入的数据输出到 LED。为了实现这个功能，需要如下的代码</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs nasm">LOOP:   IN  A,      (0)<br>        OUT (1),    A<br>        JP  LOOP<br></code></pre></td></tr></table></figure><ul><li><p>“IN A, (0)”的作用是把数据由端口 A 数据寄存器（连接在指拨开关上，对应的 I&#x2F;O 地址为 0 号）输入到 CPU 的寄存器 A</p></li><li><p>“OUT (1), A”的作用是把寄存器 A 的值输出到端口 B 数据寄存器上（连接在 LED 上，对应的 I&#x2F;O 地址为 1 号）</p></li><li><p>“JP LOOP”的作用是使程序的流程跳转到 LOOP（笔者随意起的一个标签名）标签所标识的指令上</p></li><li><p>JP 是 Jump 的缩写。“IN A, (0)”所在行的开头有一个标签“LOOP:”，代表着这一行的内存地址</p></li><li><p>当把标签作为 JP 指令的操作数时，标签名的结尾不需要冒号“:”，但是在设定标签时，标签名的结尾则需要加上一个冒号</p></li></ul></li></ul><h3 id="3-4-追踪程序的运行过程"><a href="#3-4-追踪程序的运行过程" class="headerlink" title="3.4 追踪程序的运行过程"></a>3.4 追踪程序的运行过程</h3><ul><li><p>机器语言及其对应的汇编代码</p><figure class="highlight dns"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs dns">地址             机器代码<br><span class="hljs-number">00000000</span>        <span class="hljs-number">00111110</span>  <span class="hljs-number">11001111</span>                      LD  <span class="hljs-keyword">A</span>,      <span class="hljs-number">207</span><br><span class="hljs-number">00000010</span>        <span class="hljs-number">11010011</span>  <span class="hljs-number">00000010</span>                      OUT (<span class="hljs-number">2</span>),    <span class="hljs-keyword">A</span><br><span class="hljs-number">00000100</span>        <span class="hljs-number">00111110</span>  <span class="hljs-number">11111111</span>                      LD  <span class="hljs-keyword">A</span>,      <span class="hljs-number">255</span><br><span class="hljs-number">00000110</span>        <span class="hljs-number">11010011</span>  <span class="hljs-number">00000010</span>                      OUT (<span class="hljs-number">2</span>),    <span class="hljs-keyword">A</span><br><span class="hljs-number">00001000</span>        <span class="hljs-number">00111110</span>  <span class="hljs-number">11001111</span>                      LD  <span class="hljs-keyword">A</span>,      <span class="hljs-number">207</span><br><span class="hljs-number">00001010</span>        <span class="hljs-number">11010011</span>  <span class="hljs-number">00000011</span>                      OUT (<span class="hljs-number">3</span>),    <span class="hljs-keyword">A</span><br><span class="hljs-number">00001100</span>        <span class="hljs-number">00111110</span>  <span class="hljs-number">00000000</span>                      LD  <span class="hljs-keyword">A</span>,      <span class="hljs-number">0</span><br><span class="hljs-number">00001110</span>        <span class="hljs-number">11010011</span>  <span class="hljs-number">00000011</span>                      OUT (<span class="hljs-number">3</span>),    <span class="hljs-keyword">A</span><br><span class="hljs-number">00010000</span>        <span class="hljs-number">11011011</span>  <span class="hljs-number">00000000</span>              LOOP:   <span class="hljs-keyword">IN</span>  <span class="hljs-keyword">A</span>,      (<span class="hljs-number">0</span>)<br><span class="hljs-number">00010010</span>        <span class="hljs-number">11010011</span>  <span class="hljs-number">00000001</span>                      OUT (<span class="hljs-number">1</span>),    <span class="hljs-keyword">A</span><br><span class="hljs-number">00010100</span>        <span class="hljs-number">11000011</span>  <span class="hljs-number">00010000</span>  <span class="hljs-number">00000000</span>            JP  LOOP<br></code></pre></td></tr></table></figure></li><li><p>用汇编语言编写的程序是不能直接运行的，必须先转换成机器语言。机器语言是唯一一种 CPU 能直接理解的编程语言</p></li><li><p>1 条汇编语言的指令所对应的机器语言由多个字节构成</p><ul><li><p>而且，同样是汇编语言中的 1 条指令，有的指令对应着 1 个字节的机器语言，有的指令则对应着多个字节的机器语言</p></li><li><p>转换而成的机器语言有多少个字节取决于汇编语言指令的种类以及操作数的个数</p></li></ul></li><li><p>程序运行过程</p><ul><li><p>一旦重置了 Z80 CPU,00000000 就会被自动存储到 PC 寄存器中，这意味着接下来 CPU 将要从 00000000 号地址读出程序</p></li><li><p>首先 CPU 会从 00000000 号地址读出指令 00111110，判断出这是一条由 2 个字节构成的指令，于是接下来会从下一个地址（即 00000001,1 号地址，代码清单中并没有标记出该地址本身）读出数据 11001111，把这两个数据汇集到一起解释、执行。执行的指令是把数值 207 写入到寄存器 A，用汇编语言表示的话就是“LD A, 207”</p></li><li><p>由于刚刚从内存读出了一条 2 字节的指令（占用 2 个内存地址），所以 PC 寄存器的值要增加 2，并接着从 00000010 号地址读出指令，解释并执行</p></li><li><p>接下来的流程与此类似，通过反复进行“读取指令”“解释、执行指令”“更新 PC 寄存器的值”这 3 个操作，程序就能运行起来了</p></li><li><p>一旦执行完最后一行的 JP LOOP 所对应的机器语言，PC 寄存器的值就会被设为标签 LOOP 对应的地址 00010000，这样就可以循环执行同样的操作</p></li></ul></li></ul><h3 id="3-5-尝试手工汇编"><a href="#3-5-尝试手工汇编" class="headerlink" title="3.5 尝试手工汇编"></a>3.5 尝试手工汇编</h3><ul><li><p>在 CPU 的资料中，明确写有所有可以使用的助记符，以及助记符转换成机器语言后的数值。只要查看这些资料，就可以把用汇编语言编写的程序手工转换成机器语言的程序，这样的工作称为“手工汇编”在 CPU 的资料中，明确写有所有可以使用的助记符，以及助记符转换成机器语言后的数值。只要查看这些资料，就可以把用汇编语言编写的程序手工转换成机器语言的程序，这样的工作称为“手工汇编”。进行手工汇编时，要一行一行地把用汇编语言编写的程序转换成机器语言</p></li><li><p>下表列出了汇编语言中必要指令的助记符、助记符所对应的机器语言，以及执行这些机器语言所需的时钟周期数</p><p><img src="/image/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%98%AF%E6%80%8E%E6%A0%B7%E8%B7%91%E8%B5%B7%E6%9D%A5%E7%9A%84/2228551ecc2e53c4eb5f3b5ba8a0266d32467135.jpeg" alt="epub_907760_87.jpeg"></p></li><li><p>手工汇编过程</p><ul><li><p>下面就从汇编语言的第 1 行开始转换。第一行的“LD A, 207”匹配“LD A, num”这个模式，所以可以先转换成“00111110 num”。然后将十进制数的 207 转换成 8 比特的二进制数，用这个二进制数替换 num</p></li><li><p>第 2 条指令“OUT (2), A”匹配“OUT (num), A”这个模式，所以可以先转换成“11010011 num”。然后把 num 的部分替换成 00000010，即用 8 比特的二进制数表示的十进制数 2，最终就得到了机器语言“11010011 00000010”</p><ul><li>因为内存中已经存储了 2 字节的机器语言，所以这条机器语言要从 00000010 号地址（用十进制表示的话就是 2 号地址）开始记录</li></ul></li><li><p>这之后由于 LD 指令和 OUT 指令又以相同的模式出现了 3 次，所以可以用相同的步骤转换成机器语言</p><ul><li>请诸位注意，机器语言中每条语句的字节数是多少，内存地址就相应地增加多少</li></ul></li><li><p>接下来是“IN A, (0)”匹配“IN A, (num)”这个模式，所以可以先转换成“11011011 num”。然后把 num 替换成 00000000，即用 8 比特的二进制数表示的十进制数 0，最终就得到了机器语言“11011011 00000000”。对于接下来的“OUT (1), A”，也可以按照同样的方法转换</p></li><li><p>最后一句的 JP LOOP 匹配模式“JP num”，所以可以先转换成“11000011 num”</p><ul><li><p>请注意这里要用 16 比特的二进制数替代作为内存地址的 num</p></li><li><p>在微型计算机中是以 8 比特为单位指定内存地址的，但在 Z80 CPU 中用于设定内存地址的引脚却有 16 个，所以在机器语言中也要用 16 比特的二进制数设定内存地址</p></li><li><p>JP 指令跳转的目的地为 00010000，即“LOOP:”标签所标示的语句“LD A, 0”对应的内存地址。把这个地址扩充为 16 比特就是“00000000 00010000”。要扩充到 16 位，只需要把高 8 位全部设为 0 就可以了</p></li></ul></li></ul></li><li><p>还有一点希望诸位注意，在将一个 2 字节的数据存储到内存时，存储顺序是低 8 位在前、高 8 位在后（也就是逆序存储）</p><ul><li><p>这样的存储顺序叫作“小端序”（Little Endian），与此相反，将数据由高位到低位顺序地存储到内存的存储顺序则叫作“大端序”（Big Endian）</p></li><li><p>根据 CPU 种类的不同，有的 CPU 使用大端序，有的 CPU 使用小端序</p></li><li><p>Z80 CPU 使用的是小端序，因此 JP LOOP 对应的机器语言为“11000011 00010000 00000000”</p></li></ul></li></ul>]]></content>
    
    
    <categories>
      
      <category>笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>基础体系</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【笔记】程序是怎样跑起来的（下）</title>
    <link href="/posts/1893eea5.html"/>
    <url>/posts/1893eea5.html</url>
    
    <content type="html"><![CDATA[<h2 id="第八章-从源文件到可执行文件"><a href="#第八章-从源文件到可执行文件" class="headerlink" title="第八章 从源文件到可执行文件"></a>第八章 从源文件到可执行文件</h2><ul><li><p><a href="https://blog.csdn.net/bupt073114/article/details/37049829">GCC 编译的四个阶段</a></p><ul><li><p>预处理</p></li><li><p>编译</p></li><li><p>汇编</p></li><li><p>链接</p></li></ul></li></ul><h3 id="8-1-计算机只能运行本地代码"><a href="#8-1-计算机只能运行本地代码" class="headerlink" title="8.1 计算机只能运行本地代码"></a>8.1 计算机只能运行本地代码</h3><ul><li><p>CPU 能直接解析并运行的不是源代码而是本地代码的程序。作为计算机大脑的 Pentium 等 CPU，也只能解释已经转换成本地代码的程序内容</p></li><li><p>本地（native）这个术语有“母语的”意思。对 CPU 来说，母语就是机器语言，而转换成机器语言的程序就是本地代码。用任何编程语言编写的源代码，最后都要翻译成本地代码，否则 CPU 就不能理解。也就是说，即使是用不同编程语言编写的代码，转换成本地代码后，也都变成用同一种语言（机器语言）来表示了</p></li><li><p>转换成本地代码后就变成了同样的语言</p><p><img src="/image/%E7%A8%8B%E5%BA%8F%E6%98%AF%E6%80%8E%E6%A0%B7%E8%B7%91%E8%B5%B7%E6%9D%A5%E7%9A%84/a2eeb5948c1f731383f2c9305b63d84121800816.jpeg" alt="epub907761171jpeg"></p></li></ul><h3 id="8-2-本地代码的内容"><a href="#8-2-本地代码的内容" class="headerlink" title="8.2 本地代码的内容"></a>8.2 本地代码的内容</h3><ul><li><p>Dump 是指把文件的内容，每个字节用 2 位十六进制数来表示的方式</p></li><li><p>本地代码的内容就是各种数值的罗列，这些数值就是本地代码的真面目。每个数值都表示某一个命令或数据</p></li></ul><h3 id="8-3-编译器负责转换源代码"><a href="#8-3-编译器负责转换源代码" class="headerlink" title="8.3 编译器负责转换源代码"></a>8.3 编译器负责转换源代码</h3><ul><li><p>能够把 C 语言等高级编程语言编写的源代码转换成本地代码的程序称为编译器。每个编写源代码的编程语言都需要其专用的编译器。将 C 语言编写的源代码转换成本地代码的编译器称为 C 编译器</p></li><li><p>编译器首先读入代码的内容，然后再把源代码转换成本地代码。编译器中就好像有一个源代码同本地代码的对应表。但实际上，仅仅靠对应表是无法生成本地代码的。读入的源代码还要经过语法解析、句法解析、语义解析等，才能生成本地代码</p></li><li><p>根据 CPU 类型的不同，本地代码的类型也不同。因而，编译器不仅和编程语言的种类有关，和 CPU 的类型也是相关的。例如，Pentium 等 x86 系列 CPU 用的 C 编译器，同 PowerPC 这种 CPU 用的 C 编译器就不同。从另一个方面来看，这其实是非常方便的。因为这样一来，同样的源代码就可以翻译成适用于不同 CPU 的本地代码了</p></li><li><p>因为编译器本身也是程序的一种，所以也需要运行环境。例如，有 Windows 用的 C 编译器、Linux 用的 C 编译器等。此外，还有一种交叉编译器，它生成的是和运行环境中的 CPU 不同的 CPU 所使用的本地代码</p></li></ul><h3 id="8-4-仅靠编译是无法得到可执行文件的"><a href="#8-4-仅靠编译是无法得到可执行文件的" class="headerlink" title="8.4 仅靠编译是无法得到可执行文件的"></a>8.4 仅靠编译是无法得到可执行文件的</h3><ul><li><p>编译器转换源代码后，就会生成本地文件。不过，本地文件是无法直接运行的。为了得到可以运行的 EXE 文件，编译之后还需要进行“链接”处理</p></li><li><p>gcc 通过选项<code>-c</code>即可将源代码编译汇编成目标文件，扩展名为.o</p><ul><li><p>目标文件（object file）中的 object 一词，指的是编译器生成结果的意思。和面向对象编程（object oriented programming）的 object 没有任何关系。面向对象编程的对象指的是数据和处理的集合体。</p></li><li><p>目标文件的内容也是本地代码，但是无法直接运行，原因是当前程序还处于未完成状态</p></li></ul></li><li><p>把多个目标文件结合，生成 1 个 EXE 文件的处理就是链接，运行连接的程序就称为链接器（linkageeditor 或连结器）</p></li></ul><h3 id="8-5-启动及库文件"><a href="#8-5-启动及库文件" class="headerlink" title="8.5 启动及库文件"></a>8.5 启动及库文件</h3><ul><li><p>利用编译器链接的时候，有一个较为特殊的目标文件，称为启动代码目标文件，该目标文件由启动代码编译而来，一般由编译器提供</p><ul><li><p>Borland C++ 的启动为 c0w32.obj</p></li><li><p>gcc 通过”-v”选项可以查看到调用了很多.o 文件，其中有部分就是启动代码目标文件</p></li></ul></li><li><p>c0w32.obj 是由 Borland C++ 提供的。如果 C：盘中安装有 Borland C++ 的话，文件夹 C:\Borland\bcc55\lib 中就会有 c0w32.obj 这个文件。c0w32.obj 这个目标文件记述的是同所有程序起始位置相结合的处理内容，称为程序的启动。因而，即使程序不调用其他目标文件的函数，也必须要进行链接，并和启动结合起来</p></li><li><p>库文件指的是把多个目标文件集成保存到一个文件中的形式。链接器指定库文件后，就会从中把需要的目标文件抽取出来，并同其他目标文件结合生成 EXE 文件</p><ul><li><p>windows 静态库文件就是.lib 文件，动态库文件就是.dll 文件。内容一样，都是将函数封装在一起编译后供自己或他人调用。好处在于编译后的库文件看不到源代码，可保密；同时不会因为不小心修改了函数而出问题，便于维护</p></li><li><p>unix 系统的静态库文件和动态库文件后缀分别是.a 和.so</p></li></ul></li><li><p>外部符号是指其他目标文件中的变量或函数，错误消息“无法解析的外部符号”表示的是无法找到记述着目的变量及函数的目标文件，因而无法进行链接的意思</p></li><li><p>sprintf() 等函数，不是通过源代码形式而是通过库文件形式和编译器一起提供的。这样的函数称为标准函数</p><ul><li>之所以使用库文件，是为了简化为链接器的参数指定多个目标文件这一过程。例如，在链接调用了数百个标准函数的程序时，就要在链接器的命令行中指定数百个目标文件，这样就太繁琐了。而利用存储着多个目标文件的库文件的话，则只需在链接器的命令行中指定几个库文件就可以了</li></ul></li><li><p>通过以目标文件的形式或集合多个目标文件的库文件形式来提供函数，就可以不用公开标准函数的源代码内容。由于标准函数的源代码是编译器厂商的贵重财产，因此若被其他公司任意转用的话，可能会造成一些损失</p></li></ul><h3 id="8-6-DLL-文件及导入库"><a href="#8-6-DLL-文件及导入库" class="headerlink" title="8.6 DLL 文件及导入库"></a>8.6 DLL 文件及导入库</h3><ul><li><p>Windows 以函数的形式为应用提供了各种功能。这些形式的函数称为 API（ApplicationProgramming Interface，应用程序接口）</p></li><li><p>Windows 中，API 的目标文件，并不是存储在通常的库文件中，而是存储在名为 DLL（Dynamic LinkLibrary）文件的特殊库文件中。就如 Dynamic 这一名称所表示的那样，DLL 文件是程序运行时动态结合的文件</p></li><li><p>在前面的介绍中，我们提到 MessageBox() 的目标文件是存储在 import32.lib 中的。实际上，import32.lib 中仅仅存储着两个信息，一是 MessageBox() 在 user32.dll 这个 DLL 文件中，另一个是存储着 DLL 文件的文件夹信息，MessageBox() 的目标文件的实体实际上并不存在。我们把类似于 import32.lib 这样的库文件称为导入库</p></li><li><p>与此相反，存储着目标文件的实体，并直接和 EXE 文件结合的库文件形式称为静态链接库。静态（static&#x3D;静态的）同动态（dynamic&#x3D;动态的）是相反的意思。存储着 sprintf() 的目标文件的 cw32lib 就是静态链接库。sprintf() 提供了通过指定格式把数值转换成字符串的功能</p></li><li><p>通过结合导入库文件，执行时从 DLL 文件中调出的 MessageBox() 函数这一信息就会和 EXE 文件进行结合。这样，链接器链接时就不会再出现错误消息，从而就可以顺利编写 EXE 文件</p></li><li><p>Windows 中的编译和链接机制</p><p><img src="/image/%E7%A8%8B%E5%BA%8F%E6%98%AF%E6%80%8E%E6%A0%B7%E8%B7%91%E8%B5%B7%E6%9D%A5%E7%9A%84/17a23eee634bd8e25ace04b43c9f3b29399b392f.jpeg" alt="epub907761183jpeg"></p></li></ul><h3 id="8-7-可执行文件运行时的必要条件"><a href="#8-7-可执行文件运行时的必要条件" class="headerlink" title="8.7 可执行文件运行时的必要条件"></a>8.7 可执行文件运行时的必要条件</h3><ul><li><p>本地代码在对程序中记述的变量进行读写时，是参照数据存储的内存地址来运行命令的。在调用函数时，程序的处理流程就会跳转到存储着函数处理内容的内存地址上。EXE 文件作为本地代码的程序，并没有指定变量及函数的实际内存地址。在类似于 Windows 操作系统这样的可以加载多个可执行程序的运行环境中，每次运行时，程序内的变量及函数被分配到的内存地址都是不同的</p></li><li><p>在 EXE 文件中，变量和函数的内存地址的值，是如何来表示的呢？EXE 文件中给变量及函数分配了虚拟的内存地址。在程序运行时，虚拟的内存地址会转换成实际的内存地址。链接器会在 EXE 文件的开头，追加转换内存地址所需的必要信息。这个信息称为再配置信息</p></li><li><p>EXE 文件的再配置信息，就成为了变量和函数的相对地址。相对地址表示的是相对于基点地址的偏移量，也就是相对距离</p></li><li><p>在源代码中，虽然变量及函数是在不同位置分散记述的，但在链接后的 EXE 文件中，变量及函数就会变成一个连续排列的组。这样一来，各变量的内存地址就可以用相对于变量组起始位置这一基点的偏移量来表示，同样，各函数的内存地址也可以用相对于函数组起始位置这一基点的偏移量来表示。而各组基点的内存地址则是在程序运行时被分配的</p></li><li><p>链接后的 EXE 文件的构造</p><p><img src="/image/%E7%A8%8B%E5%BA%8F%E6%98%AF%E6%80%8E%E6%A0%B7%E8%B7%91%E8%B5%B7%E6%9D%A5%E7%9A%84/04a7d9dbe16f6f8c36f8790c3f5c3d978fb2aa07.jpeg" alt="epub907761184jpeg"></p></li></ul><h3 id="8-8-程序加载时会生成栈和堆"><a href="#8-8-程序加载时会生成栈和堆" class="headerlink" title="8.8 程序加载时会生成栈和堆"></a>8.8 程序加载时会生成栈和堆</h3><ul><li><p>EXE 文件的内容分为再配置信息、变量组和函数组，除此之外还会额外生成两个组，那就是栈和堆</p><ul><li><p>栈是用来存储函数内部临时使用的变量（局部变量），以及函数调用时所用的参数的内存区域</p></li><li><p>堆是用来存储程序运行时的任意数据及对象的内存领域</p></li></ul></li><li><p>加载到内存的程序由 4 部分构成（不管是什么程序，程序的内容都是由处理和数据构成的。大多数编程语言都是用函数来表示处理、用变量来表示数据。）</p><p><img src="/image/%E7%A8%8B%E5%BA%8F%E6%98%AF%E6%80%8E%E6%A0%B7%E8%B7%91%E8%B5%B7%E6%9D%A5%E7%9A%84/fb98e6d8f7009c82fccec5eabdb7f6e22b6fad9a.jpeg" alt="epub907761186jpeg"></p></li><li><p>EXE 文件中并不存在栈及堆的组。栈和堆需要的内存空间是在 EXE 文件加载到内存后开始运行时得到分配的。因而，内存中的程序，就是由用于变量的内存空间、用于函数的内存空间、用于栈的内存空间、用于堆的内存空间这 4 部分构成的。当然，在内存中，加载 Windows 等操作系统的内存空间又是另外一回事了</p></li><li><p>栈及堆的相似之处在于，他们的内存空间都是在程序运行时得到申请分配的。不过，在内存的使用方法上，二者存在些许不同</p><ul><li><p>栈中对数据进行存储和舍弃（清理处理）的代码，是由编译器自动生成的，因此不需要程序员的参与。使用栈的数据的内存空间，每当函数被调用时都会得到申请分配，并在函数处理完毕后自动释放</p></li><li><p>堆的内存空间，则要根据程序员编写的程序，来明确进行申请分配或释放</p></li></ul></li><li><p>根据编程语言的不同，对堆用的内存空间进行申请分配和释放的程序的编写方法也是多种多样的。C 语言中是通过 malloc() 函数来进行申请分配、通过 free() 函数来释放的。而 C++ 中则是通过 new 运算符来申请分配、通过 delete 运算符来释放的</p></li><li><p>无论是 C 语言还是 C++，如果没有在程序中明确释放堆的内存空间，那么即使在处理完毕后，该内存空间仍会一直残留。这个现象称为内存泄露（memoryleak），它是令 C 语言及 C++ 的程序员们十分头疼的一个 bug（程序的错误）。如果内存泄露一直存在的话，就有可能会造成内存不足而导致宕机</p></li></ul><h2 id="第九章-操作系统和应用的关系"><a href="#第九章-操作系统和应用的关系" class="headerlink" title="第九章 操作系统和应用的关系"></a>第九章 操作系统和应用的关系</h2><h3 id="9-1-操作系统功能的历史"><a href="#9-1-操作系统功能的历史" class="headerlink" title="9.1 操作系统功能的历史"></a>9.1 操作系统功能的历史</h3><ul><li><p>操作系统（Operating System）也称为基础软件。操作系统是计算机运行时不可或缺的控制程序，以及在控制程序下运转的为其他软件运行提供操作环境的软件的统称。另外，在操作系统上运行的应用也称为“应用程序”。</p></li><li><p>操作系统的发展</p><ul><li><p>在计算机中尚不存在操作系统的年代，完全没有任何程序，因此程序员就需要编写出处理相关的所有程序</p></li><li><p>用机器语言编写程序，然后再使用开关将程序输入，这一过程非常麻烦。于是，有人开发出了仅具有加载和运行功能的监控程序，这就是操作系统的原型。通过事先启动监控程序，程序员就可以根据需要将各种程序加载到内存中运行。虽然依旧比较麻烦，但比起在没有任何程序的状态下进行开发，工作量得到了很大的缓解</p></li><li><p>随着时代的发展，人们在利用监控程序编写程序的过程中，发现很多程序都有共通的部分。例如，通过键盘输入文字数据、往显示器输出文字数据等。这些处理，在任何程序下都是一样的。而如果每编写一个新的程序都要记述相同的处理的话，那真的是太浪费时间了。因此，基本的输入输出部分的程序就被追加到了监控程序中。初期的操作系统就这样诞生了</p></li><li><p>之后，随着时代的进一步发展，开始有更多的功能被追加到监控程序中，比如，为了方便程序员的硬件控制程序、编程语言处理器（汇编、编译、解析）以及各种实用程序等，结果就形成了和现在相差不大的操作系统。因此，操作系统本身并不是单独的程序，而是多个程序的集合体</p></li></ul></li></ul><h3 id="9-2-要意识到操作系统的存在"><a href="#9-2-要意识到操作系统的存在" class="headerlink" title="9.2 要意识到操作系统的存在"></a>9.2 要意识到操作系统的存在</h3><ul><li><p>在操作系统这个运行环境下，应用并不是直接控制硬件，而是通过操作系统来间接控制硬件的。变量定义中涉及的内存的申请分配，以及 time() 和 printf() 这些函数的运行结果，都不是面向硬件而是面向操作系统的。操作系统收到应用发出的指令后，首先会对该指令进行解释，然后会对时钟 IC（实时时钟）和显示器用的 I&#x2F;O 进行控制</p></li><li><p>应用程序经过 OS 间接地控制硬件</p><p><img src="/image/%E7%A8%8B%E5%BA%8F%E6%98%AF%E6%80%8E%E6%A0%B7%E8%B7%91%E8%B5%B7%E6%9D%A5%E7%9A%84/a54934f8d42b223dd0b986033e4caea46ac25a30.jpeg" alt="epub907761196jpeg"></p></li></ul><h3 id="9-3-系统调用和高级编程语言的移植性"><a href="#9-3-系统调用和高级编程语言的移植性" class="headerlink" title="9.3 系统调用和高级编程语言的移植性"></a>9.3 系统调用和高级编程语言的移植性</h3><ul><li><p>操作系统的硬件控制功能，通常是通过一些小的函数集合体的形式来提供的。这些函数及调用函数的行为统称为系统调用（system call），也就是应用对操作系统（system）的功能进行调用（call）的意思</p></li><li><p>在前面的程序中用到了 time() 及 printf() 等函数，这些函数内部也都使用了系统调用。这里之所以用“内部”这个词，是因为在 Windows 操作系统中，提供返回当前日期和时刻，以及在显示器中显示字符串等功能的系统调用的函数名，并不是 time() 和 printf()。系统调用是在 time() 和 printf() 函数的内部执行的</p></li><li><p>C 语言等高级编程语言并不依存于特定的操作系统。这是因为人们希望不管是 Windows 还是 Linux，都能使用几乎相同的源代码。因此，高级编程语言的机制就是，使用独自的函数名，然后再在编译时将其转换成相应操作系统的系统调用（也有可能是多个系统调用的组合）。也就是说，用高级编程语言编写的应用在编译后，就转换成了利用系统调用的本地代码</p></li><li><p>在高级编程语言中，也存在可以直接调用系统调用的编程语言。不过，利用这种方式做成的应用，移植性并不友好（也俗称为有恶意行为的应用）。例如，直接调用 Windows 系统调用的应用，在 Linux 上显然是无法运行的</p></li></ul><h3 id="9-4-操作系统和高级编程语言使硬件抽象化"><a href="#9-4-操作系统和高级编程语言使硬件抽象化" class="headerlink" title="9.4 操作系统和高级编程语言使硬件抽象化"></a>9.4 操作系统和高级编程语言使硬件抽象化</h3><ul><li>通过使用操作系统提供的系统调用，程序员就没必要编写直接控制硬件的程序了。而且，通过使用高级编程语言，有时甚至也无需考虑系统调用的存在。这是因为操作系统和高级编程语言能够使硬件抽象化</li></ul><h3 id="9-5-Windows-操作系统的特征"><a href="#9-5-Windows-操作系统的特征" class="headerlink" title="9.5 Windows 操作系统的特征"></a>9.5 Windows 操作系统的特征</h3><ul><li><p>Windows 操作系统的主要特征如下所示</p><ul><li><p>32 位操作系统（也有 64 位版本）</p></li><li><p>通过 API 函数集来提供系统调用</p></li><li><p>提供采用了图形用户界面的用户界面</p></li><li><p>通过 WYSIWYG 实现打印输出</p></li><li><p>提供多任务功能</p></li><li><p>提供网络功能及数据库功能</p></li><li><p>通过即插即用实现设备驱动的自动设定</p></li></ul></li></ul><h2 id="第十章-通过汇编语言了解程序的实际构成"><a href="#第十章-通过汇编语言了解程序的实际构成" class="headerlink" title="第十章 通过汇编语言了解程序的实际构成"></a>第十章 通过汇编语言了解程序的实际构成</h2><ul><li><p>书中本章节使用的编译器 Borland C++，该编译器较为少见</p></li><li><p>比较建议该章节直接阅读原文</p></li></ul><h3 id="10-1-汇编语言和本地代码是一一对应的"><a href="#10-1-汇编语言和本地代码是一一对应的" class="headerlink" title="10.1 汇编语言和本地代码是一一对应的"></a>10.1 汇编语言和本地代码是一一对应的</h3><ul><li><p>通过调查本地代码的内容，可以了解程序最终是以何种形式来运行的。但是如果直接打开本地代码来看的话，只能看到数值的罗列。如果直接使用这些数值来编写程序的话，难以理解。因而可以在各本地代码中，附带上表示其功能的英语单词缩写。例如，在加法运算的本地代码中加上 add（addition 的缩写）、在比较运算的本地代码中加上 cmp（compare 的缩写）等。这些缩写称为助记符，使用助记符的编程语言称为汇编语言。这样，通过查看汇编语言编写的源代码，就可以了解程序的本质了。因为这和查看本地代码的源代码，是同一级别的</p></li><li><p>不过，即使是用汇编语言编写的源代码，最终也必须要转换成本地代码才能运行。负责转换工作的程序称为汇编器，转换这一处理本身称为汇编。在将源代码转换成本地代码这个功能方面，汇编器和编译器是同样的</p></li><li><p>用汇编语言编写的源代码，和本地代码是一一对应的。因而，本地代码也可以反过来转换成汇编语言的源代码。持有该功能的逆变换程序称为反汇编程序，逆变换这一处理本身称为反汇编</p></li><li><p>哪怕是用 C 语言编写的源代码，编译后也会转换成特定 CPU 用的本地代码。而将其反汇编的话，就可以得到汇编语言的源代码，并对其内容进行调查。不过，本地代码变换成 C 语言源代码的反编译，则要比反汇编困难。这是因为，C 语言的源代码同本地代码不是一一对应的，因此完全还原到原始的源代码是不太可能的</p></li><li><p>汇编语言的源代码和本地代码是一一对应的</p><p><img src="/image/%E7%A8%8B%E5%BA%8F%E6%98%AF%E6%80%8E%E6%A0%B7%E8%B7%91%E8%B5%B7%E6%9D%A5%E7%9A%84/f8eb5256d51645bbccb73f6ce346d01223e5619d.jpeg" alt="epub907761208jpeg"></p></li></ul><h3 id="10-2-通过编译器输出汇编语言的源代码"><a href="#10-2-通过编译器输出汇编语言的源代码" class="headerlink" title="10.2 通过编译器输出汇编语言的源代码"></a>10.2 通过编译器输出汇编语言的源代码</h3><ul><li><p>除了将本地代码进行反汇编这一方法外，通过其他方式也可以获取汇编语言的源代码。大部分 C 语言编译器，都可以把利用 C 语言编写的源代码转换成汇编语言的源代码，而不是本地代码。利用该功能，就可以对 C 语言的源代码和汇编语言的源代码进行比较研究</p></li><li><p>汇编语言源文件的扩展名，通常用“.asm”来表示。gcc 编译生成的汇编文件扩展名是“.s”</p></li><li><p>汇编语言的注释是每行从分号“;”开始的，分号之后的内容都属于注释</p></li></ul><h3 id="10-3-不会转换成本地代码的伪指令"><a href="#10-3-不会转换成本地代码的伪指令" class="headerlink" title="10.3 不会转换成本地代码的伪指令"></a>10.3 不会转换成本地代码的伪指令</h3><ul><li><p>汇编语言的源代码，是由转换成本地代码的指令（后面讲述的操作码）和针对汇编器的伪指令构成的</p></li><li><p>伪指令负责把程序的构造及汇编的方法指示给汇编器（转换程序）。不过伪指令本身是无法汇编转换成本地代码的</p></li><li><p>Borland C++ 编译得到的汇编文件中，由伪指令 segment 和 ends 围起来的部分，是给构成程序的命令和数据的集合体加上一个名字而得到的，称为段定义</p><ul><li><p>段定义（segment）是用来区分或者划定范围区域的意思</p></li><li><p>汇编语言的 segment 伪指令表示段定义的起始，ends 伪指令表示段定义的结束</p></li><li><p>段定义是一个连续的内存空间。</p></li></ul></li><li><p>段定义的英文表达 segment 具有“区域”的意思。在程序中，段定义指的是命令和数据等程序的集合体的意思。一个程序由多个段定义构成</p></li><li><p>C 语言源代码示例</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span> <span class="hljs-title function_">MyFunc</span><span class="hljs-params">()</span><br>&#123;<br>    <span class="hljs-type">int</span> c;<br>    c = AddNum(<span class="hljs-number">123</span>, <span class="hljs-number">456</span>);<br>&#125;<br><br><span class="hljs-type">int</span> <span class="hljs-title function_">AddNum</span><span class="hljs-params">(<span class="hljs-type">int</span> a, <span class="hljs-type">int</span> b)</span><br>&#123;<br>    <span class="hljs-keyword">return</span> a + b;<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>Borland C++ 汇编代码示例中</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><code class="hljs nasm">_TEXT  segment dword public use32 &#x27;CODE&#x27;<br>_TEXT  ends<br><br>_DATA  segment dword public use32 &#x27;DATA&#x27;<br>_DATA  ends<br><br>_BSS   segment dword public use32 &#x27;BSS&#x27;<br>_BSS   ends<br><br>DGROUP group    _BSS, _DATA<br><br>_TEXT  segment dword public use32 &#x27;CODE&#x27;<br>_AddNum         proc     near<br>    ;<br>    ;   int AddNum(int a, int b)<br>    ;<br>        push       ebp<br>        mov        ebp, esp<br>    ;<br>    ;   &#123;<br>    ;        return a + b;<br>    ;<br>        mov        eax, dword ptr [ebp+8]<br>        add        eax, dword ptr [ebp+12]<br>    ;<br>    ;   &#125;<br>    ;<br>        pop        ebp<br>        ret<br>_AddNum         endp<br>_MyFunc         proc     near<br>    ;<br>    ;   void MyFunc()<br>    ;<br>        push       ebp<br>        mov        ebp, esp<br>    ;<br>    ;  &#123;<br>    ;        int c;<br>    ;        c =AddNum(123, 456);<br>    ;<br>        push       456<br>        push       123<br>        call       _AddNum<br>        add        esp,8<br>    ;<br>    ;   &#125;<br>    ;<br>        pop        ebp<br>        ret<br>_MyFunc         endp<br>_TEXT  ends<br>        end<br></code></pre></td></tr></table></figure></li><li><p>源代码的开始位置，定义了 3 个名称分别为_TEXT、_DATA、_BSS 的段定义。_TEXT 是指令的段定义，_DATA 是被初始化（有初始值）的数据的段定义，_BSS 是尚未初始化的数据的段定义</p></li><li><p>类似于这种段定义的名称及划分方法是 Borland C++ 的规定，是由 Borland C++ 的编译器自动分配的。因而程序段定义的配置顺序就成了_TEXT、_DATA、_BSS，这样也确保了内存的连续性</p></li><li><p><a href="https://blog.csdn.net/c529283955/article/details/102979310">汇编 segment 伪指令</a></p><ul><li>segment_name SEGMENT【定位类型】【组合类型】【类别名】</li></ul></li><li><p>group 这一伪指令，表示的是把_BSS 和_DATA 这两个段定义汇总为名为 DGROUP 的组。此外，栈和堆的内存空间会在程序运行时生成，这一点已经在第 8 章中做过介绍</p><ul><li>group 指的是将源代码中不同的段定义在本地代码程序中整合为一个。</li></ul></li><li><p>围起_AddNum 和_MyFun 的_TEXT segment 和_TEXT ends，表示_AddNum 和_MyFunc 是属于_TEXT 这一段定义的。因此，即使在源代码中指令和数据是混杂编写的，经过编译或者汇编后，也会转换成段定义划分整齐的本地代码</p></li><li><p>_AddNum proc 和_AddNum endp 围起来的部分，以及_MyFunc proc 和 MyFunc endp 围起来的部分，分别表示 AddNum 函数和 MyFunc 函数的范围</p><ul><li><p>编译后在函数名前附带上下划线（_），是 Borland C++ 的规定。在 C 语言中编写的 AddNum 函数，在内部是以_AddNum 这个名称被处理的</p></li><li><p>伪指令 proc 和 endp 围起来的部分，表示的是过程（procedure）的范围。在汇编语言中，这种相当于 C 语言的函数的形式称为过程</p></li></ul></li><li><p>末尾的 end 伪指令，表示的是源代码的结束</p></li></ul><h3 id="10-4-汇编语言的语法是“操作码-操作数”"><a href="#10-4-汇编语言的语法是“操作码-操作数”" class="headerlink" title="10.4 汇编语言的语法是“操作码 + 操作数”"></a>10.4 汇编语言的语法是“操作码 + 操作数”</h3><ul><li><p>在汇编语言中，1 行表示对 CPU 的一个指令。汇编语言指令的语法结构是操作码 + 操作数（也存在只有操作码没有操作数的指令）</p></li><li><p>在汇编语言中，类似于 mov 这样的指令称为“操作码”（opcode），作为指令对象的内存地址及寄存器称为“操作数”（operand）。被转换成 CPU 可以直接解析运行的二进制的操作码和操作数，就是本地代码</p></li><li><p>操作码表示的是指令动作，操作数表示的是指令对象。操作码和操作数罗列在一起的语法，就是一个英文的指令文本。操作码是动词，操作数相当于宾语</p></li><li><p>汇编语言中存在多个操作数的情况下，要用逗号把它们分割开来</p></li><li><p>能够使用何种形式的操作码，是由 CPU 的种类决定的</p></li><li><p>10.3 节示例代码中用到的操作码如下。这些都是 32 位 x86 系列 CPU 用的操作码。操作数中指定了寄存器名、内存地址、常数等。在下表中，操作数是用 A 和 B 来表示的</p><p><img src="/image/%E7%A8%8B%E5%BA%8F%E6%98%AF%E6%80%8E%E6%A0%B7%E8%B7%91%E8%B5%B7%E6%9D%A5%E7%9A%84/d7066c4f29dbb2e5b71d71e45a042c2bdd8c3bd0.jpeg" alt="epub907761217jpeg"></p></li><li><p>本地代码加载到内存后才能运行。内存中存储着构成本地代码的指令和数据。程序运行时，CPU 会从内存中把指令和数据读出，然后再将其存储在 CPU 内部的寄存器中进行处理</p></li><li><p>寄存器是 CPU 中的存储区域。不过，寄存器并不仅仅具有存储指令和数据的功能，也有运算功能</p></li><li><p>x86 系列 CPU 的寄存器的主要种类和角色如下表所示</p><p><img src="/image/%E7%A8%8B%E5%BA%8F%E6%98%AF%E6%80%8E%E6%A0%B7%E8%B7%91%E8%B5%B7%E6%9D%A5%E7%9A%84/f9d8a7bafdb554dd16dfd81e946f89656102519f.jpeg" alt="epub907761220jpeg"></p></li><li><p>寄存器的名称会通过汇编语言的源代码指定给操作数。内存中的存储区域是用地址编号来区分的。CPU 内的寄存器是用 eax 及 ebx 这些名称来区分的</p></li><li><p>此外，CPU 内部也有程序员无法直接操作的寄存器。例如，表示运算结果正负及溢出状态的标志寄存器及操作系统专用的寄存器等，都无法通过程序员编写的程序直接进行操作</p></li><li><p>x86 系列 32 位 CPU 的寄存器名称中，开头都带了一个字母 e，例如 eax、ebx、ecx、edx 等。这是因为 16 位 CPU 的寄存器名称是 ax、bx、cx、dx 等。32 位 CPU 寄存器的名称中的 e，有扩展（extended）的意思。我们也可以仅利用 32 位寄存器的低 16 位，此时只需把要指定的寄存器名开头的字母 e 去掉即可</p></li></ul><h3 id="10-5-最常用的-mov-指令"><a href="#10-5-最常用的-mov-指令" class="headerlink" title="10.5 最常用的 mov 指令"></a>10.5 最常用的 mov 指令</h3><ul><li><p>指令中最常使用的是对寄存器和内存进行数据存储的 mov 指令</p></li><li><p>mov 指令的两个操作数，分别用来指定数据的存储地和读出源</p><ul><li><p>操作数中可以指定寄存器、常数、标签（附加在地址前），以及用方括号（[]）围起来的这些内容</p></li><li><p>如果指定了没有用方括号围起来的内容，就表示对该值进行处理</p></li><li><p>如果指定了用方括号围起来的内容，方括号中的值则会被解释为内存地址，然后就会对该内存地址对应的值进行读写操作</p></li></ul></li><li><p>mov 指令示例</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs nasm">mov ebp, esp<br>mov eax, dword ptr [ebp+8]<br></code></pre></td></tr></table></figure></li><li><p>mov ebp, esp 中，esp 寄存器中的值被直接存储在了 ebp 寄存器中。esp 寄存器的值是 100 时 ebp 寄存器的值也是 100</p></li><li><p>而在 mov eax, dword ptr [ebp+8] 的情况下，ebp 寄存器的值加 8 后得到的值会被解释为内存地址。如果 ebp 寄存器的值是 100 的话，那么 eax 寄存器中存储的就是 100 + 8&#x3D;108 地址的数据</p></li><li><p>dword ptr（double word pointer）表示的是从指定内存地址读出 4 字节的数据。像这样，有时也会在汇编语言的操作数前附带 dword ptr 这样的修饰语</p></li></ul><h3 id="10-6-对栈进行-push-和-pop"><a href="#10-6-对栈进行-push-和-pop" class="headerlink" title="10.6 对栈进行 push 和 pop"></a>10.6 对栈进行 push 和 pop</h3><ul><li><p>程序运行时，会在内存上申请分配一个称为栈的数据空间。栈（stack）有“干草堆积如山”的意思。就如该名称所表示的那样，数据在存储时是从内存的下层（大的地址编号）逐渐往上层（小的地址编号）累积，读出时则是按照从上往下的顺利进行（图 10-3）的</p></li><li><p>栈的模型</p><p><img src="/image/%E7%A8%8B%E5%BA%8F%E6%98%AF%E6%80%8E%E6%A0%B7%E8%B7%91%E8%B5%B7%E6%9D%A5%E7%9A%84/4a05f0a0d0f756e08201c618f656377bbfb55889.jpeg" alt="epub907761221jpeg"></p></li><li><p>栈是存储临时数据的区域，它的特点是通过 push 指令和 pop 指令进行数据的存储和读出。往栈中存储数据称为“入栈”，从栈中读出数据称为“出栈”。32 位 x86 系列的 CPU 中，进行 1 次 push 或 pop，即可处理 32 位（4 字节）的数据</p></li><li><p>push 指令和 pop 指令中只有一个操作数。该操作数表示的是“push 的是什么及 pop 的是什么”，而不需要指定“对哪一个地址编号的内存进行 push 或 pop”。这是因为，对栈进行读写的内存地址是由 esp 寄存器（栈指针）进行管理的。push 指令和 pop 指令运行后，esp 寄存器的值会自动进行更新（push 指令是-4, pop 命令是 +4），因而程序员就没有必要指定内存地址了</p></li></ul><h3 id="10-7-函数调用机制"><a href="#10-7-函数调用机制" class="headerlink" title="10.7 函数调用机制"></a>10.7 函数调用机制</h3><ul><li><p>MyFunc 函数调用的汇编语言代码示例</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs nasm">_MyFunc         proc     near<br>        push       ebp         ; 1.将 ebp 寄存器的值存入栈中<br>        mov        ebp, esp    ; 2.将 esp 寄存器的值存入 ebp 寄存器<br>        push       456         ; 3.456 入栈<br>        push       123         ; 4.123 入栈<br>        call       _AddNum     ; 5.调用 AddNum 函数<br>        add        esp,8       ; 6.esp 寄存器值加 8<br>        pop        ebp         ; 7.读出栈中的值存入 ebp 寄存器<br>        ret                    ; 8.结束 MyFunc 函数，返回调用源<br>_MyFunc         endp<br></code></pre></td></tr></table></figure></li></ul><p>-（1）、（2）、（7）、（8）的处理适用于 C 语言中所有的函数，我们会在后面展示 AddNum 函数处理内容时进行说明</p><p>-（3）和（4）表示的是将传递给 AddNum 函数的参数通过 push 入栈。在 C 语言的源代码中，虽然记述为函数 AddNum（123,456），但入栈时则会按照 456、123 这样的顺序，也就是位于后面的数值先入栈。这是 C 语言的规定</p><p>-（5）的 call 指令，把程序流程跳转到了操作数中指定的 AddNum 函数所在的内存地址处。在汇编语言中，函数名表示的是函数所在的内存地址。AddNum 函数处理完毕后，程序流程必须要返回到编号（6）这一行</p><ul><li>call 指令运行后，call 指令的下一行（（6）这一行）的内存地址（调用函数完毕后要返回的内存地址）会自动地 push 入栈。该值会在 AddNum 函数处理的最后通过 ret 指令 pop 出栈，然后程序流程就会返回到（6）这一行</li></ul><p>-（6）部分会把栈中存储的两个参数（456 和 123）进行销毁处理，也就是在第 5 章提到的栈清理处理。虽然通过使用两次 pop 指令也可以实现，不过采用 esp 寄存器加 8 的方式会更有效率（处理 1 次即可）</p><ul><li><p>对栈进行数值的输入输出时，数值的单位是 4 字节。因此，通过在负责栈地址管理的 esp 寄存器中加上 4 的 2 倍 8，就可以达到和运行两次 pop 命令同样的效果</p></li><li><p>虽然内存中的数据实际上还残留着，但只要把 esp 寄存器的值更新为数据存储地址前面的数据位置，该数据也就相当于被销毁了</p></li><li><p>AddNum 函数调用前后栈的状态变化</p><p><img src="/image/%E7%A8%8B%E5%BA%8F%E6%98%AF%E6%80%8E%E6%A0%B7%E8%B7%91%E8%B5%B7%E6%9D%A5%E7%9A%84/2af22962c6c0486d4d9e5411b6ed717a655ab7cc.jpeg" alt="epub907761224jpeg"></p></li><li><p>C 语言源代码示例中，有一个处理是在变量 c 中存储 AddNum 函数的返回值，不过在汇编语言的源代码中，并没有与此对应的处理。这是因为编译器有最优化功能</p><ul><li><p>最优化功能是编译器在本地代码上费尽功夫实现的，其目的是让编译后的程序运行速度更快、文件更小</p></li><li><p>在示例代码中，由于存储着 AddNum 函数返回值的变量 c 在后面没有被用到，因此编译器就会认为“该处理没有意义”，进而也就没有生成与之对应的汇编语言代码</p></li><li><p>在编译示例代码时，应该会出现“警告 W8004 Sample4.c 11: ‘c’的赋值未被使用（函数 MyFunc）”这样的警告消息</p></li></ul></li></ul><h3 id="10-8-函数内部的处理"><a href="#10-8-函数内部的处理" class="headerlink" title="10.8 函数内部的处理"></a>10.8 函数内部的处理</h3><ul><li><p>AddNum 函数调用的汇编语言代码示例</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs nasm">_AddNum         proc     near<br>        push       ebp                        ; 1<br>        mov        ebp, esp                    ; 2<br>        mov        eax, dword ptr [ebp+8]    ; 3<br>        add        eax, dword ptr [ebp+12]    ; 4<br>        pop        ebp                        ; 5<br>        ret                                    ; 6<br>_AddNum         endp<br></code></pre></td></tr></table></figure></li><li><p><a href="https://www.cnblogs.com/xiangtingshen/p/11221277.html">对于 ESP、EBP 寄存器的理解</a></p></li><li><p>ebp 寄存器的值在（1）中入栈，在（5）中出栈。这主要是为了把函数中用到的 ebp 寄存器的内容，恢复到函数调用前的状态。在进入函数处理之前，无法确定 ebp 寄存器用到了什么地方，但由于函数内部也会用到 ebp 寄存器，所以就暂时将该值保存了起来</p><ul><li>ebp 作为一个用于寻址的固定值是有时间周期的。只有在某个函数执行过程中才是固定的，在函数调用与函数执行完毕后会发生改变。在函数调用之前，将调用者的函数（caller）的 ebp 存入栈，以便于在执行完毕后恢复现场是还原 ebp 的值</li></ul></li><li><p>CPU 拥有的寄存器是有数量限制的。在函数调用前，调用源有可能已经在使用 ebp 寄存器了。因而，在函数内部利用的寄存器，要尽量返回到函数调用前的状态。为此，我们就需要将其暂时保存在栈中，然后再在函数处理完毕之前出栈，使其返回到原来的状态</p></li></ul><p>-（2）中把负责管理栈地址的 esp 寄存器的值赋值到了 ebp 寄存器中。这是因为，在 mov 指令中方括号内的参数，是不允许指定 esp 寄存器的。因此，这里就采用了不直接通过 esp，而是用 ebp 寄存器来读写栈内容的方法</p><p>-（3）是用 [ebp+8] 指定栈中存储的第 1 个参数 123，并将其读出到 eax 寄存器中。像这样，不使用 pop 指令，也可以查看栈的内容。而之所以从多个寄存器中选择了 eax 寄存器，是因为 eax 寄存器是负责运算的累加寄存器</p><ul><li><p>通过（4）的 add 指令，把当前 eax 寄存器的值同第 2 个参数相加后的结果存储在 eax 寄存器中。[ebp+12] 是用来指定第 2 个参数 456 的。在 C 语言中，函数的返回值必须通过 eax 寄存器返回，这也是规定。不过，和 ebp 寄存器不同的是，eax 寄存器的值不用还原到原始状态</p></li><li><p>函数的参数是通过栈来传递，返回值是通过寄存器来返回的</p></li></ul><p>-（6）中 ret 指令运行后，函数返回目的地的内存地址会自动出栈，据此，程序流程就会跳转返回到 10.7 代码清单的（6）（Call _AddNum 的下一行）</p><ul><li><p>AddNum 函数内部的栈状态变化</p><p><img src="/image/%E7%A8%8B%E5%BA%8F%E6%98%AF%E6%80%8E%E6%A0%B7%E8%B7%91%E8%B5%B7%E6%9D%A5%E7%9A%84/0dc3d7e03f0eb7351b3e4ef29552beb99668488a.jpeg" alt="epub907761226jpeg"></p></li><li><p>将 10.7 和图 10.8 的栈状态图按照（a）（b）（c）（d）（e）( f ) 的顺序来看的话，函数调用处理时栈的状态变化就会很清楚了。由于（a）状态时处理跳转到 AddNum 函数，因此（a）和（b）是同样的。同理，在（d）状态时，处理跳转到了调用源，因此（d）和（e）是同样的。在（f）状态时则进行了清理处理。栈的最高位的数据地址，是一直存储在 esp 寄存器中的</p></li></ul><h3 id="10-9-始终确保全局变量用的内存空间"><a href="#10-9-始终确保全局变量用的内存空间" class="headerlink" title="10.9 始终确保全局变量用的内存空间"></a>10.9 始终确保全局变量用的内存空间</h3><ul><li><p>C 语言中，在函数外部定义的变量称为全局变量，在函数内部定义的变量称为局部变量。全局变量可以引用源代码的任意部分，而局部变量只能在定义该变量的函数内进行引用</p><ul><li>例如，在 MyFuncA 函数内部定义的 i 这个局部变量就无法通过 MyFuncB 函数进行引用。与此相反，如果是在函数外部定义的全局变量，MyFuncA 函数和 MyFuncB 函数都可以引用</li></ul></li><li><p>C 语言源代码示例</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">//定义被初始化的全局变量</span><br><span class="hljs-type">int</span> a1 = <span class="hljs-number">1</span>;<br><span class="hljs-type">int</span> a2 = <span class="hljs-number">2</span>;<br><span class="hljs-type">int</span> a3 = <span class="hljs-number">3</span>;<br><span class="hljs-type">int</span> a4 = <span class="hljs-number">4</span>;<br><span class="hljs-type">int</span> a5 = <span class="hljs-number">5</span>;<br><span class="hljs-comment">//定义没有初始化的全局变量</span><br><span class="hljs-type">int</span> b1, b2, b3, b4, b5;<br><span class="hljs-comment">//定义函数</span><br><span class="hljs-type">void</span> <span class="hljs-title function_">MyFunc</span><span class="hljs-params">()</span><br>&#123;<br>    <span class="hljs-comment">//定义局部变量</span><br>    <span class="hljs-type">int</span> c1, c2, c3, c4, c5, c6, c7, c8, c9, c10;<br>    <span class="hljs-comment">//给局部变量赋值</span><br>    c1 = <span class="hljs-number">1</span>;<br>    c2 = <span class="hljs-number">2</span>;<br>    c3 = <span class="hljs-number">3</span>;<br>    c4 = <span class="hljs-number">4</span>;<br>    c5 = <span class="hljs-number">5</span>;<br>    c6 = <span class="hljs-number">6</span>;<br>    c7 = <span class="hljs-number">7</span>;<br>    c8 = <span class="hljs-number">8</span>;<br>    c9 = <span class="hljs-number">9</span>;<br>    c10 = <span class="hljs-number">10</span>;<br>    <span class="hljs-comment">//把局部变量的值赋给全局变量</span><br>    a1 = c1;<br>    a2 = c2;<br>    a3 = c3;<br>    a4 = c4;<br>    a5 = c5;<br>    b1 = c6;<br>    b2 = c7;<br>    b3 = c8;<br>    b4 = c9;<br>    b5 = c10;<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>对应的汇编代码</p><p><img src="/image/%E7%A8%8B%E5%BA%8F%E6%98%AF%E6%80%8E%E6%A0%B7%E8%B7%91%E8%B5%B7%E6%9D%A5%E7%9A%84/cda687191992ffe85e8a5487cb98974883fafb36.jpeg" alt="epub907761228jpeg"></p><p><img src="/image/%E7%A8%8B%E5%BA%8F%E6%98%AF%E6%80%8E%E6%A0%B7%E8%B7%91%E8%B5%B7%E6%9D%A5%E7%9A%84/f9df62676d6a346e0c4d3395abeb358574618767.jpeg" alt="epub907761229jpeg"></p></li><li><p>上述汇编代码为了方便说明，我们省略了一部分汇编语言源代码，并改变了一下段定义的配置顺序，删除了注释</p></li><li><p>该处汇编代码主要用到的汇编语言指令的功能</p><p><img src="/image/%E7%A8%8B%E5%BA%8F%E6%98%AF%E6%80%8E%E6%A0%B7%E8%B7%91%E8%B5%B7%E6%9D%A5%E7%9A%84/756a899132b00824ceeb73345b3cabd9ec03fac8.jpeg" alt="epub907761227jpeg"></p></li><li><p>正如本章前半部分所讲的那样，编译后的程序，会被归类到名为段定义的组</p><ul><li><p>初始化的全局变量，会像（1）那样被汇总到名为_DATA 的段定义中</p></li><li><p>没有初始化的全局变量，会像（2）那样被汇总到名为_BSS 的段定义中</p></li><li><p>指令则会像（3）那样被汇总到名为_TEXT 的段定义中</p></li><li><p>这些段定义的名称是由 Borland C++ 的使用规范来决定的。_DATA segment 和_DATA ends、_BSS segment 和_BSS ends、_TEXT segment 和_TEXT ends，这些都是表示各段定义范围的伪指令</p></li></ul></li><li><p>首先让我们来看一下_DATA 段定义的内容。（4）中的_a1 label dword 定义了_a1 这个标签</p><ul><li><p>标签表示的是相对于段定义起始位置的位置</p></li><li><p>由于_a1 在_DATA 段定义的开头位置，所以相对位置是 0</p></li><li><p>_a1 就相当于全局变量 a1。编译后的函数名和变量名前会附加一个下划线 (_），这也是 Borland C++ 的规定</p></li></ul></li></ul><p>-（5）中的 dd 1 指的是，申请分配了 4 字节的内存空间，存储着 1 这个初始值</p><ul><li><p>dd（definedouble word）表示的是定义个双字（double word），而每个字的长度是 2 个字节，也就是说申请了一个 4 字节的内存空间</p></li><li><p>Borland C++ 中，由于 int 类型的长度是 4 字节，因此汇编器就把 int a1&#x3D;1；变换成了_a1 label dword 和 dd 1</p></li><li><p>同样，这里也定义了相当于全局变量 a2～a5 的标签_a2～_a5，它们各自的初始值 2～5 也都被存储在了 4 字节的领域中</p></li><li><p>接下来，让我们来看一下_BSS 段定义的内容。这里定义了相当于全局变量 b1～b5 的标签_b1～_b5。（6）的 db 4 dup(? ) 表示的是申请分配了 4 字节的领域，但值尚未确定（这里用？来表示）的意思</p><ul><li><p>db（define byte）表示有 1 个长度是 1 字节的内存空间。因而，db 4 dup(? ) 的情况下，就是 4 字节的内存空间</p></li><li><p>这里大家要注意不要和 dd 4 混淆了。db 4 dup(? ) 表示的是 4 个长度是 1 字节的内存空间。而 dd 4 表示的则是双字（4 byte）的内存空间中存储的值是 4</p></li></ul></li><li><p>在_DATA 和_BSS 的段定义中，全局变量的内存空间都得到了确保，这一点大家想必都清楚了吧。因而，从程序的开始到结束，所有部分都可以引用全局变量。而这里之所以根据是否进行了初始化把全局变量的段定义划分为了两部分，是因为在 Borland C++ 中，程序运行时没有初始化的全局变量的领域（_BSS 段定义）都会被设定为 0 进行初始化。可见，通过汇总，初始化很容易实现，只要把内存的特定范围全部设定为 0 就可以了</p></li><li><p><a href="https://www.zhihu.com/question/20536161">计算机系统内的字长到底指的是什么？</a></p><ul><li><p>字长要从汇编语言的角度理解，就是指令集里面的运算和内存操作时操作数的长度。比如你写一条 load a, reg1，那么 a 这个操作数的长度就是字长。32 位机的字长<strong>最大</strong>是 32bit，64 位机的字长<strong>最大</strong>是 64bit</p></li><li><p>“有时候字长被定义为某个特定值是为了与早期的电脑保持兼容。现在个人电脑中最通用的微处理器（例如：Intel 的 Pentium 系列和 AMD 的 Athlon 系列）就是一个例子。它们中的 IA-32 构架是早期的具有 16 位字长的 Intel 8086 构架的扩展。而 IA-32 处理器仍然支持 8086（x86）程序，所以在 IA-32 中，“字”的含义仍然为 16 位，尽管事实上它运行起来（特别是当默认操作数为 32 位时）更像一台 32 位电脑。类似地，在更新型的 x86-64 构架中，“字”仍然是 16 位的，虽然 64 位操作数更为常见。”</p></li></ul></li></ul><h3 id="10-10-临时确保局部变量用的内存空间"><a href="#10-10-临时确保局部变量用的内存空间" class="headerlink" title="10.10 临时确保局部变量用的内存空间"></a>10.10 临时确保局部变量用的内存空间</h3><ul><li><p>为什么局部变量只能在定义该变量的函数内进行引用呢？这是因为，局部变量是临时保存在寄存器和栈中的。正如本章前半部分讲的那样，函数内部利用的栈，在函数处理完毕后会恢复到初始状态，因此局部变量的值也就被销毁了，而寄存器也可能会被用于其他目的。因此，局部变量只是在函数处理运行期间临时存储在寄存器和栈上</p></li><li><p>在代码清单 10.9 中定义了 10 个局部变量。这是为了表示存储局部变量的不仅仅是栈，还有寄存器。为确保 c1～c10 所需的领域，寄存器空闲时就使用寄存器，寄存器空间不足的话就使用</p></li><li><p>下面让我们来看一下代码清单 10-7 中_TEXT 段定义的内容。（7）表示的是 MyFunc 函数的范围。在 MyFunc 函数中定义的局部变量所需要的内存领域，会被尽可能地分配在寄存器中</p><ul><li><p>大家可能会认为用高性能的寄存器来代替普通的内存是很奢侈的事情，不过编译器不会这么认为，只要寄存器有空间，编译器就会使用它。因为与内存相比，使用寄存器时访问速度会高很多，这样就可以更快速地进行处理</p></li><li><p>局部变量利用寄存器，是 Borland C++ 编译器最优化的运行结果。旧的编译器没有类似的最优化功能，局部变量就可能会仅仅使用栈</p></li></ul></li><li><p>代码清单中的（8）表示的是往寄存器中分配局部变量的部分</p><ul><li>仅仅对局部变量进行定义是不够的，只有在给局部变量赋值时，才会被分配到寄存器的内存区域</li></ul><p>-（8）就相当于给 5 个局部变量 c1～c5 分别赋予数值 1～5 这一处理</p><ul><li>eax、edx、ecx、ebx、esi 是 Pentium 等 x86 系列 32 位 CPU 寄存器的名称。至于使用哪一个寄存器，则要由编译器来决定。这种情况下，寄存器只是被单纯地用于存储变量的值，和其本身的角色没有任何关系</li></ul></li><li><p>x86 系列 CPU 拥有的寄存器中，程序可以操作的有十几个。其中空闲的，最多也只有几个。因而，局部变量数目很多的时候，可分配的寄存器就不够了。这种情况下，局部变量就会申请分配栈的内存空间</p></li><li><p>虽然栈的内存空间也是作为一种存储数据的段定义来处理的，但在程序各部分都可以共享并临时使用这一点上，它和_DATA 段定义及_BSS 段定义在性质上还是有些差异的</p><ul><li>例如，在函数入口处为变量申请分配栈的内存空间的话，就必须在函数出口处进行释放。否则，经过多次调用函数后，栈的内存空间就会被用光了</li></ul></li><li><p>在（8）这一部分中，给局部变量 c1～c5 分配完寄存器后，可用的寄存器数量就不足了。于是，剩下的 5 个局部变量 c6～c10 就被分配了栈的内存空间，如（9）所示</p></li><li><p>函数入口（10）处的 add esp, -20 指的是，对栈数据存储位置的 esp 寄存器（栈指针）的值做减 20 的处理</p><ul><li>为了确保内部变量 c6～c10 在栈中，就需要保留 5 个 int 类型的局部变量（4 字节×5&#x3D;20 字节）所需的空间</li></ul></li></ul><p>-（11）中的 mov ebp,esp 这一处理，指的是把当前 esp 寄存器的值复制到 ebp 寄存器中。之所以需要（11）这一处理，是为了通过在函数出口处的（12）这一 move esp, ebp 的处理，把 esp 寄存器的值还原到原始状态，从而对申请分配的栈空间进行释放，这时栈中用到的局部变量就消失了。这也是栈的清理处理</p><ul><li><p>在使用寄存器的情况下，局部变量则会在寄存器被用于其他用途时自动消失</p></li><li><p>用于局部变量的栈空间的申请分配和释放</p><p><img src="/image/%E7%A8%8B%E5%BA%8F%E6%98%AF%E6%80%8E%E6%A0%B7%E8%B7%91%E8%B5%B7%E6%9D%A5%E7%9A%84/a365d794845fef62dcfdc6c11bdf49ac31ffc81d.jpeg" alt="epub907761230jpeg"></p></li></ul><p>-（9）中的 5 行代码是往栈空间中代入数值的部分</p><ul><li><p>由于在向栈申请内存空间前，借助 mov ebp, esp 这个处理，esp 寄存器的值被保存到了 ebp 寄存器中，因此，通过使用 [ebp - 4]、[ebp - 8]、[ebp -12]、[ebp - 16]、[ebp - 20] 这样的形式，就可以将申请分配的 20 字节的栈内存空间切分成 5 个长度分别是 4 字节的空间来使用</p></li><li><p>例如，（9）中的 mov dword ptr [ebp - 4], 6 表示的就是，从申请分配的内存空间的下端（ebp 寄存器指示的位置）开始往前 4 字节的地址（[ebp - 4]）中，存储着 6 这一 4 字节的数据</p></li><li><p>将栈的内存空间进行分割</p><p><img src="/image/%E7%A8%8B%E5%BA%8F%E6%98%AF%E6%80%8E%E6%A0%B7%E8%B7%91%E8%B5%B7%E6%9D%A5%E7%9A%84/62cf32fe0b9da86a0123bf4d6e416d621166856e.jpeg" alt="epub907761231jpeg"></p></li><li><p>关于往全局变量中代入局部变量的数值这一内容，这里不再进行说明。这时可能有读者会产生疑问，既然不进行说明，那为什么代码清单 10.9 中没有省略掉该部分呢？这是为了避免编译器的最优化功能。如果仅进行定义局部变量并代入数值这一处理的话，编译器的最优化功能就会启动，届时编译器就会认为某些代码没有意义，从而导致汇编语言的源代码无法生成</p></li></ul><h3 id="10-11-循环处理的实现方法"><a href="#10-11-循环处理的实现方法" class="headerlink" title="10.11 循环处理的实现方法"></a>10.11 循环处理的实现方法</h3><ul><li><p>C 语言源代码示例</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">//定义 MySub 函数</span><br><span class="hljs-type">void</span> <span class="hljs-title function_">MySub</span><span class="hljs-params">()</span><br>&#123;<br>    <span class="hljs-comment">//不做任何处理</span><br>&#125;<br><span class="hljs-comment">// 定义 MyFunc 函数</span><br><span class="hljs-type">void</span> <span class="hljs-title function_">MyFunc</span><span class="hljs-params">()</span><br>&#123;<br>    <span class="hljs-type">int</span> i;<br>    <span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10</span>; i++)<br>    &#123;<br>        <span class="hljs-comment">//重复调用 MySub 函数 10 次</span><br>        MySub();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>将代码清单 10.11 中的 for 语句转换成汇编语言的结果</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs nasm">    xor     ebx, ebx         ; 将 ebx 寄存器清 0<br>@4  call    _MySub           ; 调用 MySub 函数<br>    inc     ebx              ; ebx 寄存器的值加 1<br>    cmp     ebx,10           ; 将 ebx 寄存器的值和 10 进行比较<br>    jl      short @4         ; 如果小于 10 就跳转到 @4<br></code></pre></td></tr></table></figure></li><li><p>下面就让我们按照代码清单 10.11 的内容的顺序来进行说明。MyFunc 函数中用到的局部变量只有 i，变量 i 申请分配了 ebx 寄存器的内存空间。for 语句的括号中的 i&#x3D;0；被转换成了 xor ebx, ebx 这一处理。xor 指令会对左起第一个操作数和右起第二个操作数进行 XOR 运算，然后把结果存储在第一个操作数中</p><ul><li><p>由于这里把第一个操作数和第二个操作数都指定为了 ebx，因此就变成了对相同数值进行 XOR 运算。也就是说，不管当前 ebx 寄存器的值是什么，结果肯定都是 0</p></li><li><p>虽然用 mov 指令的 mov ebx,0 也会得到同样的结果，但与 mov 指令相比，xor 指令的处理速度更快。这里，编译器的最优化功能也会启动</p></li></ul></li><li><p>ebx 寄存器的值初始化后，会通过 call 指令调用 MySub 函数（_MySub）。从 MySub 函数返回后，则会通过 inc 指令对 ebx 寄存器的值做加 1 处理。该处理就相当于 for 语句的 i++, ++ 是当前数值加 1 的意思</p></li><li><p>下一行的 cmp 指令是用来对第一个操作数和第二个操作数的数值进行比较的指令。cmp ebx,10 就相当于 C 语言的 i&lt;10 这一处理，意思是把 ebx 寄存器的数值同 10 进行比较。汇编语言中比较指令的结果，会存储在 CPU 的标志寄存器中</p></li><li><p>标志寄存器的值，程序是无法直接参考的。那么程序是怎么来判断比较结果的？实际上，汇编语言中有多个跳转指令，这些跳转指令会根据标志寄存器的值来判定是否需要跳转。例如，最后一行的 jl，是 jump on less than（小于的话就跳转）的意思。也就是说，jl short @4 的意思就是，前面运行的比较指令的结果若“小”的话就跳转到 @4 这个标签</p></li><li><p>下列代码是按照汇编语言源代码的处理顺序重写的 C 语言源代码（由于 C 语言中无法使用 @字符开头的标签，因此这里用了 L4 这个标签名），也是对程序实际运行过程的一个直接描述</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c">    i ^=i;<br>L4: MySub();<br>    i++;<br>    <span class="hljs-keyword">if</span> (i &lt; <span class="hljs-number">10</span>) <span class="hljs-keyword">goto</span> L4<br></code></pre></td></tr></table></figure></li><li><p>上代码和 for 语句相比显得比较复杂且难以理解。汇编语言是对 CPU 的实际运行进行直接描述的低级编程语言，C 语言是用与人类的感觉相近的表现来描述的高级编程语言</p></li></ul><h3 id="10-12-条件分支的实现方法"><a href="#10-12-条件分支的实现方法" class="headerlink" title="10.12 条件分支的实现方法"></a>10.12 条件分支的实现方法</h3><ul><li><p>条件分支的实现方法同循环处理的实现方法类似，使用的也是 cmp 指令和跳转指令</p></li><li><p>C 语言程序代码示例</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">//定义 MySub1 函数</span><br><span class="hljs-type">void</span> <span class="hljs-title function_">MySub1</span><span class="hljs-params">()</span><br>&#123;<br>    <span class="hljs-comment">//不做任何处理</span><br>&#125;<br><span class="hljs-comment">//定义 MySub2 函数</span><br><span class="hljs-type">void</span> <span class="hljs-title function_">MySub2</span><span class="hljs-params">()</span><br>&#123;<br>    <span class="hljs-comment">//不做任何处理</span><br>&#125;<br><span class="hljs-comment">//定义 MySub3 函数</span><br><span class="hljs-type">void</span> <span class="hljs-title function_">MySub3</span><span class="hljs-params">()</span><br>&#123;<br>    <span class="hljs-comment">//不做任何处理</span><br>&#125;<br><span class="hljs-comment">//定义 MyFunc 函数</span><br><span class="hljs-type">void</span> <span class="hljs-title function_">MyFunc</span><span class="hljs-params">()</span><br>&#123;<br>    <span class="hljs-type">int</span> a = <span class="hljs-number">123</span>;<br>    <span class="hljs-comment">//根据条件调用不同的函数</span><br>    <span class="hljs-keyword">if</span> (a &gt; <span class="hljs-number">100</span>)<br>    &#123;<br>        MySub1();<br>    &#125;<br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (a &lt; <span class="hljs-number">50</span>)<br>    &#123;<br>        MySub2();<br>    &#125;<br>    <span class="hljs-keyword">else</span><br>    &#123;<br>        MySub3();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>将代码清单 10.12 的 MyFunc 函数转换成汇编语言后的结果</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs nasm">_MyFunc         proc        near<br>            push    ebp;<br>            mov     ebp, esp;<br>            mov     eax,123         ；把 123 存入 eax 寄存器中<br>            cmp     eax,100         ；把 eax 寄存器的值同 100 进行比较<br>            jle     short @8        ；等于或小于 100 时，跳转到 @8 标签<br>            call    _MySub1         ；调用 MySub1 函数<br>            jmp     short @11       ；跳转到 @11 标签<br>    @8:     cmp     eax,50          ；把 eax 寄存器的值同 50 进行比较<br>            jge     short @10       ；大于等于 50 时，跳转到 @10 标签<br>            call    _MySub2         ；调用 MySub2 函数<br>            jmp     short @11       ；跳转到 @11 标签<br>    @10:    call    _MySub3         ；调用 MySub3 函数<br>    @11:    pop     ebp<br>            ret<br>    _MyFunc     endp<br></code></pre></td></tr></table></figure></li><li><p>上述代码用到了三种跳转指令，分别是比较结果小或相等时跳转的 jle（jump on less orequal）、大或相等时跳转的 jge（jump on greater or equal）、不管结果怎样都无条件跳转的 jmp</p></li><li><p>在这些跳转指令之前还有用来比较的 cmp 指令，比较结果被保存在了标志寄存器中</p></li><li><p>虽然大部分的 C 语言参考书中都写着“为了便于理解程序的结构，应尽量避免使用无条件分支的 goto 语句”，不过，在汇编语言这一领域中，如果不使用相当于 C 语言 goto 语句的 jmp 指令，就无法实现循环和条件分支</p></li></ul><h2 id="第十一章-硬件控制方法"><a href="#第十一章-硬件控制方法" class="headerlink" title="第十一章 硬件控制方法"></a>第十一章 硬件控制方法</h2><h3 id="11-1-应用和硬件无关？"><a href="#11-1-应用和硬件无关？" class="headerlink" title="11.1 应用和硬件无关？"></a>11.1 应用和硬件无关？</h3><ul><li><p>在用 C 语言等高级编程语言开发的 Windows 应用中，很少能接触到直接控制硬件的指令。这是因为硬件的控制是由 Windows 全权负责的</p></li><li><p>Windows 提供了通过应用来间接控制硬件的方法。利用操作系统提供的系统调用功能就可以实现对硬件的控制。在 Windows 中，系统调用称为 API。各 API 就是应用调用的函数。这些函数的实体被存储在 DLL 文件中</p></li></ul><h3 id="11-2-支撑硬件输入输出的-IN-指令和-OUT-指令"><a href="#11-2-支撑硬件输入输出的-IN-指令和-OUT-指令" class="headerlink" title="11.2 支撑硬件输入输出的 IN 指令和 OUT 指令"></a>11.2 支撑硬件输入输出的 IN 指令和 OUT 指令</h3><ul><li><p>Window 控制硬件时借助的是输入输出指令。其中具有代表性的两个输入输出指令就是 IN 和 OUT。这些指令也是汇编语言的助记符</p></li><li><p>Pentium 等 x86 系列 CPU 用的 IN 指令和 OUT 指令的语法如下</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs nasm">IN 寄存器名，端口号<br>OUT 寄存器名，端口号<br></code></pre></td></tr></table></figure></li><li><p>IN 指令通过指定端口号的端口输入数据，并将其存储在 CPU 内部的寄存器中。OUT 指令则是把 CPU 寄存器中存储的数据，输出到指定端口号的端口</p></li><li><p>计算机主机中，附带了用来连接显示器及键盘等外围设备的连接器。而各连接器的内部，都连接有用来交换计算机主机同外围设备之间电流特性的 IC。这些 IC，统称为 I&#x2F;O 控制器。由于电压不同，数字信号及模拟信号的电流特性也不同，计算机主机和外围设备是无法直接连接的。为了解决这个问题，I&#x2F;O 控制器就很有必要了</p></li><li><p>I&#x2F;O 是 Input&#x2F;Output 的缩写。显示器、键盘等外围设备都有各自专用的 I&#x2F;O 控制器。I&#x2F;O 控制器中有用于临时保存输入输出数据的内存。这个内存就是端口</p><ul><li>端口（port）的字面意思是“港口”。由于端口就像是在计算机主机和外围设备之间进行货物（数据）装卸的港口，所以因此得名</li></ul></li><li><p>I&#x2F;O 控制器内部的内存，也称为寄存器。虽然都是寄存器，但它和 CPU 内部的寄存器在功能上是不同的。CPU 内部的寄存器是用来进行数据运算处理的，而 I&#x2F;O 寄存器则主要是用来临时存储数据的</p></li><li><p>在实现 I&#x2F;O 控制器功能的 IC 中，会有多个端口。由于计算机中连接着很多外围设备，所以就会有多个 I&#x2F;O 控制器，当然也会有多个端口。一个 I&#x2F;O 控制器既可以控制一个外围设备，也可以控制多个外围设备</p></li><li><p>各端口之间通过端口号进行区分。端口号也称为 I&#x2F;O 地址。IN 指令和 OUT 指令在端口号指定的端口和 CPU 之间进行数据的输入输出。这和通过内存地址来进行主内存的读写是一样的道理</p></li><li><p>以端口为桥梁来实现 CPU 和外围设备之间的数据传递</p><p><img src="/image/%E7%A8%8B%E5%BA%8F%E6%98%AF%E6%80%8E%E6%A0%B7%E8%B7%91%E8%B5%B7%E6%9D%A5%E7%9A%84/99801ecad3f1462f616425e00e3279c52d127875.jpeg" alt="epub907761240jpeg"></p></li><li><p>I&#x2F;O 装置，有的直接附带在计算机主机的主板（用来放置 CPU 的基板）上，有的则是各自独立的扩展板卡</p><ul><li><p>键盘、鼠标、打印机等常用的 I&#x2F;O，一般都在主板上</p></li><li><p>显示高速图形的显示器及网卡等特殊的 I&#x2F;O，通常是独立的扩张板卡</p></li></ul></li></ul><h3 id="11-3-编写测试用的输入输出程序"><a href="#11-3-编写测试用的输入输出程序" class="headerlink" title="11.3 编写测试用的输入输出程序"></a>11.3 编写测试用的输入输出程序</h3><ul><li><p>首先让我们利用 IN 指令和 OUT 指令，来进行一个直接控制硬件的试验。假设该试验的目的是让计算机内配置的蜂鸣器（小喇叭）发音。虽然蜂鸣器内置在计算机内部，但其本身也是外围设备的一种。因为就算是把蜂鸣器取出，对计算机主机也不会有什么影响</p></li><li><p>由于用汇编语言编写程序比较麻烦，因此这里我们采取在 C 语言源代码中插入助记符的方式来实现。在大部分 C 语言的处理（编译器的种类）中，只要使用_asm{和}括起来，就可以在其中记述助记符。也就是说，这样就可以编写 C 语言和汇编语言混合的源代码。这里，我们使用微软的 Visual C++ 来作成应用</p></li><li><p>在 AT 兼容机中，蜂鸣器的默认端口号是 61H（末尾的 H，表示的是十六进制数（Hexadecimal）的意思）。用 IN 指令通过该端口号输入数据，并将数据的低 2 位设定为 ON，然后再通过该端口号用 OUT 指令输出数据，这时蜂鸣器就会响起来。采用同样的操作方法，将数据的低 2 位设定为 OFF 并输出后，蜂鸣器就停止了</p></li><li><p>处理逻辑</p><ul><li><p>位设定为 ON 指的是将该位设定为 1，位设定为 OFF 指的是将该位设定为 0</p></li><li><p>把位设定为 ON，只需把想要设定为 ON 的位设定为 1，其他位设定为 0 后进行 OR 运算即可，由于这里需要把低 2 位置为 1，因此就是和 03H 进行 OR 运算。03H 用 8 位二进制数来表示的话是 00000011。由于即便高 6 位存在着具体意义，和 0 进行 OR 运算后也不会发生变化，因而就和 03H 进行 OR 运算</p></li><li><p>把位设定为 OFF，只需把想要置 OFF 的位设定为 0，其他位设定为 1 后进行 AND 运算即可。由于这里需要把低 2 位设定为 0，因此就要和 FCH 进行 AND 运算，在源代码中，FCH 是用 0FCH 来记述的。在前面加 0 是汇编语言的规定，表示的是以 A～F 这些字符开头的十六进制数是数值的意思。0FCH 用 8 位二进制数来表示的话是 11111100。由于即便高 6 位存在着具体意义，和 1 进行 AND 运算后也不会产生变化，因而就是同 0FCH 进行 OR 运算</p></li></ul></li><li><p>利用 IN&#x2F;OUT 指令来控制蜂鸣器的程序示例</p><p><img src="/image/%E7%A8%8B%E5%BA%8F%E6%98%AF%E6%80%8E%E6%A0%B7%E8%B7%91%E8%B5%B7%E6%9D%A5%E7%9A%84/585992d32b9b6191e148944e6c652b79acf16e63.jpeg" alt="epub907761245jpeg"></p></li><li><p>下面对上述代码进行说明，main 是位于 C 语言程序运行起始位置的函数。在该函数中，有两个用_asm{和}围起来的部分，它们中间有一个使用 for 语法的空循环（不做任何处理的循环）</p></li></ul><p>-（1）部分是控制蜂鸣器发音的部分。首先，通过 IN EAX,61H（助记符不区分大小写）指令，把端口 61H 的数据存储到 CPU 的 EAX 寄存器中。接下来，通过 OR EAX,03H 指令，把 EAX 寄存器的低 2 位设定成 ON。最后，通过 OUT 61H, EAX 指令，把 EAX 寄存器的内容输出到 61 号端口，使蜂鸣器开始发音。虽然 EAX 寄存器的长度是 32 位，不过由于蜂鸣器端口是 8 位，所以只需对下 8 位进行 OR 运算和 AND 运算就可以正常运行了</p><p>-（2）部分是一个重复 100 万次的空循环，主要是为了在蜂鸣器开始发音和停止发音之间稍微加上一些时间间隔。因为现在计算机的 CPU 运行速度非常快，哪怕是 100 万次的循环，也几乎是瞬间完成的</p><p>-（3）部分是用来控制蜂鸣器发音停止的部分。首先，通过 IN EAX,61H 指令，把端口 61H 的数据存储到 CPU 的 EAX 寄存器中。接下来，通过 AND EAX,0FCH 指令，把 EAX 寄存器的低 2 位设定成 OFF。最后，通过 OUT 61H, EAX 指令，把寄存器 EAX 的内容输出到 61 号端口，使蜂鸣器停止发音。大家可以把 61H 端口的低 2 位认为是蜂鸣器的开关</p><ul><li><p>最后，让我们对代码清单进行编译，并尝试运行一下。这时，蜂鸣器应该会发出“嘀！”的短促声音</p><ul><li><p>此外，有一点需要注意的是，该程序虽然在旧版本 Windows（95、98）中可以正常运行，但在这以后的 Windows（XP、Vista 等）版本中是无法正常运行的。这是因为，为了保护系统安全，现在的 Windows 禁止了应用直接控制硬件的方式</p></li><li><p>如果将该程序在最近的 Windows 版本上运行的话，就会出现错误信息，而且蜂鸣器也不会发出声音</p></li></ul></li></ul><h3 id="11-4-外围设备的中断请求"><a href="#11-4-外围设备的中断请求" class="headerlink" title="11.4 外围设备的中断请求"></a>11.4 外围设备的中断请求</h3><ul><li><p>IRQ（Interrupt Request）是中断请求的意思</p></li><li><p>IRQ 是用来暂停当前正在运行的程序，并跳转到其他程序运行的必要机制。该机制称为中断处理。中断处理在硬件控制中担当着重要角色。因为如果没有中断处理，就有可能出现处理无法顺畅进行的情况</p></li><li><p>从中断处理开始到请求中断的程序（中断处理程序）运行结束之前，被中断的程序（主程序）的处理是停止的</p></li><li><p>实施中断请求的是连接外围设备的 I&#x2F;O 控制器，负责实施中断处理程序的是 CPU</p></li><li><p>为了进行区分，外围设备的中断请求会使用不同于 I&#x2F;O 端口的其他编号，该编号称为中断编号。在控制面板中查看软盘驱动器的属性时，IRQ 处显示的数值 06，表示的就是用 06 号来识别软盘驱动器发出的中断请求。另一方面，操作系统及 BIOS 则会提供响应中断编号的中断处理程序</p></li><li><p>BIOS（Basic Input Output System）位于计算机主板或扩张板卡上内置的 ROM 中，里面记录了用来控制外围设备的程序和数据。这一点在第 7 章中进行过说明</p></li><li><p>假如同时有多个外围设备进行中断请求的话，CPU 也会为难。为此，我们可以在 I&#x2F;O 控制器和 CPU 中间加入名为中断控制器的 IC 来进行缓冲。中断控制器会把从多个外围设备发出的中断请求有序地传递给 CPU</p></li><li><p>中断控制器的功能</p><p><img src="/image/%E7%A8%8B%E5%BA%8F%E6%98%AF%E6%80%8E%E6%A0%B7%E8%B7%91%E8%B5%B7%E6%9D%A5%E7%9A%84/f90b5ca2ff1804d21d037d89b3ebea12047e066a.jpeg" alt="epub907761249jpeg"></p></li><li><p>CPU 接收到来自中断控制器的中断请求后，会把当前正在运行的主程序中断，并切换到中断处理程序</p><ul><li><p>中断处理程序的第一步处理，就是把 CPU 所有寄存器的数值保存到内存的栈中</p></li><li><p>在中断处理程序中完成外围设备的输入输出后，把栈中保存的数值还原到 CPU 寄存器中，然后再继续进行对主程序的处理</p></li><li><p>假如 CPU 寄存器的数值没有还原的话，就会影响到主程序的运行，甚至还有可能会使程序意外停止或者发生运行异常。这是因为主程序在运行过程中，出于某些原因用到 CPU 寄存器。而这时如果突然插入别的程序，主程序必然会受到影响</p></li><li><p>因此，在中断请求完毕后，各寄存器的数值必须要还原到中断前的状态。只要寄存器的值保持不变，主程序就可以像没有发生任何事情一样继续处理</p></li></ul></li><li><p>中断请求的顺序</p><p><img src="/image/%E7%A8%8B%E5%BA%8F%E6%98%AF%E6%80%8E%E6%A0%B7%E8%B7%91%E8%B5%B7%E6%9D%A5%E7%9A%84/72369ba47699c73922da74e0cc4cc9bbc9e62588.jpeg" alt="epub907761250jpeg"></p></li></ul><h3 id="11-5-用中断来实现实时处理"><a href="#11-5-用中断来实现实时处理" class="headerlink" title="11.5 用中断来实现实时处理"></a>11.5 用中断来实现实时处理</h3><ul><li><p>实际上，大部分的外围设备，都会频繁地发出中断请求。其原因就是为了实时处理从外围设备输入的数据</p></li><li><p>虽然不利用中断也可以从外围设备输入数据。但那种情况下，主程序就必须要持续不断地检测外围设备是否有数据输入</p><ul><li><p>由于外围设备有很多个，因此就有必要按照顺序来调查。按照顺序调查多个外围设备的状态称为轮询</p></li><li><p>对几乎不产生中断的系统来说，轮询是比较合适的处理。不过，对计算机来说就不适合了</p></li><li><p>举例来说，假如主程序正在调查是否有鼠标输入，这时如果发生了键盘输入的话，该如何处理呢？结果势必会导致键盘输入的文字无法实时地显示在显示器上。而通过使用中断，就可以实现实时显示了</p></li></ul></li><li><p>打印机等输出用的外围设备中，外围设备接收数据的状态，有时是需要用中断来通知的。由于外围设备的处理速度比计算机主机的处理速度要慢很多，因此，这种情况下就不需要对打印机的状态进行多次调查，只需在中断请求发生时输出数据即可，这样一来，其他时间 CPU 就可以集中处理别的程序了</p></li></ul><h3 id="11-6-DMA-可以实现短时间内传送大量数据"><a href="#11-6-DMA-可以实现短时间内传送大量数据" class="headerlink" title="11.6 DMA 可以实现短时间内传送大量数据"></a>11.6 DMA 可以实现短时间内传送大量数据</h3><ul><li><p>DMA（DirectMemory Access）是指在不通过 CPU 的情况下，外围设备直接和主内存进行数据传送</p><ul><li><p>磁盘等都用到了这个 DMA 机制</p></li><li><p>通过利用 DMA，大量数据就可以在短时间内转送到主内存</p></li><li><p>之所以这么快速，是因为 CPU 作为中介的时间被节省了</p></li></ul></li><li><p>使用 DMA 的外围设备和不使用 DMA 的外围设备的不同</p><p><img src="/image/%E7%A8%8B%E5%BA%8F%E6%98%AF%E6%80%8E%E6%A0%B7%E8%B7%91%E8%B5%B7%E6%9D%A5%E7%9A%84/8a9677088f4b454aadc5549aaf001f6ac197d696.jpeg" alt="epub907761251jpeg"></p></li><li><p>在 Windows 资源标签中有 DMA 设定，假设此处设定为 02。02 这个编号称为 DMA 通道。CPU 借助 DMA 通道，来识别是哪一个外围设备使用了 DMA</p></li><li><p>I&#x2F;O 端口号、IRQ、DMA 通道可以说是识别外围设备的 3 点组合。不过，IRQ 和 DMA 通道并不是所有的外围设备都必须具备的。计算机主机通过软件控制硬件时所需要的信息的最低限，是外围设备的 I&#x2F;O 端口号</p></li><li><p>IRQ 只对需要中断处理的外围设备来说是必需的，DMA 通道则只对需要 DMA 机制的外围设备来说是必需的</p></li><li><p>假如多个外围设备都设定成同样的端口号、IRQ 及 DMA 通道的话，计算机就无法正常工作了。这种情况下，就会出现“设备冲突”的提示</p></li></ul><h3 id="11-7-文字及图片的显示机制"><a href="#11-7-文字及图片的显示机制" class="headerlink" title="11.7 文字及图片的显示机制"></a>11.7 文字及图片的显示机制</h3><ul><li><p>如果用一句话来简单地概括显示器显示文字及图形的机制，那就是显示器中显示的信息一直存储在某内存中。该内存称为 VRAM（Video RAM）</p><ul><li><p>在程序中，只要往 VRAM 中写入数据，该数据就会在显示器中显示出来</p></li><li><p>实现该功能的程序，是由操作系统或 BIOS 提供，并借助中断来进行处理的</p></li></ul></li><li><p>在 MS-DOS 时代，对大部分计算机来说，VRAM 都是主内存的一部分。例如 PC-9801 这种机型的计算机，主内存地址 A0000 地址以后是 VRAM 区域。如果用程序往 VRAM 内存地址中写入数据，文字及图形就可以显示出来。不过，文字和图形的颜色最多只能有 16 种。这是因为 VRAM 的内存空间太小了</p></li><li><p>在现在的计算机中，显卡等专用硬件中一般都配置有与主内存相独立的 VRAM 和 GPU（GraphicsProcessing Unit，图形处理器，也称为图形芯片）。这是因为，对经常需要描绘图形的 Windows 来说，数百兆的 VRAM 是必需的。而为了提升图形的描绘速度，有时还需要专用的图形处理器。但不管怎样，内存 VRAM 中存储的数据就是显示器上显示的信息，这一机制是不变的</p></li><li><p>用软件来控制硬件听起来好像很难，但实际上只是利用输入输出指令同外围设备进行输入输出的处理而已。中断处理是根据需要来使用的选项功能，DMA 则直接交给对应的外围设备即可</p></li></ul><h2 id="第十二章-让计算机“思考”"><a href="#第十二章-让计算机“思考”" class="headerlink" title="第十二章 让计算机“思考”"></a>第十二章 让计算机“思考”</h2><h3 id="12-1-作为“工具”的程序和为了“思考”的程序"><a href="#12-1-作为“工具”的程序和为了“思考”的程序" class="headerlink" title="12.1 作为“工具”的程序和为了“思考”的程序"></a>12.1 作为“工具”的程序和为了“思考”的程序</h3><ul><li><p>程序就如同是由计算机执行的各种指令罗列起来的文章。计算机内部的 CPU，通过对该文章的内容进行解析和运行，来控制连接到计算机的各种外围设备。具体来说，控制就是指 CPU 和各种设备之间配合进行数据的输入输出处理</p></li><li><p>程序的使用目的大体可以划分为两类</p><ul><li><p>一类是大家作为工具来使用的程序。例如，文字处理器这个程序，大家是将其作为文档处理的工具来使用的。这种情况可以说是程序替代了现有的工具</p></li><li><p>另外一个使用目的是用程序来代替执行人类的思考过程。例如，微计算机 [插图] 控制的电饭煲，会根据米和水的份量来自动调整火的大小以及加热时间，进而焖出好吃的米饭。这种情况就可以说是借助程序，使计算机有了“思考”功能</p></li></ul></li></ul><h3 id="12-4-程序生成随机数的方法"><a href="#12-4-程序生成随机数的方法" class="headerlink" title="12.4 程序生成随机数的方法"></a>12.4 程序生成随机数的方法</h3><ul><li><p>在编写游戏程序时，以及在计算机模拟等情况下，经常使用随机数。随机数也是用程序来表示人类的直觉及念头的一种方法</p><ul><li>计算机模拟指的是利用计算机模拟实际试验的方式。经常被用于建筑物的耐震实验等实际难以进行的实验中。使用随机数的计算机模拟有时也称为“蒙特卡洛法”，来源于因赌博而闻名的城市──蒙特卡洛</li></ul></li><li><p>由于计算机没法晃动随机数色子，因此程序一般会通过生成类似于随机数的数值公式来得到随机数。在 C 语言中，虽然该公式的实体是隐藏的，但只要调用 rand() 函数，就可以得到结果（随机数）。不过，由于借助公式产生的随机数具有一定的规律性，因此并不是真正的随机数，通常称为伪随机数。不过，虽然是伪随机数，仍然十分有用</p></li></ul>]]></content>
    
    
    <categories>
      
      <category>笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>基础体系</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【笔记】程序是怎样跑起来的（上）</title>
    <link href="/posts/a02f89c0.html"/>
    <url>/posts/a02f89c0.html</url>
    
    <content type="html"><![CDATA[<div class="note note-success">            <p>《程序是怎样跑起来的》由日本作家矢泽久雄编撰而成，和户根勤《网络是怎样链接的？》等书籍收录于图灵程序设计丛书·图解与入门系列。</p><p>从我个人角度来说，《程序》比《网络》逊色。《网络》一书条理清晰，简单易懂，由客户端发起网络请求开始，直到服务器处理请求结束，一层层深入，抽丝剥茧，可以让读者对网络整体结构有比较好的理解记忆。《程序》一书中有较多口语化的句子，知识密度不及《网络》，既没有深挖技术细节，也没有见缝插针扩展知识，且插画水平也远不及该图书系列的一贯水准。</p><p>但是我还是很推荐想要入门 CS 的同学把这本书拿来做辅助阅读资料的！《程序》相当于《计算机科学导论》、《计算机组成原理》、《计算机组成与嵌入式系统》的简易组合阅读版，《深入理解计算机系统》的极致压缩板。读起来会比读黑皮书轻松的多，也快的多。非常适合用做打基础前的快速了解书籍，或者你把它用来当做复习书也行。</p><p>《程序》的每一章节扩展开来都可以写成一本书，但是为了平衡整本书的情况，且不偏离“给普通人看的技术书”主题，于是只能挑选最最最重要的核心部分填充其中，于是就造成了读不过瘾、内容断断续续的情况。例如第一章，CPU 的结构没有很好地向读者说明，也没有稍微探讨一下结构划分的原理，读到后面还得自己去上网查资料。</p><p>不过这也怪不得作者，只能说是篇幅受限，不得已而为之。“功夫在诗外”，书中没写出来的，读者应该尽量去“补全”。我在笔记中也加了不少附加链接，基本都是我觉得可以对书籍章节做很好补充的内容，希望你看的舒服。</p><p>总的来说，做引子不错。</p>          </div><p>剩下的笔记：</p><blockquote><p><a href="1893eea5">【笔记】程序是怎样跑起来的（下）</a></p></blockquote><h2 id="第一章-对程序员来说-CPU-是什么"><a href="#第一章-对程序员来说-CPU-是什么" class="headerlink" title="第一章 对程序员来说 CPU 是什么"></a>第一章 对程序员来说 CPU 是什么</h2><h3 id="1-1-CPU-的内部结构解析"><a href="#1-1-CPU-的内部结构解析" class="headerlink" title="1.1 CPU 的内部结构解析"></a>1.1 CPU 的内部结构解析</h3><ul><li><p>CPU：Central Processing Unit，中央处理器</p><ul><li><p>CPU 在程序运行流程中所负责的是解释和运行最终转换成机器语言的程序内容</p></li><li><p>CPU 是用来表示计算机内部元件功能的术语。另一方面，奔腾等半导体芯片，通常称为微处理器。不过，由于大部分计算机通常只有一个微处理器来承担 CPU 的功能，所以本章不对此进行区分，统一使用 CPU 这一称呼</p></li><li><p>CPU 由具有 ON&#x2F;OFF 开关功能的晶体管构成。有的 CPU 在一个集成电路中集成了两个 CPU 芯片，我们称之为双核（dual core）CPU</p></li></ul></li><li><p>CPU 和内存是由许多晶体管组成的电子部件，通常称为 IC（Integrated Circuit，集成电路）</p></li><li><p>从功能方面来看，CPU 的内部由寄存器、控制器、运算器和时钟四个部分构成，各部分之间由电流信号相互连通。</p><ul><li><p>寄存器：用于暂存指令、数据等处理对象，可以将其看作是内存的一种。根据种类的不同，一个 CPU 内部会有 20～100 个寄存器</p></li><li><p>控制器：控制指令执行的顺序；控制指令的具体执行</p></li><li><p>运算器：运算器负责运算从内存读入寄存器的数据</p></li><li><p>时钟：负责发出 CPU 开始计时的时钟信号。不过，也有些计算机的时钟位于 CPU 的外部</p></li></ul></li><li><p>CPU 的功能构成：（CPU 的结构不是本书的重点，所以书中只是简单地对 CPU 的功能进行抽象，视为几部分结构，图中几部分并不是相互独立的存在，例如控制器实际上是包含程序计数器、指令寄存器、时序产生器等部分的，运算器包含 ACC、MQ 等寄存器）</p><p><img src="/image/%E7%A8%8B%E5%BA%8F%E6%98%AF%E6%80%8E%E6%A0%B7%E8%B7%91%E8%B5%B7%E6%9D%A5%E7%9A%84/35db82c98d462daabbcae4dde427497c0c48cad5.jpeg" alt="epub9077616jpeg"></p></li><li><p>时钟：clock puzzle。Pentium 2 GHz 表示时钟信号的频率为 2 GHz（1 GHz&#x3D;10 亿次&#x2F;秒）。也就是说，时钟信号的频率越高，CPU 的运行速度越快。</p></li><li><p>内存：通常指的是计算机的主存储器（mainmemory），简称主存</p><ul><li><p>主存位于计算机机体内部，是负责存储程序、数据等的装置</p></li><li><p>主存通常使用 DRAM（Dynamic Random Access Memory，动态随机存取存储器）芯片。详情可参阅第 4 章</p><ul><li>DRAM 可以对任何地址进行数据的读写操作，但需要保持稳定的电源供给并时常刷新（确保是最新数据），关机后内容将自动清除</li></ul></li><li><p>主存通过控制芯片等与 CPU 相连，主要负责存储指令和数据</p></li><li><p>主存由可读写的元素构成，每个字节（1 字节&#x3D;8 位）都带有一个地址编号。CPU 可以通过该地址读取主存中的指令和数据，当然也可以写入数据</p></li><li><p>主存中存储的指令和数据会随着计算机的关机而自动清除</p></li></ul></li><li><p>“控制器”的控制指的是数据运算以外的处理（主要是数据输入输出的时机控制）。比如内存和磁盘等媒介的输入输出、键盘和鼠标的输入、显示器和打印机的输出等，这些都是控制的内容</p></li></ul><h3 id="1-2-CPU-是寄存器的集合体"><a href="#1-2-CPU-是寄存器的集合体" class="headerlink" title="1.2 CPU 是寄存器的集合体"></a>1.2 CPU 是寄存器的集合体</h3><ul><li><p>程序是把寄存器作为对象来描述的</p></li><li><p>汇编语言：assembly</p><ul><li>汇编语言采用助记符（memonic）来编写程序，每一个原本是电气信号的机器语言指令都会有一个与其相应的助记符，助记符通常为指令功能的英语单词的简写</li><li>把汇编语言转化成机器语言的程序称为汇编器（assembler）。有时汇编语言也称为汇编。详情可参阅第 10 章</li><li>通常将汇编语言编写的程序转化成机器语言的过程称为汇编</li><li>将机器语言程序转化成汇编语言程序的过程则称为反汇编</li></ul></li><li><p>机器语言指的是 CPU 可以直接解释和执行的语言</p></li><li><p>高级编程语言：指能够使用类似于人类语言（主要是英语）的语法来记述的编程语言的总称</p><ul><li>BASIC、C、C++、Java、Pascal、FORTRAN、COBOL 等语言都是高级编程语言</li><li>使用高级编程语言编写的程序，经过编译转换成机器语言后才能运行</li><li>与高级编程语言相对，机器语言和汇编语言称为低级编程语言。</li></ul></li><li><p>机器语言级别的程序是通过寄存器来处理的。也就是说，在程序员看来，“CPU 是寄存器的集合体”。至于控制器、运算器和时钟，程序员只需要知道 CPU 中还有这几部分就足够了</p></li><li><p>汇编语言是 80386 以上的 CPU 所使用的语言。eax 和 ebp 是 CPU 内部的寄存器的名称。内存的存储场所通过地址编号来区分，而寄存器的种类则通过名字来区分</p><ul><li>80386 是美国英特尔公司开发的微处理器的产品名。“80386 以上”是指 80386、80486、奔腾等微处理器</li></ul></li><li><p>不同类型的 CPU，其内部寄存器的数量、种类以及寄存器存储的数值范围都是不同的。不过，根据功能的不同，我们可以将寄存器大致划分为八类</p><p><img src="/image/%E7%A8%8B%E5%BA%8F%E6%98%AF%E6%80%8E%E6%A0%B7%E8%B7%91%E8%B5%B7%E6%9D%A5%E7%9A%84/142de7d5b1a81c32e345057adc1ca58f55851671.jpeg" alt="epub90776113jpeg"></p></li><li><p>可以看出，寄存器中存储的内容既可以是指令也可以是数据。其中，数据分为“用于运算的数值”和“表示内存地址的数值”两种。数据种类不同，存储该数值的寄存器也不同</p></li><li><p>CPU 中每个寄存器的功能都是不同的。用于运算的数值放在累加寄存器中存储，表示内存地址的数值则放在基址寄存器和变址寄存器中存储</p></li><li><p>CPU 是具有各种功能的寄存器的集合体。其中，程序计数器、累加寄存器、标志寄存器、指令寄存器和栈寄存器都只有一个，其他的寄存器一般有多个。另外，存储指令的指令寄存器、栈寄存器，由于不需要程序员做多关注，因此下图图中没有提到</p><p><img src="/image/%E7%A8%8B%E5%BA%8F%E6%98%AF%E6%80%8E%E6%A0%B7%E8%B7%91%E8%B5%B7%E6%9D%A5%E7%9A%84/c01dc5ad32acc0ede36852df40430196adfe7b25.jpeg" alt="epub90776114jpeg"></p></li></ul><h3 id="1-3-决定程序流程的程序计数器"><a href="#1-3-决定程序流程的程序计数器" class="headerlink" title="1.3 决定程序流程的程序计数器"></a>1.3 决定程序流程的程序计数器</h3><ul><li><p>用户发出启动程序的指示后，Windows 等操作系统会把硬盘中保存的程序复制到内存中</p></li><li><p>Windows 等操作系统把程序从硬盘复制到内存后，会将程序计数器（CPU 寄存器的一种）设定为指令起始值，然后程序便开始运行</p></li><li><p>CPU 每执行一个指令，程序计数器的值就会自动加 1。当执行的指令占据多个内存地址时，增加与指令长度相应的数值</p></li><li><p>CPU 的控制器就会参照程序计数器的数值，从内存中读取命令并执行。也就是说，程序计数器决定着程序的流程</p></li></ul><h3 id="1-4-条件分支和循环机制"><a href="#1-4-条件分支和循环机制" class="headerlink" title="1.4 条件分支和循环机制"></a>1.4 条件分支和循环机制</h3><ul><li><p>程序的流程分为顺序执行、条件分支和循环三种</p><ul><li><p>顺序执行是指按照地址内容的顺序执行指令</p></li><li><p>条件分支是指根据条件执行任意地址的指令</p></li><li><p>循环是指重复执行同一地址的指令</p></li></ul></li><li><p>条件分支和循环中使用的跳转指令，会参照当前执行的运算结果来判断是否跳转</p></li><li><p>无论当前累加寄存器的运算结果是负数、零还是正数，标志寄存器都会将运算所产生的标志保存下来（也负责存放溢出和奇偶校验的结果)。CPU 在进行运算时，标志寄存器的数值会根据运算结果自动设定。运算结果的正、零、负三种状态由标志寄存器的三个位表示</p><p><img src="/image/%E7%A8%8B%E5%BA%8F%E6%98%AF%E6%80%8E%E6%A0%B7%E8%B7%91%E8%B5%B7%E6%9D%A5%E7%9A%84/0918c8a589e132dd5c5bbe006bdc8262364512d5.jpeg" alt="epub90776121jpeg"></p></li><li><p>条件分支在跳转指令前会进行比较运算。至于是否执行跳转指令，则由 CPU 在参考标志寄存器的数值后进行判断</p></li></ul><h3 id="1-5-函数的调用机制"><a href="#1-5-函数的调用机制" class="headerlink" title="1.5 函数的调用机制"></a>1.5 函数的调用机制</h3><ul><li><p>函数调用处理也是通过把程序计数器的值设定成函数的存储地址来实现的</p></li><li><p>和条件分支、循环的机制有所不同，单纯的跳转指令无法实现函数的调用。函数的调用需要在完成函数内部的处理后，处理流程需要再返回到函数调用点（函数调用指令的下一个地址）。因此，如果只是跳转到函数的入口地址，处理流程就不知道应该返回至哪里了</p></li><li><p>函数调用使用的是 call 指令，而不是跳转指令。在将函数的入口地址设定到程序计数器之前，call 指令会把调用函数后要执行的指令地址存储在名为栈的主存内。函数处理完毕后，再通过函数的出口来执行 return 命令。return 命令的功能是把保存在栈中的地址设定到程序计数器中</p></li></ul><h3 id="1-6-通过地址和索引实现数组"><a href="#1-6-通过地址和索引实现数组" class="headerlink" title="1.6 通过地址和索引实现数组"></a>1.6 通过地址和索引实现数组</h3><ul><li>通过基址寄存器和变址寄存器，可以对主内存上特定的内存区域进行划分，从而实现类似于数组的操作</li></ul><h3 id="1-7-CPU-的处理其实很简单"><a href="#1-7-CPU-的处理其实很简单" class="headerlink" title="1.7 CPU 的处理其实很简单"></a>1.7 CPU 的处理其实很简单</h3><ul><li><p><a href="https://www.zhihu.com/question/22471643">64 位的处理器的地址总线一定也是 64 位吗？</a>、<a href="https://blog.csdn.net/wwwlyj123321/article/details/99940786">cpu 的位宽、操作系统的位宽和寻址能力的关系</a></p><ul><li><p>cpu 的位宽暂时没有严格的定义，但是一般从数值上来讲：cpu 的位宽 &#x3D; 数据总线的位宽 &#x3D; cpu 内部通用寄存器的位宽 &#x3D; 机器字长</p></li><li><p>也就是说 32&#x2F;64 位 CPU，实际上指的是 CPU 内通用寄存器的位宽为 32&#x2F;64</p></li><li><p>通用寄存器为 32&#x2F;64 位，也就意味着数据总线也是 32&#x2F;64 位，因为是需要一次读入 32&#x2F;64 位数据，一次处理 32&#x2F;64 位数据</p></li><li><p>CPU 的寻址能力与它的地址总线位宽有关，与数据总线宽度（CPU 位宽&#x3D;数据总线位宽）无关。16 位 CPU 的地址总线位宽可以是 20 位，32 位 CPU 的地址总线可以是 36 位，64 位 CPU 的地址总线位宽可以是 40 位</p></li></ul></li><li><p>机器语言指令的主要类型和功能</p><p><img src="/image/%E7%A8%8B%E5%BA%8F%E6%98%AF%E6%80%8E%E6%A0%B7%E8%B7%91%E8%B5%B7%E6%9D%A5%E7%9A%84/bde49b7a9fdbaf10f4661f6760a32dd1075555c8.jpeg" alt="epub90776129jpeg"></p></li></ul><h2 id="第二章-数据是用二进制数表示的"><a href="#第二章-数据是用二进制数表示的" class="headerlink" title="第二章 数据是用二进制数表示的"></a>第二章 数据是用二进制数表示的</h2><h3 id="2-1-用二进制数表示计算机信息的原因"><a href="#2-1-用二进制数表示计算机信息的原因" class="headerlink" title="2.1 用二进制数表示计算机信息的原因"></a>2.1 用二进制数表示计算机信息的原因</h3><ul><li><p>IC 是集成电路（Integrated Circuit）的简称，有模拟 IC 和数字 IC 两种。本章介绍的是数字 IC。关于内存 IC，我们会在第 4 章详细说明</p></li><li><p>IC 的所有引脚，只有直流电压 0V 或 5V 两个状态。也就是说，IC 的一个引脚，只能表示两个状态。IC 的这个特性，决定了计算机的信息数据只能用二进制数来处理</p><ul><li>大部分 IC 的电源电压都是 +5V。不过，为了控制电量的消耗，有的 IC 也会使用 +5V 以下的电压。如果 IC 使用的电源电压为 +5V，那么引脚状态就不只是 0V 和 +5V，还存在不接收电流信号的高阻抗（high impedance）状态。但在本书中，我们暂时不考虑高阻抗状态</li></ul></li><li><p>计算机处理信息的最小单位——位，就相当于二进制中的一位。位的英文 bit 是二进制数位（binary digit）的缩写</p></li><li><p>二进制数的位数一般是 8 位、16 位、32 位……也就是 8 的倍数，这是因为计算机所处理的信息的基本单位是 8 位二进制数</p></li><li><p>8 位二进制数被称为一个字节，字节是最基本的信息计量单位</p><ul><li>字节是由 bite（咬）一词而衍生出来的词语。8 位（8 bit）二进制数，就类似于“咬下的一口”，因此被视为信息的基本单位。</li></ul></li><li><p>位是最小单位，字节是基本单位。内存和磁盘都使用字节单位来存储和读写数据，使用位单位则无法读写数据。因此，字节是信息的基本单位</p></li><li><p>用字节单位处理数据时，如果数字小于存储数据的字节数（&#x3D;二进制数的位数），那么高位上就用 0 填补</p></li><li><p>奔腾等 32 位微处理器，具有 32 个引脚以用于信息的输入和输出。也就是说，奔腾一次可以处理 32 位（32 位&#x3D;4 字节）的二进制数信息</p></li><li><p>程序中，即使是用十进制数和文字等记述信息，在编译后也会转换成二进制数的值，所以，程序运行时计算机内部处理的也是用二进制数表示的信息</p></li><li><p>对于用二进制数表示的信息，计算机不会区分它是数值、文字，还是某种图片的模式等，而是根据编写程序的各位对计算机发出的指示来进行信息的处理（运算）</p><ul><li>例如 00100111 这样的二进制数，既可以视为纯粹的数值作加法运算，也可以视为”‘“（单引号，single quotation）文字而显示在显示器上，或者视为■■□■■□□□这一图形模式印刷出来。具体进行何种处理，取决于程序的编写方式</li></ul></li></ul><h3 id="2-2-什么是二进制数"><a href="#2-2-什么是二进制数" class="headerlink" title="2.2 什么是二进制数"></a>2.2 什么是二进制数</h3><ul><li><p>十进制数是以 10 为基数的计数方法，二进制数则是以 2 为基数的计数方法</p></li><li><p>位权&#x3D;基数^位数^</p></li></ul><h3 id="2-3-移位运算和乘除运算的关系"><a href="#2-3-移位运算和乘除运算的关系" class="headerlink" title="2.3 移位运算和乘除运算的关系"></a>2.3 移位运算和乘除运算的关系</h3><ul><li><p>移位运算指的是将二进制数值的各数位进行左右移位（shift&#x3D;移位）的运算。移位有左移（向高位方向）和右移（向低位方向）两种。在一次运算中，可以进行多个数位的移位操作</p></li><li><p>左移后空出来的低位要进行补 0 操作。这一规则只适用于左移运算</p></li><li><p>移位运算也可以通过数位移动来代替乘法运算和除法运算</p></li></ul><h3 id="2-4-便于计算机处理的“补数”"><a href="#2-4-便于计算机处理的“补数”" class="headerlink" title="2.4 便于计算机处理的“补数”"></a>2.4 便于计算机处理的“补数”</h3><ul><li><p>用来填充右移后空出来的高位的数值，有 0 和 1 两种形式</p></li><li><p>二进制数中表示负数值时，一般会把最高位作为符号来使用，因此我们把这个最高位称为符号位。符号位是 0 时表示正数，符号位是 1 时表示负数</p></li><li><p>计算机在做减法运算时，实际上内部是在做加法运算。用加法运算来实现减法运算，为此，在表示负数时就需要使用“二进制的补数”。补数就是用正数来表示负数</p></li><li><p>补数求解的变换方法就是“取反 + 1”</p></li><li><p>仔细思考一下补数的机制，大家就会明白像-32768～32767 这样负数比正数多一个的原因了。最高位是 0 的正数，有 0～32767 共 32768 个，这其中也包含 0。最高位是 1 的负数，有-1～- 32768 共 32768 个，这其中不包含 0。也就是说，0 包含在正数范围内，所以负数就要比正数多 1 个。虽然 0 不是正数，但考虑到符号位，就将其划分到了正数中</p></li></ul><h3 id="2-5-逻辑右移和算术右移的区别"><a href="#2-5-逻辑右移和算术右移的区别" class="headerlink" title="2.5 逻辑右移和算术右移的区别"></a>2.5 逻辑右移和算术右移的区别</h3><ul><li><p>当二进制数的值表示图形模式而非数值时，移位后需要在最高位补 0，这就称为逻辑右移</p></li><li><p>将二进制数作为带符号的数值进行运算时，移位后要在最高位填充移位前符号位的值（0 或 1）。这就称为算术右移</p><ul><li>如果数值是用补数表示的负数值，那么右移后在空出来的最高位补 1，就可以正确地实现 1&#x2F;2、1&#x2F;4、1&#x2F;8 等的数值运算。如果是正数，只需在最高位补 0 即可</li></ul></li><li><p>只有在右移时才必须区分逻辑位移和算术位移。左移时，无论是图形模式（逻辑左移）还是相乘运算（算术左移），都只需在空出来的低位补 0 即可</p></li><li><p>以 8 位二进制数为例，符号扩充就是指在保持值不变的前提下将其转换成 16 位和 32 位的二进制数</p></li><li><p>不管是正数还是用补数表示的负数，都只需用符号位的值（0 或者 1）填充高位即可。这就是符号扩充的方法</p></li></ul><h3 id="2-6-掌握逻辑运算的窍门"><a href="#2-6-掌握逻辑运算的窍门" class="headerlink" title="2.6 掌握逻辑运算的窍门"></a>2.6 掌握逻辑运算的窍门</h3><ul><li><p>在运算中，与逻辑相对的术语是算术。我们不妨这样考虑，将二进制数表示的信息作为四则运算的数值来处理就是算术。而像图形模式那样，将数值处理为单纯的 0 和 1 的罗列就是逻辑</p></li><li><p>计算机能处理的运算，大体可分为算术运算和逻辑运算</p><ul><li><p>算术运算是指加减乘除四则运算</p></li><li><p>逻辑运算是指对二进制数各数字位的 0 和 1 分别进行处理的运算</p></li></ul></li><li><p>逻辑运算包括</p><ul><li><p>逻辑非（NOT 运算）：逻辑非指的是 0 变成 1、1 变成 0 的取反操作</p></li><li><p>逻辑与（AND 运算）：逻辑与指的是“两个都是 1”时，运算结果为 1，其他情况下运算结果都为 0 的运算</p></li><li><p>逻辑或（OR 运算）：逻辑或指的是“至少有一方是 1”时，运算结果为 1，其他情况下运算结果都是 0 的运算</p></li><li><p>逻辑异或（XOR 运算）：XOR 是英语 exclusive or 的缩写。有时也将 XOR 称为 EOR。逻辑异或指的是排斥相同数值的运算。“两个数值不同”，也就是说，当“其中一方是 1，另一方是 0”时运算结果是 1，其他情况下结果都是 0</p></li></ul></li></ul><h2 id="第三章-计算机进行小数运算时出错的原因"><a href="#第三章-计算机进行小数运算时出错的原因" class="headerlink" title="第三章 计算机进行小数运算时出错的原因"></a>第三章 计算机进行小数运算时出错的原因</h2><h3 id="3-1-将-0-1-累加-100-次也得不到-10"><a href="#3-1-将-0-1-累加-100-次也得不到-10" class="headerlink" title="3.1 将 0.1 累加 100 次也得不到 10"></a>3.1 将 0.1 累加 100 次也得不到 10</h3><h3 id="3-2-用二进制数表示小数"><a href="#3-2-用二进制数表示小数" class="headerlink" title="3.2 用二进制数表示小数"></a>3.2 用二进制数表示小数</h3><ul><li>由于计算机内部所有的信息都是以二进制数的形式来处理的，因此在这一点上，整数和小数并无差别。不过，使用二进制数来表示整数和小数的方法却有很大的不同</li></ul><h3 id="3-3-计算机运算出错的原因"><a href="#3-3-计算机运算出错的原因" class="headerlink" title="3.3 计算机运算出错的原因"></a>3.3 计算机运算出错的原因</h3><ul><li><p>计算机之所以会出现运算错误，是因为“有一些十进制数的小数无法转换成二进制数”</p></li><li><p>小数点后 4 位用二进制数表示时的数值范围为 0.0000～0.1111。因此，这里只能表示 0.5、0.25、0.125、0.0625 这四个二进制数小数点后面的位权组合而成（相加总和）的小数</p></li><li><p>无法正确表示的数值，在计算机中最后都变成了近似值</p></li><li><p>计算机这个功能有限的机器设备，是无法处理无限循环的小数的。因此，在遇到循环小数时，计算机就会根据变量数据类型所对应的长度将数值从中间截断或者四舍五入。我们知道，将 0.3333…这样的循环小数从中间截断会变成 0.333333，这时它的 3 倍是无法得出 1 的（结果是 0.999999），计算机运算出错的原因也是同样的道理</p></li></ul><h3 id="3-4-什么是浮点数"><a href="#3-4-什么是浮点数" class="headerlink" title="3.4 什么是浮点数"></a>3.4 什么是浮点数</h3><ul><li><p>很多编程语言中都提供了两种表示小数的数据类型，分别是双精度浮点数和单精度浮点数</p><ul><li><p>双精度浮点数类型用 64 位、单精度浮点数类型用 32 位来表示全体小数</p></li><li><p>在 C 语言中，双精度浮点数类型和单精度浮点数类型分别用 double 和 float 来表示</p></li><li><p>这些数据类型都采用浮点数来表示小数</p></li><li><p>双精度浮点数能够表示的正数范围是 4.94065645841247×10^-324^～1.79769313486232×10^308^，负数范围是-1.79769313486232×10^308^～-4.94065645841247×10^-324^。单精度浮点数能够表示的正数范围是 1.401298×10^-45^～3.402823×10^38^，负数范围是-3.402823×10^38^～-1.401298×10^-45^。在这些范围中，有些数值是无法正确表示的</p></li></ul></li><li><p>浮点数是指用符号、尾数、基数和指数这四部分来表示的小数</p><ul><li>像 0.12345×10^3^和 0.12345×10^-1^这样使用与实际小数点位置不同的书写方法来表示小数的形式称为浮点数。与浮点数相对的是定点数，使用定点数表示小数时，小数点的实际位置固定不变。例如，0.12345×103 和 0.12345 ×10-1 用定点数来表示的话即为 123.45 和 0.012345</li></ul></li><li><p>浮点数表现形式</p><p><img src="/image/%E7%A8%8B%E5%BA%8F%E6%98%AF%E6%80%8E%E6%A0%B7%E8%B7%91%E8%B5%B7%E6%9D%A5%E7%9A%84/68a36c8af4982482b742136c9de96760164f4964.jpeg" alt="epub90776161jpeg"></p></li><li><p>因为计算机内部使用的是二进制数，所以基数自然就是 2。因此，实际的数据中往往不考虑基数，只用符号、尾数、指数这三部分即可表示浮点数。也就是说，64 位（双精度浮点数）和 32 位（单精度浮点数）的数据，会被分为三部分来使用</p></li><li><p>浮点数的内部构造（IEEE 的规定）</p><p><img src="/image/%E7%A8%8B%E5%BA%8F%E6%98%AF%E6%80%8E%E6%A0%B7%E8%B7%91%E8%B5%B7%E6%9D%A5%E7%9A%84/62669bc90c0678387d9685b2f00e03534194f868.jpeg" alt="epub90776162jpeg"></p></li><li><p>双精度浮点数和单精度浮点数在表示同一个数值时使用的位数不同。此外，双精度浮点数能够表示的数值范围要大于单精度浮点数</p></li><li><p>符号部分是指使用一个数据位来表示数值的符号。该数据位是 1 时表示负，为 0 时则表示“正或者 0”。这和用二进制数来表示整数时的符号位是同样的。数值的大小用尾数部分和指数部分来表示。例如，小数就是用“尾数部分× 2 的指数部分次幂”这样的形式来表示的</p></li><li><p>尾数部分和指数部分并不只是单单存储着用整数表示的二进制数。尾数部分用的是“将小数点前面的值固定为 1 的正则表达式”，而指数部分用的则是“EXCESS 系统表现”</p></li></ul><h3 id="3-5-正则表达式和-EXCESS-系统"><a href="#3-5-正则表达式和-EXCESS-系统" class="headerlink" title="3.5 正则表达式和 EXCESS 系统"></a>3.5 正则表达式和 EXCESS 系统</h3><ul><li><p>尾数部分使用正则表达式，可以将表现形式多样的浮点数统一为一种表现形式</p><ul><li>按照特定的规则来表示数据的形式即为正则表达式。除小数之外，字符串以及数据库等，也都有各自的正则表达式</li></ul></li><li><p>在二进制数中，我们使用的是“将小数点前面的值固定为 1 的正则表达式”。具体来讲，就是将二进制数表示的小数左移或右移（这里是逻辑移位。因为符号位是独立的）数次后，整数部分的第 1 位变为 1，第 2 位之后都变为 0（这样是为了消除第 2 位以上的数位）。而且，第 1 位的 1 在实际的数据中不保存。由于第 1 位必须是 1，因此，省略该部分后就节省了一个数据位，从而也就可以表示更多的数据范围（虽不算太多）</p></li><li><p>指数部分中使用的 EXCESS 系统，使用这种方法主要是为了表示负数时不使用符号位</p><ul><li><p>在某些情况下，在指数部分，需要通过“负 x 次幂”的形式来表示负数</p></li><li><p>EXCESS 系统表现是指，通过将指数部分表示范围的中间值设为 0，使得负数不需要用符号来表示</p></li><li><p>也就是说，当指数部分是 8 位单精度浮点数时，最大值 11111111&#x3D;255 的 1&#x2F;2，即 01111111&#x3D;127（小数部分舍弃）表示的是 0，指数部分是 11 位双精度浮点数时，11111111111&#x3D;2047 的 1&#x2F;2，即 01111111111&#x3D;1023（小数部分舍弃）表示的是 0</p></li></ul></li><li><p>单精度浮点数指数部分的 EXCESS 系统表现</p><p><img src="/image/%E7%A8%8B%E5%BA%8F%E6%98%AF%E6%80%8E%E6%A0%B7%E8%B7%91%E8%B5%B7%E6%9D%A5%E7%9A%84/97f6ba27e3286bf8cd4b7616e285d69c7dbc7d5d.jpeg" alt="epub90776168jpeg"></p></li><li><p>作为单精度浮点数的示例，上图中列出了指数部分的实际值和用 EXCESS 系统表现后的值。例如，指数部分为二进制数 11111111（十进制数 255），那么在 EXCESS 系统中则表示为 128 次幂。这是因为 255- 127&#x3D;128。因此，8 位的情况下，表示的范围就是-127 次幂～128 次幂</p></li></ul><h3 id="3-7-如何避免计算机计算出错"><a href="#3-7-如何避免计算机计算出错" class="headerlink" title="3.7 如何避免计算机计算出错"></a>3.7 如何避免计算机计算出错</h3><ul><li><p>计算机计算出错的原因之一是，采用浮点数来处理小数（另外，也有因“位溢出”而造成计算错误的情况）。作为程序的数据类型，不管是使用单精度浮点数还是双精度浮点数，都存在计算出错的可能性</p></li><li><p>可以采取以下两种避免该问题的方法</p><ul><li><p>首先是回避策略，即无视这些错误。根据程序目的的不同，有时一些微小的偏差并不会造成什么问题</p><ul><li>例如，假设使用计算机设计工业制品。将 100 个长 0.1 毫米的零件连接起来后，其长度并非一定要是 10 毫米，10.000002 毫米也没有任何问题。一般来讲，在科学技术计算领域，计算机的计算结果只要能得到近似值就足够了。那些微小的误差完全可以忽略掉</li></ul></li><li><p>另一个策略是把小数转换成整数来计算。计算机在进行小数计算时可能会出错，但进行整数计算（只要不超过可处理的数值范围）时一定不会出现问题。因此，进行小数的计算时可以暂时使用整数，然后再把计算结果用小数表示出来即可</p><ul><li>例如，本章一开头讲过的将 0.1 相加 100 次这一计算，就可以转换为将 0.1 扩大 10 倍后再将 1 相加 100 次的计算，最后把结果除以 10 就可以了</li></ul></li></ul></li><li><p>除此之外，BCD（Binary Coded Decimal）也是一种使用二进制表示十进制的方法。简单来讲，BCD 就是用 4 位来表示 0～9 的 1 位数字的处理方法，这里不再做详细说明</p><ul><li>计算机中用到的数据表现形式中，有一种叫作 BCD（Binary Coded Decimal，二进制化十进制数）的方法。这种方法常被用于老式的大型计算机中。编程语言中，COBOL 也会使用 BCD。BCD 分为 Zone 十进制数形式和 Pack 十进制数形式两种。</li></ul></li><li><p>在涉及财务计算等不允许出现误差的情况下，一定要将小数转换成整数或者采用 BCD 方法，以确保最终得到准确的数值</p></li></ul><h3 id="3-8-二进制数和十六进制数"><a href="#3-8-二进制数和十六进制数" class="headerlink" title="3.8 二进制数和十六进制数"></a>3.8 二进制数和十六进制数</h3><ul><li><p>在以位为单位表示数据时，使用二进制数很方便，但如果位数太多，看起来就比较麻烦。因此，在实际程序中，也经常会用十六进制数来代替二进制数。在 C 语言程序中，只需在数值的开头加上 0x（0 和 x）就可以表示十六进制数</p></li><li><p>二进制数的 4 位，正好相当于十六进制数的 1 位，通过使用十六进制数，二进制数的位数能够缩短至原来的 1&#x2F;4</p></li><li><p>用十六进制数来表示二进制小数时，小数点后的二进制数的 4 位也同样相当于十六进制数的 1 位。不够 4 位时用 0 填补二进制数的低位即可</p></li></ul><h2 id="第四章-熟练使用有棱有角的内存"><a href="#第四章-熟练使用有棱有角的内存" class="headerlink" title="第四章 熟练使用有棱有角的内存"></a>第四章 熟练使用有棱有角的内存</h2><h3 id="4-1-内存的物理机制很简单"><a href="#4-1-内存的物理机制很简单" class="headerlink" title="4.1 内存的物理机制很简单"></a>4.1 内存的物理机制很简单</h3><ul><li><p>内存实际上是一种名为内存 IC 的电子元件。虽然内存 IC 包括 DRAM、SRAM、ROM 等多种形式，但从外部来看，其基本机制都是一样的。内存 IC 中有电源、地址信号、数据信号、控制信号等用于输入输出的大量引脚（IC 的引脚），通过为其指定地址（address），来进行数据的读写</p><ul><li>DRAM（Dynamic Random Access Memory）动态随机存取存储器，需要周期性充电，定期刷新</li><li>SRAM（Static Random-Access Memory）静态随机存取存储器，所谓的“静态”，是指这种存储器只要保持通电，里面储存的数据就可以恒常保持，当电力供应停止时，SRAM 储存的数据还是会消失（被称为 volatile memory），这与在断电后还能储存资料的 ROM 或闪存是不同的</li><li>ROM（Read Only Memory）是一种只能用来读取的内存，以非破坏性读出方式工作，只能读出无法写入信息。信息一旦写入后就固定下来，即使切断电源，信息也不会丢失，所以又称为固定存储器</li></ul></li><li><p>内存 IC 的引脚配置示例：虽然这是一个虚拟的内存 IC，但它的引脚和实际的内存 IC 是一样的。VCC 和 GND 是电源，A0～A9 是地址信号的引脚，D0～D7 是数据信号的引脚，RD 和 WR 是控制信号的引脚。将电源连接到 VCC 和 GND 后，就可以给其他引脚传递比如 0 或者 1 这样的信号。大多数情况下，+ 5V 的直流电压表示 1，0V 表示 0</p><p><img src="/image/%E7%A8%8B%E5%BA%8F%E6%98%AF%E6%80%8E%E6%A0%B7%E8%B7%91%E8%B5%B7%E6%9D%A5%E7%9A%84/993b9220a8ec6d91dc652478d30547613d32cb84.jpeg" alt="epub90776176jpeg"></p></li><li><p>为了向该内存 IC 中写入 1 字节的数据，可以给 VCC 接入 +5V，给 GND 接入 0V 的电源，并使用 A0～A9 的地址信号来指定数据的存储场所，然后再把数据的值输入给 D0～D7 的数据信号，并把 WR（write&#x3D;写入的简写）信号设定成 1。执行完这些操作，就可以在内存 IC 内部写入数据了</p></li><li><p>读出数据时，只需通过 A0～A9 的地址信号指定数据的存储场所，然后再将 RD（read&#x3D;读出的简写）信号设成 1 即可。执行完这些操作，指定地址中存储的数据就会被输出到 D0～D7 的数据信号引脚中</p></li><li><p>向内存 IC 中写入和读出数据的方法</p><p><img src="/image/%E7%A8%8B%E5%BA%8F%E6%98%AF%E6%80%8E%E6%A0%B7%E8%B7%91%E8%B5%B7%E6%9D%A5%E7%9A%84/de9ee9258b27057f128deb1aaca5a85f11bd782e.jpeg" alt="epub90776178jpeg"></p></li><li><p>像 WR 和 RD 这样可以让 IC 运行的信号称为控制信号。其中，当 WR 和 RD 同时为 0 时，写入和读出的操作都无法进行</p></li></ul><h3 id="4-2-内存的逻辑模型是楼房"><a href="#4-2-内存的逻辑模型是楼房" class="headerlink" title="4.2 内存的逻辑模型是楼房"></a>4.2 内存的逻辑模型是楼房</h3><ul><li><p>虽然内存的实体是内存 IC，不过从程序员的角度来看，也可以把它假想成每层都存储着数据的楼房，并不需要过多地关注内存 IC 的电源和控制信号等</p></li><li><p>不过，程序员眼里的内存模型中，还包含着物理内存中不存在的概念，那就是数据类型</p></li><li><p>编程语言中的数据类型表示存储的是何种类型的数据。从内存来看，就是占用的内存大小（占有的楼层数）的意思。即使是物理上以 1 个字节为单位来逐一读写数据的内存，在程序中，通过指定其类型（变量的数据类型等），也能实现以特定字节数为单位来进行读写</p></li><li><p><a href="https://blog.csdn.net/qq_39400113/article/details/119463013">大端模式、小端模式、高字节序、低字节序、MSB、LSB</a></p><ul><li><p>内存的读写永远从低地址开始读&#x2F;写</p></li><li><p>大端模式（Big-Endian）：高位字节存放在低地址中，低位字节存放在高地址中</p></li><li><p>小端模式（Little-Endian）：高位字节存放在高地址中，低位字节存放在低地址中</p></li><li><p>x86 平台是小端的，ARM 平台是小端的，而 PowerPC 平台是大端的</p></li><li><p>字节高低位： 一般左边为高位，右边为低位</p></li></ul></li></ul><h3 id="4-3-简单的指针"><a href="#4-3-简单的指针" class="headerlink" title="4.3 简单的指针"></a>4.3 简单的指针</h3><ul><li><p>指针也是一种变量，它所表示的不是数据的值，而是存储着数据的内存的地址。通过使用指针，就可以对任意指定地址的数据进行读写</p></li><li><p>虽然前面所提到的假想内存 IC 中仅有 10 位地址信号，但大家在 Windows 计算机上使用的程序通常都是 32 位（4 字节）的内存地址。这种情况下，指针变量的长度也是 32 位</p></li><li><p>下面代码定义了 d、e、f 这 3 个指针变量的 C 语言程序。和通常的变量定义有所不同，在定义指针时，我们通常会在变量名前加一个星号（*）</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">char</span> *d;<br><span class="hljs-type">short</span> *e;<br><span class="hljs-type">long</span> *f;<br></code></pre></td></tr></table></figure><ul><li><p>d、e、f 都是用来存储 32 位（4 字节）的地址的变量。然而，为什么这里又用来指定 char（1 字节）、short（2 字节）、long（4 字节）这些数据类型呢？、实际上，这些数据类型表示的是从指针存储的地址中一次能够读写的数据字节数</p></li><li><p>假设 d、e、f 的值都是 100。在这种情况下，使用 d 时就能够从编号 100 的地址中读写 1 个字节的数据，使用 e 时就是 2 个字节（100 地址和 101 地址）的数据，使用 f 时就是 4 个字节（100 地址～103 地址）的数据</p></li></ul></li></ul><h3 id="4-4-数组是高效使用内存的基础"><a href="#4-4-数组是高效使用内存的基础" class="headerlink" title="4.4 数组是高效使用内存的基础"></a>4.4 数组是高效使用内存的基础</h3><ul><li><p>数组是指多个同样数据类型的数据在内存中连续排列的形式。作为数组元素的各个数据会通过连续的编号被区分开来，这个编号称为索引（index）。指定索引后，就可以对该索引所对应地址的内存进行读写操作。而索引和内存地址的变换工作则是由编译器自动实现的</p></li><li><p>数组的定义中所指定的数据类型，也表示一次能够读写的内存大小。char 类型的数组以 1 个字节为单位对内存进行读写，而 short 类型和 long 类型的数组则分别以 2 个字节、4 个字节为单位对内存进行读写</p></li><li><p>之所以说数组是内存的使用方法的基础，是因为数组和内存的物理构造是一样的。特别是 1 字节类型的数组，它和内存的物理构造完全一致。不过，如果只能逐个字节地来读写，程序就会变得比较麻烦，因而可以指定任意数据类型来定义数组</p></li></ul><h3 id="4-5-栈、队列以及环形缓冲区"><a href="#4-5-栈、队列以及环形缓冲区" class="headerlink" title="4.5 栈、队列以及环形缓冲区"></a>4.5 栈、队列以及环形缓冲区</h3><ul><li><p>栈和队列，都可以不通过指定地址和索引来对数组的元素进行读写。需要临时保存计算过程中的数据、连接在计算机上的设备或者输入输出的数据时，都可以通过这些方法来使用内存。如果每次保存临时数据都需指定地址和索引，程序就会变得比较麻烦，因此要加以改进</p></li><li><p>栈和队列的区别在于数据出入的顺序是不同的。在对内存数据进行读写时，栈用的是 LIFO（LastInput First Out，后入先出）方式，而队列用的则是 FIFO（First Input First Out，先入先出）方式。如果在内存中预留出栈和队列所需要的空间，并确定好写入和读出的顺序，就不用再指定地址和索引了</p></li><li><p>通常情况下，往栈写入数据称为 Push（入栈），从栈中读出数据称为 Pop（出栈）。往队列中写入数据称为 EnQueue（入列），从队列中读出数据称为 DeQueue（出列）</p></li><li><p>队列一般是以环状缓冲区（ring buffer）的方式来实现的</p></li></ul><h3 id="4-6-链表使元素的追加和删除更容易"><a href="#4-6-链表使元素的追加和删除更容易" class="headerlink" title="4.6 链表使元素的追加和删除更容易"></a>4.6 链表使元素的追加和删除更容易</h3><ul><li>链表和二叉查找树，都是不用考虑索引的顺序就可以对数组元素进行读写的方式。通过使用链表，可以更加高效地对数组数据（元素）进行追加和删除处理。而通过使用二叉查找树，则可以更加高效地对数组数据进行检索</li></ul><h3 id="4-7-二叉查找树使数据搜索更有效"><a href="#4-7-二叉查找树使数据搜索更有效" class="headerlink" title="4.7 二叉查找树使数据搜索更有效"></a>4.7 二叉查找树使数据搜索更有效</h3><ul><li>二叉查找树是指在链表的基础上往数组中追加元素时，考虑到数据的大小关系，将其分成左右两个方向的表现形式</li></ul><h2 id="第五章-内存和磁盘的亲密关系"><a href="#第五章-内存和磁盘的亲密关系" class="headerlink" title="第五章 内存和磁盘的亲密关系"></a>第五章 内存和磁盘的亲密关系</h2><ul><li><p>从都具有存储程序命令和数据这点来看，内存和磁盘的功能是相同的</p></li><li><p>在计算机的 5 大部件中，内存和磁盘也都被归类为存储部件</p></li><li><p>不过，利用电流来实现存储的内存，同利用磁效应来实现存储的磁盘，还是有差异的</p></li><li><p>从存储容量来看，内存是高速高价，而磁盘则是低速廉价</p></li></ul><h3 id="5-1-不读入内存就无法运行"><a href="#5-1-不读入内存就无法运行" class="headerlink" title="5.1 不读入内存就无法运行"></a>5.1 不读入内存就无法运行</h3><ul><li><p>程序保存在存储设备中，通过有序地被读出来实现运行，这一机制称为存储程序方式（程序内置方式），它的提出是一个里程碑，在此以前的程序都是通过改变计算机的布线等来变更程序的</p></li><li><p>计算机中主要的存储部件是内存和磁盘。磁盘中存储的程序，必须要加载到内存后才能运行。在磁盘中保存的原始程序是无法直接运行的。这是因为，负责解析和运行程序内容的 CPU，需要通过内部程序计数器来指定内存地址，然后才能读出程序</p></li><li><p>即使 CPU 可以直接读出并运行磁盘中保存的程序，由于磁盘读取速度慢，程序的运行速度还是会降低</p></li><li><p>总之，存储在磁盘中的程序需要读入到内存后才能运行</p></li><li><p>CPU 不能直接读取磁盘的数据</p></li></ul><h3 id="5-2-磁盘缓存加快了磁盘访问速度"><a href="#5-2-磁盘缓存加快了磁盘访问速度" class="headerlink" title="5.2 磁盘缓存加快了磁盘访问速度"></a>5.2 磁盘缓存加快了磁盘访问速度</h3><ul><li><p>磁盘缓存指的是把从磁盘中读出的数据存储到内存空间中的方式。这样一来，当接下来需要读取同一数据时，就不用通过实际的磁盘，而是从磁盘缓存中把内容读出。使用磁盘缓存可以大大改善磁盘数据的访问速度</p></li><li><p>磁盘缓存位于内存中</p></li></ul><h3 id="5-3-虚拟内存把磁盘作为部分内存来使用"><a href="#5-3-虚拟内存把磁盘作为部分内存来使用" class="headerlink" title="5.3 虚拟内存把磁盘作为部分内存来使用"></a>5.3 虚拟内存把磁盘作为部分内存来使用</h3><ul><li><p>虚拟内存（virtual memory）是指把磁盘的一部分作为假想的内存来使用。这与磁盘缓存是假想的磁盘（实际上是内存）相对，虚拟内存是假想的内存（实际上是磁盘）</p></li><li><p>通过借助虚拟内存，在内存不足时也可以运行程序。例如，在只剩下 5MB 内存空间的情况下也能运行 10MB 大小的程序。不过，就如本章开头所讲述的那样，CPU 只能执行加载到内存中的程序。虚拟内存虽说是把磁盘作为内存的一部分来使用，但实际上正在运行的程序部分，在这个时间点上是必须存在在内存中的</p></li><li><p>为了实现虚拟内存，就必须把实际内存（也可称为物理内存）的内容，和磁盘上的虚拟内存的内容进行部分置换（swap），并同时运行程序</p></li><li><p>虚拟内存的方法有分页式和分段式两种。Windows 采用的是分页式。该方式是指，在不考虑程序构造的情况下，把运行的程序按照一定大小的页（page）进行分割，并以页为单位在内存和磁盘间进行置换</p></li><li><p>分段式虚拟内存是指，把要运行的程序分割成以处理集合及数据集合等为单位的段落，然后再以分割后的段落为单位在内存和磁盘之间进行数据置换</p></li><li><p>在分页式中，我们把磁盘的内容读出到内存称为 Page In，把内存的内容写入磁盘称为 Page Out。一般情况下，Windows 计算机的页的大小是 4KB。也就是说，把大程序用 4KB 的页来进行切分，并以页为单位放入磁盘（虚拟内存）或内存中</p></li><li><p>分页式虚拟内存的机制</p><p><img src="/image/%E7%A8%8B%E5%BA%8F%E6%98%AF%E6%80%8E%E6%A0%B7%E8%B7%91%E8%B5%B7%E6%9D%A5%E7%9A%84/05aded30366c614389d68aa1e78f478376ea4ea0.jpeg" alt="epub907761108jpeg"></p></li><li><p>为了实现虚拟内存功能，Windows 在磁盘上提供了虚拟内存用的文件（page file，页文件）。该文件由 Windows 自动做成和管理。文件的大小也就是虚拟内存的大小，通常是实际内存的相同程度至两倍程度。通过 Windows 的控制面板，可以查看或变更当前虚拟内存的设定</p></li></ul><h3 id="5-4-节约内存的编程方法"><a href="#5-4-节约内存的编程方法" class="headerlink" title="5.4 节约内存的编程方法"></a>5.4 节约内存的编程方法</h3><ul><li><p>许多人可能会认为，通过借助磁盘虚拟内存就可以解决内存不足的问题。而虚拟内存也确实能避免因内存不足导致的应用无法启动。不过，由于使用虚拟内存时发生的 Page In 和 Page Out 往往伴随着低速的磁盘访问，因此在这个过程中应用的运行会变得迟钝起来</p></li><li><p>为了从根本上解决内存不足的问题，需要增加内存的容量，或者尽量把运行的应用文件变小，以下介绍两种把应用文件变小的编程方法</p></li><li><p>通过 DLL 文件实现函数共有</p><ul><li><p>DLL（Dynamic Link Library）文件，是在程序运行时可以动态加载 Library（函数和数据的集合）的文件</p></li><li><p>多个应用可以共有同一个 DLL 文件。而通过共有同一个 DLL 文件则可以达到节约内存的效果</p></li><li><p>例如，假设我们编写了一个具有某些处理功能的函数 MyFunc()。应用 A 和应用 B 都会使用这个函数。在各个应用的运行文件中内置函数 MyFunc()（这个称为 Static Link，静态链接）后同时运行这两个应用，内存中就存在了具有同一函数的两个程序。但这会导致内存的利用效率降低。如果函数 MyFunc() 是独立的 DLL 文件而不是应用的执行文件（EXE 文件），那结果会怎样呢？由于同一个 DLL 文件的内容在运行时可以被多个应用共有，因此内存中存在的函数 MyFunc() 的程序就只有 1 个。这样一来，内存的利用效率也就提高了</p></li><li><p>Windows 的操作系统本身也是多个 DLL 文件的集合体。有时在安装新应用时，DLL 文件也会被追加。应用则会通过利用这些 DLL 文件的功能来运行。像这样，之所以要利用多个 DLL 文件，其中一个原因就是可以节约内存。而且 DLL 文件还有一个优点就是，在不变更 EXE 文件的情况下，只通过升级 DLL 文件就可以更新</p></li></ul></li><li><p>通过调用_stdcall 来减小程序文件的大小</p><ul><li><p>_stdcall 是 standard call（标准调用）的略称。Windows 提供的 DLL 文件内的函数，基本上都是_stdcall 调用方式。这主要是为了节约内存。另一方面，用 C 语言编写的程序内的函数，默认设置都不是_stdcall。C 语言特有的调用方式称为 C 调用。C 语言之所以默认不使用_stdcall，是因为 C 语言所对应的函数的传入参数是可变的（可以设定任意参数），只有函数调用方才能知道到底有多少个参数，而这种情况下，栈的清理作业便无法进行。不过，在 C 语言中，如果函数的参数数量固定的话，指定_stdcall 是没有任何问题的。</p></li><li><p>通过调用_stdcall 来减小程序文件的方法，是用 C 语言编写应用时可以利用的高级技巧。不过，这一思路应该也可以应用在其他编程语言中</p></li><li><p>C 语言中，在调用函数后，需要执行栈清理处理指令。栈清理处理是指，把不需要的数据从接收和传递函数的参数时使用的内存上的栈区域中清理出去。该命令不是程序记述的，而是在程序编译时由编译器自动附加到程序中的。编译器默认将该处理附加在函数调用方</p></li></ul></li><li><p>_stdcall 的一个例子</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// 函数调用方</span><br><span class="hljs-type">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span><br>&#123;<br>    <span class="hljs-type">int</span> a;<br>    a=MyFunc(<span class="hljs-number">123</span>, <span class="hljs-number">456</span>);<br>&#125;<br><br><span class="hljs-comment">// 被调用方</span><br><span class="hljs-type">int</span> <span class="hljs-title function_">MyFunc</span><span class="hljs-params">(<span class="hljs-type">int</span> a, <span class="hljs-type">int</span> b)</span>&#123;<br>    <span class="hljs-comment">//……</span><br>&#125;<br></code></pre></td></tr></table></figure><ul><li><p>虽然通过调查编译器生成的机器语言执行文件就可以得知栈清理的处理内容，不过鉴于原始的机器语言不太容易理解，所以这里我们用汇编语言的代码清单将其显示了出来。将调用函数 MyFunc() 的部分用汇编语言来表示，就如下面代码所示。最后 1 行的处理就是清理处理</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs nasm">push 1C8h                        参数 456 入栈<br>push 7Bh                         参数 123 入栈<br>call @LTD+15 (MyFunc)(00401014)  调用 MyFunc 函数<br>add esp, 8                       运行栈清理<br></code></pre></td></tr></table></figure></li><li><p>C 语言通过栈来传递函数的参数。push 是往栈中存入数据的指令。32 位 CPU 中，1 次 push 指令可以存储 4 个字节的数据。代码清单 5-2 中，由于使用了两次 push 指令把两个参数（456 和 123）存入到了栈中，因此总的来说就是存储了 8 字节的数据。通过 call 指令调用函数 MyFunc() 后，栈中存储的数据就不再需要了。于是这时就通过 add esp, 8 这个指令，使存储着栈数据的 esp 寄存器前进 8 位（设定为指向高 8 位字节地址），来进行数据清理。由于栈是在各种情况下都可以再利用的内存领域，因此使用完毕后有必要将其恢复到原状态。上述这些操作就是栈的清理处理。另外，在 C 语言中，函数的返回值，是通过寄存器而非栈来返回的</p><ul><li>CPU 中，栈中堆积的最高位的数据地址是保存在 esp（esp 是 Pentium 系列 CPU 的栈指针名）中的。连续运行两次 pop 指令，可以消除两个存储在栈中的 4 字节数据，而同样的功能也可以通过把 esp 的数值加 8 来实现。</li></ul></li><li><p>栈清理处理，比起在函数调用方进行，在反复被调用的函数一方进行时，程序整体要小一些。这时所使用的就是_stdcall。在函数前加上_stdcall，就可以把栈清理处理变为在被调用函数一方进行。把代码清单 5-1 中的 int MyFunc(int a, int b) 部分转成 int _stdcall MyFunc(int a, int b) 进行再编译后，和代码清单 5-2 中 add esp, 8 同样的处理就会在函数 MyFunc() 一方执行。虽然该处理只能节约 3 个字节（add esp, 8 是机器语的 3 个字节）的程序大小，不过在整个程序中还是有效果的</p><p><img src="/image/%E7%A8%8B%E5%BA%8F%E6%98%AF%E6%80%8E%E6%A0%B7%E8%B7%91%E8%B5%B7%E6%9D%A5%E7%9A%84/b0666c9f4fe2e5b76672fff33c0e5ba9ce4b0e02.jpeg" alt="epub907761118jpeg"></p></li></ul></li></ul><h3 id="5-5-磁盘的物理结构"><a href="#5-5-磁盘的物理结构" class="headerlink" title="5.5 磁盘的物理结构"></a>5.5 磁盘的物理结构</h3><ul><li><p>磁盘的物理结构是指磁盘存储数据的形式</p></li><li><p>磁盘是通过把其物理表面划分成多个空间来使用的。划分的方式有扇区方式和可变长方式两种，前者是指将磁盘划分为固定长度的空间，后者则是指把磁盘划分为长度可变的空间</p></li><li><p>一般的 Windows 计算机所使用的硬盘和软盘，采用的都是扇区方式</p></li><li><p>扇区方式中，把磁盘表面分成若干个同心圆的空间就是磁道，把磁道按照固定大小（能存储的数据长度相同）划分而成的空间就是扇区</p><p><img src="/image/%E7%A8%8B%E5%BA%8F%E6%98%AF%E6%80%8E%E6%A0%B7%E8%B7%91%E8%B5%B7%E6%9D%A5%E7%9A%84/9cc43058a57e8d3608d176339d16aced306b5842.jpeg" alt="epub907761119jpeg"></p></li><li><p>扇区是对磁盘进行物理读写的最小单位</p></li><li><p>Windows 中使用的磁盘，一般 1 个扇区是 512 字节。不过，Windows 在逻辑方面（软件方面）对磁盘进行读写的单位是扇区整数倍簇</p></li><li><p>根据磁盘容量的不同，1 簇可以是 512 字节（1 簇&#x3D;1 扇区）、1KB（1 簇&#x3D;2 扇区）、2KB、4KB、8KB、16KB、32KB（1 簇&#x3D;64 扇区）</p></li><li><p>磁盘的容量越大，簇的容量也越大</p></li><li><p>在软盘中，1 簇&#x3D;512 字节&#x3D;1 扇区，簇和扇区的大小是相等的</p></li><li><p>不管是硬盘还是软盘，不同的文件是不能存储在同一个簇中的，否则就会导致只有一方的文件不能被删除。因此，不管是多么小的文件，都会占用 1 簇的空间。这样一来，所有的文件都会占用 1 簇的整数倍的磁盘空间</p></li></ul><h2 id="第六章-亲自尝试压缩数据"><a href="#第六章-亲自尝试压缩数据" class="headerlink" title="第六章 亲自尝试压缩数据"></a>第六章 亲自尝试压缩数据</h2><h3 id="6-1-文件以字节为单位保存"><a href="#6-1-文件以字节为单位保存" class="headerlink" title="6.1 文件以字节为单位保存"></a>6.1 文件以字节为单位保存</h3><ul><li><p>文件是将数据存储在磁盘等存储媒介中的一种形式。程序文件中存储数据的单位是字节。文件的大小之所以用××KB、××MB 等来表示，就是因为文件是以字节（B&#x3D;Byte）为单位来存储的</p></li><li><p>正如本书第 5 章所述，从物理上对磁盘进行读写时是以扇区（512 字节）为单位的。但另一方面，程序则可以在逻辑上以字节为单位对文件的内容进行读写。</p></li><li><p>文件就是字节数据的集合。用 1 字节（&#x3D;8 位）表示的字节数据有 256 种，用二进制数来表示的话，其范围就是 00000000～11111111。如果文件中存储的数据是文字，那么该文件就是文本文件。如果是图形，那么该文件就是图像文件</p></li><li><p>在任何情况下，文件中的字节数据都是连续存储的</p></li></ul><h3 id="6-2-RLE-算法的机制"><a href="#6-2-RLE-算法的机制" class="headerlink" title="6.2 RLE 算法的机制"></a>6.2 RLE 算法的机制</h3><ul><li><p><a href="https://blog.csdn.net/LJH_Gemini/article/details/83832836">全角&#x2F;半角字符？</a></p><ul><li><p>全角：指一个字符占用两个标准字符位置；汉字字符和规定了全角的英文字符及国标 GB2312-80 中的图形符号和特殊字符都是全角字符。一般的系统命令是不用全角字符的，只是在作文字处理时才会使用全角字符</p></li><li><p>半角：值一个字符占用一个标准字符位置；通常的英文字母、数字键、符号键都是半角的，半角的显示内码都是一个字节。在系统内部，以上三种字符是作为基本代码处理的，所以用户输入命令和参数时一般都使用半角</p></li><li><p>全角占两个字节，半角占一个字节。半角全角主要是针对标点符号来说的，全角标点占两个字节，半角占一个字节，而不管是半角还是全角，汉字都还是要占两个字节</p></li><li><p>在编程序的源代码中只能使用半角标点（不包括字符串内部的数据）<br>在不支持汉字等语言的计算机上只能使用半角标点（其实这种情况根本就不存在半角全角的概念）</p></li><li><p>对于大多数字体来说，全角看起来比半角大，当然这不是本质区别了</p></li><li><p>全角就是字母和数字等与汉字占等宽位置的字。半角就是 ASCII 方式的字符，在没有汉字输入法起做用的时候输入的字母数字和字符都是半角的。在汉字输入法出现的时候，输入的字母数字默认为半角，但是标点则是默认为全角，可以通过鼠标点击输入法工具条上的相应按钮来改变</p></li><li><p>全角：是指中 GB2312-80（《信息交换用汉字编码字符集·基本集》）中的各种符号</p></li><li><p>半角：是指英文件 ASCII 码中的各种符号</p></li></ul></li><li><p>把文件内容用“数据×重复次数”的形式来表示的压缩方法称为 RLE（Run LengthEncoding，行程长度编码）算法。RLE 算法是一种很好的压缩方法，经常被用于压缩传真的图像等。因为图像文件本质上也是字节数据的集合体，所以可以用 RLE 算法来压缩</p></li><li><p>RLE 算法示例</p><p><img src="/image/%E7%A8%8B%E5%BA%8F%E6%98%AF%E6%80%8E%E6%A0%B7%E8%B7%91%E8%B5%B7%E6%9D%A5%E7%9A%84/21b083b388aa88c0a3ecc2d4fb538156db7209fa.jpeg" alt="epub907761128jpeg"></p></li><li><p>RLE 算法经常被用于传真 FAX 等。G3 类传真机是把文字和图形都作为黑白图像来发送的。由于黑白图像的数据中，白或黑通常是部分连续的，因此就没有必要再发送这部分数据的值（白或者黑），而只需附带上重复次数即可，这样压缩效率就得到了大幅提升。例如，像白色部分重复 5 次，黑色部分重复 7 次，白色部分重复 4 次，黑色部分重复 6 次这样的部分图像，就可以用 5746 这样的重复次数数字来进行压缩。</p></li></ul><h3 id="6-3-RLE-算法的缺点"><a href="#6-3-RLE-算法的缺点" class="headerlink" title="6.3 RLE 算法的缺点"></a>6.3 RLE 算法的缺点</h3><ul><li>在实际的文本文件中，同样字符多次重复出现的情况并不多见。虽然针对相同数据经常连续出现的图像、文件等，RLE 算法可以发挥不错的效果，但它并不适合文本文件的压缩</li></ul><h3 id="6-4-通过莫尔斯编码来看哈夫曼算法的基础"><a href="#6-4-通过莫尔斯编码来看哈夫曼算法的基础" class="headerlink" title="6.4 通过莫尔斯编码来看哈夫曼算法的基础"></a>6.4 通过莫尔斯编码来看哈夫曼算法的基础</h3><ul><li><p>哈夫曼算法是哈夫曼（D. A. Huffman）于 1952 年提出来的压缩算法。日本人比较常用的压缩软件 LHA，使用的就是哈夫曼算法</p></li><li><p>文本文件是由不同类型的字符组合而成的，而且不同的字符出现的次数也是不同的。例如，在某一个文本文件中，A 出现了 100 次左右，Q 仅用到了 3 次，类似这样的情况是很常见的。而哈夫曼算法的关键就在于“多次出现的数据用小于 8 位的字节数来表示，不常用的数据则可以用超过 8 位的字节数来表示”</p></li><li><p>不过有一点需要注意，不管是不满 8 位的数据，还是超过 8 位的数据，最终都要以 8 位为单位保存到文件中。这是因为磁盘是以字节为单位来保存数据的。为了实现这一处理，压缩程序的内容会复杂很多，不过作为回报，最终得到的压缩率也是相当高的</p></li><li><p><a href="https://zhuanlan.zhihu.com/p/67855882">哈夫曼编码</a></p></li></ul><h3 id="6-5-用二叉树实现哈夫曼编码"><a href="#6-5-用二叉树实现哈夫曼编码" class="headerlink" title="6.5 用二叉树实现哈夫曼编码"></a>6.5 用二叉树实现哈夫曼编码</h3><ul><li><p>哈夫曼算法是指，为各压缩对象文件分别构造最佳的编码体系，并以该编码体系为基础来进行压缩。因此，用什么样式的编码（哈夫曼编码）对数据进行分割，就要由各个文件而定。用哈夫曼算法压缩过的文件中，存储着哈夫曼编码信息和压缩过的数据</p></li><li><p>用哈夫曼算法压缩的文件的构造</p><p><img src="/image/%E7%A8%8B%E5%BA%8F%E6%98%AF%E6%80%8E%E6%A0%B7%E8%B7%91%E8%B5%B7%E6%9D%A5%E7%9A%84/6e3651044f039a2507942b7ee0e45ce5ab159c89.jpeg" alt="epub907761134jpeg"></p></li><li><p>而在哈夫曼算法中，通过借助哈夫曼树构造编码体系，即使在不使用字符区分符号的情况下，也可以构建能够明确进行区分的编码体系。也就是说，利用哈夫曼树后，就算表示各字符的数据位数不同，也能够做成可以明确区分的编码</p></li><li><p>哈夫曼树的编码顺序</p><p><img src="/image/%E7%A8%8B%E5%BA%8F%E6%98%AF%E6%80%8E%E6%A0%B7%E8%B7%91%E8%B5%B7%E6%9D%A5%E7%9A%84/8b5747d5328c5b906aa977b72d823dda14d36539.jpeg" alt="epub907761136jpeg"></p></li></ul><h3 id="6-6-哈夫曼算法能够大幅提升压缩比率"><a href="#6-6-哈夫曼算法能够大幅提升压缩比率" class="headerlink" title="6.6 哈夫曼算法能够大幅提升压缩比率"></a>6.6 哈夫曼算法能够大幅提升压缩比率</h3><ul><li>通过上图的步骤 2 可以发现，在用枝条连接数据时，我们是从出现频率较低的数据开始的，这就意味着出现频率越低的数据到达根部的枝条数就越多。而枝条数越多，编码的位数也就随之增多了</li></ul><h3 id="6-7-可逆压缩和非可逆压缩"><a href="#6-7-可逆压缩和非可逆压缩" class="headerlink" title="6.7 可逆压缩和非可逆压缩"></a>6.7 可逆压缩和非可逆压缩</h3><ul><li><p>图像文件的使用目的通常是把图像数据输出到显示器、打印机等设备上。Windows 的标准图像数据形式为 BMP，是完全未压缩的。由于显示器及打印机输出的 bit（点）是可以直接映射（mapping）的，因此便有了 BMP&#x3D;bitmap 这一名称</p></li><li><p>除 BMP 格式以外，还有其他各种格式的图像数据形式。比如 JPEG 格式、TIFF 格式、GIF 格式等。与 BMP 格式不同的是，这些图像数据都会用一些技法来对数据进行压缩</p></li><li><p>图像文件还可以使用与前文介绍的 RLE 算法、哈夫曼算法不同的其他压缩算法。这是因为，多数情况下，并不要求压缩后的图像文件必须还原到与压缩前同等的质量。与之相比，程序的 EXE 文件以及每个字符、数值都有具体含义的文本文件则必须要还原到和压缩前同样的内容。而对于图像文件来说，即使有时无法还原到压缩前那样鲜明的图像状态，但只要肉眼看不出什么区别，有一些模糊也勉强可以接受</p></li><li><p>把能还原到压缩前状态的压缩称为可逆压缩，无法还原到压缩前状态的压缩称为非可逆压缩</p></li><li><p>JPEG 格式 [插图] 的文件是非可逆压缩，因此还原后的图像信息有一部分是模糊的，数码相机中经常用到的 JPEG 格式文件，有 3 种压缩方式</p><ul><li><p>把构成图像的点阵的颜色信息由 RGB（红色、绿色、蓝色）形式转化成 YCbCr（亮度、蓝色色度、红色色度）形式。我们知道，人眼对亮度很敏感，但对颜色的变化却有些迟钝。因此，人眼比较敏感的亮度 Y 就是一个很重要的参数，而表示颜色的 Cb、Cr 则没有那么重要。于是我们就可以通过减少 Cb 和 Cr 的信息间距来缩小图像数据的大小</p></li><li><p>将每个点的色素变化看作是波形的信号变化，进行傅里叶变换。傅里叶变换是指将波形按照频率分量进行分解。照片等图像文件的特点是低频率（柔和的颜色变化）的部分较多，高频率（强烈的颜色变化）的部分较少。因此，这里我们就可以把高频率的部分剪切掉。这样一来，图像数据也就会缩小。虽然剪切掉了高频率部分，但人眼分辨不出什么差别。不过，如果是用 Windows 画笔描绘的简单图形，其中颜色变化强烈的部分就会出现模糊现象。大家不妨使用 Windows 画笔做一个圆形或者四方形的图形，并将其保存成 JPEG 格式。然后再打开这个 JPEG 文件，你就会发现颜色变化强烈的部分变模糊了</p></li><li><p>最后，将已经瘦身的图像数据通过哈夫曼算法进行压缩。这样就可以使图像数据进一步缩小。</p></li></ul></li><li><p>而 GIF 格式的文件虽然是可逆压缩，但因为有色数不能超过 256 色的限制，所以还原后颜色信息会有一些缺失，进而导致了图像模糊</p></li><li><p>TIFF 格式的图像文件可以做到不模糊，但是却会比原始的 BMP 格式的文件还要大。TIFF 格式的文件中带有各种标签信息，是可以选择压缩格式的，当选择的是与 BMP 同样的无压缩方式时，由于与原始的图像数据相比，TIFF 格式的文件中附加了标签信息，所以结果就比 BMP 格式的文件更大了</p></li><li><p>压缩算法的种类大概有一二十种。之所以会存在如此多的压缩算法，是因为压缩比率、压缩需要的处理时间（程序的复杂程度）以及各种文件的需求等是不一样的</p></li></ul><h2 id="第七章-程序是在何种环境中运行的"><a href="#第七章-程序是在何种环境中运行的" class="headerlink" title="第七章 程序是在何种环境中运行的"></a>第七章 程序是在何种环境中运行的</h2><ul><li><p>需要理解清楚跨平台的含义</p><ul><li><p><a href="https://www.zhihu.com/question/386866683">为什么说 c,c++ 不能跨平台，编译器是在计算机操作系统上吗，难道说编译器不是在 c,c++ 程序里吗？</a></p></li><li><p><a href="https://blog.csdn.net/weixin_39524574/article/details/109971637">python 跨平台原理_为什么 Python 跨平台</a></p></li><li><p>源代码作为文本文件，除了编码的限制，实际上就是跨平台的</p></li><li><p>C&#x2F;C++ 的跨平台是代码级别的，生成的二进制不能跨平台，但是可以跨平台编译部署。这个“跨平台”说的是不修改源码的前提下，可以编译成不同平台的版本。也就是说不用改 C 语言代码，但是要换编译器重新编译一次。</p></li><li><p>对于 Java 这类语言，在源代码和机器代码之间，还有字节码这一层的存在，字节码跨平台，也就是说，只要有 jvm 虚拟机，在任何系统平台上，基本都可以无缝运行字节码</p></li></ul></li></ul><h3 id="7-1-运行环境-x3D-操作系统-硬件"><a href="#7-1-运行环境-x3D-操作系统-硬件" class="headerlink" title="7.1 运行环境&#x3D;操作系统 + 硬件"></a>7.1 运行环境&#x3D;操作系统 + 硬件</h3><ul><li><p>操作系统和硬件决定了程序的运行环境</p></li><li><p>AT 兼容机是指，可以和 IBM 开发的 PC&#x2F;AT 在硬件上相互兼容的计算机的总称。称为“PC&#x2F;AT 兼容机”和“DOS&#x2F;V 机”。现在市面上销售的大部分计算机都是 AT 兼容机。另外，IBM 现在已经把计算机事业部卖给了联想</p></li><li><p>从程序的运行环境这一角度来考量硬件时，CPU 的种类是特别重要的参数。为了保证 Office 2007 的正常运行，需要具备 Pentium 等被称为 x86 的 CPU（微处理器）</p></li><li><p>美国 Intel 的微处理器，是按照 8086、80286、80386、80486、Pentium……这样的顺序不断升级的。因为这些型号的后面都带有 86，所以总称为 x86。32 位处理器也称为“IA-32”。</p></li><li><p><a href="https://zhuanlan.zhihu.com/p/113157931">x86，x64，x86-64，amd64，arm 指令集架构之间的关系</a></p></li><li><p><a href="https://www.jianshu.com/p/2753c45af9bf">【CPU】关于 x86、x86_64&#x2F;x64、amd64 和 arm64&#x2F;aarch64 </a></p><ul><li><p>AMD，中文名（超威）超微半导体，是除了英特尔以外最大的 x86 架构微处理供应商，也是除了英伟达以外仅有的独立图形处理供应商</p></li><li><p>x86 泛指一系列由英特尔公司开发的处理器的架构，最早为 1978 年面世的“Intel 8086”CPU。早期的处理器均是以此格式来命名，如 Intel 8086，80186，80286，80386，80486，这些架构被统称为 x86。由于数字不能被注册成为商标，因此公司每当有新的处理器使用，均会采用可注册的名称，如 Pentium</p></li><li><p>基于 x86 的 32 位架构，IA-32 常被称为 i386，x86</p></li><li><p>基于 x86 的 64 位架构，x86-64 常称为 AMD64 或 Intel64。最早是由 AMD 公司首先根据 x86 的架构生产出了 64 位的处理器，但是由于是竞争关系，Intel 公司不愿意承认 AMD64，近些年才推出了 Intel 64</p></li><li><p>ARM（英文为 Advanced RISC Machine，或 Acorn RISC Machine）也是一个架构，非常适用于移动通信这种低成本，高性能，低耗电的领域</p></li><li><p>ARM 的公司为安谋控股（ARM Holding plc），又称为 ARM 公司，总部位于剑桥的设计与软件公司，现在已被日本的软银公司收购，后者同时也是国内互联网巨头阿里巴巴的最大股东</p></li><li><p>AArch64 是 ARMv8 的一种执行状态。AArch64 不是一个单纯的 32 位 ARM 构架扩展，而是 ARMv8 内全新的构架，完全使用全新的 A64 指令集。这些都源自于多年对现代构架设计的深入研究。更重要的是， AArch64 作为一个分离出的执行状态，意味着一些未来的处理器可能不支持旧的 AArch32 执行状态</p></li></ul></li><li><p>几家比较知名的微处理器厂商：Intel、AMD、高通、联发科、海思……</p></li><li><p>CPU 只能解释其自身固有的机器语言。不同的 CPU 能解释的机器语言的种类也是不同的。例如，CPU 有 x86、MIPS、SPARC、PowerPC 等几种类型，它们各自的机器语言是完全不同的</p><ul><li><p>MIPS 是美国 MIPS 科技公司开发的 CPU。曾出现过面向 MIPS 工作站的 Windows，不过现在市面上已经不再出售了</p></li><li><p>SPARC 是美国 SUN 系统开发的 CPU。很多工作站都采用了该 CPU</p></li><li><p>PowerPC 是美国苹果、IBM、摩托罗拉共同开发的 CPU。苹果的 Power Mac 及 IBM 的工作站都采用了该 CPU。不过 Mac 后来采用的是 Intel 的 x86 系列 CPU，现在正在使用基于 arm 的自研 M 系列芯片</p></li></ul></li><li><p>机器语言的程序称为本地代码（native code）。程序员用 C 语言等编写的程序，在编写阶段仅仅是文本文件。文本文件（排除文字编码的问题）在任何环境下都能显示和编辑。我们称之为源代码。通过对源代码进行编译，就可以得到本地代码。在市面上出售的用于 Windows 的应用软件包 CD-ROM 中，收录的就不是源代码，而是本地代码</p></li></ul><h3 id="7-2-Windows-克服了-CPU-以外的硬件差异"><a href="#7-2-Windows-克服了-CPU-以外的硬件差异" class="headerlink" title="7.2 Windows 克服了 CPU 以外的硬件差异"></a>7.2 Windows 克服了 CPU 以外的硬件差异</h3><ul><li><p>MS-DOS（Microsoft Disk Operating System）是 20 世纪 80 年代普遍使用的计算机操作系统，也是 Windows 的前身操作系统</p></li><li><p>在 20 年前的 MS-DOS 时代，日本国内市场上有 NEC 的 PC-9801、富士通的 FMR、东芝的 Dynabook 等各种机型的计算机。Windows3.0 及 3.1 问世前后，AT 兼容机开始普及，并开始同 PC-9801 争夺市场份额。这些机型虽然都搭载了 486 及 Pentiunm 等 x86 系列的 CPU，不过内存和 I&#x2F;O 地址的构成等都是不同的，因此每个机型都需要有专门的 MS-DOS 应用。x86 提供有专门用来同外围设备进行输入输出的 I&#x2F;O 地址空间（I&#x2F;O 地址分配）。至于各外围设备会分配到什么样的地址，则要由计算机的机型来定</p></li><li><p>为什么 MS-DOS 时代，软件需要提供各个机型专用的软件？这是因为，应用软件的功能中，存在着直接操作计算机硬件的部分。而这又是为什么呢？原因主要有两点，一是当时 MS-DOS 的功能尚不完善，二是为了提高程序的运行速度</p></li><li><p>随着 Windows 的广泛使用，这样的局面也得到了大幅改善。因为只要 Windows 能正常运行，同样的应用（本地代码）在任何机型上都是可以运行的</p></li><li><p>在 Windows 的应用软件中，键盘输入、显示器输出等并不是直接向硬件发送指令，而是通过向 Windows 发送指令来间接实现的。因此，程序员就不用注意内存和 I&#x2F;O 地址的不同构成了</p></li><li><p>因为 Windows 操作的是硬件而非应用软件，而且针对不同的机型，这些硬件的构成也是有差异的。不过，Windows 本身则需要为不同的机型分别提供专用的版本，比如用于 AT 兼容机的 Windows、用于 PC-9081 的 Windows 等</p></li><li><p>而即便是 Windows，也依然无法吸收 CPU 类型的差异。这是因为，市面上销售的 Windows 应用软件，都是用特定的 CPU 的本地代码来完成的</p></li><li><p>MS-DOS 应用大多都是不经过操作系统而直接控制硬件的，而 Windows 应用则基本上都由 Windows 来完成对硬件的控制</p><p><img src="/image/%E7%A8%8B%E5%BA%8F%E6%98%AF%E6%80%8E%E6%A0%B7%E8%B7%91%E8%B5%B7%E6%9D%A5%E7%9A%84/acaa00c7b8963cfb07d69ed25fa2d1a70ebf69fa.jpeg" alt="epub907761157jpeg"></p></li></ul><h3 id="7-3-不同操作系统的-API-不同"><a href="#7-3-不同操作系统的-API-不同" class="headerlink" title="7.3 不同操作系统的 API 不同"></a>7.3 不同操作系统的 API 不同</h3><ul><li><p>同样机型的计算机，可安装的操作系统类型也会有多种选择。例如，AT 兼容机的情况下，除 Windows 之外，还可以采用 Unix 系列的 Linux 及 FreeBSD 等多个操作系统。当然，应用软件则必须根据不同的操作系统类型来专门开发</p></li><li><p>CPU 的类型不同，所对应的机器语言也不同，同样的道理，操作系统的类型不同，应用程序向操作系统传递指令的途径也是不同的</p></li><li><p>应用程序向操作系统传递指令的途径称为 API（Application Programming Interface）</p><ul><li><p>API 也称为“系统调用”，是应用调用操作系统功能的手段</p></li><li><p>Windows 及 Unix 系列操作系统的 API，提供了任何应用程序都可以利用的函数组合</p></li></ul></li><li><p>因为不同操作系统的 API 是有差异的，因此，将同样的应用程序移植到其他操作系统时，就必须要重写应用中利用到 API 的部分</p></li><li><p>像键盘输入、鼠标输入、显示器输出、文件输入输出等同外围设备进行输入输出操作的功能，都是通过 API 提供的</p></li><li><p>在同类型操作系统下，不管硬件如何，API 基本上没有差别。因而，针对某特定操作系统的 API 所编写的程序，在任何硬件上都可以运行。当然，由于 CPU 种类不同，机器语言也不相同，因此本地代码当然也是不同的。这种情况下，就需要利用能够生成各 CPU 专用的本地代码的编译器，来对源代码进行重新编译了</p></li></ul><h3 id="7-4-FreeBSD-Port-帮你轻松使用源代码"><a href="#7-4-FreeBSD-Port-帮你轻松使用源代码" class="headerlink" title="7.4 FreeBSD Port 帮你轻松使用源代码"></a>7.4 FreeBSD Port 帮你轻松使用源代码</h3><ul><li><p>Unix 系列操作系统 FreeBSD 中，存在一种名为 Ports 的机制。该机制能够结合当前运行的硬件环境来编译应用的源代码，进而得到可以运行的本地代码系统。如果目标应用的源代码没有在硬件上的话，Ports 就会自动使用 FTP 连接到相关站点来下载代码</p></li><li><p>全球很多站点都提供适用于 FreeBSD 的应用源代码。通过使用 Ports 可以利用的程序源代码，大约有 16000 种。这些代码还被按照不同的领域进行了分类整理，可以随时拿来使用</p></li><li><p>FreeBSD 上应用的源代码，大部分都是用 C 语言来记述的。FreeBSD 等 Unix 系列操作系统中，都带有标准的 C 编译器。C 编译器可以结合 FreeBSD 的运行环境生成合适的本地代码。因而，使用 FreeBSD 的同时，肯定也会享受到 Ports 带来的益处。可以说 Ports 能够克服包含 CPU 在内的所有硬件差异的系统。而且，Ports 这个术语，表示的是 porting（移植）的意思。而根据不同的运行环境来重新调整程序，一般也称为“移植”</p></li></ul><h3 id="7-5-利用虚拟机获得其他操作系统环境"><a href="#7-5-利用虚拟机获得其他操作系统环境" class="headerlink" title="7.5 利用虚拟机获得其他操作系统环境"></a>7.5 利用虚拟机获得其他操作系统环境</h3><ul><li><p>即使不通过移植，也可以利用虚拟机软件来运行其他操作系统的应用</p></li><li><p>Virtual PC for MAC 可以使 Macintosh 这一硬件变得同 AT 兼容机一样，从而能在该硬件上安装 Windows。这样一来，Windows 下的所有应用就都可以正常运行了。Windows 应用利用的是 Windows 操作系统的 API。虽然表面上是 Windows 将硬件处理为了 AT 兼容机，但由于 Virtual PC forMAC 的作用，实际上运行的是 Macintosh 这一硬件</p></li></ul><h3 id="7-6-提供相同运行环境的-Java-虚拟机"><a href="#7-6-提供相同运行环境的-Java-虚拟机" class="headerlink" title="7.6 提供相同运行环境的 Java 虚拟机"></a>7.6 提供相同运行环境的 Java 虚拟机</h3><ul><li><p>除虚拟机的方法之外，还有一种方法能够提供不依赖于特定硬件及操作系统的程序运行环境，那就是 Java</p></li><li><p>大家说的 Java，有两个层面的意思。一个是作为编程语言的 Java，另一个是作为程序运行环境的 Java</p></li><li><p>同其他编程语言相同，Java 也是将 Java 语法记述的源代码编译后运行。不过，编译后生成的并不是特定 CPU 使用的本地代码，而是名为字节代码的程序。字节代码的运行环境就称为 Java 虚拟机（JavaVM, Java Virtual Machine）。Java 虚拟机是一边把 Java 字节代码逐一转换成本地代码一边运行的</p></li><li><p>Windows 有 Windows 专用的 Java 虚拟机，Macintosh 也有 Macintosh 专用的 Java 虚拟机。从操作系统方面来看，Java 虚拟机是一个应用，而从 Java 应用方面来看，Java 虚拟机就是运行环境</p></li><li><p>Java 虚拟机也存在不少问题</p><ul><li><p>其中一点就是，不同的 Java 虚拟机之间无法进行完整互换。这是因为，想让所有字节代码在任意 Java 虚拟机上都能运行是比较困难的。而且，当我们使用只适用于某些特定硬件的功能时，就会出现在其他 Java 虚拟机上无法运行，或者功能使用受限等情况</p></li><li><p>另一点就是运行速度的问题。Java 虚拟机每次运行时都要把字节代码变换成本机代码，这一机制是造成运行速度慢的原因。为此，目前业界也在努力改善这一问题，比如把首次变换后的本地代码保存起来，第 2 次以后直接利用本地代码，或是对字节代码中处理较为费时的部分进行优化（改善生成的本地代码质量）等</p></li></ul></li></ul><h3 id="7-7-BIOS-和引导"><a href="#7-7-BIOS-和引导" class="headerlink" title="7.7 BIOS 和引导"></a>7.7 BIOS 和引导</h3><ul><li><p>程序的运行环境中，存在着名为 BIOS（Basic Input&#x2F;Output System）的系统。BIOS 存储在 ROM 中，是预先内置在计算机主机内部的程序。BIOS 除了键盘、磁盘、显卡等基本控制程序外，还有启动“引导程序”的功能</p></li><li><p>引导程序是存储在启动驱动器起始区域的小程序。操作系统的启动驱动器一般是硬盘，不过有时也可以是 CD-ROM 或软盘</p></li><li><p>开机后，BIOS 会确认硬件是否正常运行，没有问题的话就会启动引导程序。引导程序的功能是把在硬盘等记录的 OS 加载到内存中运行。虽然启动应用是 OS 的功能，但 OS 并不能自己启动自己，而是通过引导程序来启动</p></li><li><p>Bootstrap 的原意是指靴子上部的“拔靴带”。BIOS 这样小的程序（拔靴带），可以带动（启动）操作系统这样的大程序（靴子），所以由此得名</p></li></ul>]]></content>
    
    
    <categories>
      
      <category>笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>基础体系</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【笔记】cURL必知必会</title>
    <link href="/posts/9f5d61d7.html"/>
    <url>/posts/9f5d61d7.html</url>
    
    <content type="html"><![CDATA[<div class="note note-success">            <p>秉持着在实践中学习的想法，最近为了研究学习计算机网络哪一堆东西，前前后后学了不少 UNIX&#x2F;Linux 环境下一些网络工具（如 tcpdump、curl、tshark、nmap 等）的用法。</p><p>这份笔记摘录于丹尼尔·斯坦伯格的《cURL 必知必会》。这本书前前后后详细地介绍了 cURL 项目的内容（curl 命令行工具、libcurl 库），我对其中的 curl 命令行工具的用法较为感兴趣，特此总结出来笔记。</p><p>注意，《cURL 必知必会》为“手册”类型书籍，书中的描述已经极为精简干练毫不拖泥带水，基本上不需要我再进行修补裁剪。本笔记最大的目的是方便我自己以后检索查找。因此对于描写的已经很 ok 的原文，我就不班门弄斧进行修改，直接 copy 过来了，所以你常常可以看出来大段大段的原文句子。</p>          </div><h2 id="第一章-curl-可以做什么"><a href="#第一章-curl-可以做什么" class="headerlink" title="第一章 curl 可以做什么"></a>第一章 curl 可以做什么</h2><ul><li><p>curl 关心所有与网络协议传输相关的东西，那些与此无关的就留给其他项目和产品去操心吧。</p></li><li><p>curl 和 libcurl 试图避免直接处理被传输的数据。例如，它们对 HTML 或通过 HTTP 传输的内容一无所知，只知道如何通过 HTTP 传输这些数据。</p></li><li><p>curl 的一个常见使用场景是像浏览器那样获取 URL，但浏览器做的事情比 curl 要多得多，curl 在终端输出的内容可能与你在浏览器窗口中看到的内容完全不一样。</p></li><li><p>curl 只会获取你要求它获取的内容，但永远不会解析获取到的内容，也就是服务器发送的数据。</p></li><li><p>浏览器在获取数据后会根据内容类型激活不同的解析器。例如，如果数据是 HTML，那么它会进行解析并显示网页，还可能会下载其他子资源，如图像、JavaScript 和 CSS 文件。curl 在下载 HTML 时只会获取单个 HTML 资源，而在浏览器中，则可能会触发更多下载。如果你希望 curl 也下载子资源，那么需要将这些 URL 传给 curl 并要求它获取这些 URL，就像其他 URL 一样。</p></li></ul><h2 id="第二章-命令行基础"><a href="#第二章-命令行基础" class="headerlink" title="第二章 命令行基础"></a>第二章 命令行基础</h2><ul><li><p>curl 是一个可执行的二进制文件，但 cURL 项目本身不提供二进制文件。curl 的二进制文件需要根据不同的操作系统进行构建，而且通常受不同版本系统的约束。</p></li><li><p>curl 很少会自己决定做什么，它试图在最大程度上让你做自己想做的。你给它什么，它就会处理什么。如果你提供一个拼写错误的选项，那么它可能会做出预想不到的事情。如果你给它一个不合法的 URL，那么它仍然会继续处理它。</p></li><li><p>在 curl 的使用中，curl 只处理选项和 URL，也就是说，如果不是选项，就一定是 URL</p></li></ul><h3 id="2-1-命令行选项"><a href="#2-1-命令行选项" class="headerlink" title="2.1 命令行选项"></a>2.1 命令行选项</h3><ul><li><p>curl 支持 200 多个不同的选项。</p></li><li><p>命令行选项可以将你想要用 curl 执行的任务的信息传给 curl。</p></li></ul><h4 id="2-1-1-短选项"><a href="#2-1-1-短选项" class="headerlink" title="2.1.1 短选项"></a>2.1.1 短选项</h4><ul><li><p>短选项是只有一个字母的选项，一般也会提供对应的长选项</p></li><li><p><code>-v</code>：让 curl 切换到详细（verbose）模式</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">curl -v http://example.com<br></code></pre></td></tr></table></figure></li><li><p><code>-L</code>：使得 HTTP 重定向</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">curl -L http://example.com<br></code></pre></td></tr></table></figure></li><li><p>很多选项属于切换开关，用于启用某些功能或切换两个已知状态。</p></li><li><p>指定对应的选项名称即可使用这些选项。你也可以在减号后面组合使用多个单字母选项。当然，你也可以单独指定短选项。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">curl -vL http://example.com<br>curl -v -L http://example.com<br></code></pre></td></tr></table></figure></li><li><p>curl 的命令行解析器会解析整行命令，你可以将选项放在任意位置，它们甚至可以出现在 URL 之后。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">curl -v http://example.com<br>curl http://example.com -v<br></code></pre></td></tr></table></figure></li></ul><h4 id="2-1-2-长选项"><a href="#2-1-2-长选项" class="headerlink" title="2.1.2 长选项"></a>2.1.2 长选项</h4><ul><li><p>短选项使用起来非常方便，因为它们的名字很简短。但因为字母的数量有限，需要用到的选项又比较多，所以并非所有选项都可以使用单个字母来表示，于是就有了长选项。</p></li><li><p>另外，为了方便，也为了让脚本更易于阅读，大多数短选项都有对应的长选项别名。</p></li><li><p>长选项使用两个减号（或者称为破折号），后面跟上选项名，而且每两个减号后面只能跟一个选项名</p></li><li><p><code>--verbose</code>：打开详细模式</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">curl --verbose http://example.com<br></code></pre></td></tr></table></figure></li><li><p><code>--location</code>：使得 HTTP 重定向</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">curl --location http://example.com<br></code></pre></td></tr></table></figure></li></ul><h4 id="2-1-3-选项的参数"><a href="#2-1-3-选项的参数" class="headerlink" title="2.1.3 选项的参数"></a>2.1.3 选项的参数</h4><ul><li><p>并非所有选项都只用于启用或禁用某项功能。对于一些选项，你需要向它们传递一些数据，如用户名或文件路径。你需要先指定选项，然后给出参数，中间用空格分隔。</p></li><li><p><code>-d</code>或<code>--data</code>：可以通过 HTTP POST 将一个字符串发送给服务器</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">curl -d hello http://example.com<br>curl --data hello http://example.com<br></code></pre></td></tr></table></figure></li><li><p>如果使用带参数的短选项，可以不使用空格进行分隔</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">curl -dhello http://example.com<br></code></pre></td></tr></table></figure></li></ul><h4 id="2-1-4-带空格的参数"><a href="#2-1-4-带空格的参数" class="headerlink" title="2.1.4 带空格的参数"></a>2.1.4 带空格的参数</h4><ul><li><p>有时你会想要向选项传递参数，而且参数中包含了一个或多个空格。此时你需要给字符串加上引号。使用的引号因不同的 shell 或命令提示符而异，但大多数情况下可以使用双引号。</p></li><li><p><code>-A</code>：设置 HTTP 请求的 user-agent 字段</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">curl -A <span class="hljs-string">&quot;Hello World&quot;</span> http://example.com<br></code></pre></td></tr></table></figure></li><li><p>如果字符串本身包含了双引号，比如想要向服务器发送 JSON 字符串（这种情况很常见），你可能需要使用单引号（但在 Windows 系统上使用单引号可能不行）。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">curl -d <span class="hljs-string">&#x27;&#123;&quot;name&quot;: &quot;Darth&quot;&#125;&#x27;</span> http://example.com<br></code></pre></td></tr></table></figure></li><li><p>如果想要避免使用单引号，则可以通过文件将数据传给 curl，这样就无须使用额外的引用。</p></li></ul><h4 id="2-1-5-负选项"><a href="#2-1-5-负选项" class="headerlink" title="2.1.5 负选项"></a>2.1.5 负选项</h4><ul><li><p>对于开关选项，既可以用它们打开某些功能，也可以通过它们关闭功能。你也可以使用长选项，在选项名前面加上“no-”前缀即可。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 关闭详细模式</span><br>curl --no-verbose http://example.com<br></code></pre></td></tr></table></figure></li></ul><h3 id="2-2-URL"><a href="#2-2-URL" class="headerlink" title="2.2 URL"></a>2.2 URL</h3><ul><li><p>URL 就是 curl 的操作对象。</p></li><li><p>URL：Uniform Resource Locator，统一资源定位符</p></li><li><p>严格来说，URL 是之前使用的名称，URI（Uniform Resource Identifier，统一资源标识符）才是更现代、更正确的叫法。RFC 3986 给出了它们的语法定义。</p></li><li><p>curl 接受“URL”作为输入，但实际上是“URI”。curl 支持的大多数协议也有相应的 URI 语法文档，这些文档描述了这些 URI 格式的工作原理。</p></li><li><p>curl 假定你会传给它一个有效的 URL，它只对格式进行有限的检查，以提取执行操作所需要的信息。你可能会将包含非法字符的 URL 传给 curl，但 curl 并不会注意到，也不关心这些，它只会继续执行自己的操作。</p></li><li><p>现代 Web 浏览器的“地址栏”中一般使用的不是 URL 或 URI。实际上，它们主要使用 IRI，也就是 URI 的超集，以支持国际化（如支持非拉丁符号）。它们还会处理空格、编码地址等，但规范中并没有说明这些事情应该由客户端完成。有时你在浏览器地址栏中看到的内容与传给 curl 的内容存在很大差别。</p></li></ul><h4 id="2-2-1-scheme"><a href="#2-2-1-scheme" class="headerlink" title="2.2.1 scheme"></a>2.2.1 scheme</h4><ul><li><p>URL 以“scheme”作为开头，scheme 是“http:&#x2F;&#x2F;”这部分内容的官方名称，用于告诉 curl 传入的 URL 使用了哪个协议。</p></li><li><p>scheme 必须受当前 curl 版本支持，否则 curl 将显示错误消息并退出。此外，scheme 既不能以空格开头，也不能包含空格。</p></li><li><p>“:&#x2F;&#x2F;”（一个冒号和两个斜杠）将 scheme 标识符与 URL 的其余部分分开。有些 URL 只包含一个斜杠，但 curl 不支持这种格式</p></li><li><p>curl 允许一些非法语法，并尝试在内部纠正它们，因此它也可以理解并接受一些带有一个或三个斜杠的 URL，即使它们的格式不正确。curl 这么做的原因是，浏览器已经开始支持这些 URL，进而导致这种 URL 大量存在。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># file://类型的 URL 写作 file://&lt;hostname&gt;/&lt;path&gt;</span><br><span class="hljs-comment"># 但主机名部分只能是 localhost、127.0.0.1 或空白（什么都没有）</span><br><span class="hljs-comment"># 如果在主机名部分使用其他主机名，curl 将返回错误</span><br>file://localhost/path/to/file<br>file:///path/to/file<br></code></pre></td></tr></table></figure></li><li><p>为方便起见，curl 还允许用户省略 URL 的 scheme 部分</p><ul><li><p>curl 会根据主机名的第一部分猜测要使用哪种协议。这是一种非常基本的猜测，因为它只检查主机名的第一部分是否与一组协议中的某个协议匹配，并假定你打算使用的就是这个协议。</p></li><li><p>这主要基于传统的服务器命名方式。可以通过这种方式检测的协议包括 FTP、DICT、LDAP、IMAP、SMTP 和 POP3。没有提供 scheme 的其他 URL 将默认使用 HTTP。</p></li><li><p>可以通过<code>--proto-default</code>选项将默认协议修改为 HTTP 以外的其他协议。</p></li></ul></li><li><p><code>--proto-default</code>：将默认协议修改为 HTTP 以外的其他协议。</p></li></ul><h4 id="2-2-2-用户名和密码"><a href="#2-2-2-用户名和密码" class="headerlink" title="2.2.2 用户名和密码"></a>2.2.2 用户名和密码</h4><ul><li><p>scheme 后面可以跟用户名和密码。现在通常不建议使用这种语法，因为这样很容易在脚本或其他地方泄露这些信息。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 使用给定的用户名和密码列出 FTP 服务器目录中的内容</span><br>curl ftp://user:password@example.com/<br></code></pre></td></tr></table></figure></li><li><p>在 URL 中显示用户名和密码只是可选项，curl 还允许在 URL 之外，即通过正常的命令行选项来提供这些信息。</p></li></ul><h4 id="2-2-3-主机名或地址"><a href="#2-2-3-主机名或地址" class="headerlink" title="2.2.3 主机名或地址"></a>2.2.3 主机名或地址</h4><ul><li><p>URL 的主机名部分只是一个可以解析为数字 IP 地址的名字，或者是数字 IP 地址本身。</p></li><li><p>在指定数字 IP 地址时，可以使用 IPv4 地址。如果使用的是 IPv6 地址，则需要将其放在方括号中。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">curl http://127.0.0.1/<br>curl http://[::1]/<br></code></pre></td></tr></table></figure></li><li><p>如果使用的是主机名，系统解析器会将主机名转换为 IP 地址。这通常需要在&#x2F;etc&#x2F;hosts 文件（或等效文件）中进行本地域名查找。</p></li></ul><h4 id="2-3-4-端口号"><a href="#2-3-4-端口号" class="headerlink" title="2.3.4 端口号"></a>2.3.4 端口号</h4><ul><li>每个协议都有一个“默认端口”，除非特别指定了端口号。在 URL 中指定端口号时，先在主机名后面添加一个冒号，然后是十进制的端口号。</li></ul><h4 id="2-3-5-路径"><a href="#2-3-5-路径" class="headerlink" title="2.3.5 路径"></a>2.3.5 路径</h4><ul><li><p>每个 URL 都包含一个路径。如果没有指定，则默认使用“&#x2F;”。路径将被发送给指定的服务器，用于识别要请求的资源。路径的用法取决于具体的协议。</p></li><li><p>对于具有目录概念的协议，可以在 URL 尾部以一个斜杠表示它是目录，而不是文件。</p></li></ul><h4 id="2-3-6-FTP-类型"><a href="#2-3-6-FTP-类型" class="headerlink" title="2.3.6 FTP 类型"></a>2.3.6 FTP 类型</h4><ul><li><p>用于标识 FTP 服务器文件的 URL 提供了一个特性来告诉客户端（这里是 curl）资源的文件类型。这是因为 FTP 可以改变传输模式，在不同的模式下使用不同的处理方式。注意该特性没有被广泛使用</p></li><li><p>通过在 URL 中附加“; type&#x3D;A”，你可以告诉 curl 当前的 FTP 资源是 ASCII 类型。</p></li><li><p>curl 默认为 FTP 使用二进制传输模式，但是你也可以在 URL 中通过 type&#x3D;I 来指定二进制类型。</p></li><li><p>如果你传给 curl 的类型是 D，那么就是表明请求的资源是一个目录。这可以作为目录的替代格式，不需要像之前那样在路径尾部添加斜杠。</p></li><li><p>示例：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash">curl <span class="hljs-string">&quot;ftp://example.com/hello; type=A&quot;</span><br>curl <span class="hljs-string">&quot;ftp://example.com/hello; type=I&quot;</span><br>curl <span class="hljs-string">&quot;ftp://example.com/hello; type=D&quot;</span><br></code></pre></td></tr></table></figure></li></ul><h4 id="2-3-7-片段"><a href="#2-3-7-片段" class="headerlink" title="2.3.7 片段"></a>2.3.7 片段</h4><ul><li>URL 中还可以包含“片段”，这通常由井号（#）和网页中的特定名字组成。curl 可以支持带有片段的 URL，但实际上片段并不会被发送出去，因此，无论是否存在，它对 curl 的操作并没有任何影响。</li></ul><h4 id="2-3-8-多个选项和多个-URL"><a href="#2-3-8-多个选项和多个-URL" class="headerlink" title="2.3.8 多个选项和多个 URL"></a>2.3.8 多个选项和多个 URL</h4><ul><li><p>curl 支持数百个命令行选项和无限数量的 URL。如果你的 shell 或命令行系统能够支持，那么传给 curl 的命令行长度实际上是没有限制的。</p></li><li><p>curl 首先会解析整个命令行，应用给定的命令行选项，然后（按从左到右的顺序）遍历 URL 并执行相应操作。</p></li><li><p>对于某些选项（如告诉 curl 将输出内容保存在哪里的-o 或-O），你可能希望为每个 URL 单独指定。</p></li><li><p>curl 会在处理完最后一个 URL 后返回一个退出码。想让 curl 在第一次出现错误时就退出，则可以使用–fail-early 选项。</p></li><li><p><code>--fail-early</code>：在第一次出现错误时就退出</p></li></ul><h4 id="2-3-9-URL-的单独选项"><a href="#2-3-9-URL-的单独选项" class="headerlink" title="2.3.9 URL 的单独选项"></a>2.3.9 URL 的单独选项</h4><ul><li><p><code>-;</code>或<code>--next</code>：用于在一组选项和 URL 之间插入间隔</p></li><li><p>当命令行解析器遇到–next 选项时，它会将后面的选项应用于下一组 URL。因此，–next 选项其实是一组选项和 URL 之间的分隔符。使用多少个–next 选项取决于实际的需要。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 向一个 URL 发起 HTTP GET 请求</span><br><span class="hljs-comment"># 同时向另一个 URL 发起 HTTP POST 请求</span><br><span class="hljs-comment"># 然后向第三个 URL 发起 HEAD 请求</span><br>curl --location http://example.com --next \<br>     --data hello http://exampl.com --next \<br>     --<span class="hljs-built_in">head</span> http://example.com<br></code></pre></td></tr></table></figure></li></ul><h4 id="2-3-10-连接重用"><a href="#2-3-10-连接重用" class="headerlink" title="2.3.10 连接重用"></a>2.3.10 连接重用</h4><ul><li><p>curl 在内部维护着一个连接池，这可以让之前使用过的连接继续存活一段时间，因此后续发给相同主机的请求可以重用这些已经建立的连接。</p></li><li><p>连接池中的连接可以在 curl 运行期间保持活跃状态，但最好还是在同一个命令行中完成多次传输，而不是单独运行多个 curl 命令行。</p></li></ul><h3 id="2-4-URL-通配"><a href="#2-4-URL-通配" class="headerlink" title="2.4 URL 通配"></a>2.4 URL 通配</h3><ul><li><p>curl 提供了“通配”（globbing）的方式来指定一类大致相同小部分不同的 URL。不同的部分可能是一组数字或一组名字。</p></li><li><p>curl 使用保留符号 [] 和{}进行通配，它们一般不是合法 URL 的组成部分（IPv6 地址除外，但 curl 可以很好地处理它们）</p></li><li><p><code>-g</code>或<code>--globoff</code>：禁用通配</p></li><li><p>可以使用 [N-M] 语法来指定一个数值范围，其中 N 是起始索引，M 是结束索引（包括 M 在内）。表示数值范围的同时，还可以指定步进（step counter）</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash">curl http://example.com/[1-100].png<br>curl http://example.com/[001-100].png<br>curl http://example.com/[000-100:2].png<br></code></pre></td></tr></table></figure></li><li><p>curl 也可以用以上语法来表示字母范围</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">curl http://example.com/[a-z].html<br></code></pre></td></tr></table></figure></li><li><p>有时 URL 的不同部分不会遵循这些简单的模式，那么你可以指定完整的列表，但要放在花括号，而不是中括号中。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">curl http://example.com/&#123;one, two, three&#125;.html<br></code></pre></td></tr></table></figure></li><li><p>curl 可以在同一个 URL 中使用多个通配。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">curl http://example.com/&#123;one, two, three&#125;[1-100].jpg<br></code></pre></td></tr></table></figure></li><li><p><code>-O</code>或<code>--remote-name</code>：使用 URL 中的文件名来保存目标文件</p></li><li><p><code>-o</code>或者<code>--output</code>：指定下载文件的文件名</p></li><li><p>在下载多个文件时，可以通过 curl 的输出文件名变量，实现将它们保存到不同的子目录中，或者以不同的名称保存文件</p></li><li><p>URL 中的每个通配都对应一个单独的变量，可以通过 ’#[num]’ 来引用，即在’#’ 后面跟上与通配对应的数字，从 1（对应第一个通配）开始，以最后一个通配结束。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">curl http://example.com/&#123;one, two&#125;.html -o <span class="hljs-string">&quot;file_#1.html&quot;</span><br>curl http://&#123;site, host&#125;.host[1-5].example.com -o <span class="hljs-string">&quot;subdir/#1_#2&quot;</span><br></code></pre></td></tr></table></figure></li><li><p><code>-h</code>或<code>--help</code>：列出所有选项，并提供简要的说明</p></li><li><p><code>--manual</code>：输出 curl 的整个手册页以及常见的用例教程</p></li></ul><h3 id="2-5-配置文件"><a href="#2-5-配置文件" class="headerlink" title="2.5 配置文件"></a>2.5 配置文件</h3><ul><li><p>curl 提供了“配置文件”功能。它允许你将命令行选项写在文本文件中，然后告诉 curl，除了读取命令行外，还要从这个文件中读取命令行选项。</p></li><li><p><code>-K</code>或<code>--config</code>：告诉 curl 从特定文件中读取更多的命令行选项</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">curl -K cmdline.txt http://example.com<br></code></pre></td></tr></table></figure><p>cmdline.txt 示例：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs textile"># 注释<br>--location<br>--head<br></code></pre></td></tr></table></figure></li><li><p>配置文件可以接受短选项和长选项，就像你在命令行上写的那样。为了便于阅读，它还允许你使用不带破折号的长选项。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs textile">-v<br>location<br>head<br></code></pre></td></tr></table></figure></li><li><p>配置文件可以接受短选项和长选项，就像你在命令行上写的那样。为了便于阅读，它还允许你使用不带破折号的长选项。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">user-agent <span class="hljs-string">&quot;Hello World&quot;</span><br></code></pre></td></tr></table></figure></li><li><p>为了让配置文件看起来更像真正的配置文件，它还允许你在选项及其参数之间使用’&#x3D;’或’:’。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs textile">user-agent = &quot;Hello World&quot;<br></code></pre></td></tr></table></figure></li><li><p>选项的参数也可以不使用引号，curl 将下一个空格或换行视为当前参数的结尾。不过，如果参数中带有空格，则必须使用双引号。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs textile">user-agent = Hello-World<br></code></pre></td></tr></table></figure></li><li><p>如果想在配置文件中指定 URL，则必须使用–url 或 url，而且不会像在命令行中那样不是选项的所有东西都被视为 URL。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs textile">url = &quot;http://example.com&quot;<br>--url = &quot;http://example.com&quot;<br></code></pre></td></tr></table></figure></li><li><p>当被调用时，curl 会检查是否存在默认配置文件（除非使用了-q），如果存在，则使用这个配置文件。在类 Unix 系统上，它会查找.curlrc 文件，在 Windows 系统上则查找_curlrc 文件。查找顺序：</p><ul><li><p>尝试找到“主目录”：它先检查 CURL_HOME，然后是 HOME 环境变量。如果没有找到，它会在类 Unix 系统上调用 getpwuid()（这个函数将返回当前用户的主目录）。在 Windows 系统上，它会检查 APPDATA 变量，如果没找到就尝试“%USERPROFILE%\Application Data”。</p></li><li><p>在 Windows 系统上，如果主目录中没有_curlrc 文件，那么它会查找 curl 可执行文件所在的目录。在类 Unix 系统上，它只会尝试从主目录中加载．curlrc。</p></li></ul></li><li><p><code>-q</code>：禁用.curlrc</p></li></ul><h3 id="2-6-密码和窥探"><a href="#2-6-密码和窥探" class="headerlink" title="2.6  密码和窥探"></a>2.6  密码和窥探</h3><ul><li><p><code>-u</code>和<code>--user</code>：接受一个参数，即用冒号分隔的用户名和密码</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">curl -u admin:admin http://example.com<br></code></pre></td></tr></table></figure></li><li><p>首先，我们在命令行输入了密码，而命令行可能对同一系统上的其他用户是可见的（假设你使用的是多用户系统），这会导致信息的泄露。curl 会尝试从进程列表中清空密码来降低密码泄露的风险。</p></li><li><p>避免在命令行上指定用户名和密码的一种方法是使用.netrc 文件或配置文件。你也可以使用-u 选项，但不指定密码，curl 会在运行时提示用户输入密码。</p></li></ul><h3 id="2-7-进度指示器"><a href="#2-7-进度指示器" class="headerlink" title="2.7 进度指示器"></a>2.7 进度指示器</h3><ul><li><p>curl 有一个内置的进度指示器。当调用 curl 来传输数据（上传或下载）时，它可以在终端上显示传输的进度，比如当前的传输速率、已经用掉的时间以及还需要多长时间才能完成传输。</p></li><li><p>如果 curl 需要在终端上输出内容，那么进度指示器就会被禁用，否则进度指示器会干扰输出内容，把要显示的内容弄得一团糟。</p></li><li><p>如果调用 curl 时没有看到进度指示器，则需要确保输出已经被重定向到终端以外的位置。也就是说，当输出被定向到其他位置的时候，就可以看到对应的进度显示器</p></li><li><p><code>-s</code>或<code>--silent</code>：禁用进度指示器和错误信息</p></li><li><p>curl 还提供了一个更简单的进度指示器，可以通过-#或–progress-bar 来启用。正如其名字所暗示的那样，它使用进度条的方式来显示传输进度。</p></li><li><p><code>-#</code>或<code>--progress-bar</code>：启用简单的进度显示器，使用进度条的方式来显示传输进度。</p></li><li><p>有时候，在使用 curl 传输数据时，它无法确定请求对象的大小，因此进度指示器只包含很少量的细节，并且无法预测传输时间等其他信息。</p></li><li><p>进度指示器显示的是字节数和每秒字节数。对于很大的数据，它还会使用单位后缀，以 1024 为基础，因此 1024 是千字节（1K）,2048 是 2K，并以此类推。显示时间使用的是 H:MM:SS 格式，分别对应小时、分钟和秒。</p></li></ul><h2 id="第三章-使用-curl"><a href="#第三章-使用-curl" class="headerlink" title="第三章 使用 curl"></a>第三章 使用 curl</h2><ul><li>curl 支持或可以支持（需要进行构建）以下这些协议：DICT、FILE、FTP、FTPS、GOPHER、HTTP、HTTPS、IMAP、IMAPS、LDAP、LDAPS、POP3、POP3S、RTMP、RTSP、SCP、SFTP、SMB、SMTP、SMTPS、TELNET 和 TFTP。</li></ul><h3 id="3-1-详细模式"><a href="#3-1-详细模式" class="headerlink" title="3.1 详细模式"></a>3.1 详细模式</h3><ul><li><p>如果启用了详细（verbose）模式，curl 会显示更多信息，告诉你它正在做什么。它会用前缀’＊’来打印信息。</p></li><li><p>详细信息中的’(#0)’是 curl 为这个连接分配的内部数字。如果在同一命令行中指定多个 URL，那么你就会看到它将使用多个连接或重用已有的连接，因此连接的计数器可能会增加，也可能不会增加，具体取决于 curl 需要执行的操作。</p></li></ul><h4 id="3-1-1-–trace、–trace-ascii-和–trace-time"><a href="#3-1-1-–trace、–trace-ascii-和–trace-time" class="headerlink" title="3.1.1 –trace、–trace-ascii 和–trace-time"></a>3.1.1 –trace、–trace-ascii 和–trace-time</h4><ul><li><p>当 curl 使用 HTTPS、FTPS 或 SFTP 协议进行加密文件传输时，其他网络监视工具（如 Wireshark 或 tcpdump）将无法帮你保存完整的消息。为此，curl 在-v 之外又提供了两个选项。</p></li><li><p><code>--trace</code>：–trace [filename] 选项可以将完整的跟踪信息保存在指定的文件中，也可以使用’-’（单个减号）代替文件名，将内容打印到 stdout。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 命令执行完后，会生成一个叫作 dump 的文件，发送和接收的每个字节都以十六进制的数字显示出来。</span><br>curl --trace dump http://example.com<br>curl --trace - http://example.com<br></code></pre></td></tr></table></figure></li><li><p><code>--trace-ascii</code>：类似–trace，但是输出的详细内容不是十六进制的数字，而是 ascii 内容</p></li><li><p><code>--trace-time</code>：如果使用了这个选项，则所有的输出信息前面都会被加上高精度的时间戳。它可以与常规的-v 和–verbose 选项以及–trace 和–trace-ascii 选项一起使用。格式为小时：分钟：秒，然后是微秒。</p></li></ul><h4 id="3-1-2-–write-out"><a href="#3-1-2-–write-out" class="headerlink" title="3.1.2 –write-out"></a>3.1.2 –write-out</h4><ul><li><p><code>-w</code>或<code>--write-out</code>：在传输任务完成后打印一些信息，并且它还提供了大量可添加到输出内容中的变量，这些变量包含了与传输相关的信息。</p></li><li><p>如果将一个字符串传给这个选项，那么这个字符串就会被打印出来</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">curl -w <span class="hljs-string">&quot;Hello World&quot;</span> http://example.com<br></code></pre></td></tr></table></figure></li><li><p>如果在字符串前面加上‘@’，那么 curl 就会从指定文件中读取字符串。如果使用’-’作为文件名，那么 curl 就会从标准输入（stdin）读取字符串</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">curl -w @filename http://example.com<br>curl -w @- http://example.com<br></code></pre></td></tr></table></figure></li><li><p>可以使用’\n’输出新行，使用’\r’输出回车，使用’\t’输出制表符。</p></li><li><p>可以在字符串中加入%{variable_name}来访问可用的变量，然后这些变量会被替换成对应的值。如果要输出正常的’%‘，则需要写成’%%’。在 Windows 命令行中，%是一个特殊符号，在使用这个选项时，所有出现的%必须是成双的。</p><ul><li><p>%{content_type}显示所请求文档的 Content-Type（如果有的话）。</p><ul><li>%{filename_effective}显示 curl 最终写入内容的文件名。只有使用–remote-name 或–output 选项写入文件时，这个变量才有意义。它在与–remote-header-name 选项结合使用时最有用。</li></ul></li><li><p>%{ftp_entry_path}显示连接到远程 FTP 服务器时的初始路径。</p></li><li><p>%{response_code}显示最后一次传输返回的响应码。</p></li><li><p>%{http_connect}显示最后一次针对 CONNECT 请求的响应码（来自代理）。</p></li><li><p>%{local_ip}显示最近一次连接的本地 IP 地址——可以是 IPv4 或 IPv6 地址。</p></li><li><p>%{local_port}显示最近一次连接的本地端口号。</p></li><li><p>%{num_connects}显示最近一次传输建立的新连接的数量。</p></li><li><p>%{num_redirects}显示请求的重定向次数。</p></li><li><p>%{redirect_url}显示不使用-L 选项时的 HTTP 请求的重定向 URL。</p></li><li><p>%{remote_ip}显示最近一次连接的远程 IP 地址——可以是 IPv4 或 IPv6 地址</p></li><li><p>%{remote_port}显示最近一次连接的远程端口号。</p></li><li><p>%{size_download}显示已下载的总字节数。</p></li><li><p>%{size_header}显示已下载标头的总字节数。</p></li><li><p>%{size_request}显示 HTTP 请求发送的总字节数。</p></li><li><p>%{size_upload}显示已上传的总字节数。</p></li><li><p>%{speed_download}显示整个下载的平均速率，以字节&#x2F;秒为单位。</p></li><li><p>%{speed_upload}显示整个上传的平均速率，以字节&#x2F;秒为单位。</p></li><li><p>%{ssl_verify_result}显示请求的 SSL 对等证书验证结果，0 表示验证成功。</p><ul><li><p>%{time_appconnect}显示从开始到与远程主机建立 SSL（或 SSH 等）连接（或握手）所花费的时间，以秒为单位。</p></li><li><p>%{time_connect}显示从开始到与远程主机（或代理）建立 TCP 连接所花费的时间，以秒为单位。</p></li></ul></li><li><p>%{time_namelookup}显示从开始到完成域名解析所花费的时间，以秒为单位。</p><ul><li><p>%{time_pretransfer}显示从开始到文件传输即将开始所花费的时间，包括用于所有预传输命令以及与特定协议协的时间，以秒为单位。</p></li><li><p>%{time_redirect}显示所有重定向所花费的时间，包括在最终事务启动之前的域名查找、建立连接、预传输和传输以秒为单位。</p></li><li><p>%{time_starttransfer}显示从开始到第一个字节即将开始传输所花费的时间，包括 time_pretransfer 以及服器计算结果所需的时间，以秒为单位。</p></li></ul></li><li><p>%{time_total}显示整个操作持续的总时间，以秒为单位。时间将精确到毫秒。</p><ul><li>%{url_effective}显示最后获取的 URL。如果你要 curl 跟随重定向（使用-L 选项），那么这个变量就非常有用。</li></ul></li></ul></li></ul><h4 id="3-1-3-静默模式"><a href="#3-1-3-静默模式" class="headerlink" title="3.1.3 静默模式"></a>3.1.3 静默模式</h4><ul><li><p><code>-s</code>或<code>--silent</code>：可以打开静默模式，让 curl 关闭进度指示器，而且不会在发生错误时输出任何错误信息。与详细模式相反的是静默模式。静默模式仍然会输出你请求下载的数据。</p></li><li><p><code>-S</code>或<code>--show-error</code>：启用静默模式后，可以在发生错误时输出错误信息。</p></li></ul><h3 id="3-2-持久连接"><a href="#3-2-持久连接" class="headerlink" title="3.2 持久连接"></a>3.2 持久连接</h3><ul><li><p>在建立 TCP 连接时，curl 将保留旧连接一段时间，如果下一次要连接到同一主机，那么就可以重用相同的连接，从而节省大量时间。我们称之为持久连接。curl 将始终尝试保留连接，并尽可能重用现有连接。</p></li><li><p>不过，curl 命令行工具只能在运行期间保持连接处于活跃状态，因此，只要它退出，就会关闭所有已打开的连接（并且还会释放所有缓存）。我们将这种活跃连接池称为“连接缓存”。</p></li><li><p>如果需要针对同一主机或相同的 URL 执行 N 次传输或操作，那么你可以考虑使用尽可能少的 curl 命令行来提速，而不是每次使用一个 URL 并重复调用 curl。</p></li></ul><h3 id="3-3-下载"><a href="#3-3-下载" class="headerlink" title="3.3 下载"></a>3.3 下载</h3><ul><li><p>你可以通过 URL 来指定 curl 需要下载哪些资源。除非另有说明，否则 curl 默认下载 URL 指定的资源。URL 被分解为多个部分，curl 连接到正确的服务器，然后要求服务器提供特定的资源——通常是一个文件。然后，服务器开始传输数据，或者拒绝传输（客户端请求了错误的数据）。</p></li><li><p>对资源的请求与特定的协议相关，因此 FTP:&#x2F;&#x2F; URL 与 HTTP:&#x2F;&#x2F; URL 或 SFTP:&#x2F;&#x2F; URL 的工作方式不同。</p></li><li><p>对于不包含路径的 URL，即只包含主机名（比如前面的“<a href="http://example.com”)/">http://example.com”）</a>, curl 将在内部为其添加一个斜杠（“&#x2F;”），然后它就变成了 curl 要从服务器请求的资源。</p></li><li><p>如果你在命令行中指定了多个 URL，那么 curl 将逐个下载所有 URL。在一个传输完成之前，它不会启动下一个（以及后面的）传输。</p></li><li><p>curl 会避免将二进制数据输出到终端，因为这会严重扰乱终端（有时甚至会导致终端停止运行）。可以使用-o 强制让它输出到 stdout。</p></li></ul><h4 id="3-3-1-下载文件的文件名"><a href="#3-3-1-下载文件的文件名" class="headerlink" title="3.3.1 下载文件的文件名"></a>3.3.1 下载文件的文件名</h4><ul><li><p>-O 选项从你提供的 URL 中提取文件名部分作为本地文件名。指定 URL 后，curl 从中选择文件名。即使发生重定向（而且你告诉 curl 要跟踪重定向）, curl 选择的文件名也不会发生变化。</p></li><li><p><code>-J</code>或<code>--remote-header-name</code>：HTTP 服务器可以选择在响应消息中提供 Content-Disposition 标头。这个标头可能包含服务器建议的文件名，通过该选项可以让 curl 使用这个名字作为本地文件名。</p></li><li><p>同时使用-O 和-J 选项，那么 curl 默认使用 URL 中的文件名，只有当响应消息中包含有效的 Content-Disposition 标头时，它才会使用建议的文件名。</p></li><li><p>-J 选项存在一些用户需要注意的问题和风险：</p><ul><li><p>它只会使用建议文件名的最右边部分，因此服务器建议的其他路径或目录都会被忽略。</p></li><li><p>因为文件名完全由服务器提供，所以，如果服务器恰好提供了与本地文件相同的文件名，那么 curl 将覆盖当前目录中已有的本地文件。</p></li><li><p>文件名编码和字符集问题。curl 不会对文件名进行编码，因此你可能会得到一个 URL 编码的文件名（如果是在浏览器中，那么浏览器会使用合理的字符集来解码 URL，将它还原成更易阅读的内容）。</p></li></ul></li></ul><h4 id="3-3-2-压缩"><a href="#3-3-2-压缩" class="headerlink" title="3.3.2 压缩"></a>3.3.2 压缩</h4><ul><li><p>curl 可以要求 HTTP 和 HTTPS 服务器提供压缩过的数据，并在收到数据后自动对其进行解压。</p></li><li><p>HTTP 压缩可以通过两种机制来实现，一种被认为是“正确的方式”，另一种在实际中使用得更为广泛：</p><ul><li><p>压缩 HTTP 内容的常用方法是使用 Content-Encoding 标头。</p></li><li><p>Transfer-Encoding 是一种比较罕见的方法，它是为自动压缩和解压而创建的一个标头，但并没有被广泛采用</p></li></ul></li><li><p><code>--compressed</code>：如果服务器支持压缩，它会传输压缩过的数据，curl 会在保存或发送到 stdout 前对数据进行解压。除了可能会注意到传输变得更快之外，用户并不会真正看到或感觉到压缩过程。–compressed 请求服务器使用一种受支持的压缩算法来压缩数据</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">curl --compressed http://example.com<br></code></pre></td></tr></table></figure></li><li><p><code>--tr-encoding</code>：让 curl 向服务器请求 Transfer-Encoding 压缩</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">curl --tr-cncoding http://example.com<br></code></pre></td></tr></table></figure></li><li><p>从理论上讲，你可以在同一个命令行中使用两种压缩方式。但在实践中，当被要求以两种方式进行压缩时，一些服务器可能会感到困惑。因此，只选择其中一种通常会更安全。</p></li></ul><h4 id="3-3-3-多个下载"><a href="#3-3-3-多个下载" class="headerlink" title="3.3.3 多个下载"></a>3.3.3 多个下载</h4><ul><li><p>当一个命令行中有多个 URL 的时候，每个 URL 都需要自己的“存储指令”。如果不提供“存储指令”, curl 会默认将数据发送到 stdout。</p></li><li><p>如果你要下载两个 URL 并只为第一个 URL 提供保存位置，那么第二个 URL 将被发送到 stdout，如下所示：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">curl -o one.txt http://example.com/1 http://example.com/2<br></code></pre></td></tr></table></figure></li><li><p>“存储指令”的读取和处理顺序与下载的 URL 的顺序相同，因此它们不一定要位于 URL 之后。你可以将所有输出选项放在最前面或最后面，或者与 URL 交错放置。以下写法是个等效的</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash">curl -o one.txt -o two.txt http://example.com/1 http://example.com/2<br>curl -o one.txt http://example.com/1 -o two.txt http://example.com/2<br>curl http://example.com/1 http://example.com/2 -o one.txt -o two.txt<br></code></pre></td></tr></table></figure></li><li><p><code>--remote-name-all</code>：让-O 成为所有给定 URL 的默认操作方式。你仍然可以为 URL 提供单独的“存储指令”，但对于没有提供单独“存储指令”的 URL，则默认使用-O 选项，而不是输出到 stdout。</p></li></ul><h4 id="3-3-4-速率限定"><a href="#3-3-4-速率限定" class="headerlink" title="3.3.4 速率限定"></a>3.3.4 速率限定</h4><ul><li><p>在传输数据时，curl 会尝试尽快完成任务。它的速度取决于几个因素，包括计算机的硬件配置、网络连接带宽、远程服务器的负载和延迟。</p></li><li><p><code>--limit-rate</code>：让 curl 的速率不超过指定的字节&#x2F;秒。速率限定的值可以包含一个后缀字母，K 表示千字节，M 表示兆字节，G 表示千兆字节。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">curl --limt-rate 200K http://example.com<br></code></pre></td></tr></table></figure></li><li><p>指定的限定速率是指整个传输过程的最大平均速率，也就是说，curl 有可能会在某些很短的时间段内使用高于指定速率的传输速率，但平均速率不会超过指定速率。curl 永远不会知道可能的最大速度是多少，它会在允许的范围内尽快完成传输。你可能会知道连接的最大速度，但 curl 不会。</p></li></ul><h4 id="3-3-5-最大文件"><a href="#3-3-5-最大文件" class="headerlink" title="3.3.5 最大文件"></a>3.3.5 最大文件</h4><ul><li><p><code>--max-filesize</code>：可以为 curl 指定可接受的最大下载字节数，如果 curl 可以在传输开始前确定文件的大小，那么它就会在尝试下载更大的文件之前终止传输。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">curl --max-filesize 1024 http://example.com<br></code></pre></td></tr></table></figure></li><li><p>在很多情况下，curl 无法在传输开始前确定文件大小，那么这个选项就不会产生任何影响，即使下载的内容可能大于指定的数量。</p></li></ul><h4 id="3-3-6-Metalink"><a href="#3-3-6-Metalink" class="headerlink" title="3.3.6 Metalink"></a>3.3.6 Metalink</h4><ul><li><p>Metalink 是一种文件描述标准，用于告诉客户端有多个位置保存了相同的内容。然后客户端可以选择从一个或多个位置下载内容。</p></li><li><p><code>--metalink</code>：curl 支持 Metalink 格式，你可以通过–metalink 选项来指定。指定的 URL 应该指向一个 Metalink 文件</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">curl --metalink http://example.com/example.metalink<br></code></pre></td></tr></table></figure></li><li><p>如果出现错误（如文件或服务器不可用）, curl 将使用 Metalink 文件中列出的镜像进行故障转移。下载完成后，它还会验证文件的散列。Metalink 文件会被下载到内存中，并在内存中进行处理，不会保存在本地文件系统中。</p></li></ul><h4 id="3-3-7-在文件系统中保存元数据"><a href="#3-3-7-在文件系统中保存元数据" class="headerlink" title="3.3.7 在文件系统中保存元数据"></a>3.3.7 在文件系统中保存元数据</h4><ul><li><p><code>--xattr</code>：告诉 curl 将某些文件元数据也保存在“扩展文件属性”中。这些扩展属性是保存在文件系统中的标准化的名称和值，前提是文件系统和操作系统支持扩展属性。</p></li><li><p>目前，URL 保存在 xdg.origin.url 属性中，HTTP 的 Content-Type 保存在 mime_type 属性中。如果指定了这个选项，但文件系统不支持扩展属性，则会发出警告。</p></li></ul><h4 id="3-3-8-–raw"><a href="#3-3-8-–raw" class="headerlink" title="3.3.8 –raw"></a>3.3.8 –raw</h4><ul><li><code>--raw</code>：禁用所有内部的 HTTP 内容解码或传输编码，取而代之的是传输未经修改的原始数据。</li></ul><h4 id="3-3-9-失败重试"><a href="#3-3-9-失败重试" class="headerlink" title="3.3.9 失败重试"></a>3.3.9 失败重试</h4><ul><li><p><code>--retry</code>：通常 curl 只会尝试执行一次传输，不成功则返回错误。你可以使用–retry 选项让 curl 重试失败的传输。</p></li><li><p><code>--retry-delay</code>：禁用指数退避算法，并设置自己的重试延迟。</p></li><li><p><code>--retry-max-time</code>：限制所有重试的总时间。</p></li><li><p><code>--max-time</code>：选项用于指定单个传输允许的最长时间。</p></li><li><p>如果尝试执行传输时返回临时错误，那么 curl 将在放弃之前重试指定的次数。如果将数字设为 0（默认值）, curl 将不会进行重试。临时错误可能是：超时、FTP 4xx 响应码或 HTTP 5xx 响应码。</p></li><li><p>curl 在开始重试传输前会先等待一秒，对于后续的重试，等待时间加倍，直到达到 10 分钟，然后剩余的重试延迟就是 10 分钟。–retry-delay 选项可以禁用这种指数退避算法，并设置自己的重试延迟</p></li></ul><h4 id="3-3-10-恢复下载和下载范围"><a href="#3-3-10-恢复下载和下载范围" class="headerlink" title="3.3.10 恢复下载和下载范围"></a>3.3.10 恢复下载和下载范围</h4><ul><li><p>在恢复下载时，curl 会先检查本地已存在的文件的大小，然后向服务器请求剩余的内容，并追加到本地文件中。curl 还允许指定自定义恢复点，这些恢复点对应的内容可能不存在于本地。</p></li><li><p><code>-C</code>或<code>--continu-at</code>：可以告诉 curl 从哪里开始传输，选项的值可以是一个普通的数字字节偏移量，或者使用字符串 - 让 curl 根据它所知道的信息自己决定从哪里开始传输。如果使用-，那么 curl 将基于目标文件确定本地已存在的数据量，并将其作为向服务器请求更多数据的偏移量。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 从字节偏移量为 100 的位置开始下载 FTP 文件</span><br>curl --continue-at 100 ftp://example.com/bigfile<br><span class="hljs-comment"># 继续之前中断的下载</span><br>curl --continue-at - ftp://example.com/bigfile<br></code></pre></td></tr></table></figure></li><li><p><code>--range</code>：向远程服务器请求特定字节范围的内容</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">curl --range 100-1000 ftp://example.com/bigfile<br></code></pre></td></tr></table></figure></li></ul><h3 id="3-4-上传"><a href="#3-4-上传" class="headerlink" title="3.4 上传"></a>3.4 上传</h3><ul><li><p>curl 支持一下上传协议：FILE、FTP、FTPS、HTTP、HTTPS、IMAP、IMAPS、SCP、SFTP、SMB、SMBS、SMTP、SMTPS 和 TFTP。</p></li><li><p><code>-T</code>：发送某个需要上传的文件：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">curl -T filename http://example.com<br></code></pre></td></tr></table></figure></li></ul><h4 id="3-4-1-HTTP-上传"><a href="#3-4-1-HTTP-上传" class="headerlink" title="3.4.1 HTTP 上传"></a>3.4.1 HTTP 上传</h4><ul><li><p>HTTP（和 HTTPS）提供了几种数据上传方式，而 curl 也为上传提供了简单的命令行选项，其中有三种常见的方式，后文将逐一介绍。</p></li><li><p>在 HTTP 中，上传也可以是下载，它们属于同一个操作。事实上，很多下载是通过 HTTP POST 开始的。</p></li><li><p>multipart formpost 通常用于涉及文件上传的 HTML 表单。这种类型的上传也属于 HTTP POST，但会根据一些特殊规则发送格式化的数据，因此被称为“multipart”。因为它以完全不同的方式发送格式化数据，所以你无法自己选择使用哪种类型的 POST，这完全取决于接收服务器期望和可以处理什么内容。详细内容请查看下一部分</p></li><li><p>上传类型 HTTP PUT 会发送一个完整的资源，并将其保持原样放在远程站点，甚至可以替换那里已有的资源。目前，PUT 是 Web 使用得最少的一种 HTTP 上传方式，而且大多数 Web 服务器并没有启用 PUT。</p></li></ul><h4 id="3-4-2-FTP-上传"><a href="#3-4-2-FTP-上传" class="headerlink" title="3.4.2 FTP 上传"></a>3.4.2 FTP 上传</h4><ul><li><p>在使用 FTP 时，你可以看到将要访问的远程文件系统。你可以准确地告诉服务器你想要在哪个目录放置上传文件以及要使用哪个文件名。如果你指定的 URL 尾部是一个斜杠，那么 curl 会将本地文件名附加到 URL 后面，这样它就变成了远程的文件名：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">curl -T filename ftp://example.com/<br>curl -T filename ftp://example.com/hello_filename<br></code></pre></td></tr></table></figure></li></ul><h4 id="3-4-3-SMTP-上传"><a href="#3-4-3-SMTP-上传" class="headerlink" title="3.4.3 SMTP 上传"></a>3.4.3 SMTP 上传</h4><ul><li><p>对于 curl 来说，发送电子邮件其实也是一种“上传”。你将邮件上传到 SMTP 服务器。在使用 SMTP 时，你需要在邮件中指定需要的标头（To:、From:、Date:等），因为 curl 不会自己添加这些东西。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">curl -T mail smtp://mail.example.com/ --mail-from user@example.com<br></code></pre></td></tr></table></figure></li></ul><h3 id="3-5-连接和超时"><a href="#3-5-连接和超时" class="headerlink" title="3.5 连接和超时"></a>3.5 连接和超时</h3><h4 id="3-5-1-主机名解析"><a href="#3-5-1-主机名解析" class="headerlink" title="3.5.1 主机名解析"></a>3.5.1 主机名解析</h4><ul><li><p>HTTP 客户端一般会通过 Host 标头告诉 HTTP 服务器它要连接到哪个服务器，因为通常同一个 HTTP 服务器实例会有多个名字，也就是有多个 A 或者 CNAME 记录，同时也可能会有多个站点。因此，将自定义的 Host 标头传给 curl，就可以让服务器返回目标站点的内容，即使没有使用目标站点的主机名进行连接。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 请求 www.example.com 的 index 页面</span><br>curl -H <span class="hljs-string">&quot;Host: www.example.com&quot;</span> http://localhost/<br></code></pre></td></tr></table></figure></li><li><p><code>-H</code>或<code>--header</code>：指定 HTTP 请求的 Header。</p></li><li><p>如果设置自定义的 Host 标头并使用 cookie，那么 curl 将提取自定义名称，并在匹配 cookie 时将其作为目标主机名。</p></li><li><p>与 HTTPS 服务器通信时，只使用 Host 标头是不够的。TLS 协议中有一个单独的扩展字段，称作 SNI（Server Name Indication，服务器名称指示），客户端用它来告诉服务器它想要与哪台服务器通信。curl 只会从指定的 URL 中提取 SNI。</p></li><li><p><code>--resolve</code>：为 curl 提供一个 IP 地址。将地址插入 curl 的 DNS 缓存中，以便 curl 相信那就是自己解析得到的地址。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 需要指定域名端口，以及对应的 ip 地址</span><br>curl --resolve example.com:80:127.0.0.1 http://example.com<br></code></pre></td></tr></table></figure></li><li><p>如果使用的是 HTTPS，那么将发送 URL 中的 SNI，并且 curl 会验证服务器端的响应，以确保使用的是 URL 中的名字。</p></li><li><p>可以指定多个–resolve 进行多个重定向，如果你的 URL 使用了 HTTP 重定向，或者你希望在命令行中使用多个 URL，那么这么做会很方便。</p></li><li><p><code>--connect-to</code>：–connect-to 选项提供了一个与–resolve 很相近的小变体。当需要连接特定主机名和端口时，可以通过这个选项为 curl 指定替换主机名和端口。它将源主机名和源端口重定向到目标主机名和目标端口。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">curl --connect-to example.com:80:localhost:9394 http://example.com<br></code></pre></td></tr></table></figure></li></ul><h4 id="3-5-2-基于-c-ares-库的域名解析"><a href="#3-5-2-基于-c-ares-库的域名解析" class="headerlink" title="3.5.2 基于 c-ares 库的域名解析"></a>3.5.2 基于 c-ares 库的域名解析</h4><ul><li><p>可以用不同的域名解析器库来构建 curl。其中一个库是 c-ares，如果用 c-ares 构建 curl，则可以获得一些额外的功能，比如，它能够更具体地指定使用哪些 DNS 服务器以及 DNS 流量如何使用网络。</p></li><li><p><code>--dns-servers</code>：指定 curl 使用的 DNS 服务器，而不是使用默认的那个。</p></li><li><p><code>--dns-ipv4-addr</code>和<code>--dns-ipv6-addr</code>：让 curl 将 DNS 通信的本地端“绑定”到特定的 IP 地址。</p></li><li><p><code>--dns-interface</code>：让 curl 为 DNS 请求使用特定的网络接口。</p></li></ul><h4 id="3-5-3-连接超时"><a href="#3-5-3-连接超时" class="headerlink" title="3.5.3 连接超时"></a>3.5.3 连接超时</h4><ul><li><p>curl 通常会与主机建立 TCP 连接，以作为网络传输的初始化部分。如果网络状况不稳定或远程服务器出现故障，TCP 连接可能会失败或速度很慢。要想减少对脚本或其他应用的影响，你可以为 curl 设置允许尝试连接的最长时间（以秒为单位）</p></li><li><p><code>--connect-timeoout</code>：设置 curl 允许尝试连接的最长时间，如果 curl 在指定时间内没有建立连接，则返回错误。建立连接前的所有必要步骤都必须在给定时间内完成。如果未能在给定时间内建立连接，curl 将抛出超时错误码（28）并退出。连接超时可以是亚秒精度的十进制值。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">curl --connect-timeout 2.781 https://example.com<br></code></pre></td></tr></table></figure></li><li><p>连接超时只能限制 curl 在建立连接前花费的时间，一旦成功建立 TCP 连接，则不再受这个时间的限制。如果指定较短的超时时间，则可能会影响 curl 连接远程服务器、慢服务器或通过不可靠网络访问的服务器。</p></li></ul><h4 id="3-5-4-网络接口和本地端口号"><a href="#3-5-4-网络接口和本地端口号" class="headerlink" title="3.5.4 网络接口和本地端口号"></a>3.5.4 网络接口和本地端口号</h4><ul><li><p>在具有多个网络接口并连接到多个网络的计算机上，有时你可以决定使用哪个网络接口来传出网络流量，或者在通信中使用哪个原始 IP 地址（在你拥有的多个 IP 地址之外）。</p></li><li><p><code>--interface</code>：可以告诉 curl 你希望将通信的本地端“绑定”到哪个网络接口、哪个 IP 地址或主机名</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash">curl --interface eth1 http://example.com<br>curl --interface 192.168.0.1 http://example.com<br>curl --interface machine1 http://example.com<br></code></pre></td></tr></table></figure></li><li><p>TCP 连接是在本地的 IP 地址和端口号与远程的 IP 地址和端口号之间建立起来的。你可以在 URL 中指定远程端口号，这样通常有助于识别目标服务。本地端口号通常由网络栈随机分配给 TCP 连接。在某些情况下，你会发现自己处于网络设备、防火墙或类似设备后面，它们对设置传出连接的源端口号施加了约束。对于这种情况，你可以指定 curl 使用哪个本地端口来绑定连接</p></li><li><p>你可以指定单个端口号或端口号区间。建议使用端口号区间，因为端口是稀缺资源，你想用的端口可能已经被占用。如果无法获取指定的本地端口号（或区间）, curl 将返回错误并退出。此外，在大多数操作系统上，如果没有更高权限（root），就无法绑定 1024 以下的端口号。如果可以避免，最好不要以 root 身份运行 curl。</p></li><li><p><code>--local-port</code>：指定本地端口号</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">curl --local-port 4000-4200 http://example.com/<br></code></pre></td></tr></table></figure></li></ul><h4 id="3-5-5-keepalive"><a href="#3-5-5-keepalive" class="headerlink" title="3.5.5 keepalive"></a>3.5.5 keepalive</h4><ul><li><p>空闲时，TCP 连接可以完全没有任何流量。因此，完全空闲的连接与因网络或服务器问题而过时的连接很难明显区分。现在很多网络设备（如防火墙或 NAT）都可以跟踪 TCP 连接，它们可以转换地址，阻止“错误的”传入数据包，等等。这些设备通常将空闲 N 分钟的连接视为已死亡，其中 N 因不同的设备而异，通常是 10 分钟，甚至更短。</p></li><li><p>避免慢连接（或空闲连接）被视为死亡并被错误杀死的其中一种方法是确保使用了 TCP 的 keepalive。keepalive 是 TCP 协议的一项特性，它会来回发送“ping 数据帧”，避免连接进入完全空闲的状态。它帮助空闲连接检测中断（即使在没有流量的情况下），并让中间系统不会认为连接已死亡。因此，curl 默认使用 TCP keepalive</p></li><li><p><code>--no-keepalive</code>：禁用 keepalive</p></li><li><p><code>--keepalive-time</code>：设置 keepalive 的间隔时间，默认是 60 秒</p></li></ul><h4 id="3-5-6-超时、允许的最长时间和允许的最慢速率"><a href="#3-5-6-超时、允许的最长时间和允许的最慢速率" class="headerlink" title="3.5.6 超时、允许的最长时间和允许的最慢速率"></a>3.5.6 超时、允许的最长时间和允许的最慢速率</h4><ul><li><p>网络操作本质上是不可靠的，甚至是脆弱的，因为它们依赖了一系列服务和网络。这些服务的可用性时有时无，性能也可能随着时间的推移发生很大变化。TCP 允许网络在很长一段时间内完全断开连接，传输的参与者不一定会注意到。这导致的结果就是有时网络传输需要很长时间。另外，curl 的大多数操作默认没有设置超时！</p></li><li><p><code>-m</code>或<code>--max-time</code>：在 curl 抛出超时错误码（28）并退出前，可以用-m 或–max-time 选项告诉 curl 最长有多少时间（以秒为单位）可用。当指定的时间耗尽，无论当时发生什么，curl 都会退出，即使它正在传输数据。</p></li><li><p>如果只能为 curl 设定固定的最长操作时间仍然不够灵活，特别是进行脚本传输且文件大小和传输时间变化非常大时，需要将固定超时时间设得很高，这样才能覆盖最坏的情况。</p></li><li><p><code>--speed-time</code>和<code>--speed-limit</code>：作为固定超时时间的替代方案，你可以告诉 curl，如果传输速率低于某个特定值，并且在某个时间段内一直低于这个值，那么就放弃传输。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 如果 15 秒内的传输速率低于 1000 字节/秒，则停止传输</span><br>curl --speed-tim 15 --speed-limit 1000 http://example.com<br></code></pre></td></tr></table></figure></li></ul><h3 id="3-6-netrc"><a href="#3-6-netrc" class="headerlink" title="3.6 netrc"></a>3.6 netrc</h3><ul><li><p>Unix 系统为用户提供了一种存储远程 FTP 服务器用户名和密码的方式，也就是 netrc 文件。FTP 客户端也一直支持这种方式，让用户可以快速登录到已知服务器，无须每次重新手动输入凭证。.netrc 文件通常保存在用户的主目录中。（在 Windows 系统上，curl 会查找一个名为_netrc 的文件。）</p></li><li><p>netrc 是一个已经广泛使用的概念，curl 也支持它。并且，curl 并没有将这项功能局限在 FTP 上，而是可以为任意协议获取凭证。</p></li><li><p>.netrc 的文件格式很简单：先在前面的行指定计算机名，后面的行是与该计算机相关的登录名和密码。主要是三部分：</p><ul><li><p>机器名：用于标识远程机器名。curl 在.netrc 文件中查找与 URL 中指定的远程机器匹配的名称节点。找到匹配的名称后再处理后续的.netrc 节点，直到到达文件末尾或遇到另一个机器名。</p></li><li><p>登录名：远程机器的用户名字符串。</p></li><li><p>密码字符串：登录远程机器的密码。如果存在这个节点，并且远程服务器要求使用密码登录，那么 curl 就会提供这个字符串。注意，如果.netrc 文件中存在这个节点，你需要确保这个文件不会被用户以外的人读取。</p></li></ul></li><li><p>假设主机名为 example.com，用户名为 hello，密码为 world，那么.netrc 的内容如下所示：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs textile">machine example.com<br>login hello<br>password world<br></code></pre></td></tr></table></figure></li><li><p><code>-n</code>或<code>--netrc</code>：告诉 curl 查找并使用.netrc 文件中的信息。</p></li><li><p><code>--netrc-file</code>：与–netrc 类似，只是你还额外提供了文件的实际路径。当你想要提供的信息位于另一个目录或者想要使用其他文件名时，这会非常有用。</p></li><li><p><code>--netrc-optional</code>：与–netrc 类似，只不过.netrc 文件是可选的。</p></li></ul><h3 id="3-7-代理"><a href="#3-7-代理" class="headerlink" title="3.7 代理"></a>3.7 代理</h3><ul><li><p>代理是代表客户端执行某项操作的机器或软件，类似中间人角色。</p></li><li><p>curl 支持几种不同类型的代理。默认代理类型是 HTTP，因此，如果指定没有 scheme（通常为 http:&#x2F;&#x2F;）的代理主机名（或 IP 地址），那么 curl 会假设它就是 HTTP 代理。curl 还提供了多个选项来设置代理类型，而不是使用 scheme 前缀。</p></li></ul><h4 id="3-7-1-PAC"><a href="#3-7-1-PAC" class="headerlink" title="3.7.1 PAC"></a>3.7.1 PAC</h4><ul><li><p>某些网络环境为不同场景提供了不同类型的代理，浏览器为此提供了一种名为“代理自动配置”（Proxy Auto Config, PAC）的定制化处理方式。</p></li><li><p>PAC 文件包含了一个 JavaScript 函数，用于决定给定的网络连接（URL）应该使用哪个代理，或者也可以不使用代理。通常浏览器通过一个 URL 从本地网络读取 PAC 文件。</p></li><li><p>因为 curl 不支持 JavaScript，所以也不支持 PAC 文件。如果你的浏览器和网络使用了 PAC 文件，最简单的办法是手动读取 PAC 文件，并找出需要指定给 curl 的代理。</p></li></ul><h4 id="3-7-2-HTTP-代理和-HTTPS-代理"><a href="#3-7-2-HTTP-代理和-HTTPS-代理" class="headerlink" title="3.7.2 HTTP 代理和 HTTPS 代理"></a>3.7.2 HTTP 代理和 HTTPS 代理</h4><ul><li><p>HTTP 代理是客户端用来通过 HTTP 完成传输的代理。默认情况下，curl 假设你使用-x 或–proxy 选项指定的主机就是 HTTP 代理。另外，除非你还指定了端口号，否则它将默认使用端口 3128（使用这个特定端口号纯粹是历史原因）。</p></li><li><p><code>-x</code>或<code>--proxy</code>：指定 HTTP 代理主机（和端口）</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 用主机 192.168.0.1 端口 8080 上的代理来请求 example.com 网页</span><br>curl -x 192.168.0.1:8080 http://example.com<br></code></pre></td></tr></table></figure></li><li><p>如果在与代理通信时通过-v 启用详细模式，你将看到 curl 连接的是代理而不是远程服务器，而且它使用了稍微不同的请求行。</p></li><li><p>HTTPS 旨在为客户端和服务器（以及后端）提供安全的端到端隐私。为了在使用 HTTP 代理时仍然能够提供这种安全隐私，HTTP 协议提供了一种特殊的请求，curl 可以用它设置一个通道，这个通道经过代理，并可以对流量进行加密和验证。这个 HTTP 方法就是 CONNECT。</p></li><li><p>用 CONNECT 方法设置好通道后，数据流经通道时就会被加密，代理在不破坏加密的情况下是无法查看或修改流量的</p></li></ul><h4 id="3-7-3-MITM-代理"><a href="#3-7-3-MITM-代理" class="headerlink" title="3.7.3 MITM 代理"></a>3.7.3 MITM 代理</h4><ul><li><p>MITM 是 Man-In-The-Middle（中间人）的简写。想要对 TLS 加密流量进行监控的公司通常会在“企业环境”和其他地方部署 MITM 代理。</p></li><li><p>MITM 要求用户在客户端安装自定义“信任根”（CA 证书），代理将会终结来自客户端的所有 TLS 流量，然后模拟远程服务器并充当代理。接下来，代理会返回由自定义 CA 签名的生成证书。这类代理通常会捕获从客户端发到远程计算机 TCP 443 端口的所有流量。在这样的网络中运行 curl 会导致其 HTTPS 流量被捕获。当然，这种做法为中间人窥探和解密 TLS 流量提供了机会。</p></li></ul><h4 id="3-7-4-非-HTTP-协议"><a href="#3-7-4-非-HTTP-协议" class="headerlink" title="3.7.4 非 HTTP 协议"></a>3.7.4 非 HTTP 协议</h4><ul><li><p>“HTTP 代理”意味着代理本身使用的是 HTTP 协议。HTTP 代理主要用于代理 HTTP 流量，但也支持其他协议，比如 FTP。</p></li><li><p>通过 HTTP 代理进行 FTP 传输意味着需要假装其他协议就像 HTTP 一样，然后要求代理“获取某个 URL”，即使这个 URL 不是基于 HTTP 的。这点很重要，因为这意味着通过 HTTP 代理发送流量时，即使指定了 FTP URL, curl 也不会真正使用 FTP，因此 FTP 的相关特性将不起作用</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">curl -x http://proxy.example.com:8080 ftp://ftp.example.com/file.txt<br></code></pre></td></tr></table></figure></li></ul><h4 id="3-7-5-HTTP-代理通道"><a href="#3-7-5-HTTP-代理通道" class="headerlink" title="3.7.5 HTTP 代理通道"></a>3.7.5 HTTP 代理通道</h4><ul><li><p><code>-p</code>或<code>--proxytunnel</code>：让 curl 穿过 HTTP 代理。</p></li><li><p>大多数 HTTP 代理允许客户端“穿过”它，到达另一端的服务器。通过 HTTP 代理执行 HTTPS 传输就是一个很好的示例。</p></li><li><p>通过代理执行 HTTPS 传输时，通常会连接到远程默认的 HTTPS TCP 443 端口。你会发现，大多数 HTTP 代理只允许连接到这个端口，或许还会有其他少数几个端口。大多数代理会拒绝客户端连接到随机端口上。不过，假设 HTTP 代理允许连接到随机端口，那么你可以要求它通过通道连接到远程服务器的任意端口，这样就可以“正常”使用其他协议。可以按照以下方式使用 FTP 通道：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">curl -p -x http://proxy.example.com:8080 ftp://ftp.example.com/file.txt<br></code></pre></td></tr></table></figure></li><li><p><code>--proxy1.0</code>：让 curl 在发送给 HTTP 代理的 CONNECT 请求中使用 HTTP&#x2F;1.0</p></li></ul><h4 id="3-7-6-SOCKS-类型代理"><a href="#3-7-6-SOCKS-类型代理" class="headerlink" title="3.7.6 SOCKS 类型代理"></a>3.7.6 SOCKS 类型代理</h4><ul><li><p>SOCKS 是一种代理协议，curl 支持 SOCKS 4 和 SOCKS 5，每种版本都有两种使用方法。</p></li><li><p>可以通过-x 选项指定 SOCKS 版本，对于这种情况，给定的代理主机的 scheme 部分就是 SOCKS 版本，你也可以使用单独的选项来指定。</p></li><li><p>与 SOCKS4 类似，但是 SOCKS4a 不在本地解析主机名，会将主机名发送给服务器。</p></li><li><p>与 SOCKS5 类似，但是 SOCKS5-hostname 不在本地解析主机名，会将主机名发送给服务器。</p></li><li><p>示例：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># SOCKS4</span><br>curl -x socks4://proxy.example.com http://example.com<br>curl --socks4 proxy.example.com http://example.com<br><span class="hljs-comment"># SOCKS4a</span><br>curl -x socks4a://proxy.example.com http://example.com<br>curl --socks4a proxy.example.com http://example.com<br><span class="hljs-comment"># SOCKS5</span><br>curl -x socks5://proxy.example.com http://example.com<br>curl --socks5 proxy.example.com http://example.com<br><span class="hljs-comment"># SOCKS5a</span><br>curl -x socks5h://proxy.example.com http://example.com<br>curl --socks5-hostname proxy.example.com http://example.com<br></code></pre></td></tr></table></figure></li></ul><h4 id="3-7-7-代理身份验证"><a href="#3-7-7-代理身份验证" class="headerlink" title="3.7.7 代理身份验证"></a>3.7.7 代理身份验证</h4><ul><li><p>HTTP 代理可以要求进行身份验证，因此 curl 需要向代理提供适当的凭证，否则代理将返回 407 HTTP 响应码。代理的身份验证与“普通”的 HTTP 身份验证非常相似，但它与服务器身份验证是分开的，这样客户端就可以单独使用常规的主机身份验证和代理身份验证。</p></li><li><p><code>-U</code>或<code>--proxy-user</code>：设置代理身份验证的用户名和密码</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">curl -U hello:world -x proxy.example.com:80 http://example.com<br></code></pre></td></tr></table></figure></li><li><p><code>--proxy-digest</code>和<code>--proxy-negotiate</code>和<code>--proxy-ntlm</code>：一些代理会要求使用另一种身份验证方案（代理在返回 407 响应码时会在标头中告诉你使用哪个方案），你可以用–proxy-digest、–proxy-negotiate、–proxy-ntlm 指定要使用的方法。</p></li><li><p><code>--proxy-anyauth</code>：你还可以让 curl 找出代理支持的认证方法，然后通过–proxy-anyauth 使用这些方法（可能需要发送额外的请求）。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">curl -U hello:world --proxy-anyauth -x proxy.example.com:80 http://example.com<br></code></pre></td></tr></table></figure></li></ul><h4 id="3-7-8-使用-HTTPS-连接代理"><a href="#3-7-8-使用-HTTPS-连接代理" class="headerlink" title="3.7.8 使用 HTTPS 连接代理"></a>3.7.8 使用 HTTPS 连接代理</h4><ul><li>前面提到的连接代理的所有协议都是明文协议，如 HTTP 和 SOCKS。使用这些方法将导致某些人可以通过代理所在的本地网络窃听你的流量。解决方案之一是使用 HTTPS 连接代理，从而建立一个安全的加密连接，这样就不容易被监视。</li></ul><h4 id="3-7-9-代理环境变量"><a href="#3-7-9-代理环境变量" class="headerlink" title="3.7.9 代理环境变量"></a>3.7.9 代理环境变量</h4><ul><li><p>curl 会在运行前检查是否存在某些特殊的环境变量，然后根据这些变量决定是否使用代理。可以通过设置 [scheme]_proxy 变量来指定代理（与用-x 指定主机名的方式相同）。因此，要想让 curl 访问 HTTP 服务器时使用代理，则需要设置 http_proxy 环境变量，如下所示：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">http_proxy=http://proxy.example.com:80<br>cur; http://example.com<br></code></pre></td></tr></table></figure></li><li><p>也可以设置 ftp_proxy、https_proxy，等等。除 http_proxy 外的所有环境变量名也可以是大写的，如 HTTPS_PROXY。还可以通过单个变量 ALL_PROXY 来设置所有的协议。如果存在某个特定的协议变量，则优先使用这个变量。</p></li><li><p>使用环境变量设置代理时，很容易遇到需要将一个或几个无须使用代理的主机名排除在外的情况。这个时候需要使用 NO_PROXY 变量。我们使用逗号分隔这些不需要使用代理的主机名。你也可以将 NO_PROXY 设置为单个星号（’＊’）以匹配所有主机。</p></li><li><p><code>--noproxy</code>：与 NO_PROXY 变量的作用相同。</p></li></ul><h3 id="3-8-退出状态"><a href="#3-8-退出状态" class="headerlink" title="3.8 退出状态"></a>3.8 退出状态</h3><ul><li><p>curl 在出现问题时返回一个可用的退出码，如果一切正常则返回 0（零）</p></li><li><p>可用的退出码列表：<a href="./curl%E5%8F%AF%E7%94%A8%E7%9A%84%E9%80%80%E5%87%BA%E7%A0%81.md">curl 可用的退出码</a></p></li><li><p>以非零状态码退出时，curl 还会输出一个错误消息（除非使用了–silent 选项）。这个错误消息可能会包含一些额外的信息，因此，相同的错误码可能会与不同的错误消息一起出现。</p></li><li><p>前面的状态码列表包含了很多标记为“未使用”的数字。这些状态码没有用于现在版本的 curl 中，但过去曾经被使用过或打算使用。它们很可能会用于未来的 curl 版本中。</p></li><li><p>另外，状态码列表中最大的错误状态码是 92，但这并不代表未来的 curl 版本不会在这个数字之后添加更多的退出码。</p></li></ul><h3 id="3-9-FTP"><a href="#3-9-FTP" class="headerlink" title="3.9 FTP"></a>3.9 FTP</h3><ul><li><p>FTP 出现在互联网和计算机的一个特殊时代，因此它的工作方式与大多数其他协议略有不同。如果一切运行正常，通常可以忽略这些差异，但如果出现异常，就很有必要了解这些差异了。</p></li><li><p>FTP 协议是一种命令和响应协议（ping-pong），客户端发送命令，服务器做出响应。对于普通的传输，需要发送 5～8 个命令，服务器则需要做出等量响应。如果服务器是在远程，那么开始传输文件前需要花很多时间在 ping-pong 上。对于较小的文件，初始化命令很可能比实际数据传输花费更长的时间。</p></li></ul><h4 id="3-9-1-传输模式"><a href="#3-9-1-传输模式" class="headerlink" title="3.9.1 传输模式"></a>3.9.1 传输模式</h4><ul><li><p>当 FTP 客户端开始传输数据时，它会向服务器指定要使用哪种“传输模式”。curl 支持的两种传输模式是“ASCII”和“BINARY”。ASCII 基本上用于文本，服务器将发送带有换行符的文件，而 BINARY 表示发送未经修改的数据，并假设要发送的文件不是文本文件。</p></li><li><p>curl 将默认使用 FTP 的 BINARY 传输模式，你可以通过-B、–use-ascii 选项或者以；type&#x3D;A 作为 URL 的结尾来切换到 ASCII 模式。</p></li><li><p><code>-B</code>或<code>--use-aciii</code>：对于 FTP 传输，切换为 ASCII 模式</p></li></ul><h4 id="3-9-2-身份验证"><a href="#3-9-2-身份验证" class="headerlink" title="3.9.2 身份验证"></a>3.9.2 身份验证</h4><ul><li><p>访问 FTP 通常需要用户名和密码，否则就无法访问。有些系统允许“匿名”访问，你可以使用自己喜欢的任意用户名和密码登录。</p></li><li><p>在使用 curl 进行 FTP 传输但没有指定用户名或密码的情况下，它将使用用户名 anonymous 和密码 <a href="mailto:&#102;&#116;&#x70;&#x40;&#101;&#x78;&#97;&#109;&#x70;&#108;&#101;&#46;&#x63;&#x6f;&#109;">&#102;&#116;&#x70;&#x40;&#101;&#x78;&#97;&#109;&#x70;&#108;&#101;&#46;&#x63;&#x6f;&#109;</a>。</p></li><li><p>要想提供其他用户名和密码，可以通过-u 或–user 选项将它们传给 curl，或者包含在 URL 中。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">curl -u hello:world ftp://example.com/download<br>curl ftp://hello:world@example.com/download<br></code></pre></td></tr></table></figure></li></ul><h4 id="3-9-3-建立连接"><a href="#3-9-3-建立连接" class="headerlink" title="3.9.3 建立连接"></a>3.9.3 建立连接</h4><ul><li><p>FTP 使用两个 TCP 连接！客户端在连接到 FTP 服务器时建立第一个连接，称作控制连接。作为初始连接，它将负责处理身份验证、切换到正确的远程服务器目录，等等。当客户端准备好传输文件时，第二个 TCP 连接将建立，并通过这个连接传输数据。因为各种原因，建立第二个连接会很麻烦。</p></li><li><p>建立用于数据传输的 TCP 连接有两种方式：主动连接和被动连接</p></li><li><p>客户端可以请求服务器回连到客户端来建立连接，即所谓的“主动”连接。这可以通过 PORT 或 EPRT 命令来完成。要想让远程主机回连到客户端端口，它们中间不能有防火墙或其他网络设备，但现实情况并非总是如此。</p></li><li><p><code>-P</code>或<code>--ftp-port</code>：请求进行主动传输。这个选项允许你指定要使用的地址，不过通常可以通过-P -指定当前的地址</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">curl -P - ftp://example.com/download<br></code></pre></td></tr></table></figure></li><li><p><code>--no-eprt</code>：可以通过–no-eprt 选项明确要求 curl 不使用 EPRT（这是一个比 PORT 略新的命令）。</p></li><li><p>curl 默认请求使用“被动”连接，它向服务器发送 PASV 或 EPSV 命令，服务器为第二个连接打开一个新端口，然后 curl 会连接到这个端口上。连接到新端口通常更加容易，对终端用户和客户端的限制也较少，但服务器端所在的网络必须允许这些连接。</p></li><li><p><code>--ftp-pasv</code>：默认情况下，curl 启用的是被动连接，但如果之前已启用了主动连接，可以使用–ftp-pasv 切换回被动连接。</p></li><li><p><code>--ftp-skip-pasv-ip</code>：有时候，因为服务器的一些奇怪设置，当 curl 发出 PASV 命令时，服务器会向 curl 返回一个 IP 地址，但这个地址可能是错误的，以至于 curl 无法建立数据连接。对于这种（很少见的）情况，你可以要求 curl 忽略 PASV 响应中返回的 IP 地址（–ftp-skip-pasv-ip），然后使用与控制连接相同的 IP 地址。</p></li></ul><h4 id="3-9-4-遍历目录"><a href="#3-9-4-遍历目录" class="headerlink" title="3.9.4 遍历目录"></a>3.9.4 遍历目录</h4><ul><li><p>在使用 FTP 命令遍历远程文件系统时，curl 可以通过几种不同的方式来访问目标文件，即用户想要传输的文件，分别为 multicwd、nocwd、singlecwd。</p></li><li><p><code>--ftp-method</code>：指定 FTP 访问文件的方法</p></li><li><p>mulicwd：curl 可以顺着文件树结构的每个目录执行一次更改目录命令（CWD）。如果完整路径是 one&#x2F;two&#x2F;three&#x2F;file.txt，那么请求传输 file.txt 文件前会执行三次 CWD 命令。因此，如果路径深度很深，则需要执行大量的 CWD 命令。早期规范（RFC 1738）强制要求使用这种方法，这也是 curl 的默认行为。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">curl --ftp-method multicwd ftp://example.com/one/two/three/file.txt<br></code></pre></td></tr></table></figure></li><li><p>nocwd：与为每个目录执行一次 CWD 命令相反的做法是不更改目录。这种方法请求服务器一次性使用整个路径，因此速度非常快。但有时在服务器上使用这种方法也会有问题，而且它并不符合标准。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">curl --ftp-method nocwd ftp://example.com/one/two/three/file.txt<br></code></pre></td></tr></table></figure></li><li><p>singlecwd：这种方法介于上述两种 FTP 方法之间。它会向目标目录发出一个 CWD 命令，然后请求指定的文件。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">curl --ftp-method singlecwd ftp://example.com/one/two/three/file.txt<br></code></pre></td></tr></table></figure></li></ul><h4 id="3-9-5-高级特性"><a href="#3-9-5-高级特性" class="headerlink" title="3.9.5 高级特性"></a>3.9.5 高级特性</h4><ul><li><p>你可以让 curl 列出远程 FTP 目录列表，只需要在 URL 末尾添加斜杠。如果 URL 以斜杠结尾，curl 会认为你要列出这个目录。如果它不是目录，你很可能会得到一个错误。</p></li><li><p><code>-l</code>或<code>--list-only</code>：在使用标准的 FTP 命令 LIST 列出目录时，返回的目录结构没有标准的格式。返回的列表通常是可以被人类理解的，但不同的服务器返回的列表结构稍有不同。要想列出目录中的所有内容并避免出现特殊格式，可以使用–list-only（或-l）选项。curl 会发出 FTP 命令 NLST。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">curl --list-only ftp://example.com/dir/<br></code></pre></td></tr></table></figure></li><li><p>NLST 也有一些奇怪的地方，有些 FTP 服务器在响应 NLST 命令时只列出文件部分，不包含目录和符号链接！</p></li><li><p><code>-T</code>或<code>--upload-file</code>：要想上传文件到 FTP 服务器，需要在 URL 中指定整个目标文件的路径和名字，并用-T 或–upload-file 选项指定要上传的本地文件。另外，如果目标 URL 以斜杠结尾，curl 会自动将本地路径中的文件名追加到 URL 中，并将其作为远程文件名。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">curl -T localfile ftp://example.com/dir/path/<br></code></pre></td></tr></table></figure></li><li><p>-T 参数支持通配。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">curl -T localfile[1-100] ftp://example.com/dir/path/<br></code></pre></td></tr></table></figure></li></ul><h3 id="3-10-SCP-和-SFTP"><a href="#3-10-SCP-和-SFTP" class="headerlink" title="3.10 SCP 和 SFTP"></a>3.10 SCP 和 SFTP</h3><ul><li><p>如果用第三方库 libssh2 来构建 curl，那么它就可以支持 SCP 和 SFTP 协议。</p></li><li><p>SCP 和 SFTP 都是建立在 SSH 之上的协议，SSH 是一种类似于 TLS 的安全加密数据协议，但在某些方面有所不同。例如，SSH 不使用任何类型的证书，而是使用公钥和私钥。如果使用得当，SSH 和 TLS 都可以提供强大的安全传输。（SCP 协议通常被认为是二者当中的“害群之马”，因为它的可移植性比较差，通常只能在 Unix 系统之间使用。）</p></li><li><p>SFTP 和 SCP 的 URL 与其他 URL 类似，使用这些协议下载文件的方式与其他协议差不多。如果 URL 尾部是斜杠，那么 SFTP（不是 SCP）可以获取文件列表。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">curl -u user sftp://example.com/file<br></code></pre></td></tr></table></figure></li><li><p>在使用 SFTP 或 SCP URL 请求文件时，给定的文件路径被视为远程服务器上的绝对路径，除非你特别指定要使用用户主目录的相对路径。你可以使用&#x2F;～&#x2F;来指定用户主目录的相对路径。这与 FTP URL 完全相反，因此容易导致用户混淆。</p></li><li><p>安全的网络客户端需要确保远程主机就是它要与之通信的主机。在使用基于 TLS 的协议时，这是通过客户端验证服务器的证书来实现的。SSH 协议不使用服务器证书，但每个服务器都需要提供唯一的密钥。而且与 TLS 不同的是，SSH 没有证书颁发机构，因此客户端需要确保主机的密钥与它已经知道的（通过其他方式获得的）信息相匹配。</p></li><li><p>密钥匹配通常需要用到密钥的散列和客户端用来保存已知服务器散列的文件，这个文件通常叫作 known_hosts，存放在专门的 SSH 目录中。在 Linux 系统上，通常是～&#x2F;.ssh 目录。</p></li><li><p>当连接到 SFTP 或 SCP 主机时，curl 会先确认主机的密钥散列已存在于已知主机的文件中，否则它将拒绝后续操作，因为它不相信现在连接的服务器就是真正的目标主机。如果 known_hosts 中存在正确的散列，curl 就会开始执行传输。</p></li><li><p><code>-k</code>或<code>--insecure</code>：要想强制 curl 跳过检查，可以使用-k 或–insecure 选项。在使用这两个选项时必须非常小心，因为这样有可能检测不到中间人的攻击。</p></li></ul><h3 id="3-11-IMAP-和-POP3"><a href="#3-11-IMAP-和-POP3" class="headerlink" title="3.11 IMAP 和 POP3"></a>3.11 IMAP 和 POP3</h3><ul><li><p>在互联网领域，从服务器读取或下载电子邮件（如果不把基于 Web 的读取方式算在内）的协议主要有两种，它们是 IMAP 和 POP3。前者稍微更加现代一些。curl 同时支持这两种协议。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 列出邮件编号和大小</span><br>curl pop3://mail.example.com/<br><span class="hljs-comment"># 下载邮件</span><br>curl pop3://mail.example.com/1<br><span class="hljs-comment"># 删除邮件</span><br>curl --reuqest pop3://mail.example.com/1<br></code></pre></td></tr></table></figure></li></ul><h3 id="3-12-SMTP"><a href="#3-12-SMTP" class="headerlink" title="3.12 SMTP"></a>3.12 SMTP</h3><ul><li><p>SMTP 是简单邮件传输协议（Simple Mail Transfer Protocol）的简写。curl 支持将数据发送到 SMTP 服务器，可以通过一系列命令行选项将电子邮件发送给指定的一组收件人。</p></li><li><p><code>--mail-rcpt</code>：通过该选项告诉服务器收件人的邮件地址（至少一个）。可以多次使用这个选项，curl 会告诉服务器所有指定的收件人都应该收到这封电子邮件。</p></li><li><p><code>--mail-from</code>：通过该选项告诉服务器哪个是发件人的邮件地址。这个电子邮件地址与显示在邮件正文中的 From：不一定相同。</p></li><li><p>使用 curl 发送 SMTP 时，以上两个命令行选项是必选项。然后，你需要提供要发送的电子邮件数据。它应该是一个使用 RFC 5322 指定格式的（文本）文件。它由一组标头和正文组成。标头和正文都需要进行正确编码。标头通常包括 To:、From:、Subject:、Date：等。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs bash">curl smtp://mail.example.com \<br> --mail-from myself@example.com \<br> --mail-rcpt receiver@example.com \<br> --upload-file email.txt<br></code></pre></td></tr></table></figure></li><li><p>有些邮件提供商允许或要求使用 SSL 进行 SMTP 传输。他们可能为 SSL 分配了专门的端口，或允许从明文连接升级到 SSL 连接。如果你的邮件提供商提供了专门的 SSL 端口，则可以用 smtps:&#x2F;&#x2F; 代替 smtp:&#x2F;&#x2F;，默认的 SMTP SSL 端口为 465，并且整个连接都是基于 SSL，如 smtps:&#x2F;&#x2F;smtp.gmail.com&#x2F;。</p></li><li><p><code>--ssl</code>：尝试使用 SSL&#x2F;TLS（FTP、IMAP、POP3、SMTP）。</p></li><li><p><code>--ssl-reqd</code>：要求使用 SSL&#x2F;TLS（FTP、IMAP、POP3、SMTP）。</p></li><li><p>如果你的提供商允许从明文升级到安全传输，则可以使用以上两个选项。</p></li><li><p>可以通过–ssl 选项让 curl 尝试但不一定要升级到安全传输：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs bash">curl --ssl smtp://mail.example.com<br> --mail-from myself@example.com \<br> --mail-rcpt receiver@example.com \<br> --upload-file email.txt<br></code></pre></td></tr></table></figure></li><li><p>也可以通过–ssl-reqd 选项让 curl 一定要升级到安全传输：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs bash">curl --ssl smtp://mail.example.com<br> --mail-from myself@example.com \<br> --mail-rcpt receiver@example.com \<br> --upload-file email.txt<br></code></pre></td></tr></table></figure></li><li><p>SMTP 请求的路径部分指定了与邮件服务器通信期间显示的主机名。如果省略了路径，那么 curl 将尝试使用本地计算机的主机名。不过，这样可能不会得到某些邮件服务器要求的完全限定名。你可以在路径中指定其他名字，例如计算机的完全限定名，完全限定名可以通过外部函数获取，例如 gethostname 或 getaddrinfo。</p></li><li><p>要想 curl 在 HELO 或 EHLO 命令中将 client.example.com 发送到邮件服务器 mail.example.com，参见以下方式：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">curl smtp://example.com/client.example.com<br></code></pre></td></tr></table></figure></li><li><p>用普通邮件客户端发送电子邮件时，它首先会检查目标域名的 MX 记录。如果向 <a href="mailto:&#106;&#x6f;&#x65;&#x40;&#x65;&#x78;&#x61;&#109;&#x70;&#108;&#101;&#46;&#x63;&#111;&#x6d;">&#106;&#x6f;&#x65;&#x40;&#x65;&#x78;&#x61;&#109;&#x70;&#108;&#101;&#46;&#x63;&#111;&#x6d;</a> 发送电子邮件，客户端将获取 example.com 的 MX 记录，以便找出向 example.com 发送电子邮件时需要用到的邮件服务器。</p></li><li><p>curl 本身不进行 MX 查找。如果想要指定向某个服务器发送电子邮件，需要先将它们找出来，然后在 curl 中指定这些服务器。</p></li></ul><h3 id="3-13-TLS"><a href="#3-13-TLS" class="headerlink" title="3.13 TLS"></a>3.13 TLS</h3><ul><li><p>TLS 是传输层安全（Transport Layer Security）的简写，这项技术之前叫作 SSL。不过 SSL 这个术语并没有真正消失，现在 TLS 和 SSL 这两个术语经常互换使用，实际上它们指的是同一个东西。TLS 是 TCP“之上”的一个加密安全层，基于强大的公钥加密和数字签名实现数据防篡改，并确保服务器的可靠性。</p></li><li><p>当 curl 连接到 TLS 服务器时，它们会协商如何使用协议，协商过程涉及一些参数和变量，双方需要在这些参数和变量上达成一致。</p></li><li><p>协商的其中一个参数是关于使用哪种加密算法，即所谓的密码。随着时间的推移，安全研究人员会发现现有密码存在缺陷和弱点，因此它们会逐渐被淘汰。</p></li><li><p><code>--ciphers</code>：可以通过-v 选项获得协商过程中确定的密码和 TLS 版本，也可以通过–ciphers 选项更改协商中优先使用的密码</p></li></ul><h4 id="3-13-1-启用-TLS"><a href="#3-13-1-启用-TLS" class="headerlink" title="3.13.1 启用 TLS"></a>3.13.1 启用 TLS</h4><ul><li><p>curl 支持很多协议的 TLS 版本。HTTP 有 HTTPS、FTP 有 FTPS、LDAP 有 LDAPS、POP3 有 POP3S、IMAP 有 IMAPS、SMTP 有 SMTPS。如果服务器端也支持，则可以在 curl 中使用这些协议的 TLS 版本。</p></li><li><p>启用 TLS 的方法有两种。</p><ul><li><p>一种是从第一次进行连接握手时就使用 TLS；</p></li><li><p>另一种是用协议特定指令将连接从明文“升级”到 TLS；</p></li></ul></li><li><p><code>--ssl</code>：尝试将非 TLS 连接升级到基于 TLS 的连接。</p></li><li><p><code>--ssl-reqd</code>：要求将非 TLS 连接升级到基于 TLS 的连接。</p></li><li><p>如果在 URL 中明确指定了协议的 TLS 版本（以“S”字符结尾）, curl 将尝试从一开始就建立 TLS 连接，而如果指定了非 TLS 版本，通常可以用–ssl 选项将连接升级到基于 TLS 的连接。</p></li><li><p>使用–ssl 选项意味着 curl 会尝试将连接升级到 TLS，但如果失败，它仍将继续使用明文协议来执行传输。如果一定要使用 TLS 连接，可以使用–ssl-reqd 选项，使用这个选项时，如果 curl 无法成功进行 TLS 协商，传输就会失败。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">curl --ssl-reqd ftp://ftp.example.com/file.txt<br></code></pre></td></tr></table></figure></li></ul><h4 id="3-13-2-SSL-和-TLS-版本"><a href="#3-13-2-SSL-和-TLS-版本" class="headerlink" title="3.13.2 SSL 和 TLS 版本"></a>3.13.2 SSL 和 TLS 版本</h4><ul><li><p>SSL 是在 20 世纪 90 年代中期发明并发展起来的。SSL 2 是第一个在互联网上广泛使用的版本，但很久以前就被认为是不安全的。然后就有了 SSL 3，但它也被认为不够安全。</p></li><li><p>TLS 1.0 是第一个“标准”。RFC 2246 于 1999 年发布。TLS 1.1 于 2006 年问世，此版进一步提高了安全性，然后是 2008 年的 TLS 1.2。十年来，TLS 1.2 一直是 TLS 的黄金标准。</p></li><li><p>2018 年 8 月，IETF 最终确定了 TLS 1.3（RFC 8446），并将其作为标准发布。这是迄今为止最安全、最快的 TLS 版本。但因为刚发布不久，很多软件、工具和库尚不支持它。</p></li><li><p>curl 默认使用 SSL&#x2F;TLS 的“安全版本”，也就是说，除非特别说明，否则它不会进行 SSL 2 或 SSL 3 协商。实际上，一些 TLS 库不再支持这些协议，因此，在很多情况下，除非你费了很大劲，否则 curl 甚至无法使用这些协议版本。</p></li></ul><h4 id="3-13-3-验证服务器证书和-CA-存储"><a href="#3-13-3-验证服务器证书和-CA-存储" class="headerlink" title="3.13.3 验证服务器证书和 CA 存储"></a>3.13.3 验证服务器证书和 CA 存储</h4><ul><li><p>如果不确定是否正在与正确的主机通信，那么就没有必要与服务器建立安全连接。如果不知道这一点，就有可能是在与一个冒名顶替者通信。为了确认是否与正确的 TLS 服务器通信，curl 会使用一组存储在本地的 CA 证书来验证服务器的证书签名。作为 TLS 握手的一部分，所有服务器都需要向客户端提供证书，并且所有使用 TLS 的公共服务器都会从证书颁发机构获取证书。</p></li><li><p><code>-k</code>或<code>--insecure</code>：降低安全级别。在极少数情况下，即使证书验证失败，你可能仍然希望与 TLS 服务器展开通信。如果是这样，则必须接受你的通信可能受到中间人攻击的事实。</p></li><li><p>curl 需要一个“CA 存储”（包含了一组 CA 证书）来验证 TLS 服务器。如果使用某个平台的“本地”TLS 库来构建 curl，那么这个库很可能使用了本地的 CA 存储。如果不是，那么必须让 curl 知道本地 CA 存储的位置，或者用户在调用 curl 时需要提供指向 CA 存储的路径。</p></li><li><p><code>--cacert</code>：指定要在 TLS 握手中使用的 CA 捆绑包，这个捆绑包需要采用 PEM 格式，也可以通过环境变量 CURL_CA_BUNDLE 设置捆绑包的完整路径。</p></li><li><p>在 Windows 上，没有用本地 TLS 库（Schannel）构建的 curl 需要按照一定顺序来查找和使用 CA 存储。curl 将按以下顺序在这些目录中搜索名为“curl-ca-bundle.crt”的 CA 证书文件。</p><ul><li><p>应用的目录。</p></li><li><p>当前工作目录。</p></li><li><p>Windows 系统目录（如 C:\windows\system32）。</p></li><li><p>Windows 目录（如 C:\windows）。</p></li><li><p>%PATH%中的所有目录。</p></li></ul></li></ul><h4 id="3-13-4-证书固定"><a href="#3-13-4-证书固定" class="headerlink" title="3.13.4 证书固定"></a>3.13.4 证书固定</h4><ul><li><p>TLS 证书固定用于验证签署服务器证书的公钥是否保持不变，即公钥是否是“固定”的。在进行 TLS 或 SSL 协商时，服务器会发送一个证明其身份的证书。如果从证书中提取的公钥与命令行给定的公钥不完全匹配，curl 将在开始发送或接收数据前中止连接。</p></li><li><p>可以为 curl 指定一个文件，让它从这个文件中读取 sha256 值，或者直接在命令行中用“sha256&#x2F;&#x2F;”前缀指定 base64 编码的散列。可以指定一个或多个这样的散列，用分号（;）分隔。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">curl --pinnedpubkey <span class="hljs-string">&quot;sha//&quot;</span> https://example.com<br></code></pre></td></tr></table></figure></li><li><p>并不是所有的 TLS 后端都支持这个特性。</p></li></ul><h4 id="3-13-5-OCSP-装订"><a href="#3-13-5-OCSP-装订" class="headerlink" title="3.13.5 OCSP 装订"></a>3.13.5 OCSP 装订</h4><ul><li><p>OCSP 装订是指通过 TLS 扩展（证书状态请求，Certificate Status Request）要求服务器在握手过程中提供新的“证据”，即返回的证书仍然有效。这是一种确保服务器证书未被撤销的方法。如果服务器不支持这个扩展，那么测试将会失败，curl 将返回错误。服务器不支持这种扩展的情况太常见了。</p></li><li><p><code>--cert-status</code>：要求在握手时使用装台请求</p></li><li><p>只有 OpenSSL、GnuTLS 和 NSS 后端支持这个特性。</p></li></ul><h4 id="3-13-6-客户端证书"><a href="#3-13-6-客户端证书" class="headerlink" title="3.13.6 客户端证书"></a>3.13.6 客户端证书</h4><ul><li><p>TLS 客户端证书是客户端以加密的方式向服务器证明自己就是真正对等方的一种方式。在命令行中指定证书和相应的密钥，然后在与服务器进行 TLS 握手时传递它们。密钥通常有密码保护，你需要提供密码或者以交互式的方式输入密码。</p></li><li><p><code>--cert</code>和<code>--key</code>：curl 提供了一些选项让你可以指定单个文件，这些文件既是客户端证书又是私钥（通过–cert 选项连接在一起），也可以用–key 单独指定密钥文件：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">curl --cert mycert:mypassword https://example.com<br>curl --cert mycert:mypassword --key mykey https://example.com<br></code></pre></td></tr></table></figure></li><li><p>对于某些 TLS 后端，也可以传递不同类型的密钥和证书：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash">curl --certmycert:mypassword --cert-type PEM \<br> --key mykey --key-type PEM<br> https://example.com<br></code></pre></td></tr></table></figure></li></ul><h2 id="第四章-用-curl-执行-HTTP-操作"><a href="#第四章-用-curl-执行-HTTP-操作" class="headerlink" title="第四章 用 curl 执行 HTTP 操作"></a>第四章 用 curl 执行 HTTP 操作</h2><h3 id="4-1-协议基础"><a href="#4-1-协议基础" class="headerlink" title="4.1 协议基础"></a>4.1 协议基础</h3><ul><li><p>每个 HTTP 请求都包含了一个方法，有时也被称为动词。最常用的方法是 GET、POST、HEAD 和 PUT。不过，通常不会在命令行中指定方法，具体使用哪个方法取决于使用的选项。默认方法是 GET, -d 或-F 选项对应 POST 方法，-I 对应 HEAD 方法，-T 对应 PUT 方法。</p></li><li><p><code>-G</code>或<code>--get</code>：使用 GET 方法。</p></li><li><p>-<code>d</code>或<code>--data</code>：使用 POST 方法。</p></li><li><p><code>-F</code>：使用 POST 方法。</p></li><li><p><code>-I</code>：使用 HEAD 方法。</p></li><li><p><code>-T</code>：使用 PUT 方法。</p></li><li><p>如果 HTTP URL 路径中包含&#x2F;..&#x2F;或&#x2F;.&#x2F;这样的字符串，curl 会在将路径发送到服务器前自动压缩它们，这些字符串的含义与本地文件系统中的路径含义是一样的。&#x2F;..&#x2F;前面的部分会被移除，因此&#x2F;hello&#x2F;sir&#x2F;..&#x2F;会变成&#x2F;hello&#x2F;, &#x2F;.&#x2F;会直接被移除，因此&#x2F;hello&#x2F;.&#x2F;sir&#x2F;会变成&#x2F;hello&#x2F;sir&#x2F;。</p></li><li><p><code>--path-as-is</code>：防止 curl 在将这些路径字符串发送到服务器前压缩它们</p></li></ul><h3 id="4-2-响应"><a href="#4-2-响应" class="headerlink" title="4.2 响应"></a>4.2 响应</h3><ul><li><p>当 HTTP 客户端与服务器进行 HTTP 对话时，服务器将返回 HTTP 响应消息，否则 curl 会认为服务器出了问题，然后返回 (52) 错误码，并显示错误消息“Emptyreply from server”。</p></li><li><p>HTTP 响应消息具有一定的大小，curl 需要知道它是多少。HTTP 响应消息的结束可以通过几种不同的方式来表示，其中最基本的方法是在消息中使用 Content-Length：标头，并在标头中指定响应正文的字节数。</p></li><li><p><code>--ignore-content-length</code>：一些早期的 HTTP 服务器在文件大小超过 2GB 时会有问题，并在 Content-Length：标头中发送负的字节数，或者发送错误的数据。可以通过–ignore-content-length 选项让 curl 完全忽略 Content-Length：标头。这样做可能会产生一些负作用，但至少可以获取到数据。</p></li><li><p>HTTP 响应消息的第一行有一个 3 位数的响应码。响应码是服务器用来告诉客户端它是如何处理请求的一种方式。注意，即使响应码表明无法获取所请求的文档（或类似情况）, curl 也不会将其视为错误。只要 HTTP 发送和接收成功，curl 都将其视为正常情况。</p></li><li><p>因为同一个 curl 传输中可能存在一个 HTTP 请求和一个 CONNECT 请求，所以我们通常需要将 CONNECT 响应（来自代理）与远程服务器的 HTTP 响应区分开。CONNECT 也是一个 HTTP 请求，因此它将获得相同数值范围的响应码，可以用–write-out 获取这个响应码。</p></li><li><p>HTTP 1.1 服务器可以进行“分块”编码响应，但 HTTP 1.0 不支持这种特性。在发送分块响应时，响应消息中不包含用于指示内容大小的 Content-Length：标头。相反，消息中包含了 Transfer-Encoding: chunked 标头，用于告诉 curl 后面还有其他数据块，数据将以一系列“块”的形式出现。每个数据块都以块的大小（十六进制）开头，然后是换行符，然后是块的内容。这个过程会一直重复，直到响应结束，并以大小为零的块作为结束。对于这种响应方式，客户端能够知道响应何时结束，即使服务器在开始发送数据之前不知道内容的大小。出现这种情况通常是因为响应是动态的，并且是在请求到来时生成的。当然，像 curl 这样的客户端会对块进行解码，并且不会向用户显示块大小。</p></li><li><p>与 HTTP 1.1 服务器通信时，可以让 curl 在不使用 Content-Length：标头的情况下发送请求正文。通过使用分块传输编码，curl 将逐块发送 POST 数据，每个数据块中会包含块的大小。</p></li><li><p>HTTP 响应消息能够以压缩的格式进行传输。服务器通常会在响应中包含 Content-Encoding:gzip 标头，以告诉客户端内容经过了压缩。在发送静态资源（提前进行压缩）或 CPU 资源大于带宽的情况下，使用压缩是很有意义的。</p></li><li><p><code>--compressed</code>：让 curl 请求压缩数据，并在接收 gzip（或 curl 可以理解的任意其他压缩算法）压缩的内容后自动对其进行解压</p></li><li><p>压缩是与传输编码一起使用的一个不太常见的特性。压缩本身是很常见的。随着时间的推移，前面提到的 Content-Encoding 已经成为 HTTP 压缩的主要方式。HTTP 最初的目的是允许将压缩作为传输编码，而 curl 也支持这个特性。客户端要求服务器进行压缩传输编码，如果服务器接受了，它将做出响应，并通过一个标头指明它将进行压缩编码，curl 将在接收到数据时对其进行解压。</p></li><li><p><code>--tr-encoding</code>：-请求服务器进行压缩传输编码</p></li><li><p>可以通过–raw 选项要求 curl 直接传递所收到的数据，不对齐进行解码</p></li></ul><h3 id="4-3-HTTP-身份验证"><a href="#4-3-HTTP-身份验证" class="headerlink" title="4.3 HTTP 身份验证"></a>4.3 HTTP 身份验证</h3><ul><li><p>每个 HTTP 请求都可以进行身份验证。如果服务器或代理希望用户证明他们具有访问某些 URL 或执行某些操作的凭证，则可以向客户端发送 HTTP 响应码，告诉客户端要在请求中提供正确的 HTTP 身份验证标头。</p></li><li><p>需要身份验证的服务器会发回 401 响应码和 WWW-Authenticate：标头，这个标头列出了服务器支持的所有身份验证方法。</p></li><li><p>需要身份验证的 HTTP 代理会发回 407 响应码和 Proxy-Authenticate：标头，这个标头列出了代理支持的所有身份验证方法。</p></li><li><p>需要注意的是，现在的大多数网站在登录时都不使用 HTTP 身份验证，但会要求用户登录网页，浏览器会发出带有用户名和密码等信息的 POST 请求，然后为会话保持 cookie。</p></li><li><p>要让 curl 发出带有身份验证的 HTTP 请求，可以用-u 或–user 选项提供用户名和密码（用冒号分隔）</p></li><li><p>curl 将使用默认的“Basic” HTTP 身份验证方法。这个方法确实非常基础。</p></li><li><p><code>--basic</code>：明确指定使用“Basic”HTTP 身份验证方法</p></li><li><p>因为 Basic 身份验证方法通过网络（经过 base64 编码）发送明文的用户名和密码，所以应该避免在 HTTP 传输中使用这种方法。</p></li><li><p>当被要求用（指定或隐含的）单个身份验证方法进行 HTTP 传输时，curl 将在第一个请求中插入身份验证标头。</p></li><li><p><code>--anyauth</code>：如果要让 curl 先确认服务器是否真的需要身份验证，可以使用–anyauth 选项，它会自动使用 curl 所知道的最安全的身份验证方法。curl 将尝试无须身份验证的请求，然后在必要时使用身份验证：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">curl --anyauth --user hello:world http://example.com<br></code></pre></td></tr></table></figure></li><li><p>curl 通常（取决于它是如何构建的）也支持其他几种身份验证方法，包括 Digest、Negotiate 和 NTLM。</p></li></ul><h3 id="4-4-HTTP-区间"><a href="#4-4-HTTP-区间" class="headerlink" title="4.4 HTTP 区间"></a>4.4 HTTP 区间</h3><ul><li><p>HTTP 允许客户端请求特定区间的数据。客户端可以向服务器请求起始偏移量和结束偏移量区间内的数据。它甚至可以在同一个请求中请求几个区间内的数据，并进行组合让这些片段并排发回。服务器发回多个独立的片段作为响应，并用 mime 边界字符串进行分隔，如何处理它们取决于用户的应用。curl 不会进一步对这样的响应进行分隔。</p></li><li><p>不过，获取数据区间也只是对服务器的一种请求。服务器不一定会满足所有这样的请求，在很多情况下，例如服务器动态生成内容时，它将拒绝执行这种区间请求，而是返回完整的内容。</p></li><li><p><code>-r</code>或<code>--range</code>：让 curl 发起区间请求。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">curl -r 0-199 http://example.com<br>curl -r 0-199,1000-1999 http://example.com<br></code></pre></td></tr></table></figure></li></ul><h3 id="4-5-HTTP-版本"><a href="#4-5-HTTP-版本" class="headerlink" title="4.5 HTTP 版本"></a>4.5 HTTP 版本</h3><ul><li><p>从 2016 年年中开始，curl 默认用 HTTP&#x2F;1.1 连接 HTTP 服务器。如果要连接到 HTTPS 服务器，并且你的 libcurl 内置了 HTTP&#x2F;2 功能，那么 curl 将尝试使用 HTTP&#x2F;2，或在协商失败时降级至 HTTP&#x2F;1.1。默认情况下，不支持 HTTP&#x2F;2 的 curl 将使用 HTTP&#x2F;1.1。</p></li><li><p>如果默认值对于你来说还不够好，可以考虑使用 CURLOPT_HTTP_VERSION 选项直接指定 HTTP 版本。</p></li></ul><h3 id="4-6-HTTP-POST"><a href="#4-6-HTTP-POST" class="headerlink" title="4.6 HTTP POST"></a>4.6 HTTP POST</h3><ul><li><p>POST 是为将数据发送到 Web 应用而发明的 HTTP 方法，也是 HTML 表单中最常用的方法。它通常会向接收者发送相对少量的数据块。</p></li><li><p>在表单中填充好数据后，浏览器以“URL 编码”的形式（以 &amp; 符号分隔的一系列键值对）将数据发送出去</p></li><li><p><code>-d</code>或<code>--data</code>：发送 POST 数据</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">curl -d <span class="hljs-string">&#x27;name=admin&amp;num=12&#x27;</span> http://example.com<br></code></pre></td></tr></table></figure></li><li><p>在命令行上指定多个-d 选项时，curl 会将它们串联起来，并在它们之间插入 &amp; 符号。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">curl -d <span class="hljs-string">&#x27;name=admin&#x27;</span> -d <span class="hljs-string">&quot;num=12&quot;</span> http://example.com<br></code></pre></td></tr></table></figure></li><li><p>如果要发送的数据量不适合作为字符串放在命令行中，还可以从文件中读取</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">curl -d @filename http://example.com<br></code></pre></td></tr></table></figure></li><li><p><code>--data-binary</code>：用-d 选项从文件读取内容时，回车符和换行符将被移除。如果想让 curl 从文件读取二进制内容，可以使用–data-binary。</p></li><li><p>curl 的-d 选项不会改变数据，也不会对数据进行编码，它只会发送你要它发送的内容。注意-d 选项默认使用的 Content-Type，因为它可能不是你想要的。</p></li></ul><h4 id="4-6-1-Content-Type"><a href="#4-6-1-Content-Type" class="headerlink" title="4.6.1 Content-Type"></a>4.6.1 Content-Type</h4><ul><li><p>用 curl 的-d 选项发送 POST 请求时，请求中默认会包含一个类似 Content-Type:application&#x2F;x-www-form-urlencoded 这样的标头。典型的浏览器在发送 POST 请求时也会使用这个标头。</p></li><li><p>如果默认标头对你来说还不够好，则可以用其他标头来代替。例如，如果想将 JSON POST 到服务器，并且准确地告诉服务器你发送的内容是什么类型，可以用-H 选项修改标头。</p></li></ul><h4 id="4-6-2-URL-编码"><a href="#4-6-2-URL-编码" class="headerlink" title="4.6.2 URL 编码"></a>4.6.2 URL 编码</h4><ul><li><p>URL 编码（也称为百分号编码）是一种编码数据的方式，这种方式允许数据以合法的形式出现在 URL 中。用 application&#x2F;x-www-form-urlencoded 发送 POST 请求时通常会使用这种编码方式，curl 用–data 和–data-binary 选项发送内容时就是这样。该种编码可以顺利解决汉字、特殊符号等内容的问题</p></li><li><p><code>--data-urlencode</code>：为了能够发送未经编码的数据，curl 提供了–data-urlencode 选项。这个选项提供了几种不同的方式对提供的数据进行 URL 编码。</p></li><li><p>可以像使用其他–data 选项那样使用–data-urlencode data。为了与 CGI 兼容，data 部分应该以名字开头，后面跟上分隔符和内容。可以用以下几种语法将数据传给 curl。</p><ul><li><p>“content”：curl 将对内容进行 URL 编码并发送数据。确保内容中不包含任何&#x3D;或 @符号，否则就会变成下面的其他情况之一！</p></li><li><p>“&#x3D;content”：curl 将对内容进行 URL 编码并发送数据。开头的“&#x3D;”符号不包含在数据中。</p></li><li><p>“name&#x3D;content”：curl 将对内容进行 URL 编码并发送数据。注意，name 部分应该已经经过 URL 编码。</p></li><li><p>“@filename”：curl 将从给定文件加载数据（包括换行符），对数据进行 URL 编码并在 POST 中发送数据。</p></li><li><p>“name@filename”：curl 将从给定文件加载数据（包括换行符），对数据进行 URL 编码并在 POST 中发送数据。name 部分会附加一个等号，变成 name&#x3D;urlencoded-file-content。注意，name 应该已经经过 URL 编码。</p></li></ul></li><li><p>示例：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 会被编码成为 name=%E4%BD%A0%20%E5%A5%BD</span><br>curl --dat-urlencode <span class="hljs-string">&quot;name=你 好&quot;</span> http://example.com<br><span class="hljs-comment"># 如果想对 name 进行 URL 编码，比如想要发送“user name”字段名，</span><br><span class="hljs-comment"># 那么你可以让 curl 在字段前面添加一个等号来编码整个字符串（等号不会被发送）</span><br>curl --dat-urlencode <span class="hljs-string">&quot;=user name=你 好&quot;</span> http://example.com<br></code></pre></td></tr></table></figure></li></ul><h4 id="4-6-3-转换为-GET"><a href="#4-6-3-转换为-GET" class="headerlink" title="4.6.3 转换为 GET"></a>4.6.3 转换为 GET</h4><ul><li>使用-G 或–get 选项可以将-d 选项指定的数据附加到 URL 右边，并使用“? ”分隔，然后让 curl 用 GET 方法发送数据。使用这个选项可以在 POST 和 GET 之间轻松切换。</li></ul><h4 id="4-6-5-Expect-100-continue"><a href="#4-6-5-Expect-100-continue" class="headerlink" title="4.6.5 Expect: 100-continue"></a>4.6.5 Expect: 100-continue</h4><ul><li><p>HTTP 无法在保持连接的情况下停止正在进行的传输（不管是哪个方向）。因此，如果在传输开始后发现需要停止传输，只有两种方法：关闭当前连接并为下一个请求重新建立连接，或者继续传输，这样会浪费带宽，但进行下一次传输时可以重用连接。当通过 HTTP 发送大型文件，却发现服务器需要身份验证并发回 401 响应码时，就会发生这种情况。</p></li><li><p>要想缓解这个问题，可以让 curl 传递一个额外的标头，即 Expect: 100-continue，这让服务器在客户端发送大量数据前有机会拒绝请求。如果 POST 请求的大小是已知的或者可能比较大，那么 curl 就会发送这个 Expect：标头。PUT 请求也是如此。当服务器收到包含 100-continue 的请求并允许这个请求，它将返回 100 响应码，客户端就可以继续发送数据。如果服务器不允许这个请求，它会返回错误响应码。遗憾的是，很多服务器对 Expect：标头的支持并不好，或者没能正确处理，因此 curl 只会在收到第一个响应前等待 1000 毫秒，然后继续发送数据。</p></li><li><p>等待的那 1000 毫秒可能就被浪费了。你可以从请求中移除 Expect:，并通过-H 选项来避免等待：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">curl -H Expect: -d <span class="hljs-string">&quot;hello&quot;</span> http://example.com<br></code></pre></td></tr></table></figure></li><li><p>在某些情况下，如果要发送的内容非常少（例如低于 1 千字节）, curl 将禁止使用 Expect:标头，因为“浪费”这么小的数据块并不是个大问题。</p></li></ul><h3 id="4-7-HTTP-multipart-formpost"><a href="#4-7-HTTP-multipart-formpost" class="headerlink" title="4.7 HTTP multipart formpost"></a>4.7 HTTP multipart formpost</h3><ul><li><p>multipart formpost 是指 HTTP 客户端在 HTML 表单的 enctype 属性被设置为“multipart&#x2F;form-data”时所发送的内容。它是一个 HTTP POST 请求，其中请求正文被格式化为一系列“part”，并以 MIME 边界字符串为分隔。</p></li><li><p><code>-F</code>或<code>--form</code>：可以通过该选项添加每个单独的 multipart，然后继续为表单的每个字段添加一个-F。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">curl -F person=hello -F secret=@file.txt http://example.com<br></code></pre></td></tr></table></figure></li><li><p>用 curl 的-F 选项进行 POST 时，请求中会包含默认的 Content-Type 标头。标头的值是 multipart&#x2F;form-data，后面是 MIME 边界字符串。multipart formpost 使用默认的 Content-Type，当然你也可以自行修改，如果你做了修改，curl 会自动将边界字符串附加到被替换的标头中。你无法修改边界字符串，因为 curl 需要用它来生成 POST 数据。</p></li><li><p>-d 和-F 两个选项都会将指定的数据发送到服务器。不同之处在于如何格式化数据。大多数情况下，接收端会接收特定格式的数据，并期望发送方可以正确格式化数据。客户端无法只使用自己选定的格式。</p></li><li><p>使用浏览器和 HTML 时，一般会向用户提供一个表单，并在用户填好表单后将数据发送出去。<form>标签用于网页，告诉浏览器如何格式化 POST 请求。如果<form>标签包含了 enctype&#x3D;multipart&#x2F;form-data，那就是要浏览器将数据作为 multipartformpost 发送，这与 curl 中的-F 选项等效。当表单中包含（用于文件上载的）<input type = file>标签时，通常会使用这个方法。</p></li><li><p>表单默认的 enctype 是 application&#x2F;x-www-form-urlencoded（因为是默认值，所以很少在 HTML 中显式指定）。浏览器将输入字段“URL 编码”成键值对，避免出现不安全的字符。我们通常将其称为常规 POST，在 curl 中可以通过-d 选项实现。</p></li><li><p>如果这些服务需要“原始”数据或格式化为 JSON 的数据，那么可以使用常规的 POST 方法。</p></li></ul><h3 id="4-8-重定向"><a href="#4-8-重定向" class="headerlink" title="4.8 重定向"></a>4.8 重定向</h3><ul><li><p><code>-L</code>或<code>--location</code>：一般来说，curl 只会做一些基本的操作，除非你告诉它，否则默认情况下它不会遵循 HTTP 重定向。可以通过-L 或–location 选项让它遵循 HTTP 重定向。</p></li><li><p><code>--max-redirs</code>：指定遵循重定向的选项后，curl 默认最多会执行 50 次重定向。设置最大次数限制是为了避免陷入无限循环。如果 50 次对你来说还不够，可以通过–max-redirs 选项修改最大重定向次数。</p></li><li><p>可以通过–post301、–post302 和–post303 三个选项让 curl 在收到 30x 响应后不将非 GET 请求方法改为 GET。如果你在开发基于 libcurl 的应用，那么可以使用 CURLOPT_POSTREDIR 选项来控制这种行为。</p></li><li><p>在使用 curl 时，你可能会为特定网站提供用户名和密码等凭证，但由于 HTTP 重定向可能会转移到其他主机，curl 会对发送给其他主机的内容加以限制。如果你希望凭证也被发送到后面的主机，即使与原始主机不同（这么做大概是因为你信任它们并且知道没有任何害处），则可以使用–location-trusted 选项。</p></li></ul><h3 id="4-9-修改-HTTP-请求"><a href="#4-9-修改-HTTP-请求" class="headerlink" title="4.9 修改 HTTP 请求"></a>4.9 修改 HTTP 请求</h3><h4 id="4-9-1-请求方法"><a href="#4-9-1-请求方法" class="headerlink" title="4.9.1 请求方法"></a>4.9.1 请求方法</h4><ul><li><p><code>-X</code>或<code>--request</code>：该选项后面跟上方法名，让 curl 使用其他方法。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">curl -X DELETE http://example.com<br></code></pre></td></tr></table></figure></li><li><p>-X 选项会修改请求的文本，但不会改变它的行为。知道这一点很重要，如果通过-X 选项要求 curl 发送 HEAD 请求，HEAD 请求将收到与 GET 响应相同的标头，但不会收到响应正文，即使标头表明可能会有。因此，将-X HEAD 添加到命令行将导致 curl 挂起，一直等待不会到来的响应正文。</p></li><li><p>用 curl 执行 HTTP 传输时，它会根据选项选择正确的方法，因此没必要用-X 来指定。还需要注意的是，如果用-L 选项要求 curl 遵循重定向，那么使用-X 设置的请求方法也会出现在后续的重定向请求中。</p></li></ul><h4 id="4-9-2-自定义标头"><a href="#4-9-2-自定义标头" class="headerlink" title="4.9.2 自定义标头"></a>4.9.2 自定义标头</h4><ul><li><p>curl 设置的所有标头都是可以被覆盖的，如果愿意，还可以替换它们。可以通过-H 或–header 选项让 curl 使用新的标头，如果指定的标头字段与内部字段匹配，它将替换内部标头，否则它会将指定的标头添加到标头列表中</p></li><li><p>如果想要删除内部标头，只要向 curl 提供标头名称但不提供值即可，即冒号右侧没有任何内容。</p></li><li><p>如果真的想要在冒号右侧添加一个没有内容的标头（这种情况很罕见），那么可以在标头后面加个分号，如下所示：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">curl -H <span class="hljs-string">&quot;Empty; &quot;</span> http://example.com<br></code></pre></td></tr></table></figure></li></ul><h4 id="4-9-3-referer"><a href="#4-9-3-referer" class="headerlink" title="4.9.3 referer"></a>4.9.3 referer</h4><ul><li><p>当用户点击网页上的链接时，浏览器会将用户带到下一个 URL，它会在新的请求中添加 referer 标头，表明请求的来源。虽然 referer 拼写错误，但它就是这个意思！</p></li><li><p><code>-e</code>或<code>--referer</code>：设置 referer 标头</p></li></ul><h4 id="4-9-4-User-Agent"><a href="#4-9-4-User-Agent" class="headerlink" title="4.9.4 User-Agent"></a>4.9.4 User-Agent</h4><ul><li><p>客户端可以在请求中设置 User-Agent 标头，用于告诉服务器它属于哪种用户代理。有时服务器会检查这个标头，并根据标头内容决定如何做出响应。这个标头的默认值为“curl&#x2F;[version]”, curl 7.54.1 的值为 User-Agent:curl&#x2F;7.54.1。</p></li><li><p><code>-A</code>或<code>--user-agnet</code>：可以用-A 或–user-agent 选项加上要使用的字符串来设置你喜欢的值。</p></li></ul><h4 id="4-9-5-时间条件"><a href="#4-9-5-时间条件" class="headerlink" title="4.9.5 时间条件"></a>4.9.5 时间条件</h4><ul><li><p>HTTP 支持“条件请求”。条件请求是指包含条件的请求，它请求服务器只在相关条件为 true 时才返回响应正文。时间是一个有用的条件。</p></li><li><p><code>--time-cond</code>：设置时间请求。</p></li><li><p>curl 可以直接从本地文件中获取时间戳。如果服务器的文件没有发生变更，那么就无须再次下载，如果字符串与时间或日期格式不匹配，curl 会检查是否存在同名文件，如果存在，就使用文件的修改时间。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">curl --time-cond file http://example.com/file -O<br></code></pre></td></tr></table></figure></li></ul><h3 id="4-10-PUT"><a href="#4-10-PUT" class="headerlink" title="4.10 PUT"></a>4.10 PUT</h3><ul><li><p>PUT 和 POST 之间的区别很微妙。除了方法名不同之外，其他几乎都是一样的。POST 是指将数据传给现有的远程资源，而 PUT 是指创建新的资源。在这方面，PUT 类似于其他协议的文件上传。你可以用 PUT 上传新的资源，用 URL 指定远程资源，并指定要发送的本地文件。</p></li><li><p>因为 POST 和 PUT 非常相似，所以你也可以用-d 加上字符串来发送 PUT 请求。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">curl -d <span class="hljs-string">&quot;Hello&quot;</span> -X PUT http://example.com<br></code></pre></td></tr></table></figure></li></ul><h3 id="4-11-cookie"><a href="#4-11-cookie" class="headerlink" title="4.11 cookie"></a>4.11 cookie</h3><ul><li><p>HTTP cookie 是存储在客户端的键值对。在后续请求中，它们被发回服务器，用于保持请求间的状态。HTTP 本身是没有状态的，客户端必须在后续请求中重新发送需要服务器知道的所有数据。</p></li><li><p>服务器用 Set-Cookie：标头来设置 cookie，并在每个 cookie 中发送一堆额外的属性，客户端在发回 cookie 时需要匹配这些属性。这些属性包括域名、路径，以及最重要的 cookie 应该保留多长时间</p></li><li><p>cookie 的到期时间要么设置为未来的某个固定时刻（或者存活几秒），要么永不过期。没有过期时间的 cookie 称为“会话 cookie”，只在“会话”期间存活。会话通常被认为是浏览器在浏览网站时的生命周期。关闭浏览器后，会话也将结束。</p></li><li><p>curl 通常只做最少的事情，除非你告诉它，否则默认情况下它不会使用 cookie。你需要打开“cookie 引擎”才能让 curl 跟踪它接收到的 cookie，然后在后续的请求中发送它们。</p></li><li><p>可以让 curl 读取或写入 cookie，以此来启用 cookie 引擎。如果让 curl 从一个不存在的文件中读取 cookie，那么它只会打开引擎，但内部的 cookie 存储是空的。</p></li><li><p><code>-b</code>：指定 cookie 内容</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">curl -b name=hello http://example.com<br>curl -b cookie.txt http://example.com<br></code></pre></td></tr></table></figure></li><li><p>记住，-b 只是从文件中读取 cookie。如果服务器更新了响应中的 cookie，那么 curl 会更新内存的 cookie 存储，并在退出时将它们全部丢弃。如果后续读取相同的输入文件，则会使用与原来相同的 cookie。</p></li><li><p>curl 使用的 cookie 文件格式叫作 Netscape cookie 格式，因为浏览器曾经也使用了这种格式，所以 curl 可以很轻松地处理浏览器 cookie！出于便利性方面的考虑，curl 还支持一种特殊的 cookie 文件，文件的内容是一组用于设置 cookie 的 HTTP 标头。它是一种次优的格式，但也可能是你唯一可以修改的格式。</p></li><li><p>cookie 存储有时称为“cookie jar”。当你启用了 curl 的 cookie 引擎，并且它接收到了 cookie，那么可以让 curl 在退出之前将所有已知的 cookie 写入文件（也就是 cookie jar）中。curl 只会在退出时（而不是生命周期内）更新 cookie jar，无论处理输入需要多长时间。</p></li><li><p><code>-c</code>：指定 cookie-jar 文件</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">curl -c cookie-jar.txt http://example.com<br></code></pre></td></tr></table></figure></li><li><p>-c 指示 curl 将 cookie 写入文件，-b 指示 curl 从文件读取 cookie。通常需要同时使用它们。将 cookie 写入文件时，curl 将保存所有已知的 cookie，包括会话 cookie（没有过期时间）。curl 本身没有会话的概念，它不知道会话什么时候结束，因此不会刷新会话 cookie，除非你告诉它要这么做。</p></li><li><p><code>-j</code>或<code>--junk-session-cookies</code>：为了刷新会话 cookie，并向服务器发出开始新会话的信号，curl 提供了一个选项，以便用户可以决定新会话何时开始。新的 cookie 会话意味着所有会话 cookie 都将被丢弃，这相当于重启浏览器。可以通过-j 或–junk-session-cookies 选项让 curl 开始新的 cookie 会话：</p></li></ul><h3 id="4-12-HTTP-x2F-2"><a href="#4-12-HTTP-x2F-2" class="headerlink" title="4.12 HTTP&#x2F;2"></a>4.12 HTTP&#x2F;2</h3><ul><li><p>curl 同时为 HTTP:&#x2F;&#x2F; 和 HTTPS:&#x2F;&#x2F; 类型的 URL 提供 HTTP&#x2F;2 支持（前提是用相关依赖项构建 curl）。如果指定了 HTTPS URL，那么它会默认使用 HTTP&#x2F;2。如果用 curl 访问不支持 HTTP&#x2F;2 的网站，则发出的请求将进行 HTTP&#x2F;1.1 协商。</p></li><li><p>如果使用的是 HTTP:&#x2F;&#x2F; 类型的 URL，则需要使用 Upgrade：标头升级到 HTTP&#x2F;2，但这可能会导致额外的网络往返。更麻烦的是，相当多的旧服务器遇到这种情况时会返回 400 响应码。</p></li><li><p>还需要注意的是，一些（可能是大多数）支持 HTTP&#x2F;2 的服务器（本身并非都是服务器）无法识别 POST 请求中的 Upgrade：标头。</p></li><li><p>如果你的 curl 不支持 HTTP&#x2F;2，那么命令行将返回错误。运行 curl -V 就可以知道你的 curl 版本是否支持 HTTP&#x2F;2。</p></li><li><p>HTTP&#x2F;2 协议的主要特性之一是能够在同一物理连接上复用多个逻辑流。在使用 curl 命令行工具时，你无法利用这个很酷的特性，因为 curl 严格按照串行的方式执行网络请求，一个接一个，后一个要在前一个结束后才能开始。</p></li></ul>]]></content>
    
    
    <categories>
      
      <category>笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>工具详解</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【阅读】网络是怎样连接的？</title>
    <link href="/posts/c1870777.html"/>
    <url>/posts/c1870777.html</url>
    
    <content type="html"><![CDATA[<p>今年买了个iPad，本意是用来看视频刷微博的，没想到最后每天打开的最多的是微信读书。从3月份开始到现在，我陆陆续续看了20多本书，内容很杂很乱，类型也多，有故事小说，也有教程笔记，有枕边随笔，也有编程技术。当然从书籍数量上来说，主要还是偏向技术方面的，占六成左右。如果要是让我选出今年读过的，觉得最好的技术书籍，那就非《网络是怎样连接的》这本书了。</p><p>《网络是怎样连接的》由日本作家户根勤编写，出版于2017年。该书以“从输入网址开始到显示网页内容，这个过程都发生了什么”这一问题作为核心，一路追踪网络传输的各个细节，由浅入深，由软件到系统再到硬件。这本书图文并茂，通俗易懂，非常适合计算机、网络爱好者及相关从业认识阅读。</p><p>本书主要分为六个章节，从浏览器到协议栈，然后到网络设备，接着是接入网和网络运营商，再到服务器端，最后是服务器。从软件到硬件再到软件，从总体到细节再到总体，形成了一个清晰的链路，层次分明。在介绍头部的功能，会把下一层次隐藏为黑盒，使得读者可以轻松地学习当前部分的内容而不是一下子接收太多知识；当学习下一层次的内容的时候，它又会连接上一层次的内容，使人豁然开朗大呼妙哉！</p><p><img src="/image/%E7%BD%91%E7%BB%9C%E6%98%AF%E6%80%8E%E6%A0%B7%E8%BF%9E%E6%8E%A5%E7%9A%84/%E6%8E%A2%E7%B4%A2%E9%93%BE%E8%B7%AF%E5%9B%BE.jpeg" alt="探索路线图"></p><p>要说为什么我要看这本书，还得从我大二说起。我大二时候就学习计算机网络课程，虽说实验成绩和课程成绩不低，但我实际上基本没怎么掌握计算机网络的相关概念。什么“网络模型”、“拥塞控制”、“三次握手”，全是硬背下来的，考试就对着往年原题直接写，考完后就全忘了。当时我心里想，以后还得专门找个时间补习一下计算机网络，不然以后遇到相关问题就扑街了，没想到这个预言应验在今年这个时间。</p><p>我当时的上课教材用的是《计算机网络：自顶向下方法》，也就是黑皮书。这本书可以说得上是鼎鼎大名，和《TCP&#x2F;IP协议详解》并称计算机网络入门双杰，厚过砖头。倒不是说这本书不好，但是对于当时的我来说我实在是读不下去。我学习东西基本都是遵循着一个直观到抽象的过程，可是这本书最“直观”的地方（即使是第一章），对于我来说还是太抽象了。我本身没有建立好一个针对互联网结构的总体印象，直接就开始研究应用层运输层实在是有点吃力，这就导致了越看到后面越头疼，一天看不了一章还读不懂的情况也不是没有试过。</p><p>《网络是怎样连接的》相比以上两本大部头“薄”了不少，它故意减少了关于一些协议细节、硬件细节、与整体流程关系不大的知识点的描述，这也让他能够更加专注核心问题，让读者始终把握脉络。当然这不说明这本书很浅显简单，它的知识密度绝对不滴，400多页的内容，我摘抄了接近4w多字的笔记。</p><p>《网络是怎样链接的》并没有按照OSI模型或者TCP&#x2F;IP模型为结构展开论述，而是从浏览器输入网址开始，引入浏览器所做的工作，接着进入到操作系统也就是协议栈部分所做的工作，然后来到网卡部分，再到以太网设备介绍、接入网介绍……环环相扣，非常符合我们的思维习惯。</p><p>本书的翻译也是一大特色。有很多人不喜欢看翻译过来的技术性书籍，因为其有些名词不够准确精准，而且词句之间容易带上翻译腔，翻译质量底下。《网络是怎样链接》本身是针对入门者的书籍，其本身的用语用句就不是特别晦涩难懂，大部分都是约定俗成的计算机用语。另外本书原版为日文书籍，相对欧美英文书籍，这也还是比较符合国人的阅读习惯的。本书译者是周自恒，也是一名IT从业者，既写过不少书，也翻译不少书，翻译能力也是值得信任的。</p><p>本书的精华内容浓缩在书籍中的一张张插图。真的，没有一张插图是毫无意义不知所云的。读懂了章节中的插图，就可以读懂整个章节的内容；能够串联起不同插图，那就说明能够打通不同环节。看看下面两张附录中的插图，就知道这些其浓缩的内容有多精确了。</p><p><img src="/image/%E7%BD%91%E7%BB%9C%E6%98%AF%E6%80%8E%E6%A0%B7%E8%BF%9E%E6%8E%A5%E7%9A%84/%E7%BD%91%E7%BB%9C%E5%8C%85%E6%97%85%E7%A8%8Ba.jpeg" alt="网络包旅程a"></p><p><img src="/image/%E7%BD%91%E7%BB%9C%E6%98%AF%E6%80%8E%E6%A0%B7%E8%BF%9E%E6%8E%A5%E7%9A%84/%E7%BD%91%E7%BB%9C%E5%8C%85%E6%97%85%E7%A8%8Bb.jpeg" alt="网络包旅程b"></p><p>可惜的是，本书在深度方面略有欠缺。不过这是受本书自身主题所影响的，一本书不可能同时兼顾广度和深度。《网络是怎样链接的》广度上面颇费功夫，方方面面都有涉及，若是同时又深入下去，估计此书就要成为上万页的知识手册了，这也不符合作者所说的“总览全貌，探索流程”。</p><p>从输入网址到显示出网页内容，这个过程只有短短几秒的时间。然而，在这短短几秒的背后，离不开各种设备和软件的相互配合。在《网路是怎样连接的》探险之旅中，这本书所涉猎的这些内容已经十分复杂了，但这还仅仅是网络世界的一小部分而已，还有很多内容无法一一讲解，如果深入挖掘其中一些细节也是难以穷尽的。不过，通过这段探索之旅，读者应该可以看到了网络的全貌，也了解网络的基本设计思路。总之，若是对“网络是怎样连接的？”这一问题抱有好奇心，那不妨读一读《网络是怎样链接的》，开卷有益，希望你也有收获！</p>]]></content>
    
    
    <categories>
      
      <category>阅读</category>
      
    </categories>
    
    
    <tags>
      
      <tag>感受</tag>
      
      <tag>网络</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【笔记】网络是怎样连接的（附录）</title>
    <link href="/posts/bed28f09.html"/>
    <url>/posts/bed28f09.html</url>
    
    <content type="html"><![CDATA[<h2 id="附录-网络包的旅程"><a href="#附录-网络包的旅程" class="headerlink" title="附录 网络包的旅程"></a>附录 网络包的旅程</h2><p><img src="/image/%E7%BD%91%E7%BB%9C%E6%98%AF%E6%80%8E%E6%A0%B7%E8%BF%9E%E6%8E%A5%E7%9A%84/2277f566611583ec299aa8a90a8eec4fbb32ab95.jpeg" alt="epub_907755_545.jpeg"></p><p><img src="/image/%E7%BD%91%E7%BB%9C%E6%98%AF%E6%80%8E%E6%A0%B7%E8%BF%9E%E6%8E%A5%E7%9A%84/2e0f7e0b2703e920ee957b64e1795802f29b6033.jpeg" alt="epub_907755_546.jpeg"></p>]]></content>
    
    
    <categories>
      
      <category>笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>基础体系</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【笔记】网络是怎样连接的（下）</title>
    <link href="/posts/6e602c93.html"/>
    <url>/posts/6e602c93.html</url>
    
    <content type="html"><![CDATA[<h2 id="第五章-服务器端的局域网中有什么玄机"><a href="#第五章-服务器端的局域网中有什么玄机" class="headerlink" title="第五章 服务器端的局域网中有什么玄机"></a>第五章 服务器端的局域网中有什么玄机</h2><h3 id="5-1-Web-服务器的部署地点"><a href="#5-1-Web-服务器的部署地点" class="headerlink" title="5.1 Web 服务器的部署地点"></a>5.1 Web 服务器的部署地点</h3><ul><li><p>在公司部署 Web 服务器有两种方法：</p><ul><li><p>服务器直接部署在公司网络上，并且可以从互联网直接访问</p></li><li><p>部署防火墙</p></li></ul></li><li><p>第一种方法有几个限制：</p><ul><li><p>IP 地址不足</p></li><li><p>安全问题</p></li></ul></li><li><p>防火墙：一种抵御外部网络攻击的机制，也是最早出现的一种防御机制。现在已经出现了很多可以绕过防火墙的攻击方法，因此防火墙一般需要和反病毒、非法入侵检测、访问隔离等机制并用。详细内容请查看下一部分</p></li><li><p>防火墙屏蔽了不允许从外部访问的应用程序，所以即便这些程序存在安全漏洞，用于攻击的网络包也进不来。但是即便如此风险也不会降到零，因为如果允许外部访问的应用程序中有安全漏洞，还是有可能遭到攻击的</p></li><li><p>Web 服务器不仅可以部署在公司里，也可以把服务器放在网络运营商等管理的数据中心里，或者直接租用运营商提供的服务器</p></li><li><p>数据中心是与运营商核心部分 NOC 直接连接的，或者是与运营商之间的枢纽 IX 直接连接的。换句话说，数据中心通过高速线路直接连接到互联网的核心部分，因此将服务器部署在这里可以获得很高的访问速度 [插图]，当服务器访问量很大时这是非常有效的</p><p>此外，数据中心一般位于具有抗震结构的大楼内，还具有自主发电设备，并实行 24 小时门禁管理，可以说比放在公司里具有更高的安全性</p><p>此外，数据中心不但提供安放服务器的场地，还提供各种附加服务，如服务器工作状态监控、防火墙的配置和运营、非法入侵监控等，从这一点来看，其安全性也更高</p></li><li><p>服务器三种部署地点方式：</p><p><img src="/image/%E7%BD%91%E7%BB%9C%E6%98%AF%E6%80%8E%E6%A0%B7%E8%BF%9E%E6%8E%A5%E7%9A%84/9e8b8d8013a063256f5a5aa264948f6fcb99a1b2.jpeg" alt="epub_907755_438.jpeg"></p></li></ul><h3 id="5-2-防火墙的结构和原理"><a href="#5-2-防火墙的结构和原理" class="headerlink" title="5.2 防火墙的结构和原理"></a>5.2 防火墙的结构和原理</h3><ul><li><p>网络包的头部包含了用于控制通信操作的控制信息，只要检查这些信息，就可以获得很多有用的内容。防火墙就可以通过这些信息判断网络包的通行与否</p><ul><li><p>通过 IP 地址可以确定发送方和接收方</p></li><li><p>通过端口号限定应用程序</p></li><li><p>通过控制位判断连接方向：用于禁止服务器发起 TCP 链接</p></li></ul></li><li><p>包过滤方式的防火墙不仅可以允许或者阻止网络包的通过，还具备地址转换功能 [插图]，因此还需要进行相关的设置。也就是说，互联网和公司内网之间的包需要进行地址转换才能传输，因此必须要进行相关的设置</p><p>具体来说，就是和包过滤一样，以起点和终点作为条件，根据需要设置是否需要进行地址转换。私有地址和公有地址之间的对应关系，以及端口号的对应关系都是自动管理的，因此只需要设置是否允许地址转换就可以了</p></li><li><p>在防火墙中设置各种规则后，当包到达防火墙时，会根据这些规则判断是允许通过还是阻止通过：</p><ul><li><p>如果判断结果为阻止，那么这个包会被丢弃并被记录下来（如果将内置包过滤功能的路由器用作防火墙，则在丢弃包时基本上不会留下记录，这是因为路由器的内存容量小，没有足够的空间用来记录日志）。这是因为这些被丢弃的包中通常含有非法入侵的痕迹，通过分析这些包能够搞清楚入侵者使用的手法，从而帮助我们更好地防范非法入侵</p></li><li><p>如果包被判断为允许通过，则该包会被转发出去，这个转发的过程和路由器是相同的</p></li></ul></li><li><p>包过滤并不是防火墙专用的一种特殊机制，而是应该看作在路由器的包转发功能基础上附加的一种功能。只不过当判断规则比较复杂时，通过路由器的命令难以维护这些规则，而且对阻止的包进行记录对于路由器来说负担也比较大，因此才出现了专用的硬件和软件。如果规则不复杂，也不需要记录日志，那么用内置包过滤功能的普通路由器来充当防火墙也是可以的</p></li><li><p>防火墙可以根据包的起点和终点来判断是否允许其通过，但仅凭起点和终点并不能筛选出所有有风险的包。防火墙无法抵御针对应用程序本身的攻击，要应对这种情况有两种方法：</p><ul><li><p>这个问题的根源在于 Web 服务器程序的 Bug，因此修复 Bug 防止宕机就是其中一种方法</p></li><li><p>另一种方法就是在防火墙之外部署用来检查包的内容并阻止有害包的设备或软件。当然，即便是采用这种方法也并不是完美无缺的，因为包的内容是否有风险，是由 Web 服务器有没有 Bug 决定的，因此当服务器程序中有潜在的 Bug 并且尚未被发现时，我们也无法判断包中的风险，也无法阻止这样的包。也就是说，我们无法抵御未知的风险</p></li></ul></li></ul><h3 id="5-3-通过将请求平均分配给多台服务器来平衡负载"><a href="#5-3-通过将请求平均分配给多台服务器来平衡负载" class="headerlink" title="5.3 通过将请求平均分配给多台服务器来平衡负载"></a>5.3 通过将请求平均分配给多台服务器来平衡负载</h3><h4 id="5-3-1-性能不足时需要负载均衡"><a href="#5-3-1-性能不足时需要负载均衡" class="headerlink" title="5.3.1 性能不足时需要负载均衡"></a>5.3.1 性能不足时需要负载均衡</h4><ul><li><p>当服务器访问量上升的时候，遇到“性能”问题，有几种应对方法：</p><ul><li><p>增加服务器带宽</p></li><li><p>更换性能更好的服务器</p></li><li><p>使用分布式架构来分担负载</p></li></ul></li><li><p>当服务器的访问量上升时，增加服务器线路的带宽是有效的，但并不是网络变快了就可以解决所有的问题。高速线路会传输大量的网络包，这会导致服务器的性能跟不上 [插图]。尤其是通过 CGI 等应用程序动态生成数据的情况下，对服务器 CPU 的负担更重，服务器性能的问题也会表现得越明显</p></li><li><p>更换换一台性能更好的服务器可以解决一部分问题，但当很多用户同时访问时，无论服务器的性能再好，仅靠一台服务器还是难以胜任的</p></li><li><p>使用分布式架构对负载进行分担有几种方法，最简单的一种方法就是采用多台 Web 服务器，减少每台服务器的访问量</p></li><li><p>具体的做法有很多种，最简单的一种是通过 DNS 服务器来分配。当访问服务器时，客户端需要先向 DNS 服务器查询服务器的 IP 地址，如果在 DNS 服务器中填写多个名称相同的记录，则每次查询时 DNS 服务器都会按顺序返回不同的 IP 地址</p><p>但这种方式是有缺点的。假如多台 Web 服务器中有一台出现了故障，这时我们希望在返回 IP 地址时能够跳过故障的 Web 服务器，然而普通的 DNS 服务器并不能确认 Web 服务器是否正常工作，因此即便 Web 服务器宕机了，它依然可能会返回这台服务器的 IP 地址</p><p>如果浏览器在访问 DNS 服务器返回的第一个 IP 地址失败时，能够继续尝试第二个 IP 地址，就可以回避这个问题了，最近的浏览器有很多都已经具备了这样的功能。</p></li><li><p>上述方式称为轮询（round-robin），通过这种方式可以将访问平均分配给所有的服务器</p></li><li><p>轮询分配可能会引发一些问题。在通过 CGI 等方式动态生成网页的情况下，有些操作是要跨多个页面的，如果这期间访问的服务器发生了变化，这个操作就可能无法继续</p></li></ul><h4 id="5-3-2-使用负载均衡器分配访问"><a href="#5-3-2-使用负载均衡器分配访问" class="headerlink" title="5.3.2 使用负载均衡器分配访问"></a>5.3.2 使用负载均衡器分配访问</h4><ul><li><p>可以通过负载均衡器的设备解决 DNS 服务器分配访问时所遇到的缺点</p></li><li><p>使用负载均衡器时，首先要用负载均衡器的 IP 地址代替 Web 服务器的实际地址注册到 DNS 服务器上。客户端会认为负载均衡器就是一台 Web 服务器，并向其发送请求，然后由负载均衡器来判断将请求转发给哪台 Web 服务器</p></li><li><p>转发请求消息使用的是后面要讲到的“代理”机制，缓存服务器也使用这种机制。此外，有些负载均衡器中也内置缓存功能。负载均衡器和缓存服务器很相似，或者可以说它是由缓存服务器进一步发展而来的。</p></li><li><p>如何判断将请求转发给哪台 Web 服务器？判断条件有很多种，根据操作是否跨多个页面，判断条件也会有所不同：</p><ul><li><p>如果操作没有跨多个页面，则可以根据 Web 服务器的负载状况来进行判断</p><ul><li><p>负载均衡器可以定期采集 Web 服务器的 CPU、内存使用率，并根据这些数据判断服务器的负载状况，也可以向 Web 服务器发送测试包，根据响应所需的时间来判断负载状况</p></li><li><p>当然，Web 服务器的负载可能会在短时间内上下波动，因此无法非常准确地把握负载状况，反过来说，如果过于密集地去查询服务器的负载，这个查询操作本身就会增加 Web 服务器的负载</p></li><li><p>因此也有一种方案是不去查询服务器的负载，而是根据事先设置的服务器性能指数，按比例来分配请求。无论如何，这些方法都能够避免负载集中在某一台服务器上</p></li></ul></li><li><p>当操作跨多个页面时，则不考虑 Web 服务器的负载，而是必须将请求发送到同一台 Web 服务器上。要实现这一点，关键在于我们必须要判断一个操作是否跨了多个页面</p><ul><li><p>在 Web 服务器看来，每一次 HTTP 访问都是相互独立的，无法判断是否和之前的请求相关，所以不能直接通过 HTTP 访问来确认是否是跨页的</p></li><li><p>也不能根据一系列请求的发送方 IP 地址相同这一点来来进行判断。如果使用了代理机制，所有请求的发送方 IP 地址都会变成代理服务器的 IP 地址，无法判断实际发送请求的客户端是哪个。此外，如果使用了地址转换，发送方 IP 地址则会变成地址转换设备的 IP 地址，也无法判断具体是哪个客户端</p></li><li><p>可以用一些预设的方案来判断请求之间的相关性。例如，可以在发送表单数据时在里面加上用来表示关联的信息，或者是对 HTTP 规格进行扩展，在 HTTP 头部字段中加上用来判断相关性的信息，也就是俗称的 Cookie</p></li></ul></li></ul></li><li><p>负载均衡器可以通过上述信息来作出判断，将一系列相关的请求发送到同一台 Web 服务器，对于不相关的请求则发送到负载较低的服务器了。</p></li></ul><h3 id="5-4-使用缓存服务器分担负载"><a href="#5-4-使用缓存服务器分担负载" class="headerlink" title="5.4 使用缓存服务器分担负载"></a>5.4 使用缓存服务器分担负载</h3><h4 id="5-4-1-缓存服务器"><a href="#5-4-1-缓存服务器" class="headerlink" title="5.4.1 缓存服务器"></a>5.4.1 缓存服务器</h4><ul><li><p>除了使用多台功能相同的 Web 服务器分担负载之外，还有另外一种方法，就是将整个系统按功能分成不同的服务器，如 Web 服务器、数据库服务器。缓存服务器就是一种按功能来分担负载的方法</p></li><li><p>缓存服务器是一台通过代理机制对数据进行缓存的服务器</p></li><li><p>代理介于 Web 服务器和客户端之间，具有对 Web 服务器访问进行中转的功能。当进行中转时，它可以将 Web 服务器返回的数据保存在磁盘中，并可以代替 Web 服务器将磁盘中的数据返回给客户端。这种保存的数据称为缓存，缓存服务器指的也就是这样的功能</p></li><li><p>Web 服务器需要执行检查网址和访问权限，以及在页面上填充数据等内部操作过程，因此将页面数据返回客户端所需的时间较长。相对地，缓存服务器只要将保存在磁盘上的数据读取出来发送给客户端就可以了，因此可以比 Web 服务器更快地返回数据</p></li><li><p>不过，如果在缓存了数据之后，Web 服务器更新了数据，那么缓存的数据就不能用了，因此缓存并不是永久可用的。此外，CGI 程序等产生的页面数据每次都不同，这些数据也无法缓存。无论如何，在来自客户端的访问中，总有一部分访问可以无需经过 Web 服务器，而由缓存服务器直接处理。即便只有这一部分操作通过缓存服务器提高了速度，整体性能也可以得到改善。此外，通过让缓存服务器处理一部分请求，也可以减轻 Web 服务器的负担，从而缩短 Web 服务器的处理时间</p></li><li><p>缓存服务器工作流程：</p><p><img src="/image/%E7%BD%91%E7%BB%9C%E6%98%AF%E6%80%8E%E6%A0%B7%E8%BF%9E%E6%8E%A5%E7%9A%84/1d4430ec3b47e9e000792940c8f114ce9c83fa5f.jpeg" alt="epub_907755_465.jpeg"></p></li><li><p>缓存服务器工作过程简略步骤（不命中缓存）：</p><ol><li><p>首先，缓存服务器和负载均衡器一样，需要代替 Web 服务器被注册到 DNS 服务器中</p></li><li><p>然后客户端会向缓存服务器发送 HTTP 请求消息（图（a）①），这时，缓存服务器会接收请求消息，这个接收操作和 Web 服务器相同。从客户端来看，缓存服务器就相当于 Web 服务器</p></li><li><p>接下来，缓存服务器会检查请求消息的内容，看看请求的数据是否已经保存在缓存中。根据是否存在缓存数据，后面的操作会有所不同，现在我们假设不存在缓存数据</p></li><li><p>这时，缓存服务器会在 HTTP 头部字段中添加一个 Via 字段（via 字段这个信息并不是特别重要，因此根据缓存服务器的配置，有时不会添加这个字段），表示这个消息经过缓存服务器转发，然后将消息转发给 Web 服务器（图（a）②）。在这个过程中，我们需要判断应该将请求消息转发给哪台 Web 服务器</p><ul><li><p>如果只有一台 Web 服务器，那么情况比较简单，只要将 Web 服务器的域名和 IP 地址配置在缓存服务器上，让它无条件转发给这台服务器就可以了</p></li><li><p>如果一台缓存服务器对应多台 Web 服务器，需要根据请求消息的内容来判断应该转发给哪台 Web 服务器。要实现这个目的有几种方法，其中比较有代表性的是根据请求消息的 URI（图 5（b）①）中的目录名来进行判断</p></li></ul></li><li><p>从 Web 服务器来看，缓存服务器就相当于客户端。于是，缓存服务器会收到来自 Web 服务器的响应消息（图（a）③），接收消息的过程也是以客户端的身份来完成的</p></li><li><p>接下来，缓存服务器会在响应消息中加上 Via 头部字段，它表示这个消息是经过缓存服务器中转的</p></li><li><p>然后缓存服务器会以 Web 服务器的身份向客户端发送响应消息。同时，缓存服务器会将响应消息保存到缓存中，并记录保存的时间</p></li></ol></li><li><p>缓存服务器工作过程简略步骤（命中缓存）：</p><ol><li><p>首先，接收客户端的请求消息并检查缓存的过程和刚才是一样的</p></li><li><p>然后，缓存服务器会添加一个 If-Modified-Since 头部字段并将请求转发给 Web 服务器，询问 Web 服务器用户请求的数据是否已经发生变化</p></li><li><p>然后，Web 服务器会根据 If-Modified-Since 的值与服务器上的页面数据的最后更新时间进行比较，如果在指定时间内数据没有变化，就会返回一个表示没有变化的响应消息（304 响应码）。这时，Web 服务器只要查询一下数据的最后更新时间就好了，比返回页面数据的负担要小一些。而且返回的响应消息也比较短，能相应地减少负担</p><p>此外，当 Web 服务器上的数据有变化时，后面的过程和没有命中缓存的情况是一样的。Web 服务器会返回最新版本的数据</p></li><li><p>接下来，返回消息到达缓存服务器，然后缓存服务器就会知道 Web 服务器上的数据和本地缓存中的数据是一样的，于是就会将缓存的数据返回给客户端。缓存服务器返回的响应消息的内容和没有命中缓存的情况是一样的</p></li></ol></li><li><p>这种在客户端和 Web 服务器之间充当中间人的方式就是代理的基本原理。在中转消息的过程中，缓存服务器还会顺便将页面数据保存下来，随着缓存数据的积累，用户访问的数据命中缓存的几率也会提高</p></li></ul><h4 id="5-4-2-正向代理"><a href="#5-4-2-正向代理" class="headerlink" title="5.4.2 正向代理"></a>5.4.2 正向代理</h4><ul><li><p>实际上，缓存服务器使用的代理机制最早就是放在客户端一侧的，这才是代理的原型，称为正向代理（forward proxy）</p></li><li><p>正向代理刚刚出现的时候，其目的之一就是缓存，这个目的和服务器端的缓存服务器相同。不过，当时的正向代理还有另外一个目的，那就是用来实现防火墙</p><p>简单来说，代理会先接收来自客户端的请求消息，然后再转发到互联网中，这样就可以实现只允许通过必要的网络包了。如果能够利用代理的缓存，那么效果就会更好，因为对于以前访问过的数据，可以直接从位于公司内网的代理服务器获得，这比通过低速线路访问互联网要快很多</p></li><li><p>代理（Proxy）本来的意思并不是“转发”消息，而是先把消息收下来，然后“伪装”成原始客户端向 Web 服务器发出访问请求。</p></li><li><p>由于代理在转发过程中可以查看请求的内容，所以可以根据内容判断是否允许访问。也就是说，通过代理可以禁止员工访问危险的网站，或者是与工作内容无关的网站。包过滤方式的防火墙只能根据 IP 地址和端口号进行判断，因此无法实现这一目的</p></li><li><p>在使用正向代理时，一般需要在浏览器的设置窗口中的“代理服务器”一栏中填写正向代理的 IP 地址，浏览器发送请求消息的过程也会发生相应的变化</p><ul><li><p>在没有设置正向代理的情况下，浏览器会根据网址栏中输入的 http:&#x2F;&#x2F;..．字符串判断 Web 服务器的域名，并向其发送请求消息；当设置了正向代理时，浏览器会忽略网址栏的内容，直接将所有请求发送给正向代理</p></li><li><p>请求消息的内容也会有一些不同。没有正向代理时，浏览器会从网址中提取出 Web 服务器域名后面的文件名或目录名，然后将其作为请求的 URI 进行发送；而有正向代理时，浏览器在请求的 URI 字段中填写完整的 http:&#x2F;&#x2F;..．网址</p></li></ul></li><li><p>正向代理转发消息的过程也和服务器端的缓存服务器有一些不同，不同点在于对转发目标 Web 服务器的判断上。使用正向代理时，URI 部分为 http:&#x2F;&#x2F;..．这样的完整网址，因此可以根据这个网址来转发，不需要像服务器端的缓存服务器一样实现设置好转发目标 Web 服务器，而且可以发给任意 Web 服务器。而服务器端的缓存服务器只能向事先设置好的目标进行转发，这就是两者不同的地方</p></li></ul><h4 id="5-4-3-反向代理"><a href="#5-4-3-反向代理" class="headerlink" title="5.4.3 反向代理"></a>5.4.3 反向代理</h4><ul><li><p>正向代理和反向代理（reverse proxy）的几个不同点：</p><ul><li><p>正向代理在客户端，反向代理在服务器端</p></li><li><p>正向代理转发请求消息时候 URL 的地址是完整的，反向代理可以通过将请求消息中的 URI 中的目录名与 Web 服务器进行关联，使得代理能够转发一般的不包含完整网址的请求消息</p></li></ul></li></ul><h4 id="5-4-4-透明代理"><a href="#5-4-4-透明代理" class="headerlink" title="5.4.4 透明代理"></a>5.4.4 透明代理</h4><ul><li><p>缓存服务器判断转发目标的方法还有一种，那就是查看请求消息的包头部。因为包的 IP 头部中包含接收方 IP 地址，只要知道了这个地址，就知道用户要访问哪台服务器了。HTTP 1.1 版本增加了一个用于表示访问目标 Web 服务器的 Host 字段，因此也可以通过 Host 字段来判断转发目标。这种方法称为透明代理（transparent proxy）。</p></li><li><p>这种方法也可以转发一般的请求消息，因此不需要像正向代理一样设置浏览器参数，也不需要在缓存服务器上设置转发目标，可以将请求转发给任意 Web 服务器</p></li><li><p>透明代理集合了正向代理和反向代理的优点，是一个非常方便的方式，但也需要注意一点，那就是如何才能让请求消息到达透明代理。由于透明代理不需要设置在浏览器中，那么浏览器还是照常向 Web 服务器发送请求消息。反向代理采用的是通过 DNS 服务器解析引导的方法，但透明代理是不能采用这种方法的，否则透明代理本身就变成了访问目标，也就无法通过接收方 IP 地址判断转发目标了，这就失去了透明代理的意义。总之，正常情况下，请求消息是从浏览器直接发送到 Web 服务器，并不会到达透明代理</p></li><li><p>于是需要将透明代理放在请求消息从浏览器传输到 Web 服务器的路径中，当消息经过时进行拦截。只有这样才能让消息到达透明代理，然后再转发给 Web 服务器</p></li><li><p>如果请求消息有多条路径可以到达 Web 服务器，那么就必须在这些路径上都放置透明代理，因此一般是将网络设计成只有一条路可以走的结构，然后在这一条路径上放置透明代理。连接互联网的接入网就是这样一个关口，因此可以在接入网的入口处放置透明代理。也可以采用在网络中的某些地方将 Web 访问包筛选出来并转发给透明代理的方法。</p></li><li><p>使用透明代理时，用户不会察觉到代理的存在，也不会注意到 HTTP 消息是如何被转发的，因此大家更倾向于将透明代理说成是缓存</p></li></ul><h3 id="5-5-内容分发服务"><a href="#5-5-内容分发服务" class="headerlink" title="5.5 内容分发服务"></a>5.5 内容分发服务</h3><h4 id="5-5-1-内容分发服务的背景"><a href="#5-5-1-内容分发服务的背景" class="headerlink" title="5.5.1 内容分发服务的背景"></a>5.5.1 内容分发服务的背景</h4><ul><li><p>缓存服务器部署的三种方式：</p><p><img src="/image/%E7%BD%91%E7%BB%9C%E6%98%AF%E6%80%8E%E6%A0%B7%E8%BF%9E%E6%8E%A5%E7%9A%84/97a7515663001c95c009a79a136372b7a7cc8b93.jpeg" alt="epub_907755_477.jpeg"></p></li><li><p>缓存服务器部署在服务器端还是客户端，其效果是有差别的。如图（a）所示，当缓存服务器放在服务器端时，可以减轻 Web 服务器的负载，但无法减少互联网中的流量。这一点上，将缓存服务器放在客户端更有效（图（b））。互联网中会存在一些拥塞点，通过这些地方会比较花时间。如果在客户端部署缓存服务器，就可以不受或者少受这些拥塞点的影响，让网络流量更稳定，特别是当访问内容中含有大图片或视频时效果更明显</p></li><li><p>不过，客户端的缓存服务器是归客户端网络运营管理者所有的，Web 服务器的运营者无法控制它。比如，某网站的运营者觉得最近网站上增加了很多大容量的内容，因此想要增加缓存服务器的容量。如果缓存放在服务器端，那么网站运营者可以自己通过增加磁盘空间等方式来进行扩容，但对于放在客户端的缓存就无能为力了。进一步说，客户端有没有缓存服务器还不一定呢</p></li><li><p>因此，这两种部署缓存服务器的方式各有利弊，但也有一种方式能够集合两者的优点。那就是像图（c）这样，Web 服务器运营者和网络运营商签约，将可以自己控制的缓存服务器放在客户端的运营商处。这样一来，就可以把缓存服务器部署在距离用户很近的地方，同时 Web 服务器运营者还可以控制这些服务器</p></li><li><p>但图（c）方式也有问题。对于在互联网上公开的服务器来说，任何地方的人都可以来访问它，因此如果真的要实现这个方式，必须在所有的运营商 POP 中都部署缓存服务器才行，这个数量太大了，非常不现实。可以筛选出一些主要的运营商，这样可以减少缓存服务器的数量。尽管这样做可能会导致有些用户访问到缓存服务器还是要经过很长的距离，但总比直接访问 Web 服务器的路径要短多了，因此还是可以产生一定的效果</p></li><li><p>一些专门负责提供上述相关服务的厂商出现了，他们来部署缓存服务器，并租借给 Web 服务器运营者。这种服务称为内容分发服务</p></li><li><p>内容分发服务也叫 CDS（Content Delivery Service）。现在更常用的名称叫 CDN（Content Delivery Network 或 Content Distribution Network）。</p></li><li><p>提供这种服务的厂商称为 CDSP（CDSP:Content Delivery Service Provider，内容分发服务运营商），他们会与主要的供应商签约，并部署很多台缓存服务器 [插图]。另一方面，CDSP 会与 Web 服务器运营者签约，使得 CDSP 的缓存服务器配合 Web 服务器工作。只要 Web 服务器与缓存服务器建立关联，那么当客户端访问 Web 服务器时，实际上就是在访问 CDSP 的缓存服务器了</p></li><li><p>缓存服务器可以缓存多个网站的数据，因此 CDSP 的缓存服务器就可以提供给多个 Web 服务器的运营者共享。这样一来，每个网站运营者的平均成本就降低了，从而减少了网站运营者的负担。而且，和运营商之间的签约工作也由 CDSP 统一负责，网站运营者也节省了精力</p></li></ul><h4 id="5-5-2-如何找到最近的缓存服务器"><a href="#5-5-2-如何找到最近的缓存服务器" class="headerlink" title="5.5.2 如何找到最近的缓存服务器"></a>5.5.2 如何找到最近的缓存服务器</h4><ul><li><p>如何使得用户不进行设置，也能够将请求消息发送到缓存服务器，有几种方法：</p><ul><li>第一个方法是像负载均衡一样用 DNS 服务器来分配访问。也就是说，我们可以在 DNS 服务器返回 Web 服务器 IP 地址时，对返回的内容进行一些加工，使其能够返回距离客户端最近的缓存服务器的 IP 地址</li></ul></li><li><p>对于第一个方法。在 DNS 服务器中，如果一个域名对应多个 IP 地址，则按照轮询方式按顺序返回所有的 IP 地址。如果按照 DNS 服务器的一般工作方式来看，它只能以轮询方式按顺序返回 IP 地址，完全不考虑客户端与缓存服务器的远近，因此可能会返回离客户端较远的缓存服务器 IP 地址。如果要让用户访问最近的缓存服务器，则不应采用轮询方式，而是应该判断客户端与缓存服务器的距离，并返回距离客户端最近的缓存服务器 IP 地址</p></li><li><p>如何判断客户端与缓存服务器之间的距离？</p><ol><li><p>首先，作为准备，需要事先从缓存服务器部署地点的路由器收集路由信息。举个例子，假如一共有 4 台缓存服务器，在这 4 台服务器的部署地点又分别有 4 台路由器，则我们需要分别获取这 4 台路由器的路由表，并将 4 张路由表集中到 DNS 服务器上</p></li><li><p>接下来，DNS 服务器根据路由表查询从本机到 DNS 查询消息的发送方，也就是客户端 DNS 服务器的路由信息。例如，根据上诉例子路由器 A 的路由表，可以查出路由器 A 到客户端 DNS 服务器的路由。通过互联网内部的路由表中的路由信息可以知道先通过运营商 X，然后通过运营商 Y，最后到达运营商 Z 这样的信息，通过这样的信息可以大致估算出距离</p></li><li><p>依次查询所有路由器的路由表之后，我们就可以通过比较找出哪一台路由器距离客户端 DNS 服务器最近。提供路由表的路由器位于缓存服务器的位置，而客户端 DNS 服务器也应该和客户端在同一位置，这样就等于估算出了缓存服务器与客户端之间的距离，从而能够判断出哪台缓存服务器距离客户端最近了。实际上，客户端 DNS 服务器不一定和客户端在同一位置，因此可能无法得出准确的距离，但依然可以达到相当的精度。</p></li></ol></li></ul><h4 id="5-5-3-通过重定向向服务器分配访问目标"><a href="#5-5-3-通过重定向向服务器分配访问目标" class="headerlink" title="5.5.3 通过重定向向服务器分配访问目标"></a>5.5.3 通过重定向向服务器分配访问目标</h4><ul><li><p>还有另一个让客户端访问最近的缓存服务器的方法：HTTP 规格中定义了很多头部字段，其中有一个叫作 Location 的字段。当 Web 服务器数据转移到其他服务器时可以使用这个字段，它的意思是“您要访问的数据在另一台服务器上，请访问那台服务器吧。”这种将客户端访问引导到另一台 Web 服务器的操作称为重定向，通过这种方法也可以将访问目标分配到最近的缓存服务器</p></li><li><p>当使用重定向告知客户端最近的缓存服务器时，首先需要将重定向服务器注册到 Web 服务器端的 DNS 服务器上。这样一来，客户端会将 HTTP 请求消息发送到重定向服务器上。重定向服务器和刚才一种方法中的 DNS 服务器一样，收集了来自各个路由器的路由信息，并根据这些信息找到最近的缓存服务器，然后将缓存服务器的地址放到 Location 字段中返回响应。这样，客户端就会重新去访问指定的缓存服务器了</p></li><li><p>这种方法的缺点在于增加了 HTTP 消息的交互次数，相应的开销也比较大，但它也有优点。对 DNS 服务器进行扩展的方法是估算客户端 DNS 服务器到缓存服务器之间的距离，因此精度较差；相对而言，重定向的方法是根据客户端发送来的 HTTP 消息的发送方 IP 地址来估算距离的，因此精度较高</p></li><li><p>此外，也可以使用除路由信息之外的其他一些信息来估算距离，进一步提高精度。重定向服务器不仅可以返回带有 Location 字段的 HTTP 消息，也可以返回一个通过网络包往返时间估算到缓存服务器的距离的脚本，通过在客户端运行脚本来找到最优的缓存服务器。这个脚本可以向不同的缓存服务器发送测试包并计算往返时间，然后将请求发送到往返时间最短的一台缓存服务器，这样就可以判断出对于客户端最优的缓存服务器，并让客户端去访问该服务器</p></li></ul><h4 id="5-5-4-缓存的更新方法会影响性能"><a href="#5-5-4-缓存的更新方法会影响性能" class="headerlink" title="5.5.4 缓存的更新方法会影响性能"></a>5.5.4 缓存的更新方法会影响性能</h4><ul><li><p>还有一个因素会影响缓存服务器的效率，那就是缓存内容的更新方法</p></li><li><p>缓存本来的思路是将曾经访问过的数据保存下来，然后当再次访问时拿出来用，以提高访问操作的效率。不过，这种方法对于第一次访问是无效的，而且后面的每次访问都需要向原始服务器查询数据有没有发生变化，如果遇到网络拥塞，就会使响应时间恶化</p></li><li><p>要改善上述思路，有一种方法是让 Web 服务器在原始数据发生更新时，立即通知缓存服务器，使得缓存服务器上的数据一直保持最新状态，这样就不需要每次确认原始数据是否有变化了，而且从第一次访问就可以发挥缓存的效果。内容分发服务采用的缓存服务器就具备这样的功能</p></li><li><p>此外，除了事先编写好内容的静态页面之外，还有一些在收到请求后由 CGI 程序生成的动态页面，这种动态页面是不能保存在缓存服务器上的。这种情况下，我们可以不保存整个页面，而是将应用程序生成的部分，也就是每次内容都会发生变化的动态部分，与内容不会发生变化的静态部分分开，只将静态部分保存在缓存中</p></li></ul><h2 id="第六章-请求到达-Web-服务器，响应返回浏览器"><a href="#第六章-请求到达-Web-服务器，响应返回浏览器" class="headerlink" title="第六章 请求到达 Web 服务器，响应返回浏览器"></a>第六章 请求到达 Web 服务器，响应返回浏览器</h2><h3 id="6-1-服务器概览"><a href="#6-1-服务器概览" class="headerlink" title="6.1 服务器概览"></a>6.1 服务器概览</h3><h4 id="6-1-1-客户端和服务器的区别"><a href="#6-1-1-客户端和服务器的区别" class="headerlink" title="6.1.1 客户端和服务器的区别"></a>6.1.1 客户端和服务器的区别</h4><ul><li><p>客户端和服务器的异：</p><ul><li><p>根据用途，服务器可以分为很多种类，其硬件和操作系统与客户端是有所不同的</p></li><li><p>服务器的程序可以同时和多台客户端计算机进行通信，这也是一点区别。因此，服务器程序和客户端程序在结构上是不同的</p></li><li><p>在连接过程中，客户端发起连接操作，而服务器则是等待连接操作，因此在 Socket 库的用法上还是有一些区别的，即应用程序调用的 Socket 库的程序组件不同</p></li></ul></li><li><p>客户端和服务器的同：</p><ul><li>网络相关的部分，如网卡、协议栈、Socket 库等功能和客户端却并无二致。无论硬件和 OS 如何变化，TCP 和 IP 的功能都是一样的，或者说这些功能规格都是统一的</li></ul></li></ul><h4 id="6-1-2-服务器程序的结构"><a href="#6-1-2-服务器程序的结构" class="headerlink" title="6.1.2 服务器程序的结构"></a>6.1.2 服务器程序的结构</h4><ul><li><p>服务器需要同时和多个客户端通信，但一个程序来处理多个客户端的请求是很难的，因为服务器必须把握每一个客户端的操作状态。因此一般的做法是，每有一个客户端连接进来，就启动一个新的服务器程序，确保服务器程序和客户端是一对一的状态</p></li><li><p>服务器分层简单图示：</p><p><img src="/image/%E7%BD%91%E7%BB%9C%E6%98%AF%E6%80%8E%E6%A0%B7%E8%BF%9E%E6%8E%A5%E7%9A%84/42635d6e641504ad300e5c5092141d4b2eb18208.jpeg" alt="epub_907755_495.jpeg"></p></li><li><p>服务器程序的结构如上图所示：</p><ul><li><p>首先，程序分成两个模块，即等待连接模块图（a）和负责与客户端通信的模块图（b）</p></li><li><p>当服务器程序启动并读取配置文件完成初始化操作后，就会运行等待连接模块（a）。这个模块会创建套接字，然后进入等待连接的暂停状态</p></li><li><p>接下来，当客户端连发起连接时，这个模块会恢复运行并接受连接，然后启动客户端通信模块（b），并移交完成连接的套接字</p></li><li><p>接下来，客户端通信模块（b）就会使用已连接的套接字与客户端进行通信，通信结束后，这个模块就退出了</p></li></ul></li><li><p>每次有新的客户端发起连接，都会启动一个新的客户端通信模块（b），因此（b）与客户端是一对一的关系。这样，（b）在工作时就不必考虑其他客户端的连接情况，只要关心自己对应的客户端就可以了</p><p>通过这样的方式，可以降低程序编写的难度。服务器操作系统具有多任务、多线程功能，可以同时运行多个程序，服务器程序的设计正是利用了这一功能</p></li><li><p>上述方法在每次客户端发起连接时都需要启动新的程序，这个过程比较耗时，响应时间也会相应增加。因此，还有一种方法是事先启动几个客户端通信模块，当客户端发起连接时，从空闲的模块中挑选一个出来将套接字移交给它来处理</p></li></ul><h4 id="6-1-3-服务器端的套接字和端口号"><a href="#6-1-3-服务器端的套接字和端口号" class="headerlink" title="6.1.3 服务器端的套接字和端口号"></a>6.1.3 服务器端的套接字和端口号</h4><ul><li><p>从数据收发的角度来看，这就是客户端与服务器的区别，也就是说，发起连接的一方是客户端，等待连接的一方是服务器</p></li><li><p>客户端的数据收发主要是以下四个阶段：</p><ul><li><p>创建套接字（创建套接字阶段）</p></li><li><p>用管道连接服务器端的套接字（连接阶段）</p></li><li><p>收发数据（收发阶段）</p></li><li><p>断开管道并删除套接字（断开阶段）</p></li></ul></li><li><p>相对地，服务器是将第二个阶段改成了等待连接，具体如下：</p><ul><li><p>创建套接字（创建套接字阶段）</p></li><li><p>等待阶段</p><ul><li><p>将套接字设置为等待连接状态（等待连接阶段）</p></li><li><p>接受连接（接受连接阶段）</p></li></ul></li><li><p>收发数据（收发阶段）</p></li><li><p>断开管道并删除套接字（断开阶段）</p></li></ul></li><li><p>服务器程序主要阶段的伪代码：</p><p><img src="/image/%E7%BD%91%E7%BB%9C%E6%98%AF%E6%80%8E%E6%A0%B7%E8%BF%9E%E6%8E%A5%E7%9A%84/82831f1c2532414875c69dbf52d411f8cb52a019.jpeg" alt="epub_907755_501.jpeg"></p></li><li><p>服务端的具体工作步骤：</p><ol><li><p>首先，协议栈调用 socket 创建套接字图（1），这一步和客户端是相同的。创建套接字操作的本质是分配用于套接字的内存空间，这一点上客户端和服务器是一样的。</p></li><li><p>接下来调用 bind 将端口号写入套接字中（图（2-1））。在客户端发起连接的操作中，需要指定服务器端的端口号，这个端口号也就是在这一步设置的（客户端调用 connect）。具体的编号是根据服务器程序的种类，按照规则来确定的，例如 Web 服务器使用 80 号端口</p></li><li><p>设置好端口号之后，协议栈会调用 listen 向套接字写入等待连接状态这一控制信息（图（2-1））。这样一来，套接字就会开始等待来自客户端的连接网络包</p></li><li><p>然后，协议栈会调用 accept 来接受连接（图（2-2））</p><ul><li><p>由于等待连接的模块在服务器程序启动时就已经在运行了，所以在刚启动时，应该还没有客户端的连接包到达</p></li><li><p>包都没来就调用 accept 接受连接也没关系，因为如果包没有到达，就会转为等待包到达的状态，并在包到达的时候继续执行接受连接操作。因此，在执行 accept 的时候，一般来说服务器端都是处于等待包到达的状态，这时应用程序会暂停运行。在这个状态下，一旦客户端的包到达，就会返回响应包并开始接受连接操作</p></li></ul></li><li><p>当 accept 结束之后，等待连接的过程也就结束了，接下来协议栈会给等待连接的套接字复制一个副本，然后将连接对象等控制信息写入新的套接字中。到这里，我们就创建了一个新的套接字，用于和客户端套接字连接在一起了</p></li><li><p>再接下来等待连接模块会启动客户端通信模块，然后将连接好的新套接字转交给客户端通信模块，由这个模块来负责执行与客户端之间的通信操作</p></li><li><p>之后的数据收发操作和刚才说的一样，与客户端的工作过程是相同的</p></li></ol></li><li><p>在复制出一个新的套接字之后，原来那个处于等待连接状态的套接字会以等待连接的状态继续存在，当再次调用 accept，客户端连接包到达时，它又可以再次执行接受连接操作。接受新的连接之后，和刚才一样，协议栈会为这个等待连接的套接字复制一个新的副本，然后让客户端连接到这个新的副本套接字上</p><p>像这样每次为新的连接创建新的套接字就是这一步操作的一个关键点。如果不创建新副本，而是直接让客户端连接到等待连接的套接字上，那么就没有套接字在等待连接了，这时如果有其他客户端发起连接就会遇到问题。为了避免出现这样的情况，协议栈采用了这种创建套接字的新副本，并让客户端连接到这个新副本上的方法</p></li><li><p>创建新套接字时端口号也是一个关键点</p><ul><li><p>在接受连接的时候，新创建的套接字副本就必须和原来的等待连接的套接字具有不同的端口号才行。否则客户端无法判断服务端的端口</p></li><li><p>多个套接字对应同一个端口会导致一个问题：端口号是用来识别套接字的，如果一个端口号对应多个套接字，就无法通过端口号来定位到某一个套接字了。当客户端的包到达时，如果协议栈只看 TCP 头部中的接收方端口号，是无法判断这个包到底应该交给哪个套接字的</p><p>因此服务端确定某个套接字时，不仅使用服务器端套接字对应的端口号，还同时使用客户端的端口号再加上 IP 地址，总共使用下面 4 种信息来进行判断</p><p><img src="/image/%E7%BD%91%E7%BB%9C%E6%98%AF%E6%80%8E%E6%A0%B7%E8%BF%9E%E6%8E%A5%E7%9A%84/3df6afc8ff50855735d563555a14ab979ddb38da.jpeg" alt="epub_907755_504.jpeg"></p></li><li><p>服务器上可能存在多个端口号相同的套接字，但客户端的套接字都是对应不同端口号的，因此我们可以通过客户端的端口号来确定服务器上的某个套接字。不过，使用不同端口号的规则仅限一台客户端的内部，当有多个客户端进行连接时，它们之间的端口号是可以重复的。因此，我们还必须加上客户端的 IP 地址才能进行判断</p></li></ul></li></ul><h3 id="6-2-服务器的接收操作"><a href="#6-2-服务器的接收操作" class="headerlink" title="6.2  服务器的接收操作"></a>6.2  服务器的接收操作</h3><h4 id="6-2-1-网卡的接收操作"><a href="#6-2-1-网卡的接收操作" class="headerlink" title="6.2.1 网卡的接收操作"></a>6.2.1 网卡的接收操作</h4><ul><li><p>接收操作的第一步是网卡接收到模拟信号，然后将其还原成数字信息</p><ul><li>局域网中传输的网络包信号是由 1 和 0 组成的数字信息与用来同步的时钟信号叠加而成的，因此只要从中分离出时钟信号，然后根据时钟信号进行同步，就可以读取并还原出 1 和 0 的数字信息了</li></ul></li><li><p>简略图示：</p><p><img src="/image/%E7%BD%91%E7%BB%9C%E6%98%AF%E6%80%8E%E6%A0%B7%E8%BF%9E%E6%8E%A5%E7%9A%84/06973ebcb388bdd919731d7ebb856bfc75c76ab5.jpeg" alt="epub_907755_507.jpeg"></p></li><li><p>信号的格式随传输速率的不同而不同，因此某些操作过程可能存在细微差异，例如 10BASE-T 的工作方式如上图所示。</p><ul><li><p>首先从报头部分提取出时钟信号（图①），报头的信号是按一定频率变化的，只要测定这个变化的频率就可以和时钟信号同步了</p></li><li><p>接下来，按照相同的周期延长时钟信号（图②），并在每个时钟周期位置检测信号的变化方向（图③）</p></li><li><p>图中用向上和向下的箭头表示变化方向，实际的信号则是正或负的电压，这里需要检测电压是从正变为负，还是从负变为正，这两种变化方向分别对应 0 和 1（图④）。在图中，向上的箭头为 1，向下的箭头为 0，实际上是从负到正变化为 1，从正到负变化为 0。这样，信号就被还原成数字信息了</p></li></ul></li><li><p>接下来需要根据包末尾的帧校验序列（FCS）来校验错误，即根据校验公式 [插图] 计算刚刚接收到的数字信息，然后与包末尾的 FCS 值进行比较</p><ul><li><p>FCS 值是在发送时根据转换成电信号之前的数字信息进行计算得到的，因此如果根据信号还原出的数字信息与发送前的信息一致，则计算出的 FCS 也应该与包末尾的 FCS 一致</p></li><li><p>如果两者不一致，则可能是因为噪声等影响导致信号失真，数据产生了错误，这时接收的包是无效的，因此需要丢弃</p></li></ul></li><li><p>当 FCS 一致，即确认数据没有错误时，接下来需要检查 MAC 头部中的接收方 MAC 地址，看看这个包是不是发给自己的</p><ul><li>以太网的基本工作方式是将数据广播到整个网络上，只有指定的接收者才接收数据，因此网络中还有很多发给其他设备的数据在传输，如果包的接收者不是自己，那么就需要丢弃这个包</li></ul></li><li><p>到这里，接收信号并还原成数字信息的操作就完成了，还原后的数字信息被保存在网卡内部的缓冲区中。上面这些操作都是由网卡的 MAC 模块来完成的</p></li><li><p>接下来，网卡需要通过中断将网络包到达的事件通知给 CPU</p></li><li><p>然后 CPU 就会暂停当前的工作，并切换到网卡的任务</p></li><li><p>然后，网卡驱动会开始运行，从网卡缓冲区中将接收到的包读取出来，根据 MAC 头部的以太类型字段判断协议的种类，并调用负责处理该协议的软件。网卡驱动会根据 MAC 头部判断协议类型，并将包交给相应的协议栈。这里，以太类型的值应该是表示 IP 协议，因此会调用 TCP&#x2F;IP 协议栈，并将包转交给它</p></li></ul><h4 id="6-2-2-IP-模块的接收操作"><a href="#6-2-2-IP-模块的接收操作" class="headerlink" title="6.2.2 IP 模块的接收操作"></a>6.2.2 IP 模块的接收操作</h4><ul><li><p>当网络包转交到协议栈时，IP 模块会首先开始工作，检查 IP 头部</p><ul><li><p>IP 模块首先会检查 IP 头部的格式是否符合规范，然后检查接收方 IP 地址，看包是不是发给自己的。当服务器启用类似路由器的包转发功能时，对于不是发给自己的包，会像路由器一样根据路由表对包进行转发</p></li><li><p>服务器也可以启用类似防火墙的包过滤功能，这时，在包转发的过程中还会对包进行检查，并丢弃不符合规则的包。</p></li></ul></li><li><p>确认包是发给自己的之后，接下来需要检查包有没有被分片</p><ul><li><p>检查 IP 头部的内容就可以知道是否分片，如果是分片的包，则将包暂时存放在内存中，等所有分片全部到达之后将分片组装起来还原成原始包</p></li><li><p>如果没有分片，则直接保留接收时的样子，不需要进行重组</p></li></ul></li><li><p>到这里，我们就完成了包的接收。总结来说，协议栈的 IP 模块会检查 IP 头部</p><ul><li><p>判断是不是发给自己</p></li><li><p>判断网络包是否经过分片</p></li><li><p>将包转交给 TCP 模块或 UDP 模块。</p></li></ul></li><li><p>接下来需要检查 IP 头部的协议号字段，并将包转交给相应的模块</p><ul><li><p>如果协议号为 06（十六进制），则将包转交给 TCP 模块，接下来假设是 TCP 的包</p></li><li><p>如果是 11（十六进制），则转交给 UDP 模块</p></li></ul></li></ul><h4 id="6-2-3-TCP-模块处理链接包"><a href="#6-2-3-TCP-模块处理链接包" class="headerlink" title="6.2.3 TCP 模块处理链接包"></a>6.2.3 TCP 模块处理链接包</h4><ul><li><p>服务器程序主要阶段的伪代码：</p><p><img src="/image/%E7%BD%91%E7%BB%9C%E6%98%AF%E6%80%8E%E6%A0%B7%E8%BF%9E%E6%8E%A5%E7%9A%84/8c82cdcb19b63bd67a7ce90ecac2628dd9dee298.jpeg" alt="epub_907755_518.jpeg"></p></li><li><p>当 TCP 头部中的控制位 SYN 为 1 时，表示这是一个发起连接的包（图①）。这时，TCP 模块会执行接受连接的操作，不过在此之前，需要先检查包的接收方端口号，并确认在该端口上有没有与接收方端口号相同且正在处于等待连接状态的套接字。如果指定端口号没有等待连接的套接字，则向客户端返回错误通知的包，向客户端返回一个表示接收方端口不存在等待连接的套接字的 ICMP 消息</p></li><li><p>如果存在等待连接的套接字，则为这个套接字复制一个新的副本，并将发送方 IP 地址、端口号、序号初始值、窗口大小等必要的参数写入这个套接字中，同时分配用于发送缓冲区和接收缓冲区的内存空间</p><p>然后生成代表接收确认的 ACK 号，用于从服务器向客户端发送数据的序号初始值，表示接收缓冲区剩余容量的窗口大小，并用这些信息生成 TCP 头部，委托 IP 模块发送给客户端</p></li><li><p>这个包到达客户端之后，客户端会返回表示接收确认的 ACK 号，当这个 ACK 号返回服务器后，连接操作就完成了</p></li><li><p>总结来说，如果收到的是发起连接的包，则 TCP 模块会</p><ul><li><p>确认 TCP 头部的控制位 SYN</p></li><li><p>检查接收方端口号</p></li><li><p>为相应的等待连接套接字复制一个新的副本</p></li><li><p>记录发送方 IP 地址和端口号等信息</p></li></ul></li></ul><h4 id="6-2-4-TCP-模块处理数据包"><a href="#6-2-4-TCP-模块处理数据包" class="headerlink" title="6.2.4 TCP 模块处理数据包"></a>6.2.4 TCP 模块处理数据包</h4><ul><li><p>首先，TCP 模块会检查收到的包对应哪一个套接字</p><ul><li>在服务器端，可能有多个已连接的套接字对应同一个端口号，因此仅根据接收方端口号无法找到特定的套接字。这时需要根据 IP 头部中的发送方 IP 地址和接收方 IP 地址，以及 TCP 头部中的接收方端口号和发送方端口号共 4 种信息，找到上述 4 种信息全部匹配的套接字</li></ul></li><li><p>找到 4 种信息全部匹配的套接字之后，TCP 模块会对比该套接字中保存的数据收发状态和收到的包的 TCP 头部中的信息是否匹配，以确定数据收发操作是否正常</p><ul><li><p>具体来说，就是根据套接字中保存的上一个序号和数据长度计算下一个序号，并检查与收到的包的 TCP 头部中的序号是否一致</p></li><li><p>如果两者一致，就说明包正常到达了服务器，没有丢失。这时，TCP 模块会从包中提出数据，并存放到接收缓冲区中，与上次收到的数据块连接起来。这样一来，数据就被还原成分包之前的状态了</p></li><li><p>拼合数据块的操作在每次收到数据包时都会进行，而不是等所有数据全部接受完毕之后再统一拼合的。</p></li></ul></li><li><p>当收到的数据进入接收缓冲区后，TCP 模块就会生成确认应答的 TCP 头部，并根据接收包的序号和数据长度计算出 ACK 号，然后委托 IP 模块发送给客户端</p><ul><li>在返回 ACK 号之前，会先等待一段时间，看看能不能和后续的应答包合并。</li></ul></li><li><p>收到的数据块进入接收缓冲区，意味着数据包接收的操作告一段落了</p></li><li><p>接下来，应用程序会调用 Socket 库的 read 来获取收到的数据，这时数据会被转交给应用程序</p><ul><li>如果应用程序不来获取数据，则数据会被一直保存在缓冲区中，但一般来说，应用程序会在数据到达之前调用 read 等待数据到达，在这种情况下，TCP 模块在完成接收操作的同时，就会执行将数据转交给应用程序的操作</li></ul></li><li><p>然后，控制流程会转移到服务器程序，对收到的数据进行处理，也就是检查 HTTP 请求消息的内容，并根据请求的内容向浏览器返回相应的数据</p></li><li><p>总的来说，收到数据包时，TCP 模块会</p><ul><li><p>根据收到的包的发送方 IP 地址、发送方端口号、接收方 IP 地址、接收方端口号找到相对应的套接字</p></li><li><p>将数据块拼合起来并保存在接收缓冲区中</p></li><li><p>向客户端返回 ACK</p></li></ul></li></ul><h4 id="6-2-5-TCP-模块的断开操作"><a href="#6-2-5-TCP-模块的断开操作" class="headerlink" title="6.2.5 TCP 模块的断开操作"></a>6.2.5 TCP 模块的断开操作</h4><ul><li><p>在 TCP 协议的规则中，断开操作可以由客户端或服务器任何一方发起，具体的顺序是由应用层协议决定的。Web 中，这一顺序随 HTTP 协议版本不同而不同，在 HTTP1.0 中，是服务器先发起断开操作。HTTP1.1 中，是客户端先发起断开操作，这种情况下只要将客户端和服务器的操作颠倒一下就可以了</p></li><li><p>首先，服务器程序会调用 Socket 库的 close, TCP 模块会生成一个控制位 FIN 为 1 的 TCP 头部，并委托 IP 模块发送给客户端</p></li><li><p>当客户端收到这个包之后，会返回一个 ACK 号</p></li><li><p>接下来客户端调用 close，生成一个 FIN 为 1 的 TCP 头部发给服务器，服务器再返回 ACK 号，这时断开操作就完成了</p></li><li><p>无论哪种情况，当断开操作完成后，套接字会在经过一段时间后被删除</p></li></ul><h3 id="6-3-Web-服务器程序解释请求消息并作出响应"><a href="#6-3-Web-服务器程序解释请求消息并作出响应" class="headerlink" title="6.3 Web 服务器程序解释请求消息并作出响应"></a>6.3 Web 服务器程序解释请求消息并作出响应</h3><h4 id="6-3-1-将请求的-URI-转换为文件路径"><a href="#6-3-1-将请求的-URI-转换为文件路径" class="headerlink" title="6.3.1 将请求的 URI 转换为文件路径"></a>6.3.1 将请求的 URI 转换为文件路径</h4><ul><li><p>服务器程序会根据收到的请求消息中的内容进行相应的处理，并生成响应消息，再通过 write 返回给客户端</p></li><li><p>请求消息包括一个称为“方法”的命令，以及表示数据源的 URI（文件路径名），服务器程序会根据这些内容向客户端返回数据，但对于不同的方法和 URI，服务器内部的工作过程会有所不同</p></li><li><p>Web 服务器公开的目录其实并不是磁盘上的实际目录，而是虚拟目录，而 URI 中写的就是在这个虚拟目录结构下的路径名。也就是说，客户端看到的 Web 服务器目录是虚拟的，和实际的目录结构不同。Web 服务器内部会将实际的目录名和供外部访问的虚拟目录名进行关联</p></li><li><p>Web 服务器进行文件名转换是有特例的，比如 URI 中的路径省略了文件名的情况，这时服务器会读取事先设置好的默认文件名。例如在浏览器中输入如下网址</p></li><li><p>有些 Web 服务器程序还具有文件名改写功能，只要设置好改写的规则，当 URI 中的路径符合改写规则时，就可以将 URI 中的文件名改写成其他的文件名进行访问</p></li></ul><h4 id="6-3-2-运行-CGI-程序"><a href="#6-3-2-运行-CGI-程序" class="headerlink" title="6.3.2 运行 CGI 程序"></a>6.3.2 运行 CGI 程序</h4><ul><li><p>如果 URI 指定的文件内容为 HTML 文档或图片，那么只要直接将文件内容作为响应消息返回客户端就可以了。但 URI 指定的文件内容不仅限于 HTML 文档，也有可能是一个程序。在这个情况下，服务器不会直接返回文件内容，而是会运行这个程序，然后将程序输出的数据返回给客户端</p></li><li><p>Web 服务器收到请求消息之后，Web 服务器会进行下面的工作</p><ul><li><p>首先，Web 服务器会检查 URI 指定的文件名，看一看这个文件是不是一个程序</p><ul><li><p>这里的判断方法是在 Web 服务器中事先设置好的，一般是通过文件的扩展名来进行判断，例如将．cgi、.php 等扩展名的文件设置为程序，当遇到这些文件时，Web 服务器就会将它们作为程序来对待</p></li><li><p>也可以设置一个存放程序的目录，将这个目录下的所有文件都作为程序来对待</p></li><li><p>此外，还可以根据文件的属性来进行判断</p></li></ul></li><li><p>如果判断要访问的文件为程序文件，Web 服务器会委托操作系统运行这个程序，然后从请求消息中取出数据并交给运行的程序</p><ul><li><p>如果方法为 GET，则将 URI 后面的参数传递给程序</p></li><li><p>如果方法为 POST，则将消息体中的数据传递给程序</p></li></ul></li><li><p>接下来，运行的程序收到数据后会进行一系列处理，并将输出的数据返回给 Web 服务器。无论如何，为了将数据处理的结果返回给客户端，首先需要将它返回给 Web 服务器</p><ul><li>这些输出的数据一般来说会嵌入到 HTML 文档中，因此 Web 服务器可以直接将其作为响应消息返回给客户端。输出数据的内容是由运行的程序生成的，Web 服务器并不过问，也不会去改变程序输出的内容</li></ul></li></ul></li><li><p>总的来说，Web 服务器程序在组装网络包、还原数据之后，会运行其中指定的程序（实际是委托操作系统来运行），然后将数据传递给已运行的程序</p></li></ul><h4 id="6-3-3-Web-服务器的访问控制"><a href="#6-3-3-Web-服务器的访问控制" class="headerlink" title="6.3.3 Web 服务器的访问控制"></a>6.3.3 Web 服务器的访问控制</h4><ul><li><p>Web 服务器的基本工作方式就是根据请求消息的内容判断数据源，并从中获取数据返回给客户端，不过在执行这些操作之前，Web 服务器还可以检查事先设置的一些规则，并根据规则允许或禁止访问</p><p>这种根据规则判断是否允许访问的功能称为访问控制，一些会员制的信息服务需要限制用户权限的时候会使用这一功能，公司里也可以利用访问控制只允许某些特定部门访问</p></li><li><p>Web 服务器的访问控制规则主要有以下 3 种</p><ul><li><p>客户端 IP 地址</p></li><li><p>客户端域名</p></li><li><p>用户名和密码</p></li></ul></li><li><p>访问规则可针对作为数据源的文件和目录进行设置，当收到客户端的请求消息时，服务器会根据 URI 判断数据源，并检查数据源对应的访问控制规则，只有允许访问时才读取文件或运行程序</p></li><li><p>利用 HTTP 验证用户名和密码：</p><p><img src="/image/%E7%BD%91%E7%BB%9C%E6%98%AF%E6%80%8E%E6%A0%B7%E8%BF%9E%E6%8E%A5%E7%9A%84/3a285a8d6bc96dbea51a89e45c9d137fb83c4587.jpeg" alt="epub_907755_538.jpeg"></p></li><li><p>基于用户名和密码的访问控制</p><ul><li><p>这里指的是使用 Web 服务器提供的密码认证功能时的工作过程，除此之外，还可以通过 Web 服务器运行 CGI 认证程序来验证密码。</p><p>这种情况下，认证程序会生成一个含有密码表单的网页并发送给用户，用户填写密码后发送回服务器，由认证程序进行校验。这种方式会包含密码表单页面和用户提交的密码数据的交互过程，和 Web 服务器自身提供的密码认证功能是有区别的</p></li><li><p>当访问设置了用户名和密码保护的页面时，需要在 HTTP 请求消息中添加包含用户名和密码的头部字段（Authorization）。否则，Web 服务器不会返回请求的页面内容，而是会返回一个要求提供用户名和密码的头部字段（WWW-Authenticate）消息</p></li><li><p>步骤：</p><ul><li><p>通常的请求消息中不包含用户名和密码，因此无法验证用户名和密码</p></li><li><p>因此，Web 服务器会向用户发送一条响应消息，告诉用户需要在请求消息中放入用户名和密码</p></li><li><p>浏览器收到这条响应消息后，会弹出一个输入用户名和密码的窗口，用户输入用户名和密码后，浏览器将这些信息放入请求消息中重新发送给服务器</p></li><li><p>然后，Web 服务器查看接收到的用户名和密码与事先设置好的用户名和密码是否一致，以此判断是否允许访问，如果允许访问，则返回数据</p></li></ul></li></ul></li></ul><h4 id="6-3-4-返回响应信息"><a href="#6-3-4-返回响应信息" class="headerlink" title="6.3.4 返回响应信息"></a>6.3.4 返回响应信息</h4><ul><li><p>当服务器完成对请求消息的各种处理之后，就可以返回响应消息了。这里的工作过程和客户端向服务器发送请求消息时的过程相同</p></li><li><p>首先，Web 服务器调用 Socket 库的 write，将响应消息交给协议栈。这时，需要告诉协议栈这个响应消息应该发给谁，但我们并不需要直接告知客户端的 IP 地址等信息，而是只需要给出表示通信使用的套接字的描述符就可以了</p></li><li><p>接下来，协议栈会将数据拆分成多个网络包，然后加上头部发送出去。这些包中包含接收方客户端的地址，它们将经过交换机和路由器的转发，通过互联网最终到达客户端</p></li></ul><h3 id="6-4-浏览器接收响应并显示内容"><a href="#6-4-浏览器接收响应并显示内容" class="headerlink" title="6.4 浏览器接收响应并显示内容"></a>6.4 浏览器接收响应并显示内容</h3><h4 id="6-4-1-通过响应的数据类型判断其中的内容"><a href="#6-4-1-通过响应的数据类型判断其中的内容" class="headerlink" title="6.4.1 通过响应的数据类型判断其中的内容"></a>6.4.1 通过响应的数据类型判断其中的内容</h4><ul><li><p>Web 服务器发送的响应消息会被分成多个包发送给客户端，然后客户端需要接收数据</p></li><li><p>首先，网卡将信号还原成数字信息，协议栈将拆分的网络包组装起来并取出响应消息，然后将消息转交给浏览器。这个过程和服务器的接收操作相同</p></li><li><p>接下来浏览器准备显示内容，要显示内容，首先需要判断响应消息中的数据属于哪种类型。Web 可以处理的数据包括文字、图像、声音、视频等多种类型，每种数据的显示方法都不同，因此必须先要知道返回了什么类型的数据，否则无法正确显示</p></li><li><p>浏览器需要一些信息才能判断数据类型，原则上可以根据响应消息开头的 Content-Type 头部字段的值来进行判断。这个值一般是下面这样的字符串：</p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs pgsql">Content-<span class="hljs-keyword">Type</span>: <span class="hljs-type">text</span>/html<br></code></pre></td></tr></table></figure><ul><li><p>其中“&#x2F;”左边的部分称为“主类型”，表示数据的大分类</p></li><li><p>右边的“子类型”表示具体的数据类型</p></li><li><p>主类型和子类型的含义都是事先确定好的</p></li></ul></li><li><p>消息的 Content-Type 定义的数据类型：</p><p><img src="/image/%E7%BD%91%E7%BB%9C%E6%98%AF%E6%80%8E%E6%A0%B7%E8%BF%9E%E6%8E%A5%E7%9A%84/86ad956fbeabd196d7715b975ea89f1efe4bc3bc.jpeg" alt="epub_907755_540.jpeg"></p></li><li><p>此外，当数据类型为文本时，还需要判断编码方式，这时需要用 charset 附加表示文本编码方式的信息，内容如下：</p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs pgsql">Content-<span class="hljs-keyword">Type</span>: <span class="hljs-type">text</span>/html; charset=utf<span class="hljs-number">-8</span><br></code></pre></td></tr></table></figure></li><li><p>除了通过 Content-Type 判断数据类型，还需要检查 Content-Encoding 头部字段。如果消息中存放的内容是通过压缩或编码技术对原始数据进行转换得到的，那么 Content-Encoding 的值就表示具体的转换方式，通过这个字段的值，我们可以知道如何将消息中经过转换的数据还原成原始数据</p></li><li><p>Content-Type 字段使用的表示数据类型的方法是在 MIME[插图] 规格中定义的</p><ul><li><p>MIME：Multipurpose Internet Mail Extensions，多用途因特网邮件扩充。原本是为在电子邮件中附加图片和附件等非文本信息而制定的一种规格，后来在 Web 的领域也得到了广泛使用。</p></li><li><p>MIME 规格不仅用于 Web，也是邮件等领域中普遍使用的一种方式。不过这种方式也只不过是一种原则性的规范，要通过 Content-Type 准确判断数据类型，就需要保证 Web 服务器正确设置 Content-Type 的值，但现实中并非总是如此。如果 Web 服务器管理员不当心，就可能会因为设置错误导致 Content-Type 的值不正确。因此，根据原则检查 Content-Type 并不能确保总是能够准确判断数据类型</p></li></ul></li><li><p>有时候我们需要结合其他一些信息来综合判断数据类型，例如请求文件的扩展名、数据内容的格式等。比如，我们可以检查文件的扩展名，如果为．html 或．htm 则看作是 HTML 文件，或者也可以检查数据的内容，如果是以<html>开头的则看作是 HTML 文档。不仅是 HTML 这样的文本文件，图片也是一样。图片是经过压缩的二进制数据，但其开头也有表示内容格式的信息，我们可以根据这些信息来判断数据的类型。不过，这部分的逻辑并没有一个统一的规格，因此不同的浏览器以及不同的版本都会有所差异</p></li></ul><h4 id="6-4-2-浏览器显示网页内容"><a href="#6-4-2-浏览器显示网页内容" class="headerlink" title="6.4.2 浏览器显示网页内容"></a>6.4.2 浏览器显示网页内容</h4><ul><li><p>浏览器对于不同类型的数据显示操作的过程也不一样，我们以 HTML 文档为例来介绍：   </p><ul><li><p>HTML 文档通过标签表示文档的布局和字体等样式信息，浏览器需要解释这些标签的含义，按照指定的样式显示文档的内容</p></li><li><p>实际的显示操作是由操作系统来完成的，浏览器负责对操作系统发出指令，例如在屏幕上的什么位置显示什么文字、使用什么样的字体等</p></li><li><p>网页中还可以嵌入图片等数据，HTML 文档和图片等数据是分别存在在不同的文件中的，HTML 文档中只有表示图片引用的标签</p></li><li><p>在读取文档数据时，一旦遇到相应的标签，浏览器就会向服务器请求其中的图片文件。这个请求过程和请求 HTML 文档的过程是一样的，就是在 HTTP 请求消息的 URI 中写上图片文件的文件名即可。将这个请求消息发送给 Web 服务器之后，Web 服务器就会返回图片数据了</p></li><li><p>接下来，浏览器会将图片嵌入到标签所在的位置。JPEG 和 GIF 格式的图片是经过压缩的，浏览器需要将其解压后委托操作系统进行显示。当然，为了避免图片和文字重叠，在显示文字的时候需要为图片留出相应的位置</p></li></ul></li><li><p>像 HTML 文档和图片等浏览器可自行显示的数据，就会按照上述方式委托浏览器在屏幕上显示出来</p><p>不过，Web 服务器可能还会返回其他一些类型的数据，如文字处理、幻灯片等应用程序的数据。这些数据无法由浏览器自行显示，这时浏览器会调用相应的程序</p><p>这些程序可以是浏览器的插件，也可以是独立的程序，无论如何，不同类型的数据对应不同的程序，这一对应关系是在浏览器中设置好的，只要按照这一对应关系调用相应的程序，并将数据传递给它就可以了。然后，被调用的程序会负责显示相应的内容</p></li><li><p>到这里，浏览器的显示操作就完成了，可以等待用户的下一个动作了。当用户点击网页中的链接，或者在网址栏中输入新的网址时，访问 Web 服务器的操作就又开始了</p></li></ul>]]></content>
    
    
    <categories>
      
      <category>笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>基础体系</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【笔记】网络是怎样连接的（上）</title>
    <link href="/posts/d6dc4bf6.html"/>
    <url>/posts/d6dc4bf6.html</url>
    
    <content type="html"><![CDATA[<p>剩下的笔记：</p><blockquote><p><a href="eb39dc71">【笔记】网络是怎样连接的（中）</a><br><a href="6e602c93">【笔记】网络是怎样连接的（下）</a><br><a href="bed28f09">【笔记】网络是怎样连接的（附录）</a></p></blockquote><h2 id="第一章-浏览器生成消息-–-探索浏览器内部"><a href="#第一章-浏览器生成消息-–-探索浏览器内部" class="headerlink" title="第一章 浏览器生成消息 – 探索浏览器内部"></a>第一章 浏览器生成消息 – 探索浏览器内部</h2><h3 id="1-1-浏览器收发数据阶段"><a href="#1-1-浏览器收发数据阶段" class="headerlink" title="1.1 浏览器收发数据阶段"></a>1.1 浏览器收发数据阶段</h3><ul><li><p>HTTP 协议定义了客户端和服务器之间交互的消息内容和步骤</p></li><li><p>浏览器&#x2F;网络程序收发信息主要步骤：</p><ul><li><p>用户输入 URL 或点击 URL</p></li><li><p>解析 URL：不同类型的 URL 对应不同的协议&#x2F;服务，需要通过解析 URL 决定调用对应的服务&#x2F;访问方法</p></li><li><p>生成 HTTP 报文</p></li><li><p>根据域名查询 IP 地址：</p><ul><li><p>查询浏览器 DNS 缓存</p></li><li><p>调用 Socket 库的域名解析器解析域名</p></li></ul></li><li><p>委托协议栈收发数据：协议栈和服务器收发数据主要有四个步骤，具体细节查看下一章节</p><ul><li><p>创建套接字阶段：调用 Socket 库中的 socket 程序组件创建套接字</p></li><li><p>连接阶段：将管道连接到服务器端的套接字上；委托协议栈将客户端创建的套接字与服务器那边的套接字连接起来这一操作，通过调用 Socket 库中的名为 connect 的程序组件来完成这一操作</p></li><li><p>通信阶段：收发数据阶段；发送数据，通过调用 Socket 库 write 这个程序组件完成将数据送入套接字这一操作；接收消息的操作是通过 Socket 库中的 read 程序组件委托协议栈来完成的</p></li><li><p>断开阶段：当浏览器收到数据之后，收发数据的过程就结束了。接下来调用 Socket 库的 close 程序组件进入断开阶段。最终，连接在套接字之间的管道会被断开，套接字本身也会被删除。</p></li></ul></li></ul></li><li><p>Socket 库域名解析器解析操作：</p><ul><li><p>生成 DNS 报文：在这之前应该还会有一个查询本机 DNS 缓存&#x2F;读取 hosts 文件的步骤，但是为了主要脉络的清晰，就不添加了</p></li><li><p>委托协议栈发送 DNS 请求报文：具体协议栈收发请查看下一章节</p></li><li><p>协议栈接收响应报文，解析器解析成功</p></li></ul></li><li><p>关于 Socket 库和协议栈之间的关系：委托的操作都是通过调用 Socket 库中的程序组件来执行的，但这些数据通信用的程序组件其实仅仅充当了一个桥梁的角色，并不执行任何实质性的操作，应用程序的委托内容最终会被原原本本地传递给协议栈</p></li></ul><h3 id="1-2-DNS-基础"><a href="#1-2-DNS-基础" class="headerlink" title="1.2 DNS 基础"></a>1.2 DNS 基础</h3><ul><li><p>DNS 服务器的基本工作就是接收来自客户端的查询消息，然后根据消息的内容返回响</p></li><li><p>对于 DNS 服务器，来自客户端的查询信息包含以下内容：</p><ul><li><p>域名</p></li><li><p>Class：DNS 设计为可支持除互联网以外的网络类型，但是目前除了互联网没有其他网络类型了，Class 固定为代表互联网的 IN</p></li><li><p>记录类型：表示域名对应何种类型记录</p><table><thead><tr><th>类型</th><th>含义</th></tr></thead><tbody><tr><td>A</td><td>主机 IP 地址（address）</td></tr><tr><td>AAAA</td><td>主机 IPV6 地址</td></tr><tr><td>ALIAS</td><td>自动解析的别名（alias），类似 CNAME</td></tr><tr><td>CNAME</td><td>别名的权威名称（canonical name）</td></tr><tr><td>MX</td><td>邮件交换服务器（Mail eXchange）</td></tr><tr><td>NS</td><td>域名服务器（name server）</td></tr><tr><td>TXT</td><td>描述文本</td></tr></tbody></table></li><li><p>当记录类型为 MX 时，DNS 服务器会在记录中保存两种信息，分别是邮件服务器的域名和优先级</p></li><li><p>根域和顶级域（一级域）是不同的东西</p></li><li><p>当要查询的域名不存在时，“不存在”这一响应结果也会被 DNS 服务器缓存，当下次查询这个不存在的域名时，也可以快速响应</p></li></ul></li></ul><h2 id="第二章-用电信号传输-TCP-x2F-IP–探索协议栈和网卡"><a href="#第二章-用电信号传输-TCP-x2F-IP–探索协议栈和网卡" class="headerlink" title="第二章 用电信号传输 TCP&#x2F;IP–探索协议栈和网卡"></a>第二章 用电信号传输 TCP&#x2F;IP–探索协议栈和网卡</h2><h3 id="2-1-协议栈与其他部分的结构层次"><a href="#2-1-协议栈与其他部分的结构层次" class="headerlink" title="2.1 协议栈与其他部分的结构层次"></a>2.1 协议栈与其他部分的结构层次</h3><ul><li><p>TCP&#x2F;IP 应用程序采用分层结构：图中上下关系是有一定规则的，上面的部分会向下面的部分委派工作，下面的部分接受委派的工作并实际执行；但是当然，这一上下关系只是一个总体的规则，其中也有一部分上下关系不明确，或者上下关系相反的情况，所以也不必过于纠结</p><p><img src="/image/%E7%BD%91%E7%BB%9C%E6%98%AF%E6%80%8E%E6%A0%B7%E8%BF%9E%E6%8E%A5%E7%9A%84/420c71519d8b407c23c7de0f90b9918735ba60f0.jpeg" alt="epub_907755_123.jpeg"></p><ul><li><p>图中最上面的部分是网络应用程序</p></li><li><p>应用程序的下面是 Socket 库</p></li><li><p>再下面就是操作系统内部了，其中包括协议栈：</p><ul><li><p>协议栈的上半部分有两块，分别是负责用 TCP 协议收发数据的部分和负责用 UDP 协议收发数据的部分，它们会接受应用程序的委托执行收发数据的操作</p></li><li><p>协议栈的下半部分是用 IP 协议控制网络包收发操作的部分，IP 中还包括 ICMP[插图] 协议和 ARP 协议。ICMP 用于告知网络包传送过程中产生的错误以及各种控制消息，ARP 用于根据 IP 地址查询相应的以太网 MAC 地址 [插图]。</p></li></ul></li><li><p>协议栈下面的网卡驱动程序负责控制网卡硬件</p></li><li><p>最下面的网卡则负责完成实际的收发操作，也就是对网线中的信号执行发送和接收的操作</p></li></ul></li><li><p>除了 TCP&#x2F;IP 协议栈，还有其他的协议栈，例如 NetWare 中的 IPX&#x2F;SPX 协议栈，以及 Mac 电脑中使用的 AppleTalk 协议栈等，为了方便了解，协议栈默认 TCP&#x2F;IP 协议栈</p></li><li><p>协议栈上半部分，实现的是 TCP 和 UDP 这两个传输层协议；至于 DNS、HTTP 这种应用层协议，实际上是需要用户程序&#x2F;库来完成实现的</p></li><li><p>套接字中记录了用于控制通信操作的各种控制信息，协议栈是根据套接字中记录的控制信息来工作的，这就是套接字的作用</p></li><li><p>应用程序通过套接字的描述符来区分协议栈中的不同套接字</p></li></ul><h3 id="2-2-创建套接字阶段"><a href="#2-2-创建套接字阶段" class="headerlink" title="2.2 创建套接字阶段"></a>2.2 创建套接字阶段</h3><ul><li><p>步骤：</p><ol><li>创建套接字时，首先分配一个套接字所需的内存空间，然后向其中写入初始状态</li></ol></li><li><p>客户端在创建套接字时，协议栈会为这个套接字随便分配一个空闲端口号</p></li></ul><h3 id="2-3-连接阶段"><a href="#2-3-连接阶段" class="headerlink" title="2.3 连接阶段"></a>2.3 连接阶段</h3><ul><li><p>连接（connection，或 session）实际上是通信双方交换控制信息，在套接字中记录这些必要信息并准备数据收发的一连串操作；连接操作有几个目的：</p><ul><li><p>把服务器的 IP 地址和端口号等信息告知协议栈</p></li><li><p>客户端向服务器传达开始通信的请求</p></li></ul></li><li><p>连接操作中所交换的控制信息是根据通信规则来确定的，只要根据规则执行连接操作，双方就可以得到必要的信息从而完成数据收发的准备</p></li><li><p>当执行数据收发操作时，我们还需要一块用来临时存放要收发的数据的内存空间，这块内存空间称为缓冲区，它也是在连接操作的过程中分配的</p></li><li><p>“协议栈具体需要哪些信息”会根据协议栈本身的实现方式不同而不同；同时，Windows 和 Linux 操作系统的内部结构不同，协议栈的实现方式不同，必要的控制信息也就不同</p></li><li><p>控制信息的类型：</p><ul><li><p>第一类是客户端和服务器相互联络时交换的控制信息：</p><ul><li><p>这些字段是固定的，在连接、收发、断开等各个阶段中，每次客户端和服务器之间进行通信时，都需要提供这些控制信息，整个通信过程中都需要</p></li><li><p>这些控制信息位于网络包的开头，因此被称为头部</p></li></ul></li><li><p>第二类是保存在套接字中，用来控制协议栈操作的信息：</p><ul><li>应用程序传递来的信息以及从通信对象接收到的信息都会保存在这里，还有收发</li></ul></li></ul></li><li><p>TCP 规格中定义的控制信息：</p><p><img src="/image/%E7%BD%91%E7%BB%9C%E6%98%AF%E6%80%8E%E6%A0%B7%E8%BF%9E%E6%8E%A5%E7%9A%84/420c71519d8b407c23c7de0f90b9918735ba60f0.jpeg"></p></li><li><p>步骤（三次握手）：此过程忽略应用程序调用 Socket 库的步骤，12 可以看做第一次握手，4567 看做第二次，891011 看做第三次</p><ol><li><p>在协议栈 TCP 模块处创建表示连接控制信息的头部：</p><ul><li>收发端口、SEQ 号、SYN 比特、窗口；（此时 ACK 号为 0）</li></ul></li><li><p>TCP 模块会将信息传递给 IP 模块并委托它进行发送：关于 IP 模块和 IP 协议的细节请看下一部分</p><hr></li><li><p>网络包通过网络到达服务器，服务器上的 IP 模块会将接收到的数据传递给 TCP 模块</p></li><li><p>服务器的 TCP 模块根据 TCP 头部中的信息找到端口号对应的套接字</p></li><li><p>服务器找到对应的套接字之后，套接字中会写入相应的信息，并将状态改为正在连接</p></li><li><p>服务器的 TCP 模块返回接收响应：</p><ul><li>收发端口、SEQ 号、ACK 号、SYN 比特、ACK 比特、窗口</li><li>如果某些原因不想接受链接，则设置 RST 比特</li></ul></li><li><p>TCP 模块会将信息传递给 IP 模块并委托它进行发送</p><hr></li><li><p>网络包通过网络返回到客户端，然后通过 IP 模块到达 TCP 模块，TCP 模块通过 TCP 头部的信息查找对应套接字并确认连接服务器的操作是否成功（过程类似 3、4、5）</p><ul><li>如果 SYN 为 1 则表示连接成功，这时会向套接字中写入服务器的 IP 地址、端口号等信息，同时还会将状态改为连接完毕</li></ul></li><li><p>客户端的 TCP 模块返回接收响应：</p><ul><li>收发端口、SEQ 号、ACK 号、ACK 比特、窗口</li></ul></li><li><p>TCP 模块会将信息传递给 IP 模块并委托它进行发送</p></li><li><p>服务器接收到响应（过程类似 3、4、5）</p></li></ol></li><li><p><a href="https://www.zhihu.com/question/24853633">为什么是三次握手而不是两次？四次？</a></p></li></ul><h3 id="2-4-收发数据阶段"><a href="#2-4-收发数据阶段" class="headerlink" title="2.4 收发数据阶段"></a>2.4 收发数据阶段</h3><h4 id="2-4-1-发送数据的前提"><a href="#2-4-1-发送数据的前提" class="headerlink" title="2.4.1 发送数据的前提"></a>2.4.1 发送数据的前提</h4><ul><li><p>协议栈发送数据的几个要点：</p><ul><li><p>首先，协议栈并不关心应用程序传来的数据是什么内容。应用程序在调用 write 时会指定发送数据的长度，在协议栈看来，要发送的数据就是一定长度的二进制字节序列而已</p></li><li><p>其次，协议栈并不是一收到数据就马上发送出去，而是会将数据存放在内部的发送缓冲区中，并等待应用程序的下一段数据</p></li></ul></li><li><p>协议栈积累多少数据量才进行数据发送？不同种类和版本的操作系统会有所不同，主要根据以下要素判断：</p><ul><li><p>第一个判断要素是每个网络包能容纳的数据长度，协议栈会根据一个叫作 MTU 的参数来进行判断</p></li><li><p>另一个判断要素是时间</p></li></ul><p>两个要素相互矛盾，由协议栈的开发者决定如何平衡；</p><p>协议栈也给应用程序保留了控制发送时机的余地，可以指定一些发送的设置选项</p></li><li><p>MTU 和 MSS：</p><ul><li><p>MTU 表示一个网络包的最大长度，在以太网中一般是 1500 字节</p></li><li><p>MSS 表示一个网络包的最大数据长度，MTU 是包含头部的总长度，因此需要从 MTU 减去头部的长度，得到一长度叫作 MSS，TCP 和 IP 头部加起来一般是 40 字节，所以 MSS 一般是 1460 字节</p></li></ul></li></ul><h4 id="2-4-2-确认响应"><a href="#2-4-2-确认响应" class="headerlink" title="2.4.2 确认响应"></a>2.4.2 确认响应</h4><ul><li><p>TCP 采用“SEQ 号”和“ACK 号”的方式确认对方是否收到了数据，在得到对方确认之前，发送过的包都会保存在发送缓冲区中。如果对方没有返回某些包对应的 ACK 号，那么就重新发送这些包</p></li><li><p>接收方返回 ACK 号的操作被称为确认响应，通过这样的方式，发送方就能够确认对方到底收到了多少数据；通过确认响应这一机制，我们可以确认接收方有没有收到某个包，如果没有收到则重新发送，这样一来，无论网络中发生任何错误，我们都可以发现并采取补救措施（重传网络包）</p></li></ul><h4 id="2-4-3-超时时间"><a href="#2-4-3-超时时间" class="headerlink" title="2.4.3 超时时间"></a>2.4.3 超时时间</h4><ul><li>TCP 采用了动态调整超时时间（也就是返回 ACK 号的等待时间）的方法，这个等待时间是根据 ACK 号返回所需的时间来判断的；超时时间不能太长也不能太短，太长导致延迟增加，太短导致网络更加阻塞</li></ul><h4 id="2-4-4-滑动窗口"><a href="#2-4-4-滑动窗口" class="headerlink" title="2.4.4 滑动窗口"></a>2.4.4 滑动窗口</h4><ul><li><p>TCP 在发送一个包之后，不等待 ACK 号返回，而是直接发送后续的一系列包，将等待 ACK 号的这段时间就被有效利用起来了；</p><p>但如果不等返回 ACK 号就连续发送包，就有可能会出现发送包的频率超过接收方处理能力的情况，针对这种情况，TCP 采用滑动窗口方式来管理数据发送和 ACK 号的操作</p></li><li><p>接收方需要告诉发送方自己最多能接收多少数据，然后发送方根据这个值对数据发送操作进行控制，这就是滑动窗口方式的基本思路</p></li><li><p>滑动窗口大小：接收方能够接收的最大数据量称为窗口大小，是 TCP 调优参数中非常有名的一个；窗口大小一般和缓冲区大小一致</p></li><li><p>更新窗口大小（接收方通知发送方自己窗口大小）的时机：</p><ul><li><p>当收到的数据刚刚开始填入缓冲区时，其实没必要每次都向发送方更新窗口大小，因为只要发送方在每次发送数据时减掉已发送的数据长度就可以自行计算出当前窗口的剩余长度</p></li><li><p>更新窗口大小的时机应该是接收方从缓冲区中取出数据传递给应用程序的时候；这个操作是接收方应用程序发出请求时才会进行的，而发送方不知道什么时候会进行这样的操作，因此当接收方将数据传递给应用程序，导致接收缓冲区剩余容量增加时，就需要告知发送方，这就是更新窗口大小的时机</p></li></ul></li></ul><h4 id="2-4-5-ACK-与滑动窗口的结合"><a href="#2-4-5-ACK-与滑动窗口的结合" class="headerlink" title="2.4.5 ACK 与滑动窗口的结合"></a>2.4.5 ACK 与滑动窗口的结合</h4><ul><li><p>单独发送 ACK 号和更新窗口的情况：</p><p>接收方从缓冲区中取出数据传递给应用程序的时候，应该向发送方更新窗口大小；<br>理论上，收到数据后，应该马上向发送方返回 ACK 号；<br>计算机操作很快，可以理解为收到数据后接收方基本同时需要分别发送 ACK 号和窗口更新这两个单独的包，这样就会导致网络中的包数量增多，网络效率下降</p></li><li><p>合理等待合并的情况：</p><p>接收方在发送 ACK 号或窗口更新时，并不会马上把包发送出去，而是会等待一段时间，在这个过程中很有可能会出现其他的通知操作（ACK 或者更新窗口），这样就可以把两种通知合并在一个包里面发送了；最后可能会有以下几种情况：</p><ul><li><p>ACK 号合并更新窗口</p></li><li><p>多个 ACK 号合并</p></li><li><p>多个更新窗口</p></li><li><p>ACK 号</p></li><li><p>更新窗口</p></li></ul><hr></li><li><p>步骤：此过程忽略应用程序调用 Socket 库的过程；客户端和服务器之间收发数据流程是一样的，为了便于理解，用发送方和接收方表示</p><ol><li><p>发送方 TCP 模块将来自应用程序的数据按照合理长度分割，添加 TCP 头部，构建成合理的 TCP 包</p></li><li><p>TCP 模块将信息传递给 IP 模块并且委托它进行发送：关于 IP 模块和 IP 协议的细节请看下一部分</p><hr></li><li><p>网络包通过网络到达接收方，接收方上的 IP 模块会将接收到的数据传递给 TCP 模块</p></li><li><p>接收方 TCP 模块将数据返回给接收方应用程序</p></li><li><p>接收方 TCP 模块构建 ACK 号&#x2F;更新窗口网络包，通过 IP 模块，发送回给发送方，确认接收到了数据&#x2F;更新窗口大小</p><hr></li><li><p>逆向流程，接收方变成了发送方，发送方变接收方，返回响应数据给原本的发送方</p></li></ol></li><li><p>收发数据的几个细节：</p><ul><li><p>协议栈会检查收到的数据块和 TCP 头部的内容，判断是否有数据丢失，如果没有问题则返回 ACK 号</p></li><li><p>协议栈将数据块暂存到接收缓冲区中，并将数据块按顺序连接起来还原出原始的数据，最后将数据交给应用程序；具体来说，协议栈会将接收到的数据复制到应用程序指定的内存地址中，然后将控制流程交回应用程序</p></li><li><p>将数据交给应用程序之后，协议栈还需要找到合适的时机向发送方发送窗口更新</p></li></ul></li></ul><h3 id="2-5-断开阶段"><a href="#2-5-断开阶段" class="headerlink" title="2.5 断开阶段"></a>2.5 断开阶段</h3><ul><li><p>收发数据结束的时间点应该是应用程序判断所有数据都已经发送完毕的时候，这时，数据发送完毕的一方会发起断开过程，但不同的应用程序会选择不同的断开时机</p></li><li><p>步骤（四次挥手）：完成数据发送的一方会发起断开过程，这里我们以服务器一方发起断开过程为例来进行讲解</p><ol><li><p>服务器应用程序会调用 close 来结束数据收发操作</p></li><li><p>服务器协议栈生成包含断开信息的 TCP 头部：</p><ul><li>收发端口、SEQ 号、FIN 比特、窗口</li></ul></li><li><p>TCP 模块将信息传递给 IP 模块并且委托它进行发送：关于 IP 模块和 IP 协议的细节请看下一部分</p></li><li><p>服务器的套接字记录断开操作的相关信息</p></li><li><p>当收到服务器发来的 FIN 为 1 的 TCP 头部时，客户端的协议栈会将自己的套接字标记为进入断开操作状态</p></li><li><p>为了告知服务器已收到 FIN 为 1 的包，客户端会向服务器返回一个 ACK 号</p></li><li><p>客户端应用程序读取数据的时候，协议栈告知应用程序数据收发完全</p></li><li><p>客户端应用程序会调用 close 来结束数据收发操作</p></li><li><p>客户端协议栈生成包含断开信息的 TCP 头部</p><ul><li>收发端口、SEQ 号、FIN 比特、窗口</li></ul></li><li><p>TCP 模块将信息传递给 IP 模块并且委托它进行发送：关于 IP 模块和 IP 协议的细节请看下一部分</p></li><li><p>服务器返回 ACK 号，客户端和服务器的通信正式结束</p></li></ol></li><li><p>四次挥手还是三次挥手？</p><p>从理论上来说，步骤 7 会发送一个 ACK 号，而步骤 9 会发送一个 FIN 比特，但是在实际情况中，这两个网络包有可能合并，合为一个包（ACK 号&#x2F;FIN 比特），形成了三次挥手；</p><p>利用 WireShark 进行抓包分析，这种情况似乎出现在客户端读取数据完成后，就调用 close 关闭套接字的情况，也就是步骤 7 和步骤 8 之间的时间间隔很短，两个网络包合并起来了</p></li><li><p>注意，FIN 比特是由于调用 close 而产生的</p></li><li><p>和服务器的通信结束之后，套接字不会立即被删除，而是会等待一段时间之后才会被删除；至于具体等待多长时间，这和包重传的操作方式有关</p></li></ul><h3 id="2-6-IP-与以太网的包收发操作"><a href="#2-6-IP-与以太网的包收发操作" class="headerlink" title="2.6 IP 与以太网的包收发操作"></a>2.6 IP 与以太网的包收发操作</h3><h4 id="2-6-1-IP-和以太网的关系"><a href="#2-6-1-IP-和以太网的关系" class="headerlink" title="2.6.1 IP 和以太网的关系"></a>2.6.1 IP 和以太网的关系</h4><ul><li><p>在网络中有路由器和集线器两种不同的转发设备</p><ul><li><p>路由器根据目标地址判断下一个路由器的位置，是按照 IP 规则传输包的设备（IP 协议根据目标地址判断下一个 IP 转发设备的位置）</p></li><li><p>集线器在子网中将网络包传递到下一个路由，是按照以太网规则传输包的设备（子网中的以太网协议负责将包传输到下一个转发设备）</p></li></ul></li><li><p>TCP&#x2F;IP 包包含以下两个头部：</p><ul><li><p>IP 头部（用于 IP 协议）</p></li><li><p>MAC 头部（用于以太网协议）</p></li></ul></li><li><p>在 IP 和以太网的分工中，以太网的部分也可以替换成其他的东西，例如无线局域网、ADSL、FTTH 等，它们都可以替代以太网的角色帮助 IP 协议来传输网络包。因此，将 IP 和负责传输的网络分开，可以更好地根据需要使用各种通信技术。像互联网这样庞大复杂的网络，在架构上需要保证灵活性，这就是设计这种分工方式的原因</p></li><li><p>凡是局域网所使用的头部都见做 MAC 头部，但是其内容根据局域网的类型而有所不同；</p><p>对于除局域网之外的其他通信技术，还有不同名称的各种头部，名称不一样，但是承担的作用相同</p></li></ul><h4 id="2-6-2-IP-包收发预览"><a href="#2-6-2-IP-包收发预览" class="headerlink" title="2.6.2 IP 包收发预览"></a>2.6.2 IP 包收发预览</h4><ul><li><p>尽管我们说 IP 模块负责将包发给对方，但实际上将包从发送方传输到接收方的工作是由集线器、路由器等网络设备来完成的，因此 IP 模块仅仅是整个包传输过程的入口而已</p></li><li><p>步骤：</p><ol><li><p>包收发操作的起点是 TCP 模块委托 IP 模块发送包的操作：</p><ul><li><p>这个委托的过程就是 TCP 模块在数据块的前面加上 TCP 头部，然后整个传递给 IP 模块，这部分就是网络包的内容</p></li><li><p>同时，TCP 模块还需要指定通信对象的 IP 地址，也就是需要写清楚“将什么内容发给谁”</p></li></ul></li><li><p>收到委托后，IP 模块会将包的内容当作一整块数据，在前面加上包含控制信息的头部：</p><ul><li>IP 模块会添加 IP 头部和 MAC 头部这两种头部：关于头部细节请查看下一部分</li></ul></li><li><p>接下来，封装好的包会被交给网络硬件进行发送：</p><ul><li><p>网络硬件可能是插在计算机主板上的板卡，也可能是笔记本电脑上的 PCMCIA 卡，或者是计算机主板上集成的芯片，不同形态的硬件名字也不一样，本书将它们统称为网卡</p></li><li><p>传递给网卡的网络包是由一连串 0 和 1 组成的数字信息，网卡会将这些数字信息转换为电信号或光信号，并通过网线（或光纤）发送出去，然后这些信号就会到达集线器、路由器等转发设备，再由转发设备一步一步地送达接收方</p></li></ul></li><li><p>以相反操作进行接收</p></li></ol></li><li><p>无论要收发的包是控制包还是数据包，IP 对各种类型的包的收发操作都是相同的</p></li></ul><h4 id="2-6-3-IP-头部"><a href="#2-6-3-IP-头部" class="headerlink" title="2.6.3 IP 头部"></a>2.6.3 IP 头部</h4><ul><li><p>IP 头部内容：</p><p><img src="/image/%E7%BD%91%E7%BB%9C%E6%98%AF%E6%80%8E%E6%A0%B7%E8%BF%9E%E6%8E%A5%E7%9A%84/9978119f4242eaa99e0e10068047f82a9a6b862a.jpeg" alt="epub_907755_177.jpeg"></p></li><li><p>IP 头部中最重要的内容就是 IP 地址，它表示这个包从哪里来到哪里去；</p><p>这个地址是由 TCP 模块告知的，而 TCP 又是在执行连接操作时从应用程序那里获得这个地址的，因此这个地址的最初来源就是应用程序（应用程序调用域名解析器解析域名获得 IP 地址）</p></li><li><p>当计算机上存在多张网卡的时候，每一个网卡都会有自己的 IP 地址，当一台计算机有多个 IP 地址，在填写 IP 头部发送方 IP 地址时就需要判断到底应该填写哪个地址；</p><p>这个判断相当于在多块网卡中判断应该使用哪一块网卡来发送这个包，也就相当于判断应该把包发往哪个路由器，因此只要确定了目标路由器，也就确定了应该使用哪块网卡，也就确定了发送方的 IP 地址</p></li><li><p>如何判断应该把包交给哪块网卡？</p><p>因为协议栈的 IP 模块与路由器中负责包收发的部分都是根据 IP 协议规则来进行包收发操作的，所以它们也都用相同的方法 – 路由表 – 来判断把包发送给谁；关于路由表的详细细节请查看下一部分</p></li><li><p>IP 头部中的协议号，表示包的内容来自哪个模块：</p><ul><li><p>TCP 模块委托的内容，则设置为 06（十六进制）</p></li><li><p>UDP 模块委托的内容，则设置为 17（十六进制）</p></li></ul></li></ul><h4 id="2-6-4-MAC-头部"><a href="#2-6-4-MAC-头部" class="headerlink" title="2.6.4 MAC 头部"></a>2.6.4 MAC 头部</h4><ul><li><p>MAC 头部内容：</p><p><img src="/image/%E7%BD%91%E7%BB%9C%E6%98%AF%E6%80%8E%E6%A0%B7%E8%BF%9E%E6%8E%A5%E7%9A%84/840b76ea1cb6d0ab05d37d74f962eb8fbd64ea4e.jpeg" alt="epub_907755_187.jpeg"></p></li><li><p>发送方 MAC 地址：是网卡本身的 MAC 地址，MAC 地址是在网卡生产时写入 ROM 里的，只要将这个值读取出来写入 MAC 头部就可以了</p></li><li><p>TCP&#x2F;IP 包添加 IP 头部和 MAC 头部是由 IP 模块负责的，MAC 头部是以太网需要的内容，并不属于 IP 的职责范围，但从现实来看，让 IP 负责整个打包工作是有利的：</p><ul><li><p>如果在交给网卡之前，IP 模块能够完成整个打包工作，那么网卡只要将打好的包发送出去就可以了</p></li><li><p>对于除 IP 以外的其他类型的包也是一样，如果在交给网卡之前完成打包，那么对于网卡来说，发送的操作和发送 IP 包是完全相同的，这样一来，同一块网卡就可以支持各种类型的包</p></li><li><p>如果接收的包可以原封不动直接交给 IP 模块来处理，网卡就只要负责接收就可以了</p></li></ul></li></ul><h4 id="2-6-5-ARP"><a href="#2-6-5-ARP" class="headerlink" title="2.6.5 ARP"></a>2.6.5 ARP</h4><ul><li><p>ARP 是一个独立的三层协议，所以 ARP 报文在向数据链路层传输时不需要经过 IP 协议的封装，而是直接生成自己的报文，其中包括 ARP 报头，到数据链路层后再由对应的数据链路层协议（如以太网协议）进行封装</p></li><li><p>通过 ARP 缓存可以减少 ARP 查询的数量，但是为了减少缓存差异的发生，ARP 缓存中的值在经过一段时间后会被删除，一般这个时间在几分钟左右</p></li></ul><h4 id="2-6-6-以太网基础知识"><a href="#2-6-6-以太网基础知识" class="headerlink" title="2.6.6 以太网基础知识"></a>2.6.6 以太网基础知识</h4><ul><li><p>以太网是一种为多台计算机能够彼此自由和廉价地相互通信而设计的通信技术，这种网络的本质其实就是一根网线</p></li><li><p>以太网任何一台设备发送的信号所有设备都能接收到，需要在信号的开头加上接收者的信息，也就是地址。这样一来就能够判断信号的接收者了，与接收者地址匹配的设备就接收这个包，其他的设备则丢弃这个包</p></li><li><p>现在的以太网结构，随着交换式集线器的普及，信号发送给所有设备这一性质变了，现在信号只会流到根据 MAC 地址指定的设备，而不会到达其他设备了</p></li><li><p>尽管以太网经历了数次变迁，但其基本的 3 个性质至今仍未改变，可以认为具备这 3 个性质的网络就是以太网：</p><ul><li><p>用包发送到 MAC 头部的接收方 MAC 地址代表的目的地</p></li><li><p>用发送方 MAC 地址识别发送方</p></li><li><p>用以太类型识别包的内容</p></li></ul></li><li><p>无线局域网具有前两个性质，虽然没有以太类型，但是有另外一个具备同样功能的参数，可以认为它是以太网的“一种”，但是为了方便区分，一般不会讲无线局域网视为以太网</p></li><li><p>根据以太网的规格，两台设备之间的网线不能超过 100 米（这是双绞线的情况，如果采用光纤这可以更长，而且错误率不会上升）</p></li></ul><h4 id="2-6-7-以太网包收发操作"><a href="#2-6-7-以太网包收发操作" class="headerlink" title="2.6.7 以太网包收发操作"></a>2.6.7 以太网包收发操作</h4><ul><li><p>IP 生成的网络包只是存放在内存中的一串数字信息，需要将数字信息转换为电或光信号，才能在网线上传输，这才是真正的数据发送过程</p></li><li><p>负责真正数据收发操作的是网卡，但网卡也无法单独工作，要控制网卡还需要网卡驱动程序</p></li><li><p>网卡是工作在第二层链路层的网络组件，是局域网中连接计算机和传输介质的接口，不仅能实现与局域网传输介质之间的物理连接和电信号匹配，还涉及帧的发送与接收、帧的封装与拆封、介质访问控制、数据的编码与解码以及数据缓存的功能等</p></li><li><p>网卡的内部结构：这是一张网卡主要构成要素的概念图，并不代表硬件的实际结构</p><p><img src="/image/%E7%BD%91%E7%BB%9C%E6%98%AF%E6%80%8E%E6%A0%B7%E8%BF%9E%E6%8E%A5%E7%9A%84/9edb7e674df5e4d50083ed052d24441369dfd02d.jpeg" alt="epub_907755_208.jpeg"></p></li><li><p>打开计算机启动操作系统的时候，网卡驱动程序会对硬件进行初始化操作，然后硬件才进入可以使用的状态</p><p>这些操作包括硬件错误检查、初始设置等步骤，这些步骤对于很多其他硬件也是共通的，但也有一些操作是以太网特有的，那就是在控制以太网收发操作的 MAC 模块中设置 MAC 地址</p></li><li><p><strong>核对修改</strong>网卡中的 MAC 模块不包含添加 MAC 头部的功能，这个功能由 IP 模块完成，这种层次的设计可以使得网卡专注收发操作，对于上层所传递来的不同类型的包，都可以做到直接传递</p></li><li><p>网卡的 ROM 中保存着全世界唯一的 MAC 地址，这是在生产网卡时写入的，将这个值读出之后就可以对 MAC 模块进行设置。也有一些特殊的方法，比如从命令或者配置文件中读取 MAC 地址并分配给 MAC 模块（需要网卡驱动支持）</p></li></ul><h4 id="2-6-8-网卡收发网络包"><a href="#2-6-8-网卡收发网络包" class="headerlink" title="2.6.8 网卡收发网络包"></a>2.6.8 网卡收发网络包</h4><ul><li><p>步骤：</p><ol><li><p>网卡驱动从 IP 模块获取包之后，会将其复制到网卡内的缓冲区中，然后向 MAC 模块发送发送包的命令</p></li><li><p>MAC 模块会将包从缓冲区中取出，并在开头加上报头和起始帧分界符（SFD），在末尾加上用于检测错误的帧校验序列</p></li></ol></li><li><p>MAC 头部很容易被误解为是由网卡来处理的，实际上它是由 TCP&#x2F;IP 软件也就是协议栈来负责的</p></li><li><p>网卡发送出去的帧的内容：制定以太网标准的组织 IEEE 出于历史原因使用了“帧”而不是“包”，因此在以太网术语中都是说“帧”</p><p><img src="/image/%E7%BD%91%E7%BB%9C%E6%98%AF%E6%80%8E%E6%A0%B7%E8%BF%9E%E6%8E%A5%E7%9A%84/88522683833a9eb4beb77ec3a7b62ea89a493f3d.jpeg" alt="epub_907755_212.jpeg"></p></li><li><p>报头、起始帧和 FCS：报头用来测定时机，SFD 用来确定帧的起始位置</p><ul><li><p>报头是一串像 10101010…这样 1 和 0 交替出现的比特序列，长度为 56 比特，它的作用是确定包的读取时机</p></li><li><p>SFD 的末尾比特排列有少许变化。接收方以这一变化作为标记，从这里开始提取网络包数据。也就是说，起始帧分界符是一个用来表示包起始位置的标记</p></li><li><p>末尾的 FCS（帧校验序列）用来检查包传输过程中因噪声导致的波形紊乱、数据错误，它是一串 32 比特的序列，是通过一个公式对包中从头到尾的所有内容进行计算而得出来的</p></li></ul><p><img src="/image/%E7%BD%91%E7%BB%9C%E6%98%AF%E6%80%8E%E6%A0%B7%E8%BF%9E%E6%8E%A5%E7%9A%84/e80fbe4834fbff9afc4f5f9d9444d5c7af5252d5.jpeg" alt="epub_907755_213.jpeg"></p></li><li><p>如何通过电信号读取数据：</p><p><img src="/image/%E7%BD%91%E7%BB%9C%E6%98%AF%E6%80%8E%E6%A0%B7%E8%BF%9E%E6%8E%A5%E7%9A%84/88f344f0f3316927c7891f4fb1d2cf6b59cda66e.jpeg" alt="epub_907755_214.jpeg"></p><p>-（a）中的电压信号变化就可以表示数据信号，但是由于实际的信号并不像图中那样有辅助线，因此在测量电压和电流时必须先判断出每个比特的界限在哪里</p><ul><li><p>当信号连续为 1 或连续为 0 时，比特之间的界限就会消失，如果将时钟信号叠加进去，就可以判断出比特之间的界限了</p></li><li><p>要解决界限判断问题，最简单的方法就是在数据信号之外再发送一组用来区分比特间隔的时钟信号，例如同时发送（a）和（b）两组信号，当时钟信号从下往上变化时读取电压和电流的值，然后和 0 或 1 进行对应就可以了；</p><p>但是这种方法存在问题。当距离较远，网线较长时，两条线路的长度会发生差异，数据信号和时钟信号的传输会产生时间差，时钟就会发生偏移</p></li><li><p>要解决时钟偏移问题，可以采用将数据信号和时钟信号叠加在一起的方法，例如（a）叠加（b）生成 c；</p><p>由于（b）是具有周期变化的，通过观察（c）的波形变化，就可以找出这个周期，然后就可以提取出来时钟信号（b），进而计算出数据信号（a），然后，只要根据时钟信号（b）的变化周期，我们就可以从数据信号（a）中读取相应的电压和电流值，并将其还原为 0 或 1 的比特了;</p><p>由于还需要先对（c）信号进行一段时间的观察，因此，我们不能一开始就发送包的数据，而是要在前面加上一段用来测量时钟信号的特殊信号，这就是报头的作用</p></li></ul></li></ul><h4 id="2-6-9-集线器发送网络包"><a href="#2-6-9-集线器发送网络包" class="headerlink" title="2.6.9 集线器发送网络包"></a>2.6.9 集线器发送网络包</h4><ul><li><p>发送信号的操作分为两种，一种是使用集线器的半双工模式，另一种是使用交换机的全双工模式；发送和接收同时并行的方式叫做“全双工”，相对的，某一时刻只能进行其中一种操作的叫做“半双工”</p></li><li><p>在半双工模式中，为了避免信号碰撞，首先要判断网线中是否存在其他设备发送的信；如果有，则需要等待该信号传输完毕，当之前的信号传输完毕，或者本来就没有信号在传输的情况下，才可以开始发送信号</p></li><li><p>发送网络包步骤：</p><ol><li><p>MAC 模块读取缓冲区内容</p></li><li><p>MAC 模块从报头开始将数字信息按每个比特转换成电信号，由 PHY，或者叫 MAU 的信号收发模块发送出去：</p><ul><li><p>将数字信息转换为电信号的速率就是网络的传输速率，例如每秒将 10 Mbit 的数字信息转换为电信号发送出去，则速率就是 10 Mbit&#x2F;s</p></li><li><p>以太网规格中对不同的网线类型和速率以及其对应的信号格式进行了规定，但 MAC 模块并不关心这些区别，而是将可转换为任意格式的通用信号发送给 PHY（MAU）模块，然后 PHY（MAU）模块再将其转换为可在网线上传输的格式</p></li></ul></li><li><p>PHY（MAU）模块会将信号转换为可在网线上传输的格式，并通过网线发送出去</p><ul><li><p>MAU（Medium Attchment Unit，介质链接单元）</p></li><li><p>PHY（Physical Layer Device，物理层装置），在速率为 100Mbit&#x2F;s 以上的以太网中都叫 PHY</p></li><li><p>可以认为 PHY（MAU）模块的功能就是对 MAC 模块产生的信号进行格式转换</p></li></ul></li></ol></li><li><p>PHY（MAU）的职责并不是仅仅是将 MAC 模块传递过来的信号通过网线发送出去，它还需要监控接收线路中有没有信号进来</p><ul><li><p>在开始发送信号之前，需要先确认没有其他信号进来，这时才能开始发送</p></li><li><p>如果在信号开始发送到结束发送的这段时间内一直没有其他信号进来，发送操作就成功完成了</p></li></ul></li><li><p>在使用集线器的半双工模式中，如果发送的时候，接收线路有信号进来，两组信号就会相互叠加，无法区分彼此，这就是所谓的信号碰撞；</p><p>这种情况下，继续发送信号是没有意义的，因此发送操作会终止；为了通知其他设备当前线路已发生碰撞，还会发送一段时间的阻塞信号（一种特殊的信号），然后所有的发送操作会全部停止；</p></li><li><p>发送信号碰撞等待一段时间后，等待一段时间之后，网络中的设备会尝试重新发送信号；设备的等待时间是根据 MAC 地址生成一个随机数计算出来的，理论上互不相同；</p><p>当网络拥塞时，发生碰撞的可能性就会提高，重试发送的时候可能又会和另外一台设备的发送操作冲突，这时会将等待时间延长一倍，然后再次重试。以此类推，每次发生碰撞就将等待时间延长一倍，最多重试 10 次，如果还是不行就报告通信错误。</p></li></ul><h4 id="2-6-10-接收返回包"><a href="#2-6-10-接收返回包" class="headerlink" title="2.6.10 接收返回包"></a>2.6.10 接收返回包</h4><ul><li><p>在使用集线器的半双工模式以太网中，一台设备发送的信号会到达连接在集线器上的所有设备，这意味着无论是不是发给自己的信号都会通过接收线路传进来</p></li><li><p>接收步骤：</p><ol><li><p>首先，PHY（MAU）模块会将信号转换成通用格式并发送给 MAC 模块</p></li><li><p>MAC 模块再从头开始将信号转换为数字信息</p><ul><li><p>到达信号的末尾时，还需要检查 FCS，具体来说，就是将从包开头到结尾的所有比特套用到公式中计算出 FCS，然后和包末尾的 FCS 进行对比，正常情况下两者应该是一致的，如果中途受到噪声干扰而导致波形发生紊乱，则两者的值会产生差异，这时这个包就会被当作错误包而被丢弃</p></li><li><p>如果 FCS 校验没有问题，接下来就要看一下 MAC 头部中接收方 MAC 地址与网卡在初始化时分配给自己的 MAC 地址是否一致，以判断这个包是不是发给自己的，不是自己的包就直接丢弃</p></li></ul></li><li><p>如果接收方 MAC 地址和自己 MAC 地址一致，则将包放入缓冲区，MAC 模块的工作完成</p></li><li><p>网卡通过中断机制通知计算机收到了一个包</p></li><li><p>网卡驱动被中断处理程序调用后，会从网卡的缓冲区中取出收到的包，并通过 MAC 头部中的以太类型字段判断协议的类型，然后传递给对应协议栈</p></li></ol></li></ul><h4 id="2-6-11-ICMP-和分片重组"><a href="#2-6-11-ICMP-和分片重组" class="headerlink" title="2.6.11 ICMP 和分片重组"></a>2.6.11 ICMP 和分片重组</h4><ul><li><p>响应包从 IP 到 TCP 步骤：</p><ol><li><p>网卡驱动将网络包将其交给 TCP&#x2F;IP 协议栈来进行处理</p></li><li><p>IP 模块先开始工作了，第一步是检查 IP 头部，确认格式是否正确；如果格式没有问题，下一步就是查看接收方 IP 地址；</p><p>当接收方 IP 地址不是自己的时候，一定是发生了什么错误。客户端计算机不负责对包进行转发，因此不应该收到不是发给自己的包。当发生这样的错误时，IP 模块会通过 ICMP 消息将错误告知发送方</p></li><li><p>IP 模块检查确认无误就可以接收这个包，如果接收到的包是经过分片的，IP 模块会将他们还原成原始的包</p></li><li><p>分片重组后，包交给 TCP 模块，根据对应信息查找相应套接字，找到对应的套接字之后，就可以根据套接字中记录的通信状态，执行相应的操作了</p></li></ol></li><li><p>ICMP 协议与 ARP 协议不同，ICMP 靠 IP 协议来完成任务，所以 ICMP 报文中要封装 IP 头部；换言之，ICMP 带有 IP 头部，ARP 不带有 IP 头部</p></li><li><p>ICMP 的头部和数据位于 IP 头部之后，ICMP 报文的头部长度取决于 ICMP 报文的类型且变化范围很大</p></li><li><p>主要的 ICMP 消息：</p><p><img src="/image/%E7%BD%91%E7%BB%9C%E6%98%AF%E6%80%8E%E6%A0%B7%E8%BF%9E%E6%8E%A5%E7%9A%84/14ac09520bc44af991f3f79427b15d430697d8dd.jpeg" alt="epub_907755_232.jpeg"></p></li><li><p>IP 协议有一个叫作分片的功能（关于分片的细节请查看下一部分内容），简单来说，网线和局域网中只能传输小包，因此需要将大的包切分成多个小包，如果接收到的包是经过分片的，那么 IP 模块会将它们还原成原始的包</p></li><li><p>分片的包会在 IP 头部的标志字段中进行标记，当收到分片的包时，IP 模块会将其暂存在内部的内存空间中，然后等待 IP 头部中具有相同 ID 的包全部到达，这是因为同一个包的所有分片都具有相同的 ID</p><p>此外，IP 头部还有一个分片偏移量（fragment offset）字段，它表示当前分片在整个包中所处的位置。根据这些信息，在所有分片全部收到之后，就可以将它们还原成原始的包，这个操作叫作分片重组</p></li><li><p>ICMP 可能会导致分片的出现，以太网中， MTU 设置为 1500。所以 ICMP 负载长度最大值为 MTU（1500 字节）减去 IP 首部长度（20 字节）减去 ICMP 首部长度（8 字节），为 1472 字节，当 ICMP 负载长度超过 1472 字节，ICMP 报文会被分片</p></li></ul><h3 id="2-7-UDP-协议收发"><a href="#2-7-UDP-协议收发" class="headerlink" title="2.7 UDP 协议收发"></a>2.7 UDP 协议收发</h3><ul><li><p>UDP 适用的场景：</p><ul><li><p>需要传输的数据较短，如 DNS 查询</p></li><li><p>对高速传输和实时性有较高，如音视频等多媒体通信</p></li><li><p>限定于 LAN 等特定网络中的应用通信</p></li><li><p>广播通信</p></li></ul></li><li><p>UDP 头部中的控制信息：</p><p><img src="/image/%E7%BD%91%E7%BB%9C%E6%98%AF%E6%80%8E%E6%A0%B7%E8%BF%9E%E6%8E%A5%E7%9A%84/67b0bd95ffd71d26be10c3a1ad94ba446af44cbf.jpeg" alt="epub_907755_235.jpeg"></p></li><li><p>UDP 可发送的数据最大长度为 IP 包的最大长度减去 IP 头部和 UDP 头部的长度。不过，这个长度与 MTU、MSS 不是一个层面上的概念。MTU 和 MSS 是基于以太网和通信线路上网络包的最大长度来计算的，而 IP 包的最大长度是由 IP 头部中的“全长”字段决定的。“全长”字段的长度为 16 比特，因此从 IP 协议规范来看，IP 包的最大长度为 65 535 字节，再减去 IP 头部和 UDP 头部的长度，就是 UDP 协议所能发送的数据最大长度。如果不考虑可选字段的话，一般来说 IP 头部为 20 字节，UDP 头部为 8 字节，因此 UDP 的最大数据长度为 65 507 字节。当然，这么长的数据已经超过了以太网和通信线路的最大传输长度，因此需要让 IP 模块使用分片功能拆分之后再传输</p></li><li><p>UDP 没有 TCP 的接收确认、窗口等机制，因此在收发数据之前也不需要交换控制信息，也就是说不需要建立和断开连接的步骤，只要在从应用程序获取的数据前面加上 UDP 头部，然后交给 IP 进行发送就可以了</p><p>接收也很简单，只要根据 IP 头部中的接收方和发送方 IP 地址，以及 UDP 头部中的接收方和发送方端口号，找到相应的套接字并将数据交给相应的应用程序就可以了</p></li><li><p>UDP 只负责单纯地发送包而已，并不像 TCP 一样会对包的送达状态进行监控，所以协议栈也不知道有没有发生错误；出错时收不到来自对方的回复，应用程序会注意到这个问题，并重新发送一遍数据。这样的操作本身并不复杂，也并不会增加应用程序的负担</p></li></ul>]]></content>
    
    
    <categories>
      
      <category>笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>基础体系</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【随笔】走在22岁的道路上</title>
    <link href="/posts/e91f99b0.html"/>
    <url>/posts/e91f99b0.html</url>
    
    <content type="html"><![CDATA[<div class="note note-info">            <p><strong>苦昼短【李贺】</strong><br>飞光飞光，劝尔一杯酒。<br>吾不识青天高，黄地厚。<br>唯见月寒日暖，来煎人寿。<br>食熊则肥，食蛙则瘦。<br>神君何在？太一安有？<br>天东有若木，下置衔烛龙。<br>吾将斩龙足，嚼龙肉，使之朝不得回，夜不得伏。<br>自然老者不死，少者不哭。<br>何为服黄金、吞白玉？<br>谁似任公子，云中骑碧驴？<br>刘彻茂陵多滞骨，嬴政梓棺费鲍鱼。</p>          </div><p>前些天度过了自己人生中的第 22 个生日，从心理到生理来说，我都属于是一个成年人类了。今年发生了各种各样的事情，2021 年对于我个人来说，是不同寻常承上启下的一年，连带着今年的生日，都显得不太一样了。先写着吧，和大家聊聊我最近的样子，以及未来的规划，以及杂七杂八的各种东西。</p><p>因为是想到哪就写到哪，所以可能不会有什么逻辑，又因为我不是什么人类高质量男性，所以本文也没有什么参考价值，更受限于本人的知识水平，甚至可能会出现各种纰漏错误……大家不要紧张，这不是发 sci，你们也不是审稿人，just for fun，开心就好！</p><p>开始前可以点开下面这首歌。《样样红》是由黄安作词作曲并演唱的一首歌曲，发行于 1994 年 05 月 01 日。据说这首歌曲和林志颖有点关系。林志颖 17 岁出道，随即红遍大江南北，引起了一波又一波追星狂潮，是早期娱乐造星的一个成功典范。黄安 27 岁出道，拼搏多年 30 岁才开始有点成绩，黄安自己在书里说，自己出道的时候，林志颖已经红了 10 年了多少有点眼红，有感于此，所以专门写了这首《样样红》。”青春少年是样样红 可是太匆匆”</p><iframe frameborder="no" border="0" marginwidth="0" marginheight="0" width=330 height=86 src="//music.163.com/outchain/player?type=2&id=95385&auto=1&height=66"></iframe><h2 id="关于年龄"><a href="#关于年龄" class="headerlink" title="关于年龄"></a>关于年龄</h2><p>若是这一生我能够活够 100 周岁，那么我还有 70 多年年，共计 2.8 万多天可供使用。我在这个世界上已经生活了 8 千多天，人生中的 22% 已经永远地过去了。</p><p>我曾多次暗自思揣，几十年之后，我又会是一个怎么样的人呢？那个时候我有一番事业了吗？年轻时候那些不切实际的梦想幻想实现了多少个？想起来还有一点伤感，虽说还有很长很长一段时间投入到我的生命之中，但是相对于时代、历史这种时间洪流来说，我们依旧显得渺小。</p><p>100 年前中国共产党建立，到今天这朵浪花带来的影响还在不断扩大。从人的角度来说，若是有一个人刚好历经这个阶段，一定会感叹世界变得真快。但是从历史观的角度来说，这短短一百年，不过是中华史世界史中的一个小段落。</p><p>好朋友常常说，“年纪轻轻怎么老是想这些不搭边际的东西“，建议先好好脚踏实地地关注一下眼前的生活。我一想也对，我这不是在杞人忧天吗，想了也无用，不如先继续做自己的事情比较好。</p><p>大部分时候我想到我的年龄的时候，我还是比较开心的。因为此时此刻我正处在人的一生中的黄金时代。虽然没有确切考据，但是大部分人人生成就的基础是在这一阶段打下的，也在这一个阶段收获了知心好友、甜蜜情侣，这一阶段是身体、智力、思维的活跃期。一切都有可能，未来还有无限的选择。所以我常常说，年轻人 (指我自己) 多学点都去玩下其他东西总是好的，没有坏处。</p><img src="/image/走在 22 岁的道路上/birthday1.jpg" title="" alt="" width="256"><img src="/image/走在 22 岁的道路上/birthday2.jpg" title="" alt="" width="256"><h2 id="关于身份"><a href="#关于身份" class="headerlink" title="关于身份"></a>关于身份</h2><p>今年和明年是过渡阶段，在这一段时间内我还是学生，而在下一段时间里，我就变成一个社会人了。前不久去深圳实习了一段时间，大约三个月，短暂体验了当一个工作人的生活。体验不赖，以往对真实的工作生活颇多揣测，听别人说听别人过，但终究雾里看花看不清楚。这三个月的经历，虽然不能让我完全了解清楚，但也是有了初步认识。</p><p>我从五六岁开始就上学，九年义务教育，三年高中学习，四年大学生涯，加起来快十多年了。不能说我是一个”最好”的学生，但是可以说我是一个“好”的学生。我很清楚怎么成为一个”好“的学生，怎么让爸妈放心，怎么得到老师的赞赏，怎么和同学打好关系，怎么考出好成绩。实际上在我学生生涯中，我根本没有探究过怎么做一个好学生这个命题，仿佛一切都是自然而然地发生的。</p><p>“学生”这个身份给予了我数不胜数的好处，我学到了知识，我强壮了体魄，我收获了朋友，我从小乡镇来到了大城市，我从说话磕磕巴巴到口若悬河……有那么一瞬间，真的想一直做一名学生啊，和同学朋友在校园无忧无虑地生活，不用思考外面的变化，每日搞好学习就可以了。</p><p>虽然说我挺喜欢学生这一个身份的，但是没有人一直会是实际意义上的“学生”。大家最后都还是会成为一个社会人的。我一直对踏入社会抱有极大的兴趣，初高中写的作文中，“踏入社会中应该怎样怎样”应该是我写的最多的句式，这不过是我脑海中对社会的幻想的投影而已。</p><p>在短暂踏入社会 (也就是实习) 这一段时间内，我发现我之前的想象推演都是很漂浮的，价值不大。社会和学校太不同了，一切行为准则都有了一个新的标准，举个最简单的例子，在校园中和同学之间的交流常常不需要太过于有“隔阂感”，但是你在公司工作的时候，最好还是需要有一点边际感，不然很容易给自己和别人带来麻烦。不过我还是很幸运的，实习的公司和同事都是非常 nice 的，在生活上在工作上都给了我十分多的帮助和指导，给我的个人经历留下了浓墨重彩的一笔。</p><p>但是要是让我深入剖析社会人身份和学生身份，那我就无话可说了。主要原因是我现在只是很简单简单地“了解”了一下社会生活，很多甚至都是靠猜的，受限于时间、职位、工作，真没有啥高见——如果说“早睡早起”这种也算的上是高见的话，那我还能胡扯一堆出来。学生身份我倒是可以说我有一套自己的思考，别的我就真的不敢置喙了。一叶障目、盲人摸象、雾里看花</p><h2 id="关于代码"><a href="#关于代码" class="headerlink" title="关于代码"></a>关于代码</h2><p>我一直都挺感激当初的自己选择了软件工程这一个专业。很难说我是喜欢软件工程，还是喜欢软件工程给我带来的好处，但是我确确实实在编写程序设计系统的时候，能够感受到逻辑思维迭代带来的单纯的快乐。不出意料的话，接下来很长一段时间，我和软件工程和代码深深绑定在一起了，在上面寻找生活的资本，在上面构建自己的能力，在上面书写自己的人生。</p><p>总感觉软件工程是完完全全由人类将逻辑思维具象化而形成的学科或者说是工具。完完全全是一个思维上的游戏，就像象棋一样。或许有一个平行世界里面就有象棋工程师这个工作？哈哈哈。</p><p>我实习的时候做的是后端开发，但是秋招拿到的 offer 是客户端开发，最近在摸索前端和底层软件设计。在这里稍微放一句大话，工作方向应该限制不了我的个人发挥，我还是会继续做继续学自己喜欢的东西的。希望这个 flag 不要倒。</p><p>要问我最喜欢的开发方向是什么，我一时之间也难以排出个一二三四，不过有一点可以确定的是，我对各个方向都很有兴趣。我喜欢的太多了，以至于这学一点那学一点没啥深入的，最后只能在大二稍微深入研究一下后台开发。希望接下来的时间里，在保持自己对软件工程单纯喜爱的前提下，能够深入研究一下几个方向，要是能够达到能够端起饭碗吃饭的水平就更好了。</p><p>为什么不读研？好问题。相对于单纯的科研研究，我相对来说，还是比较中意针对业界真实环境进行研发，传说中的“工具人”就是我了。当然也不是绝对的排斥，我觉得在以后肯定有这么一天，我要研究的东西太过于突出，以至于业界都还没成熟的解决方案，不得不由我从头到尾探究。如果有这么一天，那就说明我被深深需要了，相信我也是痛并快乐着的。</p><h2 id="关于感情"><a href="#关于感情" class="headerlink" title="关于感情"></a>关于感情</h2><p>这里本身是写了一大段的，但是后来发现太矫情了，不对劲，也不符合我一贯的风格。所以删了。</p><p>简单来说，我在感情上处在“未开窍”和“开窍”这两个阶段的中间。希望在应对感情这一件事情上，我最终也能像应对其他大事那样，要么逐渐开窍然后遇上故事，要么在故事发生之前突然开窍。over!</p><h2 id="关于兴趣爱好"><a href="#关于兴趣爱好" class="headerlink" title="关于兴趣爱好"></a>关于兴趣爱好</h2><p>从小到大我都没什么比较特别的兴趣爱好，小时候还有个看电视的喜好，长大了连电影都懒得看了。我也没啥喜欢的体育活动，对于游戏也无接近想法，漫画动漫对于我来说也不是一个消遣的好去处。唯一一个比较突出的，估计就是喜欢和别人聊天了。</p><p>接下的日子很长，可能会有很多的挫折和风雨，我希望我自己能够培养起来一两个和代码无关的兴趣爱好，能够在伤心的时候，自己给自己疗伤。你有什么好建议吗？我准备学学音乐，学学健身，学学做菜，去旅旅游，去唱唱歌……世界这么多种活动，总会能找到一种适合我的兴趣爱好的：）</p><h2 id="关于追求"><a href="#关于追求" class="headerlink" title="关于追求"></a>关于追求</h2><p>对于未来说不准的事情，我一向不喜欢提前说出来，毕竟说出来容易被打脸。但是趁着生日，当成一个生日愿望说出来也无妨，只说说我在工作上面的追求。</p><p><del>最简单的，那就是希望自己有一天可以设计开发以及领导一款优秀的系统 or 软件，相信这也是所有软件工程人的追求。</del></p><p><del>稍微有点难度的，那就是希望这款系统能够让用户感觉到喜爱，感觉到好用，有自己的不可替代性，知名且 nice。</del></p><p><del>再接着，可能就是希望自己能够在某一软件领域成为领军人物了。</del></p><p>（大半年后重读这段，发现写的不好，又回来修改一下）</p><p>我的追求可以分为三个部分，这几个部分在我进入大学之前就有一种朦朦胧胧的影子，经过三四年的学习，也算是逐渐成型了。</p><p>第一部分，那就是设计开发一个良好的、易用的、优秀的、受人喜欢的“好”系统，例如尤雨溪所领导开发的Vue前端开发框架。</p><p>第二部分，则是能够做到软件工程中某一领域行业的领军人物，国内最知名的莫过于在即时通信领域登峰造极的张小龙了。</p><p>第三部分，那就是希望能够拓宽软件工程的边界，例如软件工程开山之祖图灵、冯诺依曼，例如比特币之父中本聪。</p><p>更遥远的，那就说不准也没意义，说了跟没说一样，干脆不说了，放心里就行，若是日后实现了再告诉你们。</p><p>在我浅薄的计算机历史知识中，乔布斯是第三点的佼佼者，杰夫·贝索斯毫无疑问能在第二点上刻下自己大名，Linus Torvalds以对linux社区的开发贡献完成了第一第二点，开启轰轰烈烈自由化运动的Richard. M. Stallman轻松把第二第三点收入囊中……</p><p>这三个追求，说实话，找阿拉丁神灯过来都不一定能搞定。这三个追求无一不需要天赋、能力、平台、运势，非寻常人可以为之！做到第一点，往往意味着深耕技术领域登峰造极，做到第二点，那就是需要更多技术之外的能力了，领导能力、统筹能力、交流能力……，第三点，那就要有更大要求了，不用我说也知道，做到这一点的人，计算机导论教科书历史进程那一章节上说不定都有你大名。</p><p>难难难，无论哪一个都是那么的难，目之所及，皆是荆棘。可以这么说，在我有限的工作生涯中，做到一个就算大赚特赚，做到两个那就是上天保佑。</p><p>梦想还是要有的。加油，加油！</p><hr><p>乱写乱想，想到哪写到哪。如果你能看到这里，可能你觉得我还是挺有趣的一个人，不管怎么样，谢谢你！记得来找我，我会给你颁发一个”优秀阅读者“证的：）</p>]]></content>
    
    
    <categories>
      
      <category>随笔</category>
      
    </categories>
    
    
    <tags>
      
      <tag>生活</tag>
      
      <tag>三观</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【随笔】电子洁癖，赛博时代的控制欲</title>
    <link href="/posts/37a6729d.html"/>
    <url>/posts/37a6729d.html</url>
    
    <content type="html"><![CDATA[<div class="note note-info">            <p>文章写完，再读一遍有点怪怪的感觉，似乎有点词不达意，又有点胡言乱语……<br>不管了，随笔随笔，想到哪就写到哪，日后有机会，再来细细斟酌吧</p>          </div><p>若以使用时间估算，我与 Ubuntu 相伴已有一年多了，并且在可以看见的未来之内，我的个人电脑上常驻系统应该都会是 Ubuntu，朝夕相处，形影不离。倒不是因为 Windows 不好，在个人娱乐和相关软件生态圈，Ubuntu 及 Linux 其他发行版仍然需要继续追赶，在相当一段时间内，还不一定可以追的上。那么，是什么在阻止我切换 Windows 为我主要系统呢，是爱吗？当然不是，主要是因为 Ubuntu 和其他 Linux 衍生版可以提供这么一种“错觉”，提供给我这个有一点点“电子洁癖”的赛博冲浪选手一种美妙的我可以掌控所有文件的“错觉”。</p><p>“电子洁癖”是我自己造出来的词，它并不是指你真的有生理洁癖，会比绝大多数人对自身和环境的清洁度有严苛的要求，异常爱干净和整洁。“电子洁癖”是针对虚拟世界生活状态挑剔的一种描述。举几个例子，你可以看看自己是不是有电子洁癖，不允许任何不知根知底的应用安装在自己电子设备上；一遍遍检查存储空间目录，看见未知文件夹出现会想方设法搞清楚它是哪个文件夹生成的；卸载某个软件就一定要做到斩尽杀绝，不允许它留下来任何东西，配置文件缓存文件也要手动删光光……“电子洁癖”和“电子设备洁癖”听起来很容易混淆，但是后者才是现实世界中的“洁癖”，例如对自己电子设备清洁异常频繁，不允许任何一滴油脂、一粒灰尘沾染自己手机平板和电脑。</p><p>“就这？就这就这就这？” 啊朋友，倒也不必这般生气，我也没有愚弄你啊，我确实就是这样想的。我会毫无理由地想要重装系统，理由是因为我装了一个我觉得本身可以不装的软件；我常常想卸载重装 nodejs，因为我用 npm 装了许多依赖，但是我忘了它们的具体作用；apt autoremove？每一次卸载 apt 软件后我都会运行它几遍，为什么要让已经不再存在的软件占用你的空间呢？对了，maven 的本地仓库我常常手动删除，毕竟有时候我觉得里面会有一些我会很少用到的依赖。</p><p>得益于 Linux 大多数发行版对 Filesystem Hierarchy Standard（FHS）标准的遵循，我在管理我的磁盘空间的时候明显舒服了很多。FHS 制订了 Linux 根目录及其子目录的功能用途，并且号召软件开发商、操作系统制作者、以及想要维护系统的使用者，都能够遵循 FHS 的标准。我知道 bin 目录下放置着可执行文件，我知道 etc&#x2F;config 是大多数软件全局配置文件的放置位置，我知道 opt 目录下是可以放我自己安装的第三方软件……整齐划一，就像一个井井有条的书架，你可以知道哪里放着什么书，你又该怎么按照你自己的想法去处理它。这给一个“电子洁癖”用户比如我，提供了极大的安全感 – 一切都在控制之中，嗯，都在控制之中。</p><p>Window 本身的设计哲学就并不是“all documents”，在系统里面总有一些非文件，或者说难以找到并处理的文件，比如注册表。Windows 下我有个必备软件 CCleaner，我删除各种软件尤其是国产软件后，必定会用 CCleaner 扫描清理注册表。不一定有用，起码心安。我在 Windows 最烦的一件事就是卸载软件后，全局搜索文件会发现，在某处某文件夹内，还存在这个软件的遗留物，也许是它自己保存下来的日志，又或者它留下来的配置。总之在删除这些软件的时候，不知道是它忘了还是故意的，他总会留下一些“xxxx 到此一游”。没错说的就是你，某奇艺、某雷和某安全卫士！在 Linux 下，这个问题一种奇怪方式被解决了，那就是这些软件没有 Linux 版本:)，或者说 Linux 版本还算比较安分，没有在文件系统里面“乱上厕所”。</p><p>说起来这个，我想起最近的一个新闻：字节跳动一名实习生删除了公司所有 lite 模型。有匿名网友在知乎上表示，“该实习生清理 HDFS 上的目录，发现一个目录最近更新时间是 3 月份，就以为这个目录不用了，多方求证之后得到了这个目录已经没用的结果，然后删掉了……” 哈哈，我猜这名老哥一定有一点电子洁癖。“我的电脑”应该完完全全是“我”的，不应该存在的文件夹就不应该存在。从这个角度来看，一名软件工程师有电子洁癖倒不是什么好事，万一某一天删除了一些或许还需要用到的文件呢？这不给自己找麻烦吗。</p><p>“电子洁癖”还有一个层面的理解，那就是严格控制自己的账号体系，记得住每一个注册的账号，如果以为自己注册了不应该注册的账号，会想方设法注销它；拒绝暴露自己的任何真实信息，若是发现无意泄露，心理防备等级直接拉满，尝试一切方法弥补……简述：网络空间中，我需要是透明的，无靶点的，信息可控！</p><p>很难，真的很难。虽然常常可以看到 ios 比安卓信息更安全、安卓隐私保护大升级、google 重金加强个人信息保护等等之类的信息，但是我却持有一种悲观的态度。只要进入网络空间，只要你和网络的另一端发生交互，那你就会出让一部分信息。在网络空间的信息保护话题中，我是一个悲观主义者。</p><p>从信息交互的角度来说，你请求一部分服务，无论是搜索今天的天气，还是看看最新的视频，又或者是看看最近热搜，你都需要发送出自己的信息，不然服务方怎么知道你需要什么服务，又如何返回服务给你呢？对吧。可是问题就在于这里，你发送出的自己的信息，总有一些可以关联到你的，就算你请求信息精简到无任何个人信息，那不还是有一个 ip 吗？的确有一些大神可以做到信息完全不“泄露”，加密通道、请求转发、ip 代理……只不过这些都离我们这些普通人太遥远了，听一下就好，真要我们做，且不说能不能做，去哪里学都还不知道呢。不过也不必太担心，网络空间好就好在它足够庞大，混淆信息足够多，真想要精确定位到一个普通人或者一群普通人，成本太高利润太低，隐形的手会让一些别有用心的人收手的。对于另外一些大财团、大资本拥有者，比如 google 这类巨头，由于它本身就拥有雄厚的资金和广量的辅助信息，定位一群普通人所带来的收益似乎比损失大，不巧的是，我们作为消费者目前的“对抗”能力还不够强大，仍需发展。</p><p>那么就真的没有一点办法了吗。我这里有两种思路：第一种是“空白”，也就是尽量不暴露自己信息，谨慎对待自己在网络空间的每一条讯号。在这种思路下，小号注册非核心的网站 APP 账号，社交媒体尽量“闭嘴”，无用账号及时注销，慎重对待需要填写自己身份信息的业务等等都是有效的操作，关键是突出一个“控制”。第二种思路是“稻草人”。在稻田里立起无数个稻草人，别人要找出真身的位置就困难了不少，成本暴增。不同社交媒体适当发言，但是维持不同的”人设”，A 网站我是海归博士，B 网站我是无业流民，C 网站我又是未满十八岁魔法少女……每一个都是我，每一个都不完全是我。获取我真实身份的边际收益过小，得不偿失。</p><p>说是这么说，但是做还是很难做到的。我现在在实践着第一种思路“空白”，手机小号、邮箱小号、十分钟邮箱、虚拟号码……可惜，理想与生活是无限接近，但不相交，也就是俗话说的“理想很丰满，现实很骨感”。就拿社交媒体少“发言”这一点来说，是人都有分享欲，你能控制自己完全不在豆瓣、小红书、朋友圈等等这些社交媒体上分享出来吗？如果想说但不能说，那好像网络空间加了一层枷锁，没有之前那么有意思了。对了，我搭建的这一个博客，从第一种思路出发，是不应该存在的，因为我暴露了自己的许多感悟、学习和心得。假如有个朋友顺藤摸瓜发现了这一个博客，那么可能 ta 会小声嘀咕，“没想到阿 t 这么闷骚啊哈哈哈哈” :(</p><p>电子洁癖，对内和对外，其实本质上就是文章标题所说的控制。控制自己的信息不要释放出去，控制外部的信息不要释放出来。建立一道赛博围墙吧，控制好围墙内的整洁，控制好信息的出入。网络空间链接一切，可惜我们还是需要一些“网络私人空间”。</p>]]></content>
    
    
    <categories>
      
      <category>随笔</category>
      
    </categories>
    
    
    <tags>
      
      <tag>生活</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【阅读】我的Linux“私房菜”</title>
    <link href="/posts/13cc5b5c.html"/>
    <url>/posts/13cc5b5c.html</url>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>《鸟哥的 Linux 私房菜》（以下简称《私房菜》），相信在座的诸位都有听说过这本书。《私房菜》分为基础篇和服务器篇，由浅入深，由简到易，全面而详细地介绍了 Linux 操作系统的使用及操作，豆瓣评分 9.1，赞誉不断。</p><p>我使用 Ubuntu 及其他 Linux 发行版本快一年了，走的是野路子使用方法，也就是靠着个人直觉直接使用，遇到问题再找谷歌，没有系统学过如何高效使用。</p><p>在以 Ubuntu 为主学习生活过程中，我遇到了很多问题和疑惑，靠着谷歌和 wiki，我基本解决了那些常见的问题。但是单纯的谷歌 + 复制粘贴越来越不能满足我了，在跨越“能用”这一个阶段后，我觉得我是时候踏入“高效易用”这一阶段了，我需要掌握进阶的使用方法，我需要深入了解 Linux 的操作。所以趁着最近这一段空闲时间，我找来了大名鼎鼎的《私房菜》，来品一品这道佳肴，系统学学 Linux 的操作。</p><p>《私房菜》的确是本好书，虽然有些小缺点，但是瑕不掩瑜，仍然值得诸位一读。（半）读完此书后，我结合自己一年多使用 Ubuntu 和 Centos 的体验，说说我自己对 Linux 和它的感受，希望能给想入坑的朋友一些意见。</p><h2 id="我读-–-作为整体而存在"><a href="#我读-–-作为整体而存在" class="headerlink" title="我读 – 作为整体而存在"></a>我读 – 作为整体而存在</h2><p>《私房菜》第一版著于 2000 年前后，那个时候 Ubuntu 还未发力，Centos 也才稍露头角，那个时候占据天下的还是各种大型机。2018 年，《私房菜》推出第四个版本，鸟哥的私人博客网站也经历过大大小小十几次改版。第四版《私房菜》选择 Centos 7 为演示系统，详细系统地讲述 Linux 日常使用开发的方方面面。此版本也正是我所阅读的版本。</p><p>如果问我对《私房菜》最大的阅读感受是什么，那就是此书作者竭力传达的精神：Linux 是作为一个整体来使用的，各模块部分严密结合，职责分明。从系统格式与分区，到文件目录安排，到文本编辑修改，再到账号权限管理……Linux 以命令行终端为脉络，串联起方方面面，形成一个足够“精致易用”的黑盒。</p><p>注意注意，我这里所说的整体，并不完全指作为系统的各种功能紧密链接，同时也是在指在设计思维方面的统一。诚然，对于现在的我来说，一个初入茅庐的 Linux 使用者来说，言及设计思维设计哲学是有点虚的。不过，Linux 使用很少工具就能达成一个功能，的确给我带来不少“震撼”。利用管道和 sed 或 awk 就能处理各种格式化输出，达到“随心所欲”的状态，的确有点爽。</p><p>之前用 Linux 的时候，虽然我自己是有一种隐隐约约的”整体感觉“，不过就是总结不出来。看完《私房菜》后，总算是在心中形成了一个较为完整的概念。为什么要分区？为什么要格式化？为什么要这样安排目录？为什么只安排三种权限？什么是 umask？怎么分组分账户？如何分配用户权限？……细究一下，你会发现这些问题都是相互关联起来的，一个扣一个。</p><p>《私房菜》一千多页，如果想要一遍看完并且完全记住，那就是有点难了。所以我目前是把它定位为”工具书“、”字典书“，有事没事多翻翻，说不定某一天就用上其中的功能。非常贴心的时，《私房菜》是按照”模块“来组织全书的，第一部分作为起始部分。是”LInux 的安装和规划“，第二部分教我们如何“管理文件目录磁盘“，第三部分着重”Shell“，第四第五部分关注”使用者管理“和”系统管理员“。在每个部分中，又按照”功能属性“分出不同章节，尽力将一个简单的操作流程（我愿意将其成为”业务组件“）深入到方方面面，又穿插平时能用到的技巧在各个章节，使人读完后大呼过瘾，心生”原来是这样，原来能够这样做，原来还可以这样做“感觉。</p><p>《私房菜》读起来是没什么压力的，就算是一个未曾接触过 Linux 的人，也可以慢慢读下去。说起来也惭愧，刚开始阅读的时候没做什么笔记，结果看到后面就忘了前面，时不时又得跑回前面翻来翻去。好记性不如烂笔头，对于《私房菜》这种知识密度比较大的书来说，尤其如此。</p><h2 id="我用-–-好玩又有趣"><a href="#我用-–-好玩又有趣" class="headerlink" title="我用 – 好玩又有趣"></a>我用 – 好玩又有趣</h2><p>去年疫情期间，阿里云举办了一个”在家学习“的活动，送了我一个一年多的服务器。服务器耶，那不得装个 Centos？——这应该就是我正式接触 Linux 的契机了。虽然之前上操作系统课程也用 Linux 来做过各种实验，不过那时只是简简单单用个 gcc 而已，算不得接触。</p><p>Linux 给我带来了许多新的体验，包管理器、vim、nginx、docker 等等，安装和配置各种环境变得简单起来了 (相对 windows 来说)。在 Centos 学习部署几个项目后，我脑子一动——不如直接双系统吧！于是我就给自己电脑装了个 Ubuntu，从此就”弃“windows 不用了。</p><p>对于我来说，我不打游戏，少看电影，也没有特别大的 PS、修图、剪辑需求，常用软件也就 firefox、IDEA、微信 QQ 以及其他开发工具。对于浏览器以及日常工具，这个 Ubuntu 本身就做的很好，挺好用。对于 IDEA，Jetbrains 早就有 Linux 得版本了。微信 QQ 有点难解决，不过在 wine 的帮助下轻松过关。像 postman、tomcat 这些开发工具，我怎么觉得 linux 支持要比 windows 要好？</p><p>我从 windows 迁移到 linux 非常顺畅，基本没有什么特别用不惯的地方，一些只在 windows 下提供的软件例如 office 三件套也能很轻松找到各种替代用品，good。</p><p>Linux，具体是 Ubuntu，用起来给我最大的感受首先是电脑不卡了，对于一个只有 8g 内存的老古董轻薄本来说，这个优点就值得我再也不打开 windows 了。其次，我从第一天开始就发现了 Linux 的操作核心思维——终端，Linux 是围绕各种 cli 展开日常工作的，无论是复制粘贴、安装卸载软件、打开关闭应用，入口基本都是你的终端。不像 windows，windows 的入口是对强迫症极其不友好的桌面。一个很有意思的对比，我每次进入 Ubuntu 桌面，就先打开一两个 terminal，换成 windows，我则会先关掉那些不知道为什么老是自启动的应用，然后再整理下桌面图标。</p><p>我很喜欢 Linux“高自由度”这一特点，刚开始用的时候，我总想改一下各种默认配置文件，安装各种组件，看看有什么特殊情况发现。自定义主题，自定义桌面，自定义 gdm，甚至自定义开机引导，很有趣。在 windows 下也许也可以做到，但总归没有像 Linux 这样有趣。当然“高自由度”对于高手来说是锦上添花，对我这种入门者来说，有一点点“放纵”，当你知道修改的手段却不知道修复的手段时，你的探索就变成破坏了。去年我一共重装系统 13 次，不是因为 Linux 本身的问题，是我胡乱操作结果导致它启动不了或使用不了，防呆不防傻，堡垒都是从内部攻破的。</p><p>Linux 很好玩，它不像一个完全的黑盒，它若隐若现，你似乎可以看到里面的设计和纹路。它的吸引力如此巨大，以至于对于开发者来说，每个人都想要深入去了解。</p><h2 id="我想-–-有点意思"><a href="#我想-–-有点意思" class="headerlink" title="我想 – 有点意思"></a>我想 – 有点意思</h2><p>《私房菜》作者是鸟哥，台湾成功大学的教授。作为一本入门书，《私房菜》写的很口语化，这可”害惨“了我，鸟哥或许没有发觉在书本中，几乎每一处都会用上各种语气词，比如”耶“、”好啊“、”喔“、”咯“……我是没想到我能在一本书中，”看“到台湾腔，哈哈。不过也还好，除了初期看起来有点别扭，后面看习惯了还有点小可爱。</p><p>鸟哥的行文比较琐碎，我随便截取一段文字给你们看看（第十三章第 5 节）：</p><p>”运行上面的脚本后，你的系统帐号就会被捉出来检查啦！这个动作还可以用在每个帐号的删除、重整上面呢！换个角度来看，如果我现在需要一连串的数字来进行回圈呢？举例来说，我想要利用 ping 这个可以判断网络状态的命令，来进行网络状态的实际侦测时，我想要侦测的网域是本机所在 192.168.1.1~192.168.1.100，由於有 100 台主机，总不会要我在 for 后面输入 1 到 100 吧？此时你可以这样做喔！“。有没有感受到，鸟哥有种碎碎念的感觉。不知道他人怎么样，我还是觉得这种语气和行文风格挺啰嗦的，但是这是我自己的因素，不是这本书的错误。从我的角度出发，要是这些段落可以缩减一下，那就再美妙不过了。</p><p>要说《私房菜》的不足，我想作为一本入门书，它是不是有点关注工具属性了？能不能在每个章节之中，加一些简简单单的 Unix&#x2F;Linux 设计思维讲述呢？比如在将管道的时候，如果顺带提一句”一切皆是管道“这个有趣设计哲学，同时解析一下为什么这么设计，估计读者除了能够放松一下心情，也能更加加深对 Linux 的讲解。期待鸟哥笔下的 Unix&#x2F;Linux 设计思维解读。</p><h2 id="后言"><a href="#后言" class="headerlink" title="后言"></a>后言</h2><p>最近这几年，国家在大力发展操作系统国有化，前有统信，后有深度，以及各种正在蓬勃发展的国内开源社区，相信 Linux 及开源这一种子会在中国里面茁壮成长。《私房菜》第一版至今已有二十多年，对于一个变幻莫测的 IT 世界，一本技术书能够屹立多年而不倒，并且传颂度越来越高，越来越多人去阅读，我想这其中固然要考虑到技术潮流的发展，也要清楚这本书是真的有真材实料的。</p><p>不知道有多少前辈牛人是靠《私房菜》入门 Linux 的，此刻读完《私房菜》，我也成为了其中一员。《私房菜》作为一本书，力量是微弱的，或许许多人读完之后，再过个几年，就完全忘记这本书了，但是作为一枚帮许多人打开 Linux 新世界大门的钥匙，它的确是有着十分大的影响的。</p><p>常读常新，常新常学。希望《私房菜》能够继续发展，给予诸多想要一窥 Linux 世界的初学者帮助。更祝愿 Linux 和开源蓬勃发展，带来更好的技术和世界。</p><p>加油</p>]]></content>
    
    
    <categories>
      
      <category>阅读</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Linux</tag>
      
      <tag>随笔</tag>
      
      <tag>感受</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【转载】lazyprogrammer</title>
    <link href="/posts/5fb0e2b7.html"/>
    <url>/posts/5fb0e2b7.html</url>
    
    <content type="html"><![CDATA[<div class="note note-success">            <p>转载自<a href="https://www.lazyprogrammer.it/">lazy programmer</a>，考虑到全文较短且简单，就不翻译了，原汁原味挺好。<br>lazy coder but great code!</p>          </div><p>A lazy programmer <span class="label label-warning">loves programming</span> but <span class="label label-warning">hates working</span>, so they work as little as possible.</p><p>A lazy programmer finds every possible way to <span class="label label-warning">avoid working</span> on the weekends.</p><p>A lazy programmer writes a lot of <span class="label label-warning">tests</span>, so QA people do not waste their time.</p><p>A lazy programmer <span class="label label-warning">documents</span> their code, so that coworkers do not waste their time.</p><p>A lazy programmer is a <span class="label label-warning">master</span> of delegation. After they delegated a task, they immediately forget about it.</p><p>A lazy programmer does not edit long files, they teach <span class="label label-warning">regular expressions</span> how to edit the file in their place.</p><p>A lazy programmer does <span class="label label-warning">not deploy in production</span>, they instruct Jenkins to do that. Therefore a lazy programmer is not afraid of deploying on Friday afternoon.</p><p>A lazy programmer goes to the office as little as possible, possibly when other non-lazy people are not around, so they don’t <span class="label label-warning">waste their time</span>.</p><p>A lazy programmer knows <span class="label label-warning">the best tools of their trade</span> so that they can reuse other people’s work as much as possible.</p><p>A lazy programmer is <span class="label label-warning">easygoing</span>, because arguing about silly things is, well, silly and tiring.</p><p>A lazy programmer is super <span class="label label-warning">efficient</span>, does in a few o %}f hours what would take many to others so that they can spend the rest of the day lingering on the couch feasting on Netflix.</p><p>A lazy programmer stares at the code for hours, trying to figure out the way to write <span class="label label-warning">as little code as possible</span>.</p><p>A lazy programmer makes use of <span class="label label-warning">existing tools and services</span>, so they can release earlier.</p><p>A lazy programmer uses the basic UI template the <span class="label label-warning">hosting service provides them</span> and then they say it’s <a href="https://brutalist-web.design/">brutalism</a>.</p><p>At <a href="https://saasform.dev/">Saasform</a> we are lazy and we support lazy programmers to deliver great code fast and with little effort.</p>]]></content>
    
    
    <categories>
      
      <category>转载</category>
      
    </categories>
    
    
    <tags>
      
      <tag>lazy</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【随笔】春招初试</title>
    <link href="/posts/990c352f.html"/>
    <url>/posts/990c352f.html</url>
    
    <content type="html"><![CDATA[<div class="note note-info">            <p>首先呢，这不是一篇面经。面经的后缀是“经”，怎么说也算的上是一个归纳提炼升华的过程总结，面经的前缀是“面”，自带工具属性，潜意识里就让我觉得是一份“讲义”。这篇文章最多只能算是发发牢骚，写写自己的春招过程，记录这一个有趣的人生阶段，一篇随笔。</p>          </div><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>金三银四里面的”三四“，指的是三四月份。三月随着春节的结束，转职的、找实习的、跳槽的大量涌入人才市场，是人才招聘的最高峰期，因此称为“金三”。伴随而来的四月，虽然部分企业集团收缩招聘岗位，同时因为部分人获得心意岗位而早早离场，因此人才招聘激烈程度稍微下降，获得“银四”之称。</p><p>简单自我介绍下，广 door 人，985，软件工程，java 后端开发。很明显我现在还不是应届生，所以这次春招找的是实习 offer，目标是暑假实习以及实习转正。</p><p>从春招结果来说，这次我的入场演练表现得不算好当然也不算差，我获得腾讯的实习 offer，同时字节和阿里都进入了二面，不过字节和阿里二面后流程就一直卡住不动了，也没标明是流程终止还是等待安排，怪事。哦对了，我目前还有华为以及网易的面试安排，出于时间和精力考虑，我大概率会推掉，专心学习和处理之前不巩固的知识，为入职做准备。</p><h2 id="准备"><a href="#准备" class="headerlink" title="准备"></a>准备</h2><p>说实话我应该是周围这么多同学中准备春招比较早的人了。去年 12 月左右，我就开始有意识地收集关于今年春招的资料，包括不限于一线 IT 企业公司的春招启动时间、我所在学院上一届的 2020 春秋招情况、内推渠道、还有最重要的——和已经入职的师兄师姐搭上线，俗称抱大腿。12 月同时也是考试月，因此上述准备都是比较浅显地进行，基本就是看到就记录，没有也无所谓。</p><p>1月开始放寒假，作为乖乖崽我当然是早早地回家陪家人了。其实我本来是想在学校待几个星期用来自由支配的，因为在家太舒服了，极大可能我根本学不进去，这可不是随便说的，大部分小伙伴应该都做不到在家每天看 50 页书，每周整理学习笔记，同时每周一篇博客吧。虽然但是，我还是没在学校待多久，因为广州零零星星有好几例新冠病情出现，其中一例距离我学校还很近，作为一名热爱生命极度惜命的好朋友，当然是立即提桶跑路，溜之大吉了。</p><p>回家的情况和意料情况差不多，每天七点多才醒，醒来之后吃早餐，玩一会后，扫地清洁搞家务，然后开始做午饭，然后小睡一会，等到下午，学一两个小时，然后就会不自觉地打开 B 站和知乎，接着六点多开始准备做晚饭，吃完晚饭后基本也就七点多八点了，会房间玩一会，再学一会，然后睡觉……你看看，这种情况，我学习效率能有多高嘛？</p><h2 id="半入场"><a href="#半入场" class="headerlink" title="半入场"></a>半入场</h2><p>2月中旬就是春节，有谁能够拒绝得了 15 天的吃喝玩乐呢。初计划直接停下准备计划，但是计划赶不上变化。2 月开始的时候，字节跳动举行了一个 ios 客户端开发学习活动，参加这个活动并且通过的话有机会获得字节的实习 offer。考虑到我之前有 ios 开发的简单基础，很好，我心动了。</p><p>字节的这个活动，时长为一个半月，办的有模有样，学生需要观看直播学习，由企业一线开发人员教授，鼓励大家做笔记进行交流学习等等。在活动举办期间，也穿插了不少诸如 HR 面对面，简历撰写技巧等等活动，可以看出字节下了不少本。</p><p>为什么说是半入场呢，因为参加这个活动后，我就正式开始编写简历和开始刷题了。说到简历，我从二月份到现在，一个撰写了两个预备版本，四个正式版本，以及无数个废稿版本。对于投递的不同岗位公司和部门，我会使用不同的简历版本，以求达到最符合、最亮眼的标准。虽然说这里面大部分最终也没用上，但是我觉得还是很有用的，至少我提炼信息和归纳的能力得到了极大提高（误）。</p><p>活动在二月末结束，通过天天打卡我获得了字节跳动 ios 客户端开发的笔试资格。然后我做了一件至今想来都十分无语的事情——我参加了笔试，但是一道题都不写。当时单纯的我是这样想的：“我一个做后端的就不掺和客户端了，看看就好”。<del>什么是大佬，这就是大佬</del>。现在让我再选择一次，我务必直接干下去，早拿 offer 早上岸，早得工作早心安。</p><h2 id="入场"><a href="#入场" class="headerlink" title="入场"></a>入场</h2><p>时间很快来到了 3 月，春天到了，又到了万物争妍斗艳的季节，很好，让我们将视线切换到我所在的软件学院，观察一下决定考研的那些小伙伴的动作行为。可以看到，三月上旬的软件学院对于春招有三类表现：直接下场，继续准备，懵懵懂懂。一般来说，大部分自觉已经准备比较充分或者比较莽的同学，直接下场，开始投递简历，进行内推，快速开始一波又一波的面试。</p><p>我呢？我介于第一种和第二种表现之间，下场了，但是没有完全下场。我选择继续准备，整理笔记和整理之前做过的项目，同时，我也去找师兄师姐要内推码，开始进行内推。</p><p>说起来，三月大家的压力都比较大，尤其是我，简直就是个行走的负能量桶。当你觉得自己技术水平不够准备不充分，但是不得不登台演出，心中就会产生焦虑。当你发现面试迟迟没有结果，过与不过始终没有一个确定的信息，焦虑开始膨胀。当你发现周围的同学朋友开始大肆收割实习 offer，羡慕之情又加剧焦虑的生长……我有一点点的完美主义，希望所有事情都掌握在自己手里，可惜在春招这个环境中，大部分的人包括我自己，都像是一条鱼缸里的鱼，是否被捞出，选择权不在自己这里。</p><p>在这里我要专门感谢一下我的舍友。我们宿舍晚上睡觉前经常会聊聊天，每当我释放我焦虑的时候，他们都会鼓励和安慰我。当然，其实我们讨论的最多的还是各种青春伤痛文学和沙雕段子，这个是极大的释放压力的方式。</p><h2 id="上岸"><a href="#上岸" class="headerlink" title="上岸"></a>上岸</h2><p>不能说是上岸，但我暂时没想到更好的词了。现在是四月中旬，我在前几天正式拿到了腾讯的 offer。当 offer 邮件发送过来的时候，心里好像还是有点恍惚感，“我真的过了吗？”。没办法，大家在得到渴望已久的东西时，心里泛起的感情除了开心高兴之外，应该就是不真实感，和平静，是的，平静。</p><p>这几天好好放松了自己，人像电脑，运行久了得清一下缓存，不然容易宕机。吐槽一下字节和阿里，流程一动不动快两周了，如果面试没过，干脆直接终止就行了，这样还能有时间进入下一个流程呢。</p><p>前天有一个美团的笔试，不得不说，人一放松就很难续上，笔试我脑子基本都转不起来了，一道题都没做出来，惨。如果没拿到 offer 之前，我一定会自己给自己开个批评大会和写个分析日记，现在考虑到个人心情及状态，也就算了，偷个懒，嘻嘻。</p><p>接下来就要忙入职的准备了，虽然我是准备暑假采取实习的，但是准备的越早越好，不是吗：）</p><h2 id="结言"><a href="#结言" class="headerlink" title="结言"></a>结言</h2><p>对于我来说，春招开始告一段落了。我的老师之前说有压力的时候，才能学习地更快。确实，在二月和三月，我感觉我学习的速度、理解的能力、以及软件工程素养都得到了极大的提高。我拿到了 offer，但是这证明不了什么，我觉得它很大来源于我的幸运。我很清楚，我的实力不是最好的，也不是最强的，我还欠缺很多，无论是技术上的，还是心态上的。继续前进，冲。</p><p>在春招期间，我写了很多篇日记，每一篇日记里面，都会有这么一个词——“加油”。“加油”，这两个字很简单，但是确实我对自己的勉励，压力很大，offer 不明，无论如何，继续加油就好，不要松懈。</p><p>加油！加油。</p>]]></content>
    
    
    <categories>
      
      <category>随笔</category>
      
    </categories>
    
    
    <tags>
      
      <tag>春招</tag>
      
      <tag>offer</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【转载】一个技术男的自白</title>
    <link href="/posts/7b64ec0a.html"/>
    <url>/posts/7b64ec0a.html</url>
    
    <content type="html"><![CDATA[<div class="note note-success">            <p>本文摘抄自林沛满<strong>《Wireshark 网络分析就这么简单》</strong>一书中最后一节。</p><p>此书出版于 2014 年 12 月，那个时候我还只是个初中生。书是老书，技术或者说解决问题的思路依旧很“新”，值得细细品读读，对于初入编程世界的你我来说，很有启发意义。</p><p>《一个技术男的自白》为此书最后一节，是林沛满作者对他编程道路一个小结。不同程序员有着不一样的人生道路，但是在“编程”这一个方面却是有不少的共通之处的。这一份自白写的很中肯，言辞也很朴素，字里行间铺满作者自己的感慨。希望这一篇转载的文章，能够让你有一些些简单的触动、感悟或者思索。</p>          </div><p>当我在台灯下写到这一篇时，不由得想到几个月后，另一束灯光下的读者正翻到这一页，跨越时空的交流真是奇妙。我要感谢你购买本书并坚持读到这里。作为小众图书的作者，我最珍视的是读者对本书内容的喜爱，也希望你在阅读中有所收获。最后一篇，就让我们忘记那些乏味的术语，谈些有趣一点的话题吧。</p><p>关于技术，当下的热点是 Full Stack Engineer，翻译过来就是全栈工程师。我的理解就是从前端到后端，从软件到硬件都懂的通才。其实在全栈的概念出现之前，关于技术广度和深度的讨论就从来没有停止过。在时间有限的情况下，究竟是应该扩展广度，各种技术都去涉猎，还是把所有精力都投入在一门技术上呢？我个人更倾向于后者，因为当某项技术学到了较深的程度后，眼界就不一样了，再学其他的技术也容易达到类似境界。以本书提到的协议为例，如果你已经精通 CIFS，那很可能稍加点拨就能完全理解 NFS；同样如果你理解了网络的分层和流控，再学习存储的层次和缓存也比较容易。但假如一个人连最擅长的技术都浅尝辄止，那学习其他技术也会停留在表面上。我有位技术出色的朋友用过一个生动的比喻来说明这个问题：技术深度和广度的关系，就像登山时的高度和视野。假如你爬到半山腰就停下来眺望，就只能看到一半的视野；但如果埋头爬到山顶，一抬头便是无边的风景。</p><p>关于薪水，是很多工程师自怨自艾的口水话题。不知道从何时开始，大家似乎都觉得自己被亏待了。微博上流传各种自嘲的段子，比如“今天你编程时流的汗，就是当初填志愿时脑子进的水”；我也曾经开玩笑说自己的英文名是“Low Payman”；我有位年薪 40 多万的同事，MSN 签名是“少壮不努力，老大干 IT”；还有一种流行的说法，认为在中国不适合走技术路线，否则为什么在国外才有白发苍苍的老工程师？看过太多类似段子之后，我觉得这种群体心态已经有点矫情了。无论在什么国家，工程师都排不上收入最高的群体。相比国外，中国工程师地位已经算高了，比如美国工程师的收入就完全比不上律师和医生等职业，但在中国就未必是这样。中国也不是没有老工程师的发展空间，而是因为第一批工程师还没有变老。热爱自嘲的人其实也心知肚明—他们的薪水完全足以维持体面的生活，比如那位“少壮不努力”的同学，一直在上海这个大染缸过着纸醉金迷的日子。而真正徒伤悲的职业，恐怕根本没有心情自我编排……我认为自嘲是一种难得的幽默，但是当一个群体的自嘲都专注在薪水上，听上去就有点无聊。</p><p>关于办公室政治，那真不是属于我们的战场。孟子的“劳心者治人，劳力者治于人”对中国影响太过深远，我不止一位朋友从技术路线改走管理路线的时候，以这句话作为座右铭。而在我看来，自从人类进化到可以坐在办公室里“劳力”之后，“劳心”就缺乏吸引力了。人类比电脑狡诈太多，还是管电脑省心。我们就把办公室政治这样劳心的活儿留给走管理路线的同事吧，只要不站队不说是非，用技术帮助所有人，自然会成为单位里最受尊敬的人。</p><p>关于创业，我想没有哪个行业比 IT 界更热衷于此了。或许是因为这一行有过太多轻易成功的故事，所以工程师们蠢蠢欲动，仿佛每个人都在想，连一个毫无技术含量的导航网站都能被高价收购，满腹才华的我能干出怎样惊天动地的事业？于是有志者开始对职业不满，觉得无论如何应该出去闯闯，寻找自己被封印的灵魂，他们振臂一挥，豪气万丈地说“走，创业去！”其实我个人是非常羡慕这样充满激情的人生的，无奈看过太多失败的例子，总觉得创业的成功率被高估。有位朋友到福建承包一片山林之后，很快发现这东西并没有想象中那么赚钱。终于在花光所有积蓄之后，萌发了“不如归去”的念头。虽然听上去颇有禅意，其实心里还是很懊悔的，最后不仅回到原来公司，还坐到原来的位子上。当然成功者也是有的，不要妒嫉他们，因为这是冒着风险得到的。</p><p>关于跳槽，除了印度之外，我还没有见过比中国工程师更爱跳槽的群体。由于每跳槽一次基本能加薪 30%，的确让人难以淡定地呆在一个岗位上。不过在我看来，频繁跳槽所付出的代价恐怕高于这点收益，因为很快就会发现无处可跳了。而且更大的副作用是，多次换工作导致了各种技术都只学到皮毛，等醒悟过来已经晚了。如果某个新职位吸引你的亮点只是加薪，我建议三思而行。</p><p>关于理科生的骄傲，在工程师群体中，有小部分年轻人至今还保持着源自高中理科班的自豪感。比如看到一本精彩的科幻小说，便觉得文科生不可能懂；如果新来的领导不是理工科出身，就感叹所处的并非技术驱动型公司；最让我吃惊的一次，是一位 DBA 质疑不懂技术的销售人员为什么地位那么高。这种错误的认知显然源于交际圈子的狭隘，对非技术人员的能力缺乏了解。其实你在调试代码时，他们同样在推敲文案；你在餐桌上只管品菜海侃，他们却要左右逢源，让所有宾客感到满意；你结交朋友只看心情喜好，他们在朋友圈里只说“正确”的话，永远如沐春风地倾听；你在内部会议上发言都显拘谨，他们面对突如其来的话筒也能侃侃而谈……毫无疑问，非技术工作的“技术含量”一点都不低。幸好随着阅历的增长，大多数理科生都能改掉这个毛病。</p><p>关于生活，IT 男们已经被打上了太多标签：宅、木讷、生活简单。这当然是一种偏见，至少我身边的朋友就不是这样。不过比起国外的工程师群体，我们的业余生活似乎是单调了些。比如与我合作多年的国外同事中，有组乐队的、当冰球教练的、玩帆船的、DIY 花园的……有些朋友对此羡慕不已，以为发达国家才玩得起多样化的娱乐，对此我不敢苟同。比如中国学习乐器的人数早就全球第一，在我屈指可数的女同事中，至少有三位在小时候考过钢琴十级。我所住的小区一楼都配有朝南的大院子，园艺条件极佳，只是户户都铺砖硬化了……所以细想起来，经济上并不是主因，只是不够热情罢了。工程师本来就是最擅长 DIY 的群体，只要行动起来，完全可以让业余生活更加丰富，成为一个更加有趣的人。</p>]]></content>
    
    
    <categories>
      
      <category>转载</category>
      
    </categories>
    
    
    <tags>
      
      <tag>感悟</tag>
      
      <tag>编程思索</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【项目】谈谈在线请假管理系统设计实现中的问题和解决方案</title>
    <link href="/posts/360a8974.html"/>
    <url>/posts/360a8974.html</url>
    
    <content type="html"><![CDATA[<h2 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h2><p>这个学期（大三上），我选修了一门“web 服务体系结构”通选课，由学院的徐杨老师授课。和其他的通选课有点不同，这门课程的考核方式不是期末考试 + 平时作业，而是实现系统 + 项目文档。</p><p>课程的考核要求听起来很简单：</p><ul><li><p>每四人为一个小组，组内每两人为一个小团队，开发两个 web 系统</p></li><li><p>web 系统技术上异构，后端所使用的开发语言、开发框架尽量不要相同。</p></li><li><p>两个 web 系统之间需要有信息交互，也就是数据的传输。</p></li><li><p>两个系统间的交互途径为<strong>SOAP 风格</strong>和<strong>Restful 风格</strong>的<strong>web service（web 服务）</strong>。</p></li><li><p>在系统的设计实现过程中需要编写相关的项目文档</p></li></ul><p>知易行难，听起来似乎上面的要求都可以很简单地实现。但是在选题、技术选型、文档编写等等环节中，我们小组都遇到了不少困难，走了不少弯路，所幸的是最终我们还是实现了这两个东西。</p><p><a href="https://github.com/tivnantu/studentls">点击此处跳转到项目 github 仓库</a></p><p>此篇文章便是为了记录这个有趣的项目经历。</p><h2 id="项目选题-–-从业务的角度去选择"><a href="#项目选题-–-从业务的角度去选择" class="headerlink" title="项目选题 – 从业务的角度去选择"></a>项目选题 – 从业务的角度去选择</h2><p>最开始我们的选题是做一个<strong>在线请假管理系统【教师端】【学生端】</strong>。原因也很简单</p><ul><li><p>其一，我所在的学校校区面积广大，整体呈长条形。比较惨的是，我们学生的宿舍楼在校区最北边，教师所在的办公楼以及学院楼在校区的最南边。一般情况下，如果一个学生要请假，那么他首先得去到校医院开得一张请假凭证，然后横跨校区走上 2 到 3 公里找到教务员签字确认，然后去提交给教师。这个过程效率太低了，如果可以转移到手机上进行操作，效率会提高很多。</p></li><li><p>其二，我曾经和团队内的以为成员参加过 2020 年的微信小程序应用开发大赛，而当时我们做作品就是在线请假系统。有之前的参赛经验，也算是有一个保底了。</p></li></ul><p>但是我们把这个项目选题提交给任课教师后，老师很明确的告诉我们不行。因为从<strong>技术的角度</strong>来说，我们这的确可以是两个系统（不是的开发框架，不同的部署环境），但是从<strong>业务的角度</strong>来说，我们这个本质上是一个系统。请假这一个行为，这一个业务，本身就是涉及到教师、学生这两个角色，是业务过程中的有机组成，强制分裂成两个技术上的异构系统，未免太过于多此一举了。</p><p>这的确是我们没有想到的问题。在之前，包括我自己，我们都陷入了一个这样的误区：用不同的技术实现的系统，就是两个不同的系统。我们想当然的认为，做一个负责审核的教师端，做一个负责请假的学生端，那么就是两个不同的系统了。班级里也有不少队伍犯了和我们同样的错误，比如有一个队伍就选择做一个电商系统【顾客端】【商家端】。</p><p>这是我们学到的第一个知识，对于<strong>系统</strong>这一概念来说，开发人员可以从技术层面解读他，不过对于大多数人，尤其是对于 boss，我们需要从业务的角度来解读。</p><p>最终，我们选择这样一个选题：</p><ul><li><p><strong>异构系统 A：在线请假管理系统【教师端 + 学生端】</strong></p></li><li><p><strong>异构系统 B：教务管理系统</strong></p></li></ul><h2 id="管理需求-–-用例文档的敲定"><a href="#管理需求-–-用例文档的敲定" class="headerlink" title="管理需求 – 用例文档的敲定"></a>管理需求 – 用例文档的敲定</h2><p>选题确定后，就要用文档来确定系统的需求了。本来还需要有一个调研的步骤，不过这只是一个大作业项目，所以就忽略了这一个步骤，直接进行下一步。</p><p>上个学期我们已经上完了项目管理课程，对于用例文档、需求文档、数据字典这些概念都有了一定的了解。只不过，当时学的囫囵吞枣，现在需要自己上手去做，难免有一种雾里看花的感受。</p><p>我们都知道，确定系统需求的时候，最重要的交付物是<strong>用例文档</strong>。在编写用例文档的时候，我们就遇到了一个问题：<strong>用例的粒度</strong>。</p><p>举个例子，在请假系统中，<strong>编辑请假单</strong>这一个用例是一个很小粒度的用例，我们是把他独立出来，作为一个单独的用例；还是把他并入<strong>新建请假单</strong>这个大粒度用例，作为一个操作步骤。</p><p>用例的粒度很难确定，粒度太小容易导致团队做很多无用功，粒度太大又容易导致后期编码的时候不断扯皮。同时，确定用例的时候，如果没有做到一个统一的大小，可以预见的是，最后没有人想要去阅读用例文档，完全是按照自己的想法去开发，出了问题就歇逼。</p><p>出于锻炼和学习的目的，我们最终决定用例粒度大小以<strong>编辑请假单</strong>为基准，尽量覆盖同层次的用例，大用例分解成小用例。虽然一开始我们觉得这样会导致用例文档巨长巨繁琐，后来发现其实还好，并不是特别多。</p><p>这是请假管理系统中的一个用例示例：</p><table><thead><tr><th>用例标识</th><th>UC03</th></tr></thead><tbody><tr><td><strong>优先级</strong></td><td>高</td></tr><tr><td><strong>用例名称</strong></td><td>编辑请假单信息</td></tr><tr><td><strong>版本</strong></td><td>v3.0</td></tr><tr><td><strong>创建人</strong></td><td>tivnantu</td></tr><tr><td><strong>创建日期</strong></td><td>2020.10.1</td></tr><tr><td><strong>用例描述</strong></td><td>请假学生编辑请假单的请假信息</td></tr><tr><td><strong>参与者</strong></td><td>请假学生</td></tr><tr><td><strong>触发事件</strong></td><td>请假学生开始填写操作请假单信息页面</td></tr><tr><td><strong>前置条件</strong></td><td>学生已经新建了一张新的请假单或者打开了一张上次保存下来的旧请假单</td></tr><tr><td><strong>基本流程</strong></td><td>1. 请假学生进入请假单信息页面  <br>2. 请假学生填写请假原因，选择请假日期  <br>3. 请假学生选择请假课程  <br>4. 请假学生选择请假类型  <br>5. 请假学生填写请假原因</td></tr><tr><td><strong>分支流程</strong></td><td>无</td></tr><tr><td><strong>异常流程</strong></td><td>1a.学生未登录在线请假管理系统，提示学生先登录后操作  <br>4a.学生基础个人信息补全失败，提示学生先补全基础个人信息</td></tr><tr><td><strong>后置条件</strong></td><td>请假学生编辑请假单信息成功，获得一张带请假信息的请假单</td></tr><tr><td><strong>依赖关系</strong></td><td>UC02. 新建请假单</td></tr><tr><td><strong>数据实体</strong></td><td>电子请假单</td></tr></tbody></table><h2 id="技术选型-–-哪个是又快又好？"><a href="#技术选型-–-哪个是又快又好？" class="headerlink" title="技术选型 – 哪个是又快又好？"></a>技术选型 – 哪个是又快又好？</h2><p>严格来说，技术选型本身不是一个问题。在小组中，我负责请假系统的后端开发，技术选型为<strong>java【ssm】+mysql+tomcat</strong>，经典 web 开发三件套。但是另一位队友 – 负责教务系统后端开发的队友，却变迁了好几次技术选型。</p><p>由于有异构的要求，所以教务系统的开发不能选择 java，因此一开始我们选择的是<strong>nodejs</strong>。我们看中了 nodejs 的简便快捷。而且在我们当时查询技术资料的时候，我们发现 nodejs 对 restful 风格有着比较好的支持。</p><p>但是在我们做好这次技术选型后，我们被另外一门课程的大作业给拖延住了，一直到了两周后才开始实际的代码编写工作。一开始编写，就出现了一点小问题 – 负责教务系统后端实现的同学，他之前没有接触过 nodejs，也就是说，他还需要一段额外的时间去学习 nodejs。这就很尴尬了，虽然 nodejs 的确很简便，但是学习路线也不是十分平滑的。而此时，距离课程验收还有两周。Time lapse!</p><p>在征求其他队友以及大佬意见后，我们决定采取一个更为稳妥的方式，使用<strong>python【flask】</strong> 开发教务系统的后端。和 nodejs 相比，python 更加简便易用，且学习路线比较平滑，可以快速上手。在不考虑序列化、并发、mvc、系统分层情况下，在两周内开发出一个简易版教务系统是很有可能。当然，最后的结局的确是成功完成了开发。</p><p>至于我这边，也是有不少问题的。一开始我想尝试一下<strong>spring boot</strong>。不过在我写了三天代码后，我查看 spring boot 文档资料后，发现一个有趣的难点。spring boot 对 web service 有着良好的支持，但是主要是针对<strong>restful 风格</strong>的 web service。对于传统的<strong>soap 风格</strong>的 web service，spring boot 也能用，却没有 ssm 那么好用，因为 ssm 直接集成了<strong>cxf webservice 开发框架</strong>。出于这个原因，我就切换回 ssm 了，下次有机会再试一下 spring boot 开发</p><p>更多的技术选型请查看项目的 github 仓库</p><h2 id="接口设计-–-约定好于编码"><a href="#接口设计-–-约定好于编码" class="headerlink" title="接口设计 – 约定好于编码"></a>接口设计 – 约定好于编码</h2><p>在线请假管理系统是一个前后端分离的项目，通过前后端接口传输数据。在这之前，我们小组都还没有接触过实际上前后端分离的项目的开发，于是我们就犯了一个大多数新手都会犯的错误：<strong>忽略接口设计</strong>。</p><p>上文说到，我们在技术选型后两周才开始实际编码，中间由于其他事情而耽搁了一定时间。但是在这一段时间，我们也不是完全停下手头上的工作。我让负责在线请假管理系统前端开发的同学给我一份接口设计文档。</p><p>我本来的想法是，由<strong>后端去适配前端</strong>，也就是按照前端的接口文档去开发后端。可以说，后面测试以及集成 80% 的问题都来自于我这个错误的想法。</p><p>由于接口并不是前端和后端一起约定的。在最终集成系统的时候，在系统中我们实际上是有四套不同格式&#x2F;命名的数据实体：</p><ul><li><p>mysql 数据库中的数据实体（也就是数据表）</p></li><li><p>后端中的数据实体</p></li><li><p>接口传输的数据实体</p></li><li><p>前端中的数据实体</p></li></ul><p>我来举一个例子：请假单这一个数据实体的 id，在数据库中，命名为<code>note_id</code>，类型是<code>char(20)</code>；在后端系统中，命名为<code>noteId</code>，类型是<code>int</code>；但是在接口设计中，后端传输给前端的<code>id</code>，类型是<code>string</code>。</p><p>由于没有提前约定好接口，编码的开始阶段，我一直在写各种转换类，写了七八个 vo。当时我就一直在想，要是一开始就约定好接口数据格式及命名，哪来的这么多屁事。</p><p>项目复盘的时候，我和其他人一致认为，在这种前后端分离的项目中，接口的设计以及约定是特别重要的。约定好了，不仅可以使数据从上到下畅通无阻，还可以对前后端开发产生指导作用。</p><p>oop 三大概念之一封装，其本身针对的是系统中的数据以及操作。接口设计开发和封装联系十分紧密，甚至还有一个类似 oop 的概念：<strong>面向接口开发</strong>。没有做好接口设计约定，实际上就是对封装的破坏。难免会给系统开发带来坏处。</p><h2 id="数据库设计-–-立足系统层面"><a href="#数据库设计-–-立足系统层面" class="headerlink" title="数据库设计 – 立足系统层面"></a>数据库设计 – 立足系统层面</h2><p><strong>数据库是为系统服务的</strong>。我一直都记得住这句话，这次的任务也让我对这句话产生更深层的理解。</p><p>一开始我所设计的数据库，以我现在的眼光（即使才过了不到一个月），都觉得十分地冗余。我在设计的时候，的确考虑到了<strong>BGNF 范式</strong>、<strong>多值属性</strong>这些条件和约束。但是只是单纯地从数据库设计的角度出发的。</p><p>有这样的操作不算奇怪，我在上数据库设计的课程时，只是一味地看书，看了书上的概念，学了 mysql 的操作，就以为差不多了，没有实际的上手操作。这可能就是作为学生的局限吧，很少有实际的、生活中的机会来实际操作学习。</p><p>我一开始设计的数据库中，包含了<code>course</code>这一个数据表，包含了上课时间、课程 id、课程名字等等属性。你可能觉得很正常，请假不是要关联课程吗，设计一个数据表再正常不过了。</p><p>错了，<code>course</code>实际上是一个冗余的表。我们从整个业务流程和数据流向来考虑一下。首先，请假的确需要关联课程没错，但是需要我们存储上课时间、课程名字等这些属性吗？课程明确要求了两个系统中要有数据交互，那么为什么不直接让上课时间、课程名字这些关联度不是特别高的信息，由教务系统通过 web service 提供呢？</p><p>给请假单添加一个多值属性，负责保存关联课程的 id。在需要呈现给用户相关课程信息时候，后端利用课程 id，通过 web 服务拉取数据，再返回给前端。这么一操作，请假系统的数据库就不需要单独存储一个课程的数据表了。</p><p>从业务角度来说，数据库设计的时候应该保持着这么两个准则“<strong>如无必要，勿增实体</strong>”，“<strong>一切都是为了系统</strong>”</p><h2 id="分支管理-–-用好-git"><a href="#分支管理-–-用好-git" class="headerlink" title="分支管理 – 用好 git"></a>分支管理 – 用好 git</h2><p>不可否认，git 是一个非常好的版本管理工具。我之前早有接触，现在则是基本每一个项目都用上了 git。git 好用，但是还得自己学会怎么去好好用。</p><p>我其实在接近完成后端代码过程中，重构过一次项目工程。<a href="https://github.com/tivnantu/studentls-old">未重构前的项目仓库点击这里</a>。我进行重构的原因，除了重新设计数据库外，还有一个就是之前的 git 分支管理太乱了。</p><p>原本的项目中一共有 7 个分支，除了常见的<code>master</code>、<code>dev</code>、<code>test</code>，还有一些我现在已经记不清作用的分支，例如<code>safe</code>、<code>section-dev</code>。当时我一言不合就想着开一个新分支，在上面写完功能代码后，我又不<code>merge</code>到主分支或者<code>dev</code>分支上。继续在上面写下一个功能代码。写着写着，又切换到另外一个分支，又写一段代码……到后面，每一次<code>merge</code>都是折磨，数不胜数的冲突，还得一个个去修改确认。</p><p>另外还有一个重构诱因就是，我的<code>commit</code>信息十分杂乱。本来觉得就那么几个<code>commit</code>，自己可以直接人肉记住信息，所以<code>commit</code>就直接乱写了，什么“修改了配置”，“实现了登录功能”。事实证明，记不住的，三天后你就记不住上一次你修改了什么，<code>commit</code>了什么。结果后面每一次回退或者查询，都不得不小心翼翼，是不是还得跑到源代码上去看。最近发现了一款规范 git 提交信息的工具，<strong>commitizen</strong>，倒是可以好好学一下怎么用。</p><p>git 的确很好用，功能强大，可以让我们很轻松地进行版本，不过要是使用者乱用的话，反而在项目开发过程中是一种痛苦折磨。</p><h2 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h2><p>课程的答辩已经过去了两周，本来很早就想写这篇文章的，但是一直被其他事情耽搁了。</p><p>在两个系统的设计和实现中，遇到了许多弯路挫折，但是学到的东西也不少。从环境配置，git 分支管理，项目管理这些方面来说，我受益颇多。<strong>知行合一</strong>啊，现在发现以前的确是有点偏向”知“而忽视”行了“。</p><p>再次感谢授课的徐杨老师和团队内的每一个成员。</p><p>顺便在此再次推销一下 git 项目，如果你觉得还不错，希望你能给我一个 star。</p><p><a href="https://github.com/tivnantu/studentls-old">点击此处跳转到项目 github 仓库</a></p>]]></content>
    
    
    <categories>
      
      <category>项目</category>
      
    </categories>
    
    
    <tags>
      
      <tag>web</tag>
      
      <tag>web service</tag>
      
      <tag>前后端分离</tag>
      
      <tag>项目管理</tag>
      
    </tags>
    
  </entry>
  
  
  
  
  
  
  <entry>
    <title>about</title>
    <link href="/"/>
    <url>/</url>
    
    <content type="html"><![CDATA[<h2 id="About"><a href="#About" class="headerlink" title="About"></a>About</h2><h3 id="About-Me"><a href="#About-Me" class="headerlink" title="About Me"></a>About Me</h3><p>tivnan，也就是我，是个普通人，和你身边的大多数人差不多。你身边一定有一个爱笑的、十分喜欢聊天的、性急匆匆的、多数情况下都很开朗的人，没准那个人就是我</p><p>我喜欢聊天，我喜欢coding，我喜欢学习新知识，我喜欢的东西太多太多。我有一个目标，那就是希望有朝一日能够探寻到软件工程世界的真谛</p><p>又普通又有趣</p><h3 id="About-Blog"><a href="#About-Blog" class="headerlink" title="About Blog"></a>About Blog</h3><p>我脑海里常常冒出来奇奇怪怪的想法，有时有趣，有时搞笑，有时无厘头。但无论如何，我都觉得把如果这些想法给一一实现，会是一件开心的事情</p><p>这个博客建立于2020年12月，主要作用，是记录下我在生活中的coding经历和经验。当然，也不一定全是关于代码的，那太无聊了。有时候还会抒发一下自己的感悟，或者探讨一下几个项目，又或者翻译几篇有趣的博客</p><p>这里是我的小小后花园</p>]]></content>
    
  </entry>
  
  
  
</search>
