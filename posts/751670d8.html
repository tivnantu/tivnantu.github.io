<!DOCTYPE html><html lang="zh-CN" data-default-color-scheme="light"><head><meta charset="UTF-8"><link rel="apple-touch-icon" sizes="76x76" href="/image/theme/favicon.png"><link rel="icon" href="/image/theme/favicon.png"><meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=5,shrink-to-fit=no"><meta http-equiv="x-ua-compatible" content="ie=edge"><meta name="theme-color" content="#2f4154"><meta name="author" content="tivnantu"><meta name="keywords" content="code"><meta name="description" content="虽然现在都用2.0了，但是看1.1也不算过时吧？"><meta property="og:type" content="article"><meta property="og:title" content="【笔记】图解HTTP（上）"><meta property="og:url" content="https://tivnantu.github.io/posts/751670d8"><meta property="og:site_name" content="tivnantu"><meta property="og:description" content="虽然现在都用2.0了，但是看1.1也不算过时吧？"><meta property="og:locale" content="zh_CN"><meta property="og:image" content="https://tivnantu.github.io/image/%E5%9B%BE%E8%A7%A3HTTP/index.jpg"><meta property="article:published_time" content="2022-04-04T08:33:47.000Z"><meta property="article:modified_time" content="2022-04-04T08:33:47.000Z"><meta property="article:author" content="tivnantu"><meta property="article:tag" content="基础体系"><meta name="twitter:card" content="summary_large_image"><meta name="twitter:image" content="https://tivnantu.github.io/image/%E5%9B%BE%E8%A7%A3HTTP/index.jpg"><meta name="referrer" content="no-referrer-when-downgrade"><title>【笔记】图解HTTP（上） &lt; tivnantu</title><link rel="stylesheet" href="https://lib.baomitu.com/twitter-bootstrap/4.6.1/css/bootstrap.min.css"><link rel="stylesheet" href="https://lib.baomitu.com/github-markdown-css/4.0.0/github-markdown.min.css"><link rel="stylesheet" href="https://lib.baomitu.com/hint.css/2.7.0/hint.min.css"><link rel="stylesheet" href="https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.css"><link rel="stylesheet" href="//at.alicdn.com/t/font_1749284_hj8rtnfg7um.css"><link rel="stylesheet" href="//at.alicdn.com/t/font_1736178_lbnruvf0jn.css"><link rel="stylesheet" href="/css/main.css"><link id="highlight-css" rel="stylesheet" href="/css/highlight.css"><link id="highlight-css-dark" rel="stylesheet" href="/css/highlight-dark.css"><script id="fluid-configs">var dntVal,Fluid=window.Fluid||{},CONFIG=(Fluid.ctx=Object.assign({},Fluid.ctx),{hostname:"tivnantu.github.io",root:"/",version:"1.9.4",typing:{enable:!0,typeSpeed:70,cursorChar:"",loop:!1,scope:[]},anchorjs:{enable:!0,element:"h1,h2,h3,h4,h5,h6",placement:"right",visible:"hover",icon:"§"},progressbar:{enable:!0,height_px:3,color:"#29d",options:{showSpinner:!1,trickleSpeed:100}},code_language:{enable:!0,default:"TEXT"},copy_btn:!0,image_caption:{enable:!0},image_zoom:{enable:!0,img_url_replace:["",""]},toc:{enable:!0,placement:"right",headingSelector:"h1,h2,h3,h4,h5,h6",collapseDepth:0},lazyload:{enable:!0,loading_img:"/image/theme/loading.gif",onlypost:!1,offset_factor:2},web_analytics:{enable:!1,follow_dnt:!0,baidu:null,google:null,gtag:null,tencent:{sid:null,cid:null},woyaola:null,cnzz:null,leancloud:{app_id:null,app_key:null,server_url:null,path:"window.location.pathname",ignore_local:!1}},search_path:"/local-search.xml"});CONFIG.web_analytics.follow_dnt&&(dntVal=navigator.doNotTrack||window.doNotTrack||navigator.msDoNotTrack,Fluid.ctx.dnt=dntVal&&(dntVal.startsWith("1")||dntVal.startsWith("yes")||dntVal.startsWith("on")))</script><script src="/js/utils.js"></script><script src="/js/color-schema.js"></script><meta name="generator" content="Hexo 6.3.0"></head><body><header><div class="header-inner" style="height:70vh"><nav id="navbar" class="navbar fixed-top navbar-expand-lg navbar-dark scrolling-navbar"><div class="container"><a class="navbar-brand" href="/"><strong>tivnantu</strong> </a><button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarSupportedContent" aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation"><div class="animated-icon"><span></span><span></span><span></span></div></button><div class="collapse navbar-collapse" id="navbarSupportedContent"><ul class="navbar-nav ml-auto text-center"><li class="nav-item"><a class="nav-link" href="/"><i class="iconfont icon-home-fill"></i> <span>首页</span></a></li><li class="nav-item"><a class="nav-link" href="/archives/"><i class="iconfont icon-archive-fill"></i> <span>归档</span></a></li><li class="nav-item"><a class="nav-link" href="/categories/"><i class="iconfont icon-category-fill"></i> <span>分类</span></a></li><li class="nav-item"><a class="nav-link" href="/tags/"><i class="iconfont icon-tags-fill"></i> <span>标签</span></a></li><li class="nav-item"><a class="nav-link" href="/about/"><i class="iconfont icon-user-fill"></i> <span>关于</span></a></li><li class="nav-item" id="search-btn"><a class="nav-link" target="_self" href="javascript:;" data-toggle="modal" data-target="#modalSearch" aria-label="Search"><i class="iconfont icon-search"></i></a></li><li class="nav-item" id="color-toggle-btn"><a class="nav-link" target="_self" href="javascript:;" aria-label="Color Toggle"><i class="iconfont icon-dark" id="color-toggle-icon"></i></a></li></ul></div></div></nav><div id="banner" class="banner" parallax="true" style="background:url(/image/%E5%9B%BE%E8%A7%A3HTTP/banner.jpg) no-repeat center center;background-size:cover"><div class="full-bg-img"><div class="mask flex-center" style="background-color:rgba(0,0,0,.3)"><div class="banner-text text-center fade-in-up"><div class="h2"><span id="subtitle" data-typed-text="【笔记】图解HTTP（上）"></span></div><div class="mt-3"><span class="post-meta"><i class="iconfont icon-date-fill" aria-hidden="true"></i> <time datetime="2022-04-04 16:33" pubdate>2022年4月4日 下午</time></span></div><div class="mt-1"><span class="post-meta mr-2"><i class="iconfont icon-chart"></i> 21k 字 </span><span class="post-meta mr-2"><i class="iconfont icon-clock-fill"></i> 89 分钟 </span><span id="busuanzi_container_page_pv" style="display:none"><i class="iconfont icon-eye" aria-hidden="true"></i> <span id="busuanzi_value_page_pv"></span> 次</span></div></div></div></div></div></div></header><main><div class="container-fluid nopadding-x"><div class="row nomargin-x"><div class="side-col d-none d-lg-block col-lg-2"></div><div class="col-lg-8 nopadding-x-md"><div class="container nopadding-x-md" id="board-ctn"><div id="board"><article class="post-content mx-auto"><h1 style="display:none">【笔记】图解HTTP（上）</h1><div class="markdown-body"><div class="note note-success"><p>《图解HTTP》出版于2013年，至今已有将近十年的时光。如果你在网上搜索一下《图解HTTP》，便会发现本书的讨论热度依旧不减，依然是不少论坛博客推荐的HTTP学习材料，笔记摘录也是一抓一大堆（比如我）。我想，一本技术类的书籍能够享有如此长时间的关注，这和它本身的写作手法、文章布局以及内容层面是息息相关的。</p><p>2013年，http在移动互联网领域再领风骚，https后发先至引人注目，http2.0正在提上日程即将发力。对于开发过程来说，则更凸现了开发者对计算机网络了解的重要性。不说深入到内部细节，但起码要整体认识。正如其书译者序中写到，“在我的印象中，讲解网络协议的书仅有两本。一本是《HTTP权威指南》，但其厚度令人望而生畏；另一本是《TCP&#x2F;IP详解，卷1》，内容艰涩难懂，学习难度较大。这两本书都是被读者们奉为“圣经”的经典之作，大师们的授道自然无可挑剔，但关键是它们对初学者都不那么友好，大家的学习信心很容易受到打击，阅读中途或将束之高阁。本书的出现及时缓解了该问题。”，于是《图解HTTP》应运而生。实际上，如果想要在专业技术道路上走得更坚实，绝对不能绕开学习HTTP协议这一环节。</p><p>那么如何学习http呢？固然有些大佬可以对着RFC标准直接上手开啃，但是对于我们普通人来说，还是得要有个循序渐进的过程，首先先学习具象的表面内容，再学习抽象的深层知识比较合适。我们在后端开发、前端开发、爬虫使用、服务器使用等等环节中早已积累了很多第一手的http实践知识，比如如何发送请求、如何处理响应、不同的状态怎么判断，不同错误如何解决……这些朴素的http实践知识弥足珍贵，因为它代表着我们对http的第一印象，但是还不够，得加料。那么《图解HTTP》的作用就凸现出来了，它可以让你用一个比较轻松的方式切入http协议的内部，知其然知其所以然。对于操作中的一些疑问，它可以提供解答，对于实践中的一些现象，它可以给出原理。</p><p>本书知识密度也很密集，经常大段大段的知识点连在一起，连读不缀，所以我笔记也是大段大段地摘抄下来。不用担心看的头疼，作者和译者的功力深厚，读者只要对前面的内容弄懂弄通了，“新”知识点也就和喝水一般水到渠成进入脑子，再加点自己的小小实践融会贯通，perfect！</p><p>本书稍难一点的章节也就是第六章“HTTP首部”，主要是因为该章节出现很多首部及其解析，读者一时半会可能分不清，而且有些首部也没怎么接触过，难以形成记忆。至于其他章节，难度水平波动不大，相对来说都是挺易懂的。</p><p>本书名字前缀带有“图解”，所以书中自然也插入了很多用于解析的图片了。对于这部分图片的作用，那么见仁见智了。从我自己的角度来看，图片有点多了，而且也不是所有图片都是必要的，文字内容已经足够清晰了，再加上一张照片就显得略有累赘。不过我也理解这种情况，毕竟一千个人眼中有一千个哈姆雷特，不同人对图片的看法肯定不一样，说不定这处我觉得很精妙的图片，在另外一个人看来就是画蛇添足。</p><p>在看这本书的时候，读者最好可以通过nginx&#x2F;Apache来搭建一个简单的Web服务器，然后利用postman等api测试工具进行手动收发请求响应作为辅助的http实验，这样会对书中内容有更直观的认识。本书极少上手实验的内容，一是难以提供统一的实验环境，即使是作者自己搭建一个Web服务器让我们测试，估计也很难维持个十多年，说不定由于内容绑定了具体环境，反而会落得和《xx天学会http协议》这类书籍一样短命；二是添加实验内容会导致本书极度膨胀，毕竟http协议细节繁多，知识点也多，再加上一点实验操作的话，页数翻倍也不是不可能。所以读者就自行解决动手操作这一个难题吧。</p></div><p>剩下的笔记：</p><blockquote><p><a href="48f3e75f">【笔记】图解HTTP（中）</a><br><a href="cdaa17bd">【笔记】图解HTTP（下）</a></p></blockquote><h2 id="第一章-了解Web及网络基础"><a href="#第一章-了解Web及网络基础" class="headerlink" title="第一章 了解Web及网络基础"></a>第一章 了解Web及网络基础</h2><h3 id="1-1-使用HTTP协议访问Web"><a href="#1-1-使用HTTP协议访问Web" class="headerlink" title="1.1 使用HTTP协议访问Web"></a>1.1 使用HTTP协议访问Web</h3><ul><li><p>Web浏览器根据地址栏中指定的URL，从Web服务器端获取文件资源（resource）等信息，从而显示出Web页面</p><ul><li>像这种通过发送请求获取服务器资源的Web浏览器等，都可称为客户端（client）</li></ul></li><li><p>Web使用一种名为HTTP（HyperText Transfer Protocol，超文本传输协议）的协议作为规范，完成从客户端到服务器端等一系列运作流程</p><ul><li><p>HTTP通常被译为超文本传输协议，但这种译法并不严谨。严谨的译名应该为“超文本转移协议”。但是前一译法已约定俗成，本书将会沿用</p></li><li><p>协议是指规则的约定。可以说，Web是建立在HTTP协议上通信的</p></li></ul></li></ul><h3 id="1-2-HTTP的诞生"><a href="#1-2-HTTP的诞生" class="headerlink" title="1.2 HTTP的诞生"></a>1.2 HTTP的诞生</h3><h4 id="1-2-1-为知识共享而规划Web"><a href="#1-2-1-为知识共享而规划Web" class="headerlink" title="1.2.1 为知识共享而规划Web"></a>1.2.1 为知识共享而规划Web</h4><ul><li><p>1989年3月，互联网还只属于少数人。CERN（欧洲核子研究组织）的蒂姆·伯纳斯-李（Tim Berners-Lee）博士提出了一种能让远隔两地的研究者们共享知识的设想。最初设想的基本理念是：借助多文档之间相互关联形成的超文本（HyperText），连成可相互参阅的WWW（World Wide Web，万维网）</p></li><li><p>现在已提出了3项WWW构建技术，分别是：把SGML（Standard GeneralizedMarkup Language，标准通用标记语言）作为页面的文本标记语言的HTML（HyperText Markup Language，超文本标记语言）；作为文档传递协议的HTTP；指定文档所在地址的URL（Uniform Resource Locator，统一资源定位符）</p></li><li><p>WWW这一名称，是Web浏览器当年用来浏览超文本的客户端应用程序时的名称。现在则用来表示这一系列的集合，也可简称为Web</p></li></ul><h4 id="1-2-2-Web成长时代"><a href="#1-2-2-Web成长时代" class="headerlink" title="1.2.2 Web成长时代"></a>1.2.2 Web成长时代</h4><ul><li><p>1990年11月，CERN成功研发了世界上第一台Web服务器和Web浏览器</p></li><li><p>1990年，大家针对HTML 1.0草案进行了讨论，因HTML 1.0中存在多处模糊不清的部分，草案被直接废弃了</p></li><li><p>1993年1月，现代浏览器的祖先NCSA（National Center for SupercomputerApplications，美国国家超级计算机应用中心）研发的Mosaic问世了。它以in-line（内联）等形式显示HTML的图像，在图像方面出色的表现使它迅速在世界范围内流行开来。同年秋天，Mosaic的Windows版和Macintosh版面世。使用CGI技术的NCSAWeb服务器、NCSA HTTPd 1.0也差不多是在这个时期出现的</p></li><li><p>1994年的12月，网景通信公司发布了Netscape Navigator 1.0, 1995年微软公司发布Internet Explorer 1.0和2.0</p></li><li><p>紧随其后的是现在已然成为Web服务器标准之一的Apache，当时它以Apache0.2的姿态出现在世人眼前。而HTML也发布了2.0版本。那一年，Web技术的发展突飞猛进</p></li><li><p>时光流转，从1995年左右起，微软公司与网景通信公司之间爆发的浏览器大战愈演愈烈。两家公司都各自对HTML做了扩展，于是导致在写HTML页面时，必须考虑兼容他们两家公司的浏览器。时至今日，这个问题仍令那些写前端页面的工程师感到棘手</p><ul><li>在这场浏览器供应商之间的竞争中，他们不仅对当时发展中的各种Web标准化视而不见，还屡次出现新增功能没有对应说明文档的情况</li></ul></li><li><p>2000年前后，这场浏览器战争随着网景通信公司的衰落而暂告一段落。但就在2004年，Mozilla基金会发布了Firefox浏览器，第二次浏览器大战随即爆发</p></li><li><p>Internet Explorer浏览器的版本从6升到7前后花费了5年时间。之后接连不断地发布了8、9、10版本。另外，Chrome、Opera、Safari等浏览器也纷纷抢占市场份额</p></li></ul><h4 id="1-2-3-驻足不前的HTTP"><a href="#1-2-3-驻足不前的HTTP" class="headerlink" title="1.2.3 驻足不前的HTTP"></a>1.2.3 驻足不前的HTTP</h4><ul><li><p>HTTP&#x2F;0.9</p><ul><li>HTTP于1990年问世。那时的HTTP并没有作为正式的标准被建立。这时的HTTP其实含有HTTP&#x2F;1.0之前版本的意思，因此被称为HTTP&#x2F;0.9</li></ul></li><li><p>HTTP&#x2F;1.0</p><ul><li>HTTP正式作为标准被公布是在1996年的5月，版本被命名为HTTP&#x2F;1.0，并记载于RFC1945。虽说是初期标准，但该协议标准至今仍被广泛使用在服务器端</li></ul></li><li><p>HTTP&#x2F;1.1</p><ul><li>1997年1月公布的HTTP&#x2F;1.1是目前主流的HTTP协议版本。当初的标准是RFC2068，之后发布的修订版RFC2616就是当前的最新版本</li></ul></li><li><p>HTTP&#x2F;2 （原名HTTP&#x2F;2.0）</p><ul><li><p>即超文本传输协议 2.0，是下一代HTTP协议。是由互联网工程任务组（IETF）的Hypertext Transfer Protocol Bis (httpbis)工作小组进行开发。是自1999年http1.1发布后的首个更新</p></li><li><p>HTTP 2.0在2013年8月进行首次合作共事性测试。在开放互联网上HTTP 2.0将只用于https:&#x2F;&#x2F;网址，而 http:&#x2F;&#x2F;网址将继续使用HTTP&#x2F;1，目的是在开放互联网上增加使用加密技术，以提供强有力的保护去遏制主动攻击</p></li></ul></li><li><p>可见，作为Web文档传输协议的HTTP，它的版本几乎没有更新</p></li><li><p>当年HTTP协议的出现主要是为了解决文本传输的难题。由于协议本身非常简单，于是在此基础上设想了很多应用方法并投入了实际使用。现在HTTP协议已经超出了Web这个框架的局限，被运用到了各种场景里</p></li></ul><h3 id="1-3-网络基础TCP-x2F-IP"><a href="#1-3-网络基础TCP-x2F-IP" class="headerlink" title="1.3 网络基础TCP&#x2F;IP"></a>1.3 网络基础TCP&#x2F;IP</h3><ul><li>通常使用的网络（包括互联网）是在TCP&#x2F;IP协议族的基础上运作的。而HTTP属于它内部的一个子集</li></ul><h4 id="1-3-1-TCP-x2F-IP协议族"><a href="#1-3-1-TCP-x2F-IP协议族" class="headerlink" title="1.3.1 TCP&#x2F;IP协议族"></a>1.3.1 TCP&#x2F;IP协议族</h4><ul><li><p>计算机与网络设备要相互通信，双方就必须基于相同的方法。比如，如何探测到通信目标、由哪一边先发起通信、使用哪种语言进行通信、怎样结束通信等规则都需要事先确定。不同的硬件、操作系统之间的通信，所有的这一切都需要一种规则。而我们就把这种规则称为协议（protocol）</p></li><li><p>TCP&#x2F;IP是互联网相关的各类协议族的总称，以下是部分常见的协议：ICMP、IP、TCP、UDP、DNS、PPPoE、SNMP、FTP、HTTP、FDDI、IEEE 802.3</p></li><li><p>协议中存在各式各样的内容。从电缆的规格到IP地址的选定方法、寻找异地用户的方法、双方建立通信的顺序，以及Web页面显示需要处理的步骤，等等</p></li></ul><h4 id="1-3-2-TCP-x2F-IP的分层管理"><a href="#1-3-2-TCP-x2F-IP的分层管理" class="headerlink" title="1.3.2 TCP&#x2F;IP的分层管理"></a>1.3.2 TCP&#x2F;IP的分层管理</h4><ul><li><p>TCP&#x2F;IP协议族里重要的一点就是分层。TCP&#x2F;IP协议族按层次分别分为以下4层：应用层、传输层、网络层和数据链路层</p></li><li><p>把TCP&#x2F;IP层次化是有好处的</p><ul><li><p>比如，如果互联网只由一个协议统筹，某个地方需要改变设计时，就必须把所有部分整体替换掉。而分层之后只需把变动的层替换掉即可。把各层之间的接口部分规划好之后，每个层次内部的设计就能够自由改动了</p></li><li><p>层次化之后，设计也变得相对简单了。处于应用层上的应用可以只考虑分派给自己的任务，而不需要弄清对方在地球上哪个地方、对方的传输路线是怎样的、是否能确保传输送达等问题</p></li></ul></li><li><p>TCP&#x2F;IP协议族各层的作用如下</p><ul><li><p>应用层</p><ul><li><p>应用层决定了向用户提供应用服务时通信的活动</p></li><li><p>TCP&#x2F;IP协议族内预存了各类通用的应用服务。比如，FTP（File TransferProtocol，文件传输协议）和DNS（Domain Name System，域名系统）服务就是其中两类</p></li><li><p>HTTP协议也处于该层</p></li></ul></li><li><p>传输层</p><ul><li><p>传输层对上层应用层，提供处于网络连接中的两台计算机之间的数据传输</p></li><li><p>在传输层有两个性质不同的协议：TCP（Transmission ControlProtocol，传输控制协议）和UDP（User Data Protocol，用户数据报协议）</p></li></ul></li><li><p>网络层（又名网络互连层）</p><ul><li><p>网络层用来处理在网络上流动的数据包。数据包是网络传输的最小数据单位。该层规定了通过怎样的路径（所谓的传输路线）到达对方计算机，并把数据包传送给对方</p></li><li><p>与对方计算机之间通过多台计算机或网络设备进行传输时，网络层所起的作用就是在众多的选项内选择一条传输路线</p></li></ul></li><li><p>链路层（又名数据链路层，网络接口层）</p><ul><li><p>用来处理连接网络的硬件部分。包括控制操作系统、硬件的设备驱动、NIC（Network Interface Card，网络适配器，即网卡），及光纤等物理可见部分（还包括连接器等一切传输媒介）</p></li><li><p>硬件上的范畴均在链路层的作用范围之内</p></li></ul></li></ul></li><li><p>利用TCP&#x2F;IP协议族进行网络通信时，会通过分层顺序与对方进行通信。发送端从应用层往下走，接收端则往应用层往上走</p></li><li><p>用HTTP举例来说明</p><p><img src="/image/%E5%9B%BE%E8%A7%A3HTTP/c85cfc9a6d3f3ecf628c9e8b89803f3830785086.jpeg" srcset="/image/theme/loading.gif" lazyload alt="epub_907764_9.jpeg"></p><ul><li><p>首先作为发送端的客户端在应用层（HTTP协议）发出一个想看某个Web页面的HTTP请求</p></li><li><p>接着，为了传输方便，在传输层（TCP协议）把从应用层处收到的数据（HTTP请求报文）进行分割，并在各个报文上打上标记序号及端口号后转发给网络层</p></li><li><p>在网络层（IP协议），增加作为通信目的地的MAC地址后转发给链路层。这样一来，发往网络的通信请求就准备齐全了</p></li><li><p>接收端的服务器在链路层接收到数据，按序往上层发送，一直到应用层。当传输到应用层，才能算真正接收到由客户端发送过来的HTTP请求</p></li></ul></li><li><p>发送端在层与层之间传输数据时，每经过一层时必定会被打上一个该层所属的首部信息。反之，接收端在层与层传输数据时，每经过一层时会把对应的首部消去。这种把数据信息包装起来的做法称为封装（encapsulate）</p></li></ul><h3 id="1-4-与HTTP关系密切的协议：IP、TCP和DNS"><a href="#1-4-与HTTP关系密切的协议：IP、TCP和DNS" class="headerlink" title="1.4 与HTTP关系密切的协议：IP、TCP和DNS"></a>1.4 与HTTP关系密切的协议：IP、TCP和DNS</h3><h4 id="1-4-1-负责传输的IP协议"><a href="#1-4-1-负责传输的IP协议" class="headerlink" title="1.4.1 负责传输的IP协议"></a>1.4.1 负责传输的IP协议</h4><ul><li><p>按层次分，IP（Internet Protocol）网际协议位于网络层</p><ul><li><p>几乎所有使用网络的系统都会用到IP协议</p></li><li><p>TCP&#x2F;IP协议族中的IP指的就是网际协议</p></li><li><p>可能有人会把“IP”和“IP地址”搞混，“IP”其实是一种协议的名称</p></li></ul></li><li><p>IP协议的作用是把各种数据包传送给对方。而要保证确实传送到对方那里，则需要满足各类条件。其中两个重要的条件是IP地址和MAC地址（Media AccessControl Address）</p><ul><li><p>IP地址指明了节点被分配到的地址，MAC地址是指网卡所属的固定地址</p></li><li><p>IP地址可以和MAC地址进行配对</p></li><li><p>IP地址可变换，但MAC地址基本上不会更改</p></li></ul></li><li><p>使用ARP协议凭借MAC地址进行通信</p><ul><li><p>IP间的通信依赖MAC地址</p></li><li><p>在网络上，通信的双方在同一局域网（LAN）内的情况是很少的，通常是经过多台计算机和网络设备中转才能连接到对方。而在进行中转时，会利用下一站中转设备的MAC地址来搜索下一个中转目标。这时，会采用ARP协议（Address Resolution Protocol）</p></li><li><p>ARP是一种用以解析地址的协议，根据通信方的IP地址就可以反查出对应的MAC地址</p></li></ul></li><li><p>没有人能够全面掌握互联网中的传输状况</p><ul><li><p>在到达通信目标前的中转过程中，那些计算机和路由器等网络设备只能获悉很粗略的传输路线</p></li><li><p>这种机制称为路由选择（routing），有点像快递公司的送货过程。想要寄快递的人，只要将自己的货物送到集散中心，就可以知道快递公司是否肯收件发货，该快递公司的集散中心检查货物的送达地址，明确下站该送往哪个区域的集散中心。接着，那个区域的集散中心自会判断是否能送到对方的家中</p></li><li><p>无论哪台计算机、哪台网络设备，它们都无法全面掌握互联网中的细节</p></li></ul></li></ul><h4 id="1-4-2-确保可靠性的TCP协议"><a href="#1-4-2-确保可靠性的TCP协议" class="headerlink" title="1.4.2 确保可靠性的TCP协议"></a>1.4.2 确保可靠性的TCP协议</h4><ul><li><p>按层次分，TCP位于传输层，提供可靠的字节流服务</p><ul><li><p>所谓的字节流服务（Byte Stream Service）是指，为了方便传输，将大块数据分割成以报文段（segment）为单位的数据包进行管理</p></li><li><p>而可靠的传输服务是指，能够把数据准确可靠地传给对方</p></li><li><p>一言以蔽之，TCP协议为了更容易传送大数据才把数据分割，而且TCP协议能够确认数据最终是否送达到对方</p></li></ul></li><li><p>确保数据能到达目标</p><ul><li><p>为了准确无误地将数据送达目标处，TCP协议采用了三次握手（three-wayhandshaking）策略</p><ul><li><p>用TCP协议把数据包送出去后，TCP不会对传送后的情况置之不理，它一定会向对方确认是否成功送达</p></li><li><p>握手过程中使用了TCP的标志（flag）——SYN（synchronize）和ACK（acknowledgement）</p></li><li><p>发送端首先发送一个带SYN标志的数据包给对方。接收端收到后，回传一个带有SYN&#x2F;ACK标志的数据包以示传达确认信息。最后，发送端再回传一个带ACK标志的数据包，代表“握手”结束</p></li></ul></li><li><p>若在握手过程中某个阶段莫名中断，TCP协议会再次以相同的顺序发送相同的数据包</p></li></ul></li></ul><h4 id="1-5-负责域名解析的DNS服务"><a href="#1-5-负责域名解析的DNS服务" class="headerlink" title="1.5 负责域名解析的DNS服务"></a>1.5 负责域名解析的DNS服务</h4><ul><li><p>DNS（Domain Name System）服务是和HTTP协议一样位于应用层的协议。它提供域名到IP地址之间的解析服务</p></li><li><p>DNS服务出现的原因：</p><ul><li><p>计算机既可以被赋予IP地址，也可以被赋予主机名和域名</p></li><li><p>用户通常使用主机名或域名来访问对方的计算机，而不是直接通过IP地址访问。因为与IP地址的一组纯数字相比，用字母配合数字的表示形式来指定计算机名更符合人类的记忆习惯</p></li><li><p>但要让计算机去理解名称，相对而言就变得困难了。因为计算机更擅长处理一长串数字</p></li></ul></li><li><p>DNS协议提供通过域名查找IP地址，或逆向从IP地址反查域名的服务</p></li></ul><h4 id="1-6-各种协议与HTTP协议的关系"><a href="#1-6-各种协议与HTTP协议的关系" class="headerlink" title="1.6 各种协议与HTTP协议的关系"></a>1.6 各种协议与HTTP协议的关系</h4><ul><li><p>各种协议在通信过程中发挥的作用</p><p><img src="/image/%E5%9B%BE%E8%A7%A3HTTP/4f110dda11ee37a6d87d92b9287c385c198f1336.jpeg" srcset="/image/theme/loading.gif" lazyload alt="epub_907764_13.jpeg"></p></li></ul><h3 id="1-7-URI和URL"><a href="#1-7-URI和URL" class="headerlink" title="1.7 URI和URL"></a>1.7 URI和URL</h3><ul><li>与URI（统一资源标识符）相比，我们更熟悉URL（Uniform ResourceLocator，统一资源定位符）。URL正是使用Web浏览器等访问Web页面时需要输入的网页地址</li></ul><h4 id="1-7-1-统一资源标识符"><a href="#1-7-1-统一资源标识符" class="headerlink" title="1.7.1 统一资源标识符"></a>1.7.1 统一资源标识符</h4><ul><li><p>URI是Uniform Resource Identifier的缩写。RFC2396分别对这3个单词进行了如下定义</p><ul><li><p>Uniform：规定统一的格式可方便处理多种不同类型的资源，而不用根据上下文环境来识别资源指定的访问方式。另外，加入新增的协议方案（如http：或ftp:）也更容易</p></li><li><p>Resource：资源的定义是“可标识的任何东西”。不仅是文档文件，图像或服务（例如当天的天气预报）等能够区别于其他类型的，全都可作为资源。另外，资源不仅可以是单一的，也可以是多数的集合体</p></li><li><p>Identifier：表示可标识的对象。也称为标识符</p></li></ul></li><li><p>综上所述，URI就是由某个协议方案表示的资源的定位标识符。协议方案是指访问资源所使用的协议类型名称</p><ul><li><p>采用HTTP协议时，协议方案就是http</p></li><li><p>除此之外，还有ftp、mailto、telnet、file等</p></li></ul></li><li><p>标准的URI协议方案有30种左右，由隶属于国际互联网资源管理的非营利社团ICANN（Internet Corporation for Assigned Names andNumbers，互联网名称与数字地址分配机构）的IANA（Internet AssignedNumbers Authority，互联网号码分配局）管理颁布</p></li><li><p>URI用字符串标识某一互联网资源，而URL表示资源的地点（互联网上所处的位置）。可见URL是URI的子集</p></li><li><p>“RFC3986：统一资源标识符（URI）通用语法”中列举了几种URI例子，如下所示</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">http</span>://www.ietf.org/rfc/rfc2396.txt<br><span class="hljs-attribute">ldap</span>://[<span class="hljs-number">2001</span>:db8::<span class="hljs-number">7</span>]/c=GB?objectClass?one<br><span class="hljs-attribute">mailto</span>:John.Doe@example.com<br><span class="hljs-attribute">news</span>:comp.infosystems.www.servers.unix<br><span class="hljs-attribute">tel</span>:+<span class="hljs-number">1</span>-<span class="hljs-number">816</span>-<span class="hljs-number">555</span>-<span class="hljs-number">1212</span><br><span class="hljs-attribute">telnet</span>://<span class="hljs-number">192.0.2.16:80</span>/<br><span class="hljs-attribute">urn</span>:oasis:names:specification:docbook:dtd:xml:<span class="hljs-number">4</span>.<span class="hljs-number">1</span>.<span class="hljs-number">2</span><br></code></pre></td></tr></table></figure></li></ul><h4 id="1-7-2-URI格式"><a href="#1-7-2-URI格式" class="headerlink" title="1.7.2 URI格式"></a>1.7.2 URI格式</h4><ul><li><p>表示指定的URI，要使用涵盖全部必要信息的绝对URI、绝对URL以及相对URL</p><ul><li>相对URL，是指从浏览器中基本URI处指定的URL，形如 &#x2F;image&#x2F;logo.gif</li></ul></li><li><p>绝对URI的格式：</p><p><img src="/image/%E5%9B%BE%E8%A7%A3HTTP/b22bc2fe1a598316338814ec6e207782d37904c0.jpeg" srcset="/image/theme/loading.gif" lazyload alt="epub_907764_15.jpeg"></p><ul><li><p>使用http:或https:等协议方案名获取访问资源时要指定协议类型。不区分字母大小写，最后附一个冒号（:）。也可使用data:或javascript:这类指定数据或脚本程序的方案名</p></li><li><p>登录信息（认证）：指定用户名和密码作为从服务器端获取资源时必要的登录信息（身份认证）。此项是可选项</p></li><li><p>服务器地址：使用绝对URI必须指定待访问的服务器地址。地址可以是类似hackr.jp这种DNS可解析的名称，或是192.168.1.1这类IPv4地址名，还可以是[:0:0:0:0:0:0:1]这样用方括号括起来的IPv6地址名</p></li><li><p>服务器端口号：指定服务器连接的网络端口号。此项也是可选项，若用户省略则自动使用默认端口号</p></li><li><p>带层次的文件路径：指定服务器上的文件路径来定位特指的资源。这与UNIX系统的文件目录结构相似</p></li><li><p>查询字符串：针对已指定的文件路径内的资源，可以使用查询字符串传入任意参数。此项可选</p></li><li><p>片段标识符：使用片段标识符通常可标记出已获取资源中的子资源（文档内的某个位置）。但在RFC中并没有明确规定其使用方法。该项也为可选项</p></li></ul></li><li><p>并不是所有的应用程序都符合RFC</p><ul><li><p>有一些用来制定HTTP协议技术标准的文档，它们被称为RFC（Requestfor Comments，征求修正意见书）</p></li><li><p>通常，应用程序会遵照由RFC确定的标准实现。可以说，RFC是互联网的设计文档，要是不按照RFC标准执行，就有可能导致无法通信的状况。比如，有一台Web服务器内的应用服务没有遵照RFC的标准实现，那Web浏览器就很可能无法访问这台服务器了</p></li><li><p>由于不遵照RFC标准实现就无法进行HTTP协议通信，所以基本上客户端和服务器端都会以RFC为标准来实现HTTP协议。但也存在某些应用程序因客户端或服务器端的不同，而未遵照RFC标准，反而将自成一套的“标准”扩展的情况</p></li><li><p>不按RFC标准来实现，当然也不必劳心费力让自己的“标准”符合其他所有的客户端和服务器端。但设想一下，如果这款应用程序的使用者非常多，那会发生什么情况？不难想象，其他的客户端或服务器端必然都不得不去配合它</p></li><li><p>实际在互联网上，已经实现了HTTP协议的一些服务器端和客户端里就存在上述情况。说不定它们会与本书介绍的HTTP协议的实现情况不一样</p></li><li><p>本书接下来要介绍的HTTP协议内容，除去部分例外，基本上都以RFC的标准为准</p></li></ul></li><li><p>URL和URI的区别</p><ul><li><p><a target="_blank" rel="noopener" href="https://www.javatpoint.com/uri-vs-url">URI vs URL | Difference between URI and URL</a></p></li><li><p><a target="_blank" rel="noopener" href="https://www.cnblogs.com/blknemo/p/13198506.html">【Web思考】URI和URL的区别？以及URL的结构</a></p><ul><li><p>我们要找一个人——张三，我们可以通过他的唯一的标识来找，比如说<strong>身份证</strong>，那么这个身份证就唯一的标识了一个人，这个身份证就是一个 URI；</p></li><li><p>而要找到张三，我们不一定要用身份证去找，我们还可以根据地址去找，如 在清华大学18号宿舍楼的404房间第一个床铺的张三，我们也可以唯一确定一个张三，<code>动物住址协议://地球/中国/北京市/清华大学/18号宿舍楼/404号寝/张三.人</code>。而这个地址就是我们用于标识和定位的 URL</p></li><li><p>我们从上面可以很明显的看出，URI 通过任何方法标识一个人即可，而 URL 虽然也可以标识一个人，但是它主要是通过定位地址的方法标识一个人，所以 URL 其实是 URI 的一个子集，即 URL 是靠标识定位地址的一个 URI</p></li></ul></li><li><p>简单来说，URI是标识某一资源，但是不一定能定位到，而URL除了标识某一资源，还可以定位到这一资源</p></li></ul></li></ul><h2 id="第二章-简单的HTTP协议"><a href="#第二章-简单的HTTP协议" class="headerlink" title="第二章 简单的HTTP协议"></a>第二章 简单的HTTP协议</h2><h3 id="2-1-HTTP协议用于客户端和服务器端之间的通信"><a href="#2-1-HTTP协议用于客户端和服务器端之间的通信" class="headerlink" title="2.1 HTTP协议用于客户端和服务器端之间的通信"></a>2.1 HTTP协议用于客户端和服务器端之间的通信</h3><ul><li><p>HTTP协议和TCP&#x2F;IP协议族内的其他众多的协议相同，用于客户端和服务器之间的通信</p></li><li><p>请求访问文本或图像等资源的一端称为客户端，而提供资源响应的一端称为服务器端</p></li><li><p>应用HTTP协议时，必定是一端担任客户端角色，另一端担任服务器端角色</p></li><li><p>有时候，按实际情况，两台计算机作为客户端和服务器端的角色有可能会互换。但就仅从一条通信路线来说，服务器端和客户端的角色是确定的，而用HTTP协议能够明确区分哪端是客户端，哪端是服务器端</p></li></ul><h3 id="2-2-通过请求和响应的交换达成通信"><a href="#2-2-通过请求和响应的交换达成通信" class="headerlink" title="2.2 通过请求和响应的交换达成通信"></a>2.2 通过请求和响应的交换达成通信</h3><ul><li><p>HTTP协议规定，请求从客户端发出，最后服务器端响应该请求并返回。换句话说，肯定是先从客户端开始建立通信的，服务器端在没有接收到请求之前不会发送响应</p></li><li><p>HTTP通信示例</p><p><img src="/image/%E5%9B%BE%E8%A7%A3HTTP/b652df550c08be444515045970281cc186897d16.jpeg" srcset="/image/theme/loading.gif" lazyload alt="epub_907764_19.jpeg"></p></li><li><p>从客户端发送给某个HTTP服务器端的请求报文中的内容示例</p><figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs http"><span class="hljs-keyword">GET</span> <span class="hljs-string">/index.html</span> <span class="hljs-meta">HTTP/1.1</span><br><span class="hljs-attribute">Host</span><span class="hljs-punctuation">: </span>hackr.jp<br></code></pre></td></tr></table></figure><ul><li><p>起始行开头的GET表示请求访问服务器的类型，称为方法（method）</p></li><li><p>随后的字符串&#x2F;index.htm指明了请求访问的资源对象，也叫做请求URI（request-URI）</p></li><li><p>最后的HTTP&#x2F;1.1，即HTTP的版本号，用来提示客户端使用的HTTP协议功能</p></li><li><p>综合来看，这段请求内容的意思是：请求访问某台HTTP服务器上的&#x2F;index.htm页面资源</p></li></ul></li><li><p>请求报文是由请求方法、请求URI、协议版本、可选的请求首部字段和内容实体构成的。首部字段和内容实体之间以空行为间隔</p><p><img src="/image/%E5%9B%BE%E8%A7%A3HTTP/4b0bfee1e36d0a852f518bb38f2fd663a607fd57.jpeg" srcset="/image/theme/loading.gif" lazyload alt="epub_907764_20.jpeg"></p></li><li><p>接收到请求的服务器，会将请求内容的处理结果以响应的形式返回</p><figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs http"><span class="hljs-meta">HTTP/1.1</span> <span class="hljs-number">200</span> OK<br><span class="hljs-attribute">Date</span><span class="hljs-punctuation">: </span>Tue, 10 Jul 2012 06:50:15 GMT<br><span class="hljs-attribute">Cotent-Length</span><span class="hljs-punctuation">: </span>362<br><span class="hljs-attribute">Content-Type</span><span class="hljs-punctuation">: </span>text/html<br><br><span class="language-lasso">&lt;html&gt;</span><br><span class="language-lasso"><span class="hljs-params">...</span><span class="hljs-params">...</span></span><br></code></pre></td></tr></table></figure><ul><li><p>在起始行开头的HTTP&#x2F;1.1表示服务器对应的HTTP版本</p></li><li><p>紧挨着的200 OK表示请求的处理结果的状态码（status code）和原因短语（reason-phrase）</p></li><li><p>下一行显示了创建响应的日期时间，是首部字段（header field）内的一个属性</p></li><li><p>接着以一空行分隔，之后的内容称为资源实体的主体（entity body）</p></li></ul></li><li><p>响应报文基本上由协议版本、状态码（表示请求成功或失败的数字代码）、用以解释状态码的原因短语、可选的响应首部字段以及实体主体构成</p><p><img src="/image/%E5%9B%BE%E8%A7%A3HTTP/63a1ed37ca819a9f09b4faec46eb3a3f9e7b30fb.jpeg" srcset="/image/theme/loading.gif" lazyload alt="epub_907764_21.jpeg"></p></li></ul><h3 id="2-3-HTTP是不保存状态的协议"><a href="#2-3-HTTP是不保存状态的协议" class="headerlink" title="2.3 HTTP是不保存状态的协议"></a>2.3 HTTP是不保存状态的协议</h3><ul><li><p>HTTP是一种不保存状态，即无状态（stateless）协议。HTTP协议自身不对请求和响应之间的通信状态进行保存。也就是说在HTTP这个级别，协议对于发送过的请求或响应都不做持久化处理</p></li><li><p>使用HTTP协议，每当有新的请求发送时，就会有对应的新响应产生。协议本身并不保留之前一切的请求或响应报文的信息。这是为了更快地处理大量事务，确保协议的可伸缩性，而特意把HTTP协议设计成如此简单的</p></li><li><p>可是，随着Web的不断发展，因无状态而导致业务处理变得棘手的情况增多了。比如，用户登录到一家购物网站，即使他跳转到该站的其他页面后，也需要能继续保持登录状态。针对这个实例，网站为了能够掌握是谁送出的请求，需要保存用户的状态</p></li><li><p>HTTP&#x2F;1.1虽然是无状态协议，但为了实现期望的保持状态功能，于是引入了Cookie技术。有了Cookie再用HTTP协议通信，就可以管理状态了</p></li></ul><h3 id="2-4-请求URI定位资源"><a href="#2-4-请求URI定位资源" class="headerlink" title="2.4 请求URI定位资源"></a>2.4 请求URI定位资源</h3><ul><li><p>HTTP协议使用URI定位互联网上的资源。正是因为URI的特定功能，在互联网上任意位置的资源都能访问到</p></li><li><p>当客户端请求访问资源而发送请求时，URI需要将作为请求报文中的请求URI包含在内。指定请求URI的方式有很多</p><ul><li><p>URI为完整的请求URI</p><figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs http"><span class="hljs-keyword">GET</span> <span class="hljs-string">http://hackr.jp/index.html</span> <span class="hljs-meta">HTTP/1.1</span><br></code></pre></td></tr></table></figure></li><li><p>在首部字段Host中写明网络域名或IP地址</p><figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs http"><span class="hljs-keyword">GET</span> <span class="hljs-string">/index.html</span> <span class="hljs-meta">HTTP/1.1</span><br><span class="hljs-attribute">Host</span><span class="hljs-punctuation">: </span>hackr.jp<br></code></pre></td></tr></table></figure></li></ul></li><li><p>如果不是访问特定资源而是对服务器本身发起请求，可以用一个*来代替请求URI。下述例子用于查询HTTP服务器端支持的HTTP方法种类</p><figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs http"><span class="hljs-keyword">OPTIONS</span> <span class="hljs-string">*</span> <span class="hljs-meta">HTTP/1.1</span><br></code></pre></td></tr></table></figure></li></ul><h3 id="2-5-告知服务器意图的HTTP方法"><a href="#2-5-告知服务器意图的HTTP方法" class="headerlink" title="2.5 告知服务器意图的HTTP方法"></a>2.5 告知服务器意图的HTTP方法</h3><ul><li><p>GET：获取资源</p><ul><li><p>GET方法用来请求访问已被URI识别的资源。指定的资源经服务器端解析后返回响应内容</p></li><li><p>也就是说，如果请求的资源是文本，那就保持原样返回；如果是像CGI（Common Gateway Interface，通用网关接口）那样的程序，则返回经过执行后的输出结果</p></li></ul></li><li><p>POST：传输实体主体</p><ul><li><p>POST方法用来传输实体的主体</p></li><li><p>虽然用GET方法也可以传输实体的主体，但一般不用GET方法进行传输，而是用POST方法</p></li><li><p>虽说POST的功能与GET很相似，但POST的主要目的并不是获取响应的主体内容</p></li></ul></li><li><p>PUT：传输文件</p><ul><li><p>PUT方法用来传输文件。就像FTP协议的文件上传一样，要求在请求报文的主体中包含文件内容，然后保存到请求URI指定的位置</p></li><li><p>但是，鉴于HTTP&#x2F;1.1的PUT方法自身不带验证机制，任何人都可以上传文件，存在安全性问题，因此一般的Web网站不使用该方法。若配合Web应用程序的验证机制，或架构设计采用REST（Representational State Transfer，表征状态转移）标准的同类Web网站，就可能会开放使用PUT方法</p></li></ul></li><li><p>HEAD：获得报文首部</p><ul><li>HEAD方法和GET方法一样，只是不返回报文主体部分。用于确认URI的有效性及资源更新的日期时间等</li></ul></li><li><p>DELETE：删除文件</p><ul><li><p>DELETE方法用来删除文件，是与PUT相反的方法。DELETE方法按请求URI删除指定的资源</p></li><li><p>但是，HTTP&#x2F;1.1的DELETE方法本身和PUT方法一样不带验证机制，所以一般的Web网站也不使用DELETE方法。当配合Web应用程序的验证机制，或遵守REST标准时还是有可能会开放使用的</p></li></ul></li><li><p>OPTIONS：询问支持的方法</p><ul><li>OPTIONS方法用来查询针对请求URI指定的资源支持的方法</li></ul></li><li><p>TRACE：追踪路径</p><ul><li><p>TRACE方法是让Web服务器端将之前的请求通信环回给客户端的方法</p></li><li><p>发送请求时，在Max-Forwards首部字段中填入数值，每经过一个服务器端就将该数字减1，当数值刚好减到0时，就停止继续传输，最后接收到请求的服务器端则返回状态码200 OK的响应</p></li><li><p>客户端通过TRACE方法可以查询发送出去的请求是怎样被加工修改&#x2F;篡改的。这是因为，请求想要连接到源目标服务器可能会通过代理中转，TRACE方法就是用来确认连接过程中发生的一系列操作</p></li><li><p>但是，TRACE方法本来就不怎么常用，再加上它容易引发XST（Cross-SiteTracing，跨站追踪）攻击，通常就更不会用到了</p></li></ul></li><li><p>CONNECT：要求用隧道协议连接代理</p><ul><li><p>CONNECT方法要求在与代理服务器通信时建立隧道，实现用隧道协议进行TCP通信。主要使用SSL（Secure Sockets Layer，安全套接层）和TLS（Transport Layer Security，传输层安全）协议把通信内容加密后经网络隧道传输</p></li><li><p>CONNECT方法的格式如下所示</p><figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs http">CONNECT 代理服务器:端口号 HTTP版本<br></code></pre></td></tr></table></figure></li></ul></li></ul><h2 id="第三章-HTTP报文内的HTTP消息"><a href="#第三章-HTTP报文内的HTTP消息" class="headerlink" title="第三章 HTTP报文内的HTTP消息"></a>第三章 HTTP报文内的HTTP消息</h2><h3 id="3-1-HTTP报文"><a href="#3-1-HTTP报文" class="headerlink" title="3.1 HTTP报文"></a>3.1 HTTP报文</h3><ul><li><p>用于HTTP协议交互的信息被称为HTTP报文</p><ul><li><p>请求端（客户端）的HTTP报文叫做请求报文，响应端（服务器端）的叫做响应报文</p></li><li><p>HTTP报文本身是由多行（用CR+LF作换行符）数据构成的字符串文本</p></li></ul></li><li><p>HTTP报文大致可分为报文首部和报文主体两块。两者由最初出现的空行（CR+LF）来划分。通常，并不一定要有报文主体</p><p><img src="/image/%E5%9B%BE%E8%A7%A3HTTP/3d2ef9e09f5c724acbdc2eb468948efcf2b91eb5.jpeg" srcset="/image/theme/loading.gif" lazyload alt="epub_907764_52.jpeg"></p></li></ul><h3 id="3-2-请求报文及响应报文的结构"><a href="#3-2-请求报文及响应报文的结构" class="headerlink" title="3.2 请求报文及响应报文的结构"></a>3.2 请求报文及响应报文的结构</h3><ul><li><p>请求报文和响应报文的结构</p><p><img src="/image/%E5%9B%BE%E8%A7%A3HTTP/2c7241ff7035e12c4181b673d43943c3f440d404.jpeg" srcset="/image/theme/loading.gif" lazyload alt="epub_907764_53.jpeg"></p></li><li><p>请求报文和响应报文的实例</p><p><img src="/image/%E5%9B%BE%E8%A7%A3HTTP/55a496ad131973ea835bdd4f1e65da7f625942ad.jpeg" srcset="/image/theme/loading.gif" lazyload alt="epub_907764_54.jpeg"></p></li><li><p>请求报文和响应报文的首部内容由以下数据组成</p><ul><li><p>请求行：包含用于请求的方法，请求URI和HTTP版本</p></li><li><p>状态行：包含表明响应结果的状态码，原因短语和HTTP版本</p></li><li><p>首部字段：包含表示请求和响应的各种条件和属性的各类首部</p><ul><li>一般有4种首部，分别是：通用首部、请求首部、响应首部和实体首部</li></ul></li><li><p>其他：可能包含HTTP的RFC里未定义的首部（Cookie等）</p></li></ul></li></ul><h3 id="3-3-编码提升传输速率"><a href="#3-3-编码提升传输速率" class="headerlink" title="3.3 编码提升传输速率"></a>3.3 编码提升传输速率</h3><ul><li>HTTP在传输数据时可以按照数据原貌直接传输，但也可以在传输过程中通过编码提升传输速率。通过在传输时编码，能有效地处理大量的访问请求。但是，编码的操作需要计算机来完成，因此会消耗更多的CPU等资源</li></ul><h4 id="3-3-1-报文主体和实体主体的差异"><a href="#3-3-1-报文主体和实体主体的差异" class="headerlink" title="3.3.1 报文主体和实体主体的差异"></a>3.3.1 报文主体和实体主体的差异</h4><ul><li><p>报文（message）是HTTP通信中的基本单位，由8位组字节流（octet sequence，其中octet为8个比特）组成，通过HTTP通信传输</p></li><li><p>实体（entity）作为请求或响应的有效载荷数据（补充项）被传输，其内容由实体首部和实体主体组成</p></li><li><p>HTTP报文的主体用于传输请求或响应的实体主体。通常，报文主体等于实体主体。只有当传输中进行编码操作时，实体主体的内容发生变化，才导致它和报文主体产生差异</p><ul><li><p><a target="_blank" rel="noopener" href="https://www.zhihu.com/question/263752229">http报文和实体的差别？</a></p></li><li><p>实体主体指的是，HTTP报文在网络上传输的过程中，载荷的真实模样</p></li><li><p>报文主体指的是，使用HTTP通信的一方想要发送给另一方的消息的模样</p></li><li><p>如果没有经过编码，那实体主体就是报文主体。如果经过编码，那实体主体就是编码前的报文主体</p></li></ul></li></ul><h4 id="3-3-2-压缩传输的内容编码"><a href="#3-3-2-压缩传输的内容编码" class="headerlink" title="3.3.2 压缩传输的内容编码"></a>3.3.2 压缩传输的内容编码</h4><ul><li><p>向待发送邮件内增加附件时，为了使邮件容量变小，我们会先用ZIP压缩文件之后再添加附件发送。HTTP协议中有一种被称为内容编码的功能也能进行类似的操作</p></li><li><p>内容编码指明应用在实体内容上的编码格式，并保持实体信息原样压缩。内容编码后的实体由客户端接收并负责解码</p></li><li><p>常用的内容编码有以下几种</p><ul><li><p>gzip（GNU zip）</p></li><li><p>compress（UNIX系统的标准压缩）</p></li><li><p>deflate（zlib）</p></li><li><p>identity（不进行编码）</p></li></ul></li></ul><h4 id="3-3-3-分割发送的分块传输编码"><a href="#3-3-3-分割发送的分块传输编码" class="headerlink" title="3.3.3 分割发送的分块传输编码"></a>3.3.3 分割发送的分块传输编码</h4><ul><li><p>在HTTP通信过程中，请求的编码实体资源尚未全部传输完成之前，浏览器无法显示请求页面。在传输大容量数据时，通过把数据分割成多块，能够让浏览器逐步显示页面。这种把实体主体分块的功能称为分块传输编码（Chunked TransferCoding）</p></li><li><p>分块传输编码会将实体主体分成多个部分（块）。每一块都会用十六进制来标记块的大小，而实体主体的最后一块会使用“0(CR+LF)”来标记</p></li><li><p>使用分块传输编码的实体主体会由接收的客户端负责解码，恢复到编码前的实体主体</p></li><li><p>HTTP&#x2F;1.1中存在一种称为传输编码（Transfer Coding）的机制，它可以在通信时按某种编码方式传输，但只定义作用于分块传输编码中</p></li><li><p>内容编码和分块传输编码的区别</p><ul><li><p>内容编码是为了压缩内容，减少体积</p></li><li><p>传输编码是为了切割发送的内容，它不但不会减少实体内容传输大小，甚至还会使传输变大</p></li></ul></li></ul><h3 id="3-4-发送多种数据的多部分对象集合"><a href="#3-4-发送多种数据的多部分对象集合" class="headerlink" title="3.4 发送多种数据的多部分对象集合"></a>3.4 发送多种数据的多部分对象集合</h3><ul><li><p>发送邮件时，我们可以在邮件里写入文字并添加多份附件。这是因为采用了MIME（Multipurpose Internet Mail Extensions，多用途因特网邮件扩展）机制，它允许邮件处理文本、图片、视频等多个不同类型的数据</p><ul><li><p>例如，图片等二进制数据以ASCII码字符串编码的方式指明，就是利用MIME来描述标记数据类型</p></li><li><p>MIME扩展中会使用一种称为多部分对象集合（Multipart）的方法，使得邮件容纳多份不同类型的数据</p></li></ul></li><li><p>HTTP协议中也采纳了多部分对象集合，发送的一份报文主体内可含有多类型实体。通常是在图片或文本文件等上传时使用</p></li><li><p>多部分对象集合包含的对象如下</p><ul><li><p>multipart&#x2F;form-data：在Web表单文件上传时使用</p></li><li><p>multipart&#x2F;byteranges：状态码206（Partial Content，部分内容）响应报文包含了多个范围的内容时使用</p></li></ul></li><li><p>multipart&#x2F;form-data示例</p><figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs http"><span class="hljs-keyword">POST</span> <span class="hljs-string">http://localhost/file</span> <span class="hljs-meta">HTTP/1.1</span><br><span class="hljs-attribute">Content-Type</span><span class="hljs-punctuation">: </span>multipart/form-data; boundary=AaB03x<br><br><span class="language-fortran">--AaB03x</span><br><span class="language-fortran">Content-Disposition: <span class="hljs-keyword">form</span>-<span class="hljs-keyword">data</span>; <span class="hljs-keyword">name</span>=<span class="hljs-string">&quot;field1&quot;</span></span><br><span class="language-fortran"></span><br><span class="language-fortran">Hello</span><br><span class="language-fortran">--AaB03x</span><br><span class="language-fortran">Content-Disposition: <span class="hljs-keyword">form</span>-<span class="hljs-keyword">data</span>; <span class="hljs-keyword">name</span>=<span class="hljs-string">&quot;file&quot;</span>; filename=<span class="hljs-string">&quot;index.txt&quot;</span></span><br><span class="language-fortran">Content-<span class="hljs-keyword">Type</span>: text/plain</span><br><span class="language-fortran"></span><br><span class="language-fortran">...(<span class="hljs-built_in">index</span>.txt content)</span><br><span class="language-fortran">--AaB03x--</span><br></code></pre></td></tr></table></figure></li><li><p>multipart&#x2F;byteranges示例</p><figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs http"><span class="hljs-meta">HTTP/1.1</span> <span class="hljs-number">206</span> Partial Content<br><span class="hljs-attribute">Date</span><span class="hljs-punctuation">: </span>Fri, 13 Jul 2012 02:45:26 GMT<br><span class="hljs-attribute">Last-Modified</span><span class="hljs-punctuation">: </span>Fri, 31 Aug 2007 02:02:20 GMT<br><span class="hljs-attribute">Content-Type</span><span class="hljs-punctuation">: </span>multipart/byteranges; boundary=THIS_STRING_SEPARATES<br>--THIS_STRING_SEPARATES<br><span class="hljs-attribute">Content-Type</span><span class="hljs-punctuation">: </span>application/pdf<br><span class="hljs-attribute">Content-Range</span><span class="hljs-punctuation">: </span>bytes 500-999/8000<br>...（范围指定的数据）...<br>--THIS_STRING_SEPARATES<br><span class="hljs-attribute">Content-Type</span><span class="hljs-punctuation">: </span>application/pdf<br><span class="hljs-attribute">Content-Range</span><span class="hljs-punctuation">: </span>bytes 7000-7999/8000<br>...（范围指定的数据）...<br>--THIS_STRING_SEPARATES--<br></code></pre></td></tr></table></figure></li><li><p>在HTTP报文中使用多部分对象集合时，需要在首部字段里加上Content-type。有关这个首部字段，我们稍后讲解</p></li><li><p>使用boundary字符串来划分多部分对象集合指明的各类实体。在boundary字符串指定的各个实体的起始行之前插入“–”标记（例如：–AaB03x、–THIS_STRING_SEPARATES），而在多部分对象集合对应的字符串的最后插入“–”标记（例如：–AaB03x–、–THIS_STRING_SEPARATES–）作为结束</p></li><li><p>多部分对象集合的每个部分类型中，都可以含有首部字段。另外，可以在某个部分中嵌套使用多部分对象集合。有关多部分对象集合更详细的解释，请参考RFC2046</p></li></ul><h3 id="3-5-获取部分内容的范围请求"><a href="#3-5-获取部分内容的范围请求" class="headerlink" title="3.5 获取部分内容的范围请求"></a>3.5 获取部分内容的范围请求</h3><ul><li><p>为了解决低带宽下载大文件容易中断而重头开始的情况，Http传输需要一种可恢复的机制。所谓恢复是指能从之前下载中断处恢复下载</p></li><li><p>要实现该功能需要指定下载的实体范围。像这样，指定范围发送的请求叫做范围请求（Range Request）</p></li><li><p>执行范围请求时，会用到首部字段Range来指定资源的byte范围。byte范围的指定形式如下</p><figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs http"><span class="hljs-attribute">Range</span><span class="hljs-punctuation">: </span>bytes=5001-10000<br><span class="hljs-attribute">Range</span><span class="hljs-punctuation">: </span>bytes=5001-<br><span class="hljs-attribute">Range</span><span class="hljs-punctuation">: </span>bytes=-3000, 5000-7000<br></code></pre></td></tr></table></figure></li><li><p>针对范围请求，响应会返回状态码为206 Partial Content的响应报文。另外，对于多重范围的范围请求，响应会在首部字段Content-Type标明multipart&#x2F;byteranges后返回响应报文</p></li><li><p>如果服务器端无法响应范围请求，则会返回状态码200 OK和完整的实体内容</p></li></ul><h3 id="3-6-内容协商返回最合适的内容"><a href="#3-6-内容协商返回最合适的内容" class="headerlink" title="3.6 内容协商返回最合适的内容"></a>3.6 内容协商返回最合适的内容</h3><ul><li><p>同一个Web网站有可能存在着多份相同内容的页面。比如英语版和中文版的Web页面，它们内容上虽相同，但使用的语言却不同。当浏览器的默认语言为英语或中文，访问相同URI的Web页面时，则会显示对应的英语版或中文版的Web页面。这样的机制称为内容协商（ContentNegotiation）</p></li><li><p>内容协商机制是指客户端和服务器端就响应的资源内容进行交涉，然后提供给客户端最为适合的资源。内容协商会以响应资源的语言、字符集、编码方式等作为判断的基准</p></li><li><p>包含在请求报文中的某些首部字段（如下）就是判断的基准</p><ul><li><p>Accept</p></li><li><p>Accept-Charset</p></li><li><p>Accept-Encoding</p></li><li><p>Accept-Language</p></li><li><p>Content-Language</p></li></ul></li><li><p>内容协商技术</p><ul><li><p>服务器驱动协商（Server-driven Negotiation）</p><ul><li><p>由服务器端进行内容协商</p></li><li><p>以请求的首部字段为参考，在服务器端自动处理</p></li><li><p>但对用户来说，以浏览器发送的信息作为判定的依据，并不一定能筛选出最优内容</p></li></ul></li><li><p>客户端驱动协商（Agent-driven Negotiation）</p><ul><li><p>由客户端进行内容协商的方式</p></li><li><p>用户从浏览器显示的可选项列表中手动选择。还可以利用JavaScript脚本在Web页面上自动进行上述选择。比如按OS的类型或浏览器类型，自行切换成PC版页面或手机版页面</p></li></ul></li><li><p>透明协商（Transparent Negotiation）</p><ul><li>是服务器驱动和客户端驱动的结合体，是由服务器端和客户端各自进行内容协商的一种方法</li></ul></li></ul></li></ul><h2 id="第四章-返回结果的HTTP状态码"><a href="#第四章-返回结果的HTTP状态码" class="headerlink" title="第四章 返回结果的HTTP状态码"></a>第四章 返回结果的HTTP状态码</h2><h3 id="4-1-状态码告知从服务器端返回的请求结果"><a href="#4-1-状态码告知从服务器端返回的请求结果" class="headerlink" title="4.1 状态码告知从服务器端返回的请求结果"></a>4.1 状态码告知从服务器端返回的请求结果</h3><ul><li><p>状态码的职责是当客户端向服务器端发送请求时，描述返回的请求结果。借助状态码，用户可以知道服务器端是正常处理了请求，还是出现了错误</p></li><li><p>状态码如200 OK，以3位数字和原因短语组成。数字中的第一位指定了响应类别，后两位无分类</p></li><li><p>响应类别有以下5种</p><p><img src="/image/%E5%9B%BE%E8%A7%A3HTTP/28387e95d3944882418b800289b70afb79a64d8d.jpeg" srcset="/image/theme/loading.gif" lazyload alt="epub_907764_62.jpeg"></p></li><li><p>仅记录在RFC2616上的HTTP状态码就达40种，若再加上WebDAV（Web-based Distributed Authoring and Versioning，基于万维网的分布式创作和版本控制）（RFC4918、5842）和附加HTTP状态码（RFC6585）等扩展，数量就达60余种。别看种类繁多，实际上经常使用的大概只有14种</p></li><li><p>只要遵守状态码类别的定义，即使改变RFC2616中定义的状态码，或服务器端自行创建状态码都没问题</p></li></ul><h3 id="4-2-2XX成功"><a href="#4-2-2XX成功" class="headerlink" title="4.2 2XX成功"></a>4.2 2XX成功</h3><ul><li><p>2XX的响应结果表明请求被正常处理</p></li><li><p>200 OK</p><ul><li><p>表示从客户端发来的请求在服务器端被正常处理了</p></li><li><p>在响应报文内，随状态码一起返回的信息会因方法的不同而发生改变</p><ul><li><p>比如，使用GET方法时，对应请求资源的实体会作为响应返回</p></li><li><p>而使用HEAD方法时，对应请求资源的实体主体不随报文首部作为响应返回（即在响应中只返回首部，不会返回实体的主体部分）</p></li></ul></li></ul></li><li><p>204 No Content</p><ul><li><p>该状态码代表服务器接收的请求已成功处理，但在返回的响应报文中不含实体的主体部分。另外，也不允许返回任何实体的主体</p><ul><li>比如，当从浏览器发出请求处理后，返回204响应，那么浏览器显示的页面不发生更新</li></ul></li><li><p>一般在只需要从客户端往服务器发送信息，而对客户端不需要发送新信息内容的情况下使用</p></li></ul></li><li><p>206 Partial Content</p><ul><li>该状态码表示客户端进行了范围请求，而服务器成功执行了这部分的GET请求。响应报文中包含由Content-Range指定范围的实体内容</li></ul></li></ul><h3 id="4-3-3XX重定向"><a href="#4-3-3XX重定向" class="headerlink" title="4.3 3XX重定向"></a>4.3 3XX重定向</h3><ul><li><p>3XX响应结果表明浏览器需要执行某些特殊的处理以正确处理请求</p></li><li><p>301 Moved Permanently</p><ul><li><p>永久性重定向。该状态码表示请求的资源已被分配了新的URI，以后应使用资源现在所指的URI</p><ul><li>也就是说，如果已经把资源对应的URI保存为书签了，这时应该按Location首部字段提示的URI重新保存</li></ul></li></ul></li><li><p>302 Found</p><ul><li><p>临时性重定向。该状态码表示请求的资源已被分配了新的URI，希望用户（本次）能使用新的URI访问</p></li><li><p>和301 Moved Permanently状态码相似，但302状态码代表的资源不是被永久移动，只是临时性质的</p><ul><li><p>换句话说，已移动的资源对应的URI将来还有可能发生改变</p></li><li><p>比如，用户把URI保存成书签，但不会像301状态码出现时那样去更新书签，而是仍旧保留返回302状态码的页面对应的URI</p></li></ul></li></ul></li><li><p>303 See Other</p><ul><li><p>该状态码表示由于请求对应的资源存在着另一个URI，应使用GET方法定向获取请求的资源</p></li><li><p>303状态码和302 Found状态码有着相同的功能，但303状态码明确表示客户端应当采用GET方法获取资源，这点与302状态码有区别</p></li><li><p>比如，当使用POST方法访问CGI程序，其执行后的处理结果是希望客户端能以GET方法重定向到另一个URI上去时，返回303状态码。虽然302 Found状态码也可以实现相同的功能，但这里使用303状态码是最理想的</p></li><li><p>本书采用的是HTTP&#x2F;1.1，而许多HTTP&#x2F;1.1版以前的浏览器不能正确理解303状态码。虽然RFC 1945和RFC 2068规范不允许客户端在重定向时改变请求的方法，但是很多现存的浏览器将302响应视为303响应，并且使用GET方式访问在Location中规定的URI，而无视原先请求的方法。所以作者说这里使用303是最理想的。——译者注</p></li></ul></li><li><p>当301、302、303响应状态码返回时，几乎所有的浏览器都会把POST改成GET，并删除请求报文内的主体，之后请求会自动再次发送。301、302标准是禁止将POST方法改变成GET方法的，但实际使用时大家都会这么做</p></li><li><p>304 Not Modified</p><ul><li><p>该状态码表示客户端发送附带条件的请求时，服务器端允许请求访问资源，但因发生请求未满足条件的情况后，直接返回304 Not Modified（服务器端资源未改变，可直接使用客户端未过期的缓存）</p></li><li><p>304状态码返回时，不包含任何响应的主体部分。304虽然被划分在3XX类别中，但是和重定向没有关系</p></li><li><p>附带条件的请求是指采用GET方法的请求报文中包含If-Match,If-Modified-Since,If-None-Match,If-Range,If-Unmodified-Since中任一首部</p></li></ul></li><li><p>307 Temporary Redirect</p><ul><li><p>临时重定向。该状态码与302 Found有着相同的含义。尽管302标准禁止POST变换成GET，但实际使用时大家并不遵守。307会遵照浏览器标准，不会从POST变成GET</p></li><li><p>但是，对于处理响应时的行为，每种浏览器有可能出现不同的情况</p></li></ul></li></ul><h3 id="4-4-4XX客户端错误"><a href="#4-4-4XX客户端错误" class="headerlink" title="4.4 4XX客户端错误"></a>4.4 4XX客户端错误</h3><ul><li><p>4XX的响应结果表明客户端是发生错误的原因所在</p></li><li><p>400 Bad Request</p><ul><li>该状态码表示请求报文中存在语法错误。当错误发生时，需修改请求的内容后再次发送请求。另外，浏览器会像200 OK一样对待该状态码</li></ul></li><li><p>401 Unauthorized</p><ul><li><p>该状态码表示发送的请求需要有通过HTTP认证（BASIC认证、DIGEST认证）的认证信息。另外若之前已进行过1次请求，则表示用户认证失败</p></li><li><p>返回含有401的响应必须包含一个适用于被请求资源的WWW-Authenticate首部用以质询（challenge）用户信息。当浏览器初次接收到401响应，会弹出认证用的对话窗口</p></li></ul></li><li><p>403 Forbidden</p><ul><li><p>该状态码表明对请求资源的访问被服务器拒绝了。服务器端没有必要给出拒绝的详细理由，但如果想作说明的话，可以在实体的主体部分对原因进行描述，这样就能让用户看到了</p></li><li><p>未获得文件系统的访问授权，访问权限出现某些问题（从未授权的发送源IP地址试图访问）等列举的情况都可能是发生403的原因</p></li></ul></li><li><p>404 Not Found</p><ul><li>该状态码表明服务器上无法找到请求的资源。除此之外，也可以在服务器端拒绝请求且不想说明理由时使用</li></ul></li></ul><h3 id="5XX服务器错误"><a href="#5XX服务器错误" class="headerlink" title="5XX服务器错误"></a>5XX服务器错误</h3><ul><li><p>5XX的响应结果表明服务器本身发生错误</p></li><li><p>500 Internal Server Error</p><ul><li>该状态码表明服务器端在执行请求时发生了错误。也有可能是Web应用存在的bug或某些临时的故障</li></ul></li><li><p>503 Service Unavailable</p><ul><li>该状态码表明服务器暂时处于超负载或正在进行停机维护，现在无法处理请求。如果事先得知解除以上状况需要的时间，最好写入Retry-After首部字段再返回给客户端</li></ul></li><li><p>不少返回的状态码响应都是错误的，但是用户可能察觉不到这点。比如Web应用程序内部发生错误，状态码依然返回200 OK，这种情况也经常遇到</p></li></ul><h3 id="第五章-与HTTP协作的Web服务器"><a href="#第五章-与HTTP协作的Web服务器" class="headerlink" title="第五章 与HTTP协作的Web服务器"></a>第五章 与HTTP协作的Web服务器</h3><h3 id="5-1-用单台虚拟主机实现多个域名"><a href="#5-1-用单台虚拟主机实现多个域名" class="headerlink" title="5.1 用单台虚拟主机实现多个域名"></a>5.1 用单台虚拟主机实现多个域名</h3><ul><li><p>HTTP&#x2F;1.1规范允许一台HTTP服务器搭建多个Web站点。比如，提供Web托管服务（Web Hosting Service）的供应商，可以用一台服务器为多位客户服务，也可以以每位客户持有的域名运行各自不同的网站。这是因为利用了虚拟主机（Virtual Host，又称虚拟服务器）的功能</p></li><li><p>即使物理层面只有一台服务器，但只要使用虚拟主机的功能，则可以假想已具有多台服务器</p></li><li><p>在相同的IP地址下，由于虚拟主机可以寄存多个不同主机名和域名的Web网站，因此在发送HTTP请求时，必须在Host首部内完整指定主机名或域名的URI</p><ul><li>客户端使用HTTP协议访问服务器时，会经常采用类似<a target="_blank" rel="noopener" href="http://www.hackr.jp这样的主机名和域名.在互联网上,域名通过dns服务映射到ip地址(域名解析)之后访问目标网站.可见,当请求发送到服务器时,已经是以ip地址形式访问了.所以,如果一台服务器内托管了www.tricorder.jp和www.hackr.jp这两个域名,当收到请求时就需要弄清楚究竟要访问哪个域名/">www.hackr.jp这样的主机名和域名。在互联网上，域名通过DNS服务映射到IP地址（域名解析）之后访问目标网站。可见，当请求发送到服务器时，已经是以IP地址形式访问了。所以，如果一台服务器内托管了www.tricorder.jp和www.hackr.jp这两个域名，当收到请求时就需要弄清楚究竟要访问哪个域名</a></li></ul></li></ul><h3 id="5-2-通信数据转发程序：代理、网关、隧道"><a href="#5-2-通信数据转发程序：代理、网关、隧道" class="headerlink" title="5.2 通信数据转发程序：代理、网关、隧道"></a>5.2 通信数据转发程序：代理、网关、隧道</h3><ul><li><p>HTTP通信时，除客户端和服务器以外，还有一些用于通信数据转发的应用程序，例如代理、网关和隧道。它们可以配合服务器工作。这些应用程序和服务器可以将请求转发给通信线路上的下一站服务器，并且能接收从那台服务器发送的响应再转发给客户端</p></li><li><p>代理：代理是一种有转发功能的应用程序，它扮演了位于服务器和客户端“中间人”的角色，接收由客户端发送的请求并转发给服务器，同时也接收服务器返回的响应并转发给客户端</p></li><li><p>网关：网关是转发其他服务器通信数据的服务器，接收从客户端发送来的请求时，它就像自己拥有资源的源服务器一样对请求进行处理。有时客户端可能都不会察觉，自己的通信目标是一个网关</p></li><li><p>隧道隧道是在相隔甚远的客户端和服务器两者之间进行中转，并保持双方通信连接的应用程序</p></li></ul><h4 id="5-2-1-代理"><a href="#5-2-1-代理" class="headerlink" title="5.2.1 代理"></a>5.2.1 代理</h4><ul><li><p>代理服务器的基本行为就是接收客户端发送的请求后转发给其他服务器。代理不改变请求URI，会直接发送给前方持有资源的目标服务器</p></li><li><p>持有资源实体的服务器被称为源服务器。从源服务器返回的响应经过代理服务器后再传给客户端</p></li><li><p>在HTTP通信过程中，可级联多台代理服务器。请求和响应的转发会经过数台类似锁链一样连接起来的代理服务器。转发时，需要附加Via首部字段以标记出经过的主机信息</p></li><li><p>每次通过代理服务器转发请求或响应时，会追加写入Via首部信息</p><p><img src="/image/%E5%9B%BE%E8%A7%A3HTTP/0bcecc352ffd1823bd40139f08c2607d9ac0d2cb.jpeg" srcset="/image/theme/loading.gif" lazyload alt="epub_907764_82.jpeg"></p></li><li><p>使用代理服务器的理由有：利用缓存技术（稍后讲解）减少网络带宽的流量，组织内部针对特定网站的访问控制，以获取访问日志为主要目的，等等</p></li><li><p>代理有多种使用方法，按两种基准分类。一种是是否使用缓存，另一种是是否会修改报文</p><ul><li><p>缓存代理</p><ul><li><p>代理转发响应时，缓存代理（Caching Proxy）会预先将资源的副本（缓存）保存在代理服务器上</p></li><li><p>当代理再次接收到对相同资源的请求时，就可以不从源服务器那里获取资源，而是将之前缓存的资源作为响应返回</p></li></ul></li><li><p>透明代理</p><ul><li><p>转发请求或响应时，不对报文做任何加工的代理类型被称为透明代理（Transparent Proxy）</p></li><li><p>反之，对报文内容进行加工的代理被称为非透明代理</p></li></ul></li></ul></li></ul><h4 id="5-2-2-网关"><a href="#5-2-2-网关" class="headerlink" title="5.2.2 网关"></a>5.2.2 网关</h4><ul><li><p>网关的工作机制和代理十分相似。而网关能使通信线路上的服务器提供非HTTP协议服务</p></li><li><p>利用网关能提高通信的安全性，因为可以在客户端与网关之间的通信线路上加密以确保连接的安全。比如，网关可以连接数据库，使用SQL语句查询数据。另外，在Web购物网站上进行信用卡结算时，网关可以和信用卡结算系统联动</p></li><li><p>利用网关可以由HTTP请求转化为其他协议通信</p><p><img src="/image/%E5%9B%BE%E8%A7%A3HTTP/0ad9b96be273bfb906eab58a39eb8a858fd7db1c.jpeg" srcset="/image/theme/loading.gif" lazyload alt="epub_907764_84.jpeg"></p></li></ul><h4 id="5-2-3-隧道"><a href="#5-2-3-隧道" class="headerlink" title="5.2.3 隧道"></a>5.2.3 隧道</h4><ul><li><p>隧道可按要求建立起一条与其他服务器的通信线路，届时使用SSL等加密手段进行通信。隧道的目的是确保客户端能与服务器进行安全的通信</p></li><li><p>隧道本身不会去解析HTTP请求。也就是说，请求保持原样中转给之后的服务器。隧道会在通信双方断开连接时结束</p></li><li><p>通过隧道的传输，可以和远距离的服务器安全通信。隧道本身是透明的，客户端不用在意隧道的存在</p><p><img src="/image/%E5%9B%BE%E8%A7%A3HTTP/3341e84011144464ac3467060e3d95aa48449b55.jpeg" srcset="/image/theme/loading.gif" lazyload alt="epub_907764_85.jpeg"></p></li></ul><h3 id="5-3-保存资源的缓存"><a href="#5-3-保存资源的缓存" class="headerlink" title="5.3 保存资源的缓存"></a>5.3 保存资源的缓存</h3><ul><li><p>缓存是指代理服务器或客户端本地磁盘内保存的资源副本。利用缓存可减少对源服务器的访问，因此也就节省了通信流量和通信时间</p></li><li><p>缓存服务器是代理服务器的一种，并归类在缓存代理类型中。换句话说，当代理转发从服务器返回的响应时，代理服务器将会保存一份资源的副本</p></li><li><p>缓存服务器的优势在于利用缓存可避免多次从源服务器转发资源。因此客户端可就近从缓存服务器上获取资源，而源服务器也不必多次处理相同的请求了</p></li></ul><h4 id="5-3-1-缓存的有效期限"><a href="#5-3-1-缓存的有效期限" class="headerlink" title="5.3.1 缓存的有效期限"></a>5.3.1 缓存的有效期限</h4><ul><li><p>即便缓存服务器内有缓存，也不能保证每次都会返回对同资源的请求。因为这关系到被缓存资源的有效性问题</p><ul><li><p>当遇上源服务器上的资源更新时，如果还是使用不变的缓存，那就会演变成返回更新前的“旧”资源了</p></li><li><p>即使存在缓存，也会因为客户端的要求、缓存的有效期等因素，向源服务器确认资源的有效性</p></li><li><p>若判断缓存失效，缓存服务器将会再次从源服务器上获取“新”资源</p></li></ul></li></ul><h4 id="5-3-2-客户端的缓存"><a href="#5-3-2-客户端的缓存" class="headerlink" title="5.3.2 客户端的缓存"></a>5.3.2 客户端的缓存</h4><ul><li><p>缓存不仅可以存在于缓存服务器内，还可以存在客户端浏览器中</p><ul><li><p>以InternetExplorer程序为例，把客户端缓存称为临时网络文件（Temporary InternetFile）</p></li><li><p>浏览器缓存如果有效，就不必再向服务器请求相同的资源了，可以直接从本地磁盘内读取</p></li><li><p>另外，和缓存服务器相同的一点是，当判定缓存过期后，会向源服务器确认资源的有效性。若判断浏览器缓存失效，浏览器会再次请求新资源</p></li></ul></li></ul></div><hr><div><div class="post-metas my-3"><div class="post-meta mr-3 d-flex align-items-center"><i class="iconfont icon-category"></i> <span class="category-chains"><span class="category-chain"><a href="/categories/%E7%AC%94%E8%AE%B0/" class="category-chain-item">笔记</a></span></span></div><div class="post-meta"><i class="iconfont icon-tags"></i> <a href="/tags/%E5%9F%BA%E7%A1%80%E4%BD%93%E7%B3%BB/">#基础体系</a></div></div><div class="license-box my-3"><div class="license-title"><div>【笔记】图解HTTP（上）</div><div>https://tivnantu.github.io/posts/751670d8</div></div><div class="license-meta"><div class="license-meta-item"><div>作者</div><div>tivnantu</div></div><div class="license-meta-item license-meta-date"><div>发布于</div><div>2022年4月4日</div></div><div class="license-meta-item"><div>许可协议</div><div><a target="_blank" href="https://creativecommons.org/licenses/by/4.0/"><span class="hint--top hint--rounded" aria-label="BY - 署名"><i class="iconfont icon-by"></i></span></a></div></div></div><div class="license-icon iconfont"></div></div><div class="post-prevnext my-3"><article class="post-prev col-6"><a href="/posts/48f3e75f" title="【笔记】图解HTTP（中）"><i class="iconfont icon-arrowleft"></i> <span class="hidden-mobile">【笔记】图解HTTP（中）</span> <span class="visible-mobile">上一篇</span></a></article><article class="post-next col-6"><a href="/posts/5ab5fb1f" title="【笔记】计算机是怎样跑起来的"><span class="hidden-mobile">【笔记】计算机是怎样跑起来的</span> <span class="visible-mobile">下一篇</span> <i class="iconfont icon-arrowright"></i></a></article></div></div></article></div></div></div><div class="side-col d-none d-lg-block col-lg-2"><aside class="sidebar" style="margin-left:-1rem"><div id="toc"><p class="toc-header"><i class="iconfont icon-list"></i> <span>目录</span></p><div class="toc-body" id="toc-body"></div></div></aside></div></div></div><a id="scroll-top-button" aria-label="TOP" href="#" role="button"><i class="iconfont icon-arrowup" aria-hidden="true"></i></a><div class="modal fade" id="modalSearch" tabindex="-1" role="dialog" aria-labelledby="ModalLabel" aria-hidden="true"><div class="modal-dialog modal-dialog-scrollable modal-lg" role="document"><div class="modal-content"><div class="modal-header text-center"><h4 class="modal-title w-100 font-weight-bold">搜索</h4><button type="button" id="local-search-close" class="close" data-dismiss="modal" aria-label="Close"><span aria-hidden="true">&times;</span></button></div><div class="modal-body mx-3"><div class="md-form mb-5"><input type="text" id="local-search-input" class="form-control validate"> <label data-error="x" data-success="v" for="local-search-input">关键词</label></div><div class="list-group" id="local-search-result"></div></div></div></div></div></main><footer><div class="footer-inner"><div class="footer-content"><i class="iconfont icon-code"></i> <i class="iconfont icon-love"></i> <i class="iconfont icon-books"></i></div><div class="statistics"><span id="busuanzi_container_site_pv" style="display:none">总访问量 <span id="busuanzi_value_site_pv"></span> 次 </span><span id="busuanzi_container_site_uv" style="display:none">总访客数 <span id="busuanzi_value_site_uv"></span> 人</span></div></div></footer><script src="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.js"></script><link rel="stylesheet" href="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.css"><script>NProgress.configure({showSpinner:!1,trickleSpeed:100}),NProgress.start(),window.addEventListener("load",function(){NProgress.done()})</script><script src="https://lib.baomitu.com/jquery/3.6.0/jquery.min.js"></script><script src="https://lib.baomitu.com/twitter-bootstrap/4.6.1/js/bootstrap.min.js"></script><script src="/js/events.js"></script><script src="/js/plugins.js"></script><script src="https://lib.baomitu.com/typed.js/2.0.12/typed.min.js"></script><script>!function(t){var e=Fluid.plugins.typing,t=t.getElementById("subtitle");t&&e&&e(t.getAttribute("data-typed-text"))}((window,document))</script><script src="/js/img-lazyload.js"></script><script>Fluid.utils.createScript("https://lib.baomitu.com/tocbot/4.18.2/tocbot.min.js",function(){var t,o=jQuery("#toc");0!==o.length&&window.tocbot&&(t=jQuery("#board-ctn").offset().top,window.tocbot.init(Object.assign({tocSelector:"#toc-body",contentSelector:".markdown-body",linkClass:"tocbot-link",activeLinkClass:"tocbot-active-link",listClass:"tocbot-list",isCollapsedClass:"tocbot-is-collapsed",collapsibleClass:"tocbot-is-collapsible",scrollSmooth:!0,includeTitleTags:!0,headingsOffset:-t},CONFIG.toc)),0<o.find(".toc-list-item").length&&o.css("visibility","visible"),Fluid.events.registerRefreshCallback(function(){var t;"tocbot"in window&&(tocbot.refresh(),0!==(t=jQuery("#toc")).length)&&tocbot&&0<t.find(".toc-list-item").length&&t.css("visibility","visible")}))})</script><script src="https://lib.baomitu.com/clipboard.js/2.0.11/clipboard.min.js"></script><script>Fluid.plugins.codeWidget()</script><script>Fluid.utils.createScript("https://lib.baomitu.com/anchor-js/4.3.1/anchor.min.js",function(){window.anchors.options={placement:CONFIG.anchorjs.placement,visible:CONFIG.anchorjs.visible},CONFIG.anchorjs.icon&&(window.anchors.options.icon=CONFIG.anchorjs.icon);var n,o=[];for(n of(CONFIG.anchorjs.element||"h1,h2,h3,h4,h5,h6").split(","))o.push(".markdown-body > "+n.trim());"left"===CONFIG.anchorjs.placement&&(window.anchors.options.class="anchorjs-link-left"),window.anchors.add(o.join(", ")),Fluid.events.registerRefreshCallback(function(){if("anchors"in window){anchors.removeAll();var n,o=[];for(n of(CONFIG.anchorjs.element||"h1,h2,h3,h4,h5,h6").split(","))o.push(".markdown-body > "+n.trim());"left"===CONFIG.anchorjs.placement&&(anchors.options.class="anchorjs-link-left"),anchors.add(o.join(", "))}})})</script><script>Fluid.utils.createScript("https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.js",function(){Fluid.plugins.fancyBox()})</script><script>Fluid.plugins.imageCaption()</script><script src="/js/local-search.js"></script><script defer src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><script src="/js/boot.js"></script><noscript><div class="noscript-warning">博客在允许 JavaScript 运行的环境下浏览效果更佳</div></noscript></body></html>