<!DOCTYPE html><html lang="zh-CN" data-default-color-scheme="light"><head><meta charset="UTF-8"><link rel="apple-touch-icon" sizes="76x76" href="/image/theme/favicon.png"><link rel="icon" href="/image/theme/favicon.png"><meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=5,shrink-to-fit=no"><meta http-equiv="x-ua-compatible" content="ie=edge"><meta name="theme-color" content="#2f4154"><meta name="author" content="tivnantu"><meta name="keywords" content="code"><meta name="description" content="curl命令行用法大览"><meta property="og:type" content="article"><meta property="og:title" content="【笔记】cURL必知必会"><meta property="og:url" content="https://tivnantu.github.io/posts/9f5d61d7"><meta property="og:site_name" content="tivnantu"><meta property="og:description" content="curl命令行用法大览"><meta property="og:locale" content="zh_CN"><meta property="og:image" content="https://tivnantu.github.io/image/cURL%E5%BF%85%E7%9F%A5%E5%BF%85%E4%BC%9A/cURL%E5%BF%85%E7%9F%A5%E5%BF%85%E4%BC%9A.jpg"><meta property="article:published_time" content="2021-12-29T03:24:01.000Z"><meta property="article:modified_time" content="2021-12-29T03:24:01.000Z"><meta property="article:author" content="tivnantu"><meta property="article:tag" content="工具详解"><meta name="twitter:card" content="summary_large_image"><meta name="twitter:image" content="https://tivnantu.github.io/image/cURL%E5%BF%85%E7%9F%A5%E5%BF%85%E4%BC%9A/cURL%E5%BF%85%E7%9F%A5%E5%BF%85%E4%BC%9A.jpg"><meta name="referrer" content="no-referrer-when-downgrade"><title>【笔记】cURL必知必会 &lt; tivnantu</title><link rel="stylesheet" href="https://lib.baomitu.com/twitter-bootstrap/4.6.1/css/bootstrap.min.css"><link rel="stylesheet" href="https://lib.baomitu.com/github-markdown-css/4.0.0/github-markdown.min.css"><link rel="stylesheet" href="https://lib.baomitu.com/hint.css/2.7.0/hint.min.css"><link rel="stylesheet" href="https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.css"><link rel="stylesheet" href="//at.alicdn.com/t/font_1749284_hj8rtnfg7um.css"><link rel="stylesheet" href="//at.alicdn.com/t/font_1736178_lbnruvf0jn.css"><link rel="stylesheet" href="/css/main.css"><link id="highlight-css" rel="stylesheet" href="/css/highlight.css"><link id="highlight-css-dark" rel="stylesheet" href="/css/highlight-dark.css"><script id="fluid-configs">var dntVal,Fluid=window.Fluid||{},CONFIG=(Fluid.ctx=Object.assign({},Fluid.ctx),{hostname:"tivnantu.github.io",root:"/",version:"1.9.4",typing:{enable:!0,typeSpeed:70,cursorChar:"",loop:!1,scope:[]},anchorjs:{enable:!0,element:"h1,h2,h3,h4,h5,h6",placement:"right",visible:"hover",icon:"§"},progressbar:{enable:!0,height_px:3,color:"#29d",options:{showSpinner:!1,trickleSpeed:100}},code_language:{enable:!0,default:"TEXT"},copy_btn:!0,image_caption:{enable:!0},image_zoom:{enable:!0,img_url_replace:["",""]},toc:{enable:!0,placement:"right",headingSelector:"h1,h2,h3,h4,h5,h6",collapseDepth:0},lazyload:{enable:!0,loading_img:"/image/theme/loading.gif",onlypost:!1,offset_factor:2},web_analytics:{enable:!1,follow_dnt:!0,baidu:null,google:null,gtag:null,tencent:{sid:null,cid:null},woyaola:null,cnzz:null,leancloud:{app_id:null,app_key:null,server_url:null,path:"window.location.pathname",ignore_local:!1}},search_path:"/local-search.xml"});CONFIG.web_analytics.follow_dnt&&(dntVal=navigator.doNotTrack||window.doNotTrack||navigator.msDoNotTrack,Fluid.ctx.dnt=dntVal&&(dntVal.startsWith("1")||dntVal.startsWith("yes")||dntVal.startsWith("on")))</script><script src="/js/utils.js"></script><script src="/js/color-schema.js"></script><meta name="generator" content="Hexo 6.3.0"></head><body><header><div class="header-inner" style="height:70vh"><nav id="navbar" class="navbar fixed-top navbar-expand-lg navbar-dark scrolling-navbar"><div class="container"><a class="navbar-brand" href="/"><strong>tivnantu</strong> </a><button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarSupportedContent" aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation"><div class="animated-icon"><span></span><span></span><span></span></div></button><div class="collapse navbar-collapse" id="navbarSupportedContent"><ul class="navbar-nav ml-auto text-center"><li class="nav-item"><a class="nav-link" href="/"><i class="iconfont icon-home-fill"></i> <span>首页</span></a></li><li class="nav-item"><a class="nav-link" href="/archives/"><i class="iconfont icon-archive-fill"></i> <span>归档</span></a></li><li class="nav-item"><a class="nav-link" href="/categories/"><i class="iconfont icon-category-fill"></i> <span>分类</span></a></li><li class="nav-item"><a class="nav-link" href="/tags/"><i class="iconfont icon-tags-fill"></i> <span>标签</span></a></li><li class="nav-item"><a class="nav-link" href="/about/"><i class="iconfont icon-user-fill"></i> <span>关于</span></a></li><li class="nav-item" id="search-btn"><a class="nav-link" target="_self" href="javascript:;" data-toggle="modal" data-target="#modalSearch" aria-label="Search"><i class="iconfont icon-search"></i></a></li><li class="nav-item" id="color-toggle-btn"><a class="nav-link" target="_self" href="javascript:;" aria-label="Color Toggle"><i class="iconfont icon-dark" id="color-toggle-icon"></i></a></li></ul></div></div></nav><div id="banner" class="banner" parallax="true" style="background:url(/image/cURL%E5%BF%85%E7%9F%A5%E5%BF%85%E4%BC%9A/curl.png) no-repeat center center;background-size:cover"><div class="full-bg-img"><div class="mask flex-center" style="background-color:rgba(0,0,0,.3)"><div class="banner-text text-center fade-in-up"><div class="h2"><span id="subtitle" data-typed-text="【笔记】cURL必知必会"></span></div><div class="mt-3"><span class="post-meta"><i class="iconfont icon-date-fill" aria-hidden="true"></i> <time datetime="2021-12-29 11:24" pubdate>2021年12月29日 上午</time></span></div><div class="mt-1"><span class="post-meta mr-2"><i class="iconfont icon-chart"></i> 42k 字 </span><span class="post-meta mr-2"><i class="iconfont icon-clock-fill"></i> 353 分钟 </span><span id="busuanzi_container_page_pv" style="display:none"><i class="iconfont icon-eye" aria-hidden="true"></i> <span id="busuanzi_value_page_pv"></span> 次</span></div></div></div></div></div></div></header><main><div class="container-fluid nopadding-x"><div class="row nomargin-x"><div class="side-col d-none d-lg-block col-lg-2"></div><div class="col-lg-8 nopadding-x-md"><div class="container nopadding-x-md" id="board-ctn"><div id="board"><article class="post-content mx-auto"><h1 style="display:none">【笔记】cURL必知必会</h1><div class="markdown-body"><div class="note note-success"><p>秉持着在实践中学习的想法，最近为了研究学习计算机网络哪一堆东西，前前后后学了不少 UNIX&#x2F;Linux 环境下一些网络工具（如 tcpdump、curl、tshark、nmap 等）的用法。</p><p>这份笔记摘录于丹尼尔·斯坦伯格的《cURL 必知必会》。这本书前前后后详细地介绍了 cURL 项目的内容（curl 命令行工具、libcurl 库），我对其中的 curl 命令行工具的用法较为感兴趣，特此总结出来笔记。</p><p>注意，《cURL 必知必会》为“手册”类型书籍，书中的描述已经极为精简干练毫不拖泥带水，基本上不需要我再进行修补裁剪。本笔记最大的目的是方便我自己以后检索查找。因此对于描写的已经很 ok 的原文，我就不班门弄斧进行修改，直接 copy 过来了，所以你常常可以看出来大段大段的原文句子。</p></div><h2 id="第一章-curl-可以做什么"><a href="#第一章-curl-可以做什么" class="headerlink" title="第一章 curl 可以做什么"></a>第一章 curl 可以做什么</h2><ul><li><p>curl 关心所有与网络协议传输相关的东西，那些与此无关的就留给其他项目和产品去操心吧。</p></li><li><p>curl 和 libcurl 试图避免直接处理被传输的数据。例如，它们对 HTML 或通过 HTTP 传输的内容一无所知，只知道如何通过 HTTP 传输这些数据。</p></li><li><p>curl 的一个常见使用场景是像浏览器那样获取 URL，但浏览器做的事情比 curl 要多得多，curl 在终端输出的内容可能与你在浏览器窗口中看到的内容完全不一样。</p></li><li><p>curl 只会获取你要求它获取的内容，但永远不会解析获取到的内容，也就是服务器发送的数据。</p></li><li><p>浏览器在获取数据后会根据内容类型激活不同的解析器。例如，如果数据是 HTML，那么它会进行解析并显示网页，还可能会下载其他子资源，如图像、JavaScript 和 CSS 文件。curl 在下载 HTML 时只会获取单个 HTML 资源，而在浏览器中，则可能会触发更多下载。如果你希望 curl 也下载子资源，那么需要将这些 URL 传给 curl 并要求它获取这些 URL，就像其他 URL 一样。</p></li></ul><h2 id="第二章-命令行基础"><a href="#第二章-命令行基础" class="headerlink" title="第二章 命令行基础"></a>第二章 命令行基础</h2><ul><li><p>curl 是一个可执行的二进制文件，但 cURL 项目本身不提供二进制文件。curl 的二进制文件需要根据不同的操作系统进行构建，而且通常受不同版本系统的约束。</p></li><li><p>curl 很少会自己决定做什么，它试图在最大程度上让你做自己想做的。你给它什么，它就会处理什么。如果你提供一个拼写错误的选项，那么它可能会做出预想不到的事情。如果你给它一个不合法的 URL，那么它仍然会继续处理它。</p></li><li><p>在 curl 的使用中，curl 只处理选项和 URL，也就是说，如果不是选项，就一定是 URL</p></li></ul><h3 id="2-1-命令行选项"><a href="#2-1-命令行选项" class="headerlink" title="2.1 命令行选项"></a>2.1 命令行选项</h3><ul><li><p>curl 支持 200 多个不同的选项。</p></li><li><p>命令行选项可以将你想要用 curl 执行的任务的信息传给 curl。</p></li></ul><h4 id="2-1-1-短选项"><a href="#2-1-1-短选项" class="headerlink" title="2.1.1 短选项"></a>2.1.1 短选项</h4><ul><li><p>短选项是只有一个字母的选项，一般也会提供对应的长选项</p></li><li><p><code>-v</code>：让 curl 切换到详细（verbose）模式</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">curl -v http://example.com<br></code></pre></td></tr></table></figure></li><li><p><code>-L</code>：使得 HTTP 重定向</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">curl -L http://example.com<br></code></pre></td></tr></table></figure></li><li><p>很多选项属于切换开关，用于启用某些功能或切换两个已知状态。</p></li><li><p>指定对应的选项名称即可使用这些选项。你也可以在减号后面组合使用多个单字母选项。当然，你也可以单独指定短选项。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">curl -vL http://example.com<br>curl -v -L http://example.com<br></code></pre></td></tr></table></figure></li><li><p>curl 的命令行解析器会解析整行命令，你可以将选项放在任意位置，它们甚至可以出现在 URL 之后。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">curl -v http://example.com<br>curl http://example.com -v<br></code></pre></td></tr></table></figure></li></ul><h4 id="2-1-2-长选项"><a href="#2-1-2-长选项" class="headerlink" title="2.1.2 长选项"></a>2.1.2 长选项</h4><ul><li><p>短选项使用起来非常方便，因为它们的名字很简短。但因为字母的数量有限，需要用到的选项又比较多，所以并非所有选项都可以使用单个字母来表示，于是就有了长选项。</p></li><li><p>另外，为了方便，也为了让脚本更易于阅读，大多数短选项都有对应的长选项别名。</p></li><li><p>长选项使用两个减号（或者称为破折号），后面跟上选项名，而且每两个减号后面只能跟一个选项名</p></li><li><p><code>--verbose</code>：打开详细模式</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">curl --verbose http://example.com<br></code></pre></td></tr></table></figure></li><li><p><code>--location</code>：使得 HTTP 重定向</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">curl --location http://example.com<br></code></pre></td></tr></table></figure></li></ul><h4 id="2-1-3-选项的参数"><a href="#2-1-3-选项的参数" class="headerlink" title="2.1.3 选项的参数"></a>2.1.3 选项的参数</h4><ul><li><p>并非所有选项都只用于启用或禁用某项功能。对于一些选项，你需要向它们传递一些数据，如用户名或文件路径。你需要先指定选项，然后给出参数，中间用空格分隔。</p></li><li><p><code>-d</code>或<code>--data</code>：可以通过 HTTP POST 将一个字符串发送给服务器</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">curl -d hello http://example.com<br>curl --data hello http://example.com<br></code></pre></td></tr></table></figure></li><li><p>如果使用带参数的短选项，可以不使用空格进行分隔</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">curl -dhello http://example.com<br></code></pre></td></tr></table></figure></li></ul><h4 id="2-1-4-带空格的参数"><a href="#2-1-4-带空格的参数" class="headerlink" title="2.1.4 带空格的参数"></a>2.1.4 带空格的参数</h4><ul><li><p>有时你会想要向选项传递参数，而且参数中包含了一个或多个空格。此时你需要给字符串加上引号。使用的引号因不同的 shell 或命令提示符而异，但大多数情况下可以使用双引号。</p></li><li><p><code>-A</code>：设置 HTTP 请求的 user-agent 字段</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">curl -A <span class="hljs-string">&quot;Hello World&quot;</span> http://example.com<br></code></pre></td></tr></table></figure></li><li><p>如果字符串本身包含了双引号，比如想要向服务器发送 JSON 字符串（这种情况很常见），你可能需要使用单引号（但在 Windows 系统上使用单引号可能不行）。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">curl -d <span class="hljs-string">&#x27;&#123;&quot;name&quot;: &quot;Darth&quot;&#125;&#x27;</span> http://example.com<br></code></pre></td></tr></table></figure></li><li><p>如果想要避免使用单引号，则可以通过文件将数据传给 curl，这样就无须使用额外的引用。</p></li></ul><h4 id="2-1-5-负选项"><a href="#2-1-5-负选项" class="headerlink" title="2.1.5 负选项"></a>2.1.5 负选项</h4><ul><li><p>对于开关选项，既可以用它们打开某些功能，也可以通过它们关闭功能。你也可以使用长选项，在选项名前面加上“no-”前缀即可。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 关闭详细模式</span><br>curl --no-verbose http://example.com<br></code></pre></td></tr></table></figure></li></ul><h3 id="2-2-URL"><a href="#2-2-URL" class="headerlink" title="2.2 URL"></a>2.2 URL</h3><ul><li><p>URL 就是 curl 的操作对象。</p></li><li><p>URL：Uniform Resource Locator，统一资源定位符</p></li><li><p>严格来说，URL 是之前使用的名称，URI（Uniform Resource Identifier，统一资源标识符）才是更现代、更正确的叫法。RFC 3986 给出了它们的语法定义。</p></li><li><p>curl 接受“URL”作为输入，但实际上是“URI”。curl 支持的大多数协议也有相应的 URI 语法文档，这些文档描述了这些 URI 格式的工作原理。</p></li><li><p>curl 假定你会传给它一个有效的 URL，它只对格式进行有限的检查，以提取执行操作所需要的信息。你可能会将包含非法字符的 URL 传给 curl，但 curl 并不会注意到，也不关心这些，它只会继续执行自己的操作。</p></li><li><p>现代 Web 浏览器的“地址栏”中一般使用的不是 URL 或 URI。实际上，它们主要使用 IRI，也就是 URI 的超集，以支持国际化（如支持非拉丁符号）。它们还会处理空格、编码地址等，但规范中并没有说明这些事情应该由客户端完成。有时你在浏览器地址栏中看到的内容与传给 curl 的内容存在很大差别。</p></li></ul><h4 id="2-2-1-scheme"><a href="#2-2-1-scheme" class="headerlink" title="2.2.1 scheme"></a>2.2.1 scheme</h4><ul><li><p>URL 以“scheme”作为开头，scheme 是“http:&#x2F;&#x2F;”这部分内容的官方名称，用于告诉 curl 传入的 URL 使用了哪个协议。</p></li><li><p>scheme 必须受当前 curl 版本支持，否则 curl 将显示错误消息并退出。此外，scheme 既不能以空格开头，也不能包含空格。</p></li><li><p>“:&#x2F;&#x2F;”（一个冒号和两个斜杠）将 scheme 标识符与 URL 的其余部分分开。有些 URL 只包含一个斜杠，但 curl 不支持这种格式</p></li><li><p>curl 允许一些非法语法，并尝试在内部纠正它们，因此它也可以理解并接受一些带有一个或三个斜杠的 URL，即使它们的格式不正确。curl 这么做的原因是，浏览器已经开始支持这些 URL，进而导致这种 URL 大量存在。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># file://类型的 URL 写作 file://&lt;hostname&gt;/&lt;path&gt;</span><br><span class="hljs-comment"># 但主机名部分只能是 localhost、127.0.0.1 或空白（什么都没有）</span><br><span class="hljs-comment"># 如果在主机名部分使用其他主机名，curl 将返回错误</span><br>file://localhost/path/to/file<br>file:///path/to/file<br></code></pre></td></tr></table></figure></li><li><p>为方便起见，curl 还允许用户省略 URL 的 scheme 部分</p><ul><li><p>curl 会根据主机名的第一部分猜测要使用哪种协议。这是一种非常基本的猜测，因为它只检查主机名的第一部分是否与一组协议中的某个协议匹配，并假定你打算使用的就是这个协议。</p></li><li><p>这主要基于传统的服务器命名方式。可以通过这种方式检测的协议包括 FTP、DICT、LDAP、IMAP、SMTP 和 POP3。没有提供 scheme 的其他 URL 将默认使用 HTTP。</p></li><li><p>可以通过<code>--proto-default</code>选项将默认协议修改为 HTTP 以外的其他协议。</p></li></ul></li><li><p><code>--proto-default</code>：将默认协议修改为 HTTP 以外的其他协议。</p></li></ul><h4 id="2-2-2-用户名和密码"><a href="#2-2-2-用户名和密码" class="headerlink" title="2.2.2 用户名和密码"></a>2.2.2 用户名和密码</h4><ul><li><p>scheme 后面可以跟用户名和密码。现在通常不建议使用这种语法，因为这样很容易在脚本或其他地方泄露这些信息。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 使用给定的用户名和密码列出 FTP 服务器目录中的内容</span><br>curl ftp://user:password@example.com/<br></code></pre></td></tr></table></figure></li><li><p>在 URL 中显示用户名和密码只是可选项，curl 还允许在 URL 之外，即通过正常的命令行选项来提供这些信息。</p></li></ul><h4 id="2-2-3-主机名或地址"><a href="#2-2-3-主机名或地址" class="headerlink" title="2.2.3 主机名或地址"></a>2.2.3 主机名或地址</h4><ul><li><p>URL 的主机名部分只是一个可以解析为数字 IP 地址的名字，或者是数字 IP 地址本身。</p></li><li><p>在指定数字 IP 地址时，可以使用 IPv4 地址。如果使用的是 IPv6 地址，则需要将其放在方括号中。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">curl http://127.0.0.1/<br>curl http://[::1]/<br></code></pre></td></tr></table></figure></li><li><p>如果使用的是主机名，系统解析器会将主机名转换为 IP 地址。这通常需要在&#x2F;etc&#x2F;hosts 文件（或等效文件）中进行本地域名查找。</p></li></ul><h4 id="2-3-4-端口号"><a href="#2-3-4-端口号" class="headerlink" title="2.3.4 端口号"></a>2.3.4 端口号</h4><ul><li>每个协议都有一个“默认端口”，除非特别指定了端口号。在 URL 中指定端口号时，先在主机名后面添加一个冒号，然后是十进制的端口号。</li></ul><h4 id="2-3-5-路径"><a href="#2-3-5-路径" class="headerlink" title="2.3.5 路径"></a>2.3.5 路径</h4><ul><li><p>每个 URL 都包含一个路径。如果没有指定，则默认使用“&#x2F;”。路径将被发送给指定的服务器，用于识别要请求的资源。路径的用法取决于具体的协议。</p></li><li><p>对于具有目录概念的协议，可以在 URL 尾部以一个斜杠表示它是目录，而不是文件。</p></li></ul><h4 id="2-3-6-FTP-类型"><a href="#2-3-6-FTP-类型" class="headerlink" title="2.3.6 FTP 类型"></a>2.3.6 FTP 类型</h4><ul><li><p>用于标识 FTP 服务器文件的 URL 提供了一个特性来告诉客户端（这里是 curl）资源的文件类型。这是因为 FTP 可以改变传输模式，在不同的模式下使用不同的处理方式。注意该特性没有被广泛使用</p></li><li><p>通过在 URL 中附加“; type&#x3D;A”，你可以告诉 curl 当前的 FTP 资源是 ASCII 类型。</p></li><li><p>curl 默认为 FTP 使用二进制传输模式，但是你也可以在 URL 中通过 type&#x3D;I 来指定二进制类型。</p></li><li><p>如果你传给 curl 的类型是 D，那么就是表明请求的资源是一个目录。这可以作为目录的替代格式，不需要像之前那样在路径尾部添加斜杠。</p></li><li><p>示例：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash">curl <span class="hljs-string">&quot;ftp://example.com/hello; type=A&quot;</span><br>curl <span class="hljs-string">&quot;ftp://example.com/hello; type=I&quot;</span><br>curl <span class="hljs-string">&quot;ftp://example.com/hello; type=D&quot;</span><br></code></pre></td></tr></table></figure></li></ul><h4 id="2-3-7-片段"><a href="#2-3-7-片段" class="headerlink" title="2.3.7 片段"></a>2.3.7 片段</h4><ul><li>URL 中还可以包含“片段”，这通常由井号（#）和网页中的特定名字组成。curl 可以支持带有片段的 URL，但实际上片段并不会被发送出去，因此，无论是否存在，它对 curl 的操作并没有任何影响。</li></ul><h4 id="2-3-8-多个选项和多个-URL"><a href="#2-3-8-多个选项和多个-URL" class="headerlink" title="2.3.8 多个选项和多个 URL"></a>2.3.8 多个选项和多个 URL</h4><ul><li><p>curl 支持数百个命令行选项和无限数量的 URL。如果你的 shell 或命令行系统能够支持，那么传给 curl 的命令行长度实际上是没有限制的。</p></li><li><p>curl 首先会解析整个命令行，应用给定的命令行选项，然后（按从左到右的顺序）遍历 URL 并执行相应操作。</p></li><li><p>对于某些选项（如告诉 curl 将输出内容保存在哪里的-o 或-O），你可能希望为每个 URL 单独指定。</p></li><li><p>curl 会在处理完最后一个 URL 后返回一个退出码。想让 curl 在第一次出现错误时就退出，则可以使用–fail-early 选项。</p></li><li><p><code>--fail-early</code>：在第一次出现错误时就退出</p></li></ul><h4 id="2-3-9-URL-的单独选项"><a href="#2-3-9-URL-的单独选项" class="headerlink" title="2.3.9 URL 的单独选项"></a>2.3.9 URL 的单独选项</h4><ul><li><p><code>-;</code>或<code>--next</code>：用于在一组选项和 URL 之间插入间隔</p></li><li><p>当命令行解析器遇到–next 选项时，它会将后面的选项应用于下一组 URL。因此，–next 选项其实是一组选项和 URL 之间的分隔符。使用多少个–next 选项取决于实际的需要。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 向一个 URL 发起 HTTP GET 请求</span><br><span class="hljs-comment"># 同时向另一个 URL 发起 HTTP POST 请求</span><br><span class="hljs-comment"># 然后向第三个 URL 发起 HEAD 请求</span><br>curl --location http://example.com --next \<br>     --data hello http://exampl.com --next \<br>     --<span class="hljs-built_in">head</span> http://example.com<br></code></pre></td></tr></table></figure></li></ul><h4 id="2-3-10-连接重用"><a href="#2-3-10-连接重用" class="headerlink" title="2.3.10 连接重用"></a>2.3.10 连接重用</h4><ul><li><p>curl 在内部维护着一个连接池，这可以让之前使用过的连接继续存活一段时间，因此后续发给相同主机的请求可以重用这些已经建立的连接。</p></li><li><p>连接池中的连接可以在 curl 运行期间保持活跃状态，但最好还是在同一个命令行中完成多次传输，而不是单独运行多个 curl 命令行。</p></li></ul><h3 id="2-4-URL-通配"><a href="#2-4-URL-通配" class="headerlink" title="2.4 URL 通配"></a>2.4 URL 通配</h3><ul><li><p>curl 提供了“通配”（globbing）的方式来指定一类大致相同小部分不同的 URL。不同的部分可能是一组数字或一组名字。</p></li><li><p>curl 使用保留符号 [] 和{}进行通配，它们一般不是合法 URL 的组成部分（IPv6 地址除外，但 curl 可以很好地处理它们）</p></li><li><p><code>-g</code>或<code>--globoff</code>：禁用通配</p></li><li><p>可以使用 [N-M] 语法来指定一个数值范围，其中 N 是起始索引，M 是结束索引（包括 M 在内）。表示数值范围的同时，还可以指定步进（step counter）</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash">curl http://example.com/[1-100].png<br>curl http://example.com/[001-100].png<br>curl http://example.com/[000-100:2].png<br></code></pre></td></tr></table></figure></li><li><p>curl 也可以用以上语法来表示字母范围</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">curl http://example.com/[a-z].html<br></code></pre></td></tr></table></figure></li><li><p>有时 URL 的不同部分不会遵循这些简单的模式，那么你可以指定完整的列表，但要放在花括号，而不是中括号中。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">curl http://example.com/&#123;one, two, three&#125;.html<br></code></pre></td></tr></table></figure></li><li><p>curl 可以在同一个 URL 中使用多个通配。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">curl http://example.com/&#123;one, two, three&#125;[1-100].jpg<br></code></pre></td></tr></table></figure></li><li><p><code>-O</code>或<code>--remote-name</code>：使用 URL 中的文件名来保存目标文件</p></li><li><p><code>-o</code>或者<code>--output</code>：指定下载文件的文件名</p></li><li><p>在下载多个文件时，可以通过 curl 的输出文件名变量，实现将它们保存到不同的子目录中，或者以不同的名称保存文件</p></li><li><p>URL 中的每个通配都对应一个单独的变量，可以通过 ’#[num]’ 来引用，即在’#’ 后面跟上与通配对应的数字，从 1（对应第一个通配）开始，以最后一个通配结束。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">curl http://example.com/&#123;one, two&#125;.html -o <span class="hljs-string">&quot;file_#1.html&quot;</span><br>curl http://&#123;site, host&#125;.host[1-5].example.com -o <span class="hljs-string">&quot;subdir/#1_#2&quot;</span><br></code></pre></td></tr></table></figure></li><li><p><code>-h</code>或<code>--help</code>：列出所有选项，并提供简要的说明</p></li><li><p><code>--manual</code>：输出 curl 的整个手册页以及常见的用例教程</p></li></ul><h3 id="2-5-配置文件"><a href="#2-5-配置文件" class="headerlink" title="2.5 配置文件"></a>2.5 配置文件</h3><ul><li><p>curl 提供了“配置文件”功能。它允许你将命令行选项写在文本文件中，然后告诉 curl，除了读取命令行外，还要从这个文件中读取命令行选项。</p></li><li><p><code>-K</code>或<code>--config</code>：告诉 curl 从特定文件中读取更多的命令行选项</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">curl -K cmdline.txt http://example.com<br></code></pre></td></tr></table></figure><p>cmdline.txt 示例：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs textile"># 注释<br>--location<br>--head<br></code></pre></td></tr></table></figure></li><li><p>配置文件可以接受短选项和长选项，就像你在命令行上写的那样。为了便于阅读，它还允许你使用不带破折号的长选项。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs textile">-v<br>location<br>head<br></code></pre></td></tr></table></figure></li><li><p>配置文件可以接受短选项和长选项，就像你在命令行上写的那样。为了便于阅读，它还允许你使用不带破折号的长选项。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">user-agent <span class="hljs-string">&quot;Hello World&quot;</span><br></code></pre></td></tr></table></figure></li><li><p>为了让配置文件看起来更像真正的配置文件，它还允许你在选项及其参数之间使用’&#x3D;’或’:’。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs textile">user-agent = &quot;Hello World&quot;<br></code></pre></td></tr></table></figure></li><li><p>选项的参数也可以不使用引号，curl 将下一个空格或换行视为当前参数的结尾。不过，如果参数中带有空格，则必须使用双引号。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs textile">user-agent = Hello-World<br></code></pre></td></tr></table></figure></li><li><p>如果想在配置文件中指定 URL，则必须使用–url 或 url，而且不会像在命令行中那样不是选项的所有东西都被视为 URL。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs textile">url = &quot;http://example.com&quot;<br>--url = &quot;http://example.com&quot;<br></code></pre></td></tr></table></figure></li><li><p>当被调用时，curl 会检查是否存在默认配置文件（除非使用了-q），如果存在，则使用这个配置文件。在类 Unix 系统上，它会查找.curlrc 文件，在 Windows 系统上则查找_curlrc 文件。查找顺序：</p><ul><li><p>尝试找到“主目录”：它先检查 CURL_HOME，然后是 HOME 环境变量。如果没有找到，它会在类 Unix 系统上调用 getpwuid()（这个函数将返回当前用户的主目录）。在 Windows 系统上，它会检查 APPDATA 变量，如果没找到就尝试“%USERPROFILE%\Application Data”。</p></li><li><p>在 Windows 系统上，如果主目录中没有_curlrc 文件，那么它会查找 curl 可执行文件所在的目录。在类 Unix 系统上，它只会尝试从主目录中加载．curlrc。</p></li></ul></li><li><p><code>-q</code>：禁用.curlrc</p></li></ul><h3 id="2-6-密码和窥探"><a href="#2-6-密码和窥探" class="headerlink" title="2.6  密码和窥探"></a>2.6 密码和窥探</h3><ul><li><p><code>-u</code>和<code>--user</code>：接受一个参数，即用冒号分隔的用户名和密码</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">curl -u admin:admin http://example.com<br></code></pre></td></tr></table></figure></li><li><p>首先，我们在命令行输入了密码，而命令行可能对同一系统上的其他用户是可见的（假设你使用的是多用户系统），这会导致信息的泄露。curl 会尝试从进程列表中清空密码来降低密码泄露的风险。</p></li><li><p>避免在命令行上指定用户名和密码的一种方法是使用.netrc 文件或配置文件。你也可以使用-u 选项，但不指定密码，curl 会在运行时提示用户输入密码。</p></li></ul><h3 id="2-7-进度指示器"><a href="#2-7-进度指示器" class="headerlink" title="2.7 进度指示器"></a>2.7 进度指示器</h3><ul><li><p>curl 有一个内置的进度指示器。当调用 curl 来传输数据（上传或下载）时，它可以在终端上显示传输的进度，比如当前的传输速率、已经用掉的时间以及还需要多长时间才能完成传输。</p></li><li><p>如果 curl 需要在终端上输出内容，那么进度指示器就会被禁用，否则进度指示器会干扰输出内容，把要显示的内容弄得一团糟。</p></li><li><p>如果调用 curl 时没有看到进度指示器，则需要确保输出已经被重定向到终端以外的位置。也就是说，当输出被定向到其他位置的时候，就可以看到对应的进度显示器</p></li><li><p><code>-s</code>或<code>--silent</code>：禁用进度指示器和错误信息</p></li><li><p>curl 还提供了一个更简单的进度指示器，可以通过-#或–progress-bar 来启用。正如其名字所暗示的那样，它使用进度条的方式来显示传输进度。</p></li><li><p><code>-#</code>或<code>--progress-bar</code>：启用简单的进度显示器，使用进度条的方式来显示传输进度。</p></li><li><p>有时候，在使用 curl 传输数据时，它无法确定请求对象的大小，因此进度指示器只包含很少量的细节，并且无法预测传输时间等其他信息。</p></li><li><p>进度指示器显示的是字节数和每秒字节数。对于很大的数据，它还会使用单位后缀，以 1024 为基础，因此 1024 是千字节（1K）,2048 是 2K，并以此类推。显示时间使用的是 H:MM:SS 格式，分别对应小时、分钟和秒。</p></li></ul><h2 id="第三章-使用-curl"><a href="#第三章-使用-curl" class="headerlink" title="第三章 使用 curl"></a>第三章 使用 curl</h2><ul><li>curl 支持或可以支持（需要进行构建）以下这些协议：DICT、FILE、FTP、FTPS、GOPHER、HTTP、HTTPS、IMAP、IMAPS、LDAP、LDAPS、POP3、POP3S、RTMP、RTSP、SCP、SFTP、SMB、SMTP、SMTPS、TELNET 和 TFTP。</li></ul><h3 id="3-1-详细模式"><a href="#3-1-详细模式" class="headerlink" title="3.1 详细模式"></a>3.1 详细模式</h3><ul><li><p>如果启用了详细（verbose）模式，curl 会显示更多信息，告诉你它正在做什么。它会用前缀’＊’来打印信息。</p></li><li><p>详细信息中的’(#0)’是 curl 为这个连接分配的内部数字。如果在同一命令行中指定多个 URL，那么你就会看到它将使用多个连接或重用已有的连接，因此连接的计数器可能会增加，也可能不会增加，具体取决于 curl 需要执行的操作。</p></li></ul><h4 id="3-1-1-–trace、–trace-ascii-和–trace-time"><a href="#3-1-1-–trace、–trace-ascii-和–trace-time" class="headerlink" title="3.1.1 –trace、–trace-ascii 和–trace-time"></a>3.1.1 –trace、–trace-ascii 和–trace-time</h4><ul><li><p>当 curl 使用 HTTPS、FTPS 或 SFTP 协议进行加密文件传输时，其他网络监视工具（如 Wireshark 或 tcpdump）将无法帮你保存完整的消息。为此，curl 在-v 之外又提供了两个选项。</p></li><li><p><code>--trace</code>：–trace [filename] 选项可以将完整的跟踪信息保存在指定的文件中，也可以使用’-’（单个减号）代替文件名，将内容打印到 stdout。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 命令执行完后，会生成一个叫作 dump 的文件，发送和接收的每个字节都以十六进制的数字显示出来。</span><br>curl --trace dump http://example.com<br>curl --trace - http://example.com<br></code></pre></td></tr></table></figure></li><li><p><code>--trace-ascii</code>：类似–trace，但是输出的详细内容不是十六进制的数字，而是 ascii 内容</p></li><li><p><code>--trace-time</code>：如果使用了这个选项，则所有的输出信息前面都会被加上高精度的时间戳。它可以与常规的-v 和–verbose 选项以及–trace 和–trace-ascii 选项一起使用。格式为小时：分钟：秒，然后是微秒。</p></li></ul><h4 id="3-1-2-–write-out"><a href="#3-1-2-–write-out" class="headerlink" title="3.1.2 –write-out"></a>3.1.2 –write-out</h4><ul><li><p><code>-w</code>或<code>--write-out</code>：在传输任务完成后打印一些信息，并且它还提供了大量可添加到输出内容中的变量，这些变量包含了与传输相关的信息。</p></li><li><p>如果将一个字符串传给这个选项，那么这个字符串就会被打印出来</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">curl -w <span class="hljs-string">&quot;Hello World&quot;</span> http://example.com<br></code></pre></td></tr></table></figure></li><li><p>如果在字符串前面加上‘@’，那么 curl 就会从指定文件中读取字符串。如果使用’-’作为文件名，那么 curl 就会从标准输入（stdin）读取字符串</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">curl -w @filename http://example.com<br>curl -w @- http://example.com<br></code></pre></td></tr></table></figure></li><li><p>可以使用’\n’输出新行，使用’\r’输出回车，使用’\t’输出制表符。</p></li><li><p>可以在字符串中加入%{variable_name}来访问可用的变量，然后这些变量会被替换成对应的值。如果要输出正常的’%‘，则需要写成’%%’。在 Windows 命令行中，%是一个特殊符号，在使用这个选项时，所有出现的%必须是成双的。</p><ul><li><p>%{content_type}显示所请求文档的 Content-Type（如果有的话）。</p><ul><li>%{filename_effective}显示 curl 最终写入内容的文件名。只有使用–remote-name 或–output 选项写入文件时，这个变量才有意义。它在与–remote-header-name 选项结合使用时最有用。</li></ul></li><li><p>%{ftp_entry_path}显示连接到远程 FTP 服务器时的初始路径。</p></li><li><p>%{response_code}显示最后一次传输返回的响应码。</p></li><li><p>%{http_connect}显示最后一次针对 CONNECT 请求的响应码（来自代理）。</p></li><li><p>%{local_ip}显示最近一次连接的本地 IP 地址——可以是 IPv4 或 IPv6 地址。</p></li><li><p>%{local_port}显示最近一次连接的本地端口号。</p></li><li><p>%{num_connects}显示最近一次传输建立的新连接的数量。</p></li><li><p>%{num_redirects}显示请求的重定向次数。</p></li><li><p>%{redirect_url}显示不使用-L 选项时的 HTTP 请求的重定向 URL。</p></li><li><p>%{remote_ip}显示最近一次连接的远程 IP 地址——可以是 IPv4 或 IPv6 地址</p></li><li><p>%{remote_port}显示最近一次连接的远程端口号。</p></li><li><p>%{size_download}显示已下载的总字节数。</p></li><li><p>%{size_header}显示已下载标头的总字节数。</p></li><li><p>%{size_request}显示 HTTP 请求发送的总字节数。</p></li><li><p>%{size_upload}显示已上传的总字节数。</p></li><li><p>%{speed_download}显示整个下载的平均速率，以字节&#x2F;秒为单位。</p></li><li><p>%{speed_upload}显示整个上传的平均速率，以字节&#x2F;秒为单位。</p></li><li><p>%{ssl_verify_result}显示请求的 SSL 对等证书验证结果，0 表示验证成功。</p><ul><li><p>%{time_appconnect}显示从开始到与远程主机建立 SSL（或 SSH 等）连接（或握手）所花费的时间，以秒为单位。</p></li><li><p>%{time_connect}显示从开始到与远程主机（或代理）建立 TCP 连接所花费的时间，以秒为单位。</p></li></ul></li><li><p>%{time_namelookup}显示从开始到完成域名解析所花费的时间，以秒为单位。</p><ul><li><p>%{time_pretransfer}显示从开始到文件传输即将开始所花费的时间，包括用于所有预传输命令以及与特定协议协的时间，以秒为单位。</p></li><li><p>%{time_redirect}显示所有重定向所花费的时间，包括在最终事务启动之前的域名查找、建立连接、预传输和传输以秒为单位。</p></li><li><p>%{time_starttransfer}显示从开始到第一个字节即将开始传输所花费的时间，包括 time_pretransfer 以及服器计算结果所需的时间，以秒为单位。</p></li></ul></li><li><p>%{time_total}显示整个操作持续的总时间，以秒为单位。时间将精确到毫秒。</p><ul><li>%{url_effective}显示最后获取的 URL。如果你要 curl 跟随重定向（使用-L 选项），那么这个变量就非常有用。</li></ul></li></ul></li></ul><h4 id="3-1-3-静默模式"><a href="#3-1-3-静默模式" class="headerlink" title="3.1.3 静默模式"></a>3.1.3 静默模式</h4><ul><li><p><code>-s</code>或<code>--silent</code>：可以打开静默模式，让 curl 关闭进度指示器，而且不会在发生错误时输出任何错误信息。与详细模式相反的是静默模式。静默模式仍然会输出你请求下载的数据。</p></li><li><p><code>-S</code>或<code>--show-error</code>：启用静默模式后，可以在发生错误时输出错误信息。</p></li></ul><h3 id="3-2-持久连接"><a href="#3-2-持久连接" class="headerlink" title="3.2 持久连接"></a>3.2 持久连接</h3><ul><li><p>在建立 TCP 连接时，curl 将保留旧连接一段时间，如果下一次要连接到同一主机，那么就可以重用相同的连接，从而节省大量时间。我们称之为持久连接。curl 将始终尝试保留连接，并尽可能重用现有连接。</p></li><li><p>不过，curl 命令行工具只能在运行期间保持连接处于活跃状态，因此，只要它退出，就会关闭所有已打开的连接（并且还会释放所有缓存）。我们将这种活跃连接池称为“连接缓存”。</p></li><li><p>如果需要针对同一主机或相同的 URL 执行 N 次传输或操作，那么你可以考虑使用尽可能少的 curl 命令行来提速，而不是每次使用一个 URL 并重复调用 curl。</p></li></ul><h3 id="3-3-下载"><a href="#3-3-下载" class="headerlink" title="3.3 下载"></a>3.3 下载</h3><ul><li><p>你可以通过 URL 来指定 curl 需要下载哪些资源。除非另有说明，否则 curl 默认下载 URL 指定的资源。URL 被分解为多个部分，curl 连接到正确的服务器，然后要求服务器提供特定的资源——通常是一个文件。然后，服务器开始传输数据，或者拒绝传输（客户端请求了错误的数据）。</p></li><li><p>对资源的请求与特定的协议相关，因此 FTP:&#x2F;&#x2F; URL 与 HTTP:&#x2F;&#x2F; URL 或 SFTP:&#x2F;&#x2F; URL 的工作方式不同。</p></li><li><p>对于不包含路径的 URL，即只包含主机名（比如前面的“<a target="_blank" rel="noopener" href="http://example.com”)/">http://example.com”）</a>, curl 将在内部为其添加一个斜杠（“&#x2F;”），然后它就变成了 curl 要从服务器请求的资源。</p></li><li><p>如果你在命令行中指定了多个 URL，那么 curl 将逐个下载所有 URL。在一个传输完成之前，它不会启动下一个（以及后面的）传输。</p></li><li><p>curl 会避免将二进制数据输出到终端，因为这会严重扰乱终端（有时甚至会导致终端停止运行）。可以使用-o 强制让它输出到 stdout。</p></li></ul><h4 id="3-3-1-下载文件的文件名"><a href="#3-3-1-下载文件的文件名" class="headerlink" title="3.3.1 下载文件的文件名"></a>3.3.1 下载文件的文件名</h4><ul><li><p>-O 选项从你提供的 URL 中提取文件名部分作为本地文件名。指定 URL 后，curl 从中选择文件名。即使发生重定向（而且你告诉 curl 要跟踪重定向）, curl 选择的文件名也不会发生变化。</p></li><li><p><code>-J</code>或<code>--remote-header-name</code>：HTTP 服务器可以选择在响应消息中提供 Content-Disposition 标头。这个标头可能包含服务器建议的文件名，通过该选项可以让 curl 使用这个名字作为本地文件名。</p></li><li><p>同时使用-O 和-J 选项，那么 curl 默认使用 URL 中的文件名，只有当响应消息中包含有效的 Content-Disposition 标头时，它才会使用建议的文件名。</p></li><li><p>-J 选项存在一些用户需要注意的问题和风险：</p><ul><li><p>它只会使用建议文件名的最右边部分，因此服务器建议的其他路径或目录都会被忽略。</p></li><li><p>因为文件名完全由服务器提供，所以，如果服务器恰好提供了与本地文件相同的文件名，那么 curl 将覆盖当前目录中已有的本地文件。</p></li><li><p>文件名编码和字符集问题。curl 不会对文件名进行编码，因此你可能会得到一个 URL 编码的文件名（如果是在浏览器中，那么浏览器会使用合理的字符集来解码 URL，将它还原成更易阅读的内容）。</p></li></ul></li></ul><h4 id="3-3-2-压缩"><a href="#3-3-2-压缩" class="headerlink" title="3.3.2 压缩"></a>3.3.2 压缩</h4><ul><li><p>curl 可以要求 HTTP 和 HTTPS 服务器提供压缩过的数据，并在收到数据后自动对其进行解压。</p></li><li><p>HTTP 压缩可以通过两种机制来实现，一种被认为是“正确的方式”，另一种在实际中使用得更为广泛：</p><ul><li><p>压缩 HTTP 内容的常用方法是使用 Content-Encoding 标头。</p></li><li><p>Transfer-Encoding 是一种比较罕见的方法，它是为自动压缩和解压而创建的一个标头，但并没有被广泛采用</p></li></ul></li><li><p><code>--compressed</code>：如果服务器支持压缩，它会传输压缩过的数据，curl 会在保存或发送到 stdout 前对数据进行解压。除了可能会注意到传输变得更快之外，用户并不会真正看到或感觉到压缩过程。–compressed 请求服务器使用一种受支持的压缩算法来压缩数据</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">curl --compressed http://example.com<br></code></pre></td></tr></table></figure></li><li><p><code>--tr-encoding</code>：让 curl 向服务器请求 Transfer-Encoding 压缩</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">curl --tr-cncoding http://example.com<br></code></pre></td></tr></table></figure></li><li><p>从理论上讲，你可以在同一个命令行中使用两种压缩方式。但在实践中，当被要求以两种方式进行压缩时，一些服务器可能会感到困惑。因此，只选择其中一种通常会更安全。</p></li></ul><h4 id="3-3-3-多个下载"><a href="#3-3-3-多个下载" class="headerlink" title="3.3.3 多个下载"></a>3.3.3 多个下载</h4><ul><li><p>当一个命令行中有多个 URL 的时候，每个 URL 都需要自己的“存储指令”。如果不提供“存储指令”, curl 会默认将数据发送到 stdout。</p></li><li><p>如果你要下载两个 URL 并只为第一个 URL 提供保存位置，那么第二个 URL 将被发送到 stdout，如下所示：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">curl -o one.txt http://example.com/1 http://example.com/2<br></code></pre></td></tr></table></figure></li><li><p>“存储指令”的读取和处理顺序与下载的 URL 的顺序相同，因此它们不一定要位于 URL 之后。你可以将所有输出选项放在最前面或最后面，或者与 URL 交错放置。以下写法是个等效的</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash">curl -o one.txt -o two.txt http://example.com/1 http://example.com/2<br>curl -o one.txt http://example.com/1 -o two.txt http://example.com/2<br>curl http://example.com/1 http://example.com/2 -o one.txt -o two.txt<br></code></pre></td></tr></table></figure></li><li><p><code>--remote-name-all</code>：让-O 成为所有给定 URL 的默认操作方式。你仍然可以为 URL 提供单独的“存储指令”，但对于没有提供单独“存储指令”的 URL，则默认使用-O 选项，而不是输出到 stdout。</p></li></ul><h4 id="3-3-4-速率限定"><a href="#3-3-4-速率限定" class="headerlink" title="3.3.4 速率限定"></a>3.3.4 速率限定</h4><ul><li><p>在传输数据时，curl 会尝试尽快完成任务。它的速度取决于几个因素，包括计算机的硬件配置、网络连接带宽、远程服务器的负载和延迟。</p></li><li><p><code>--limit-rate</code>：让 curl 的速率不超过指定的字节&#x2F;秒。速率限定的值可以包含一个后缀字母，K 表示千字节，M 表示兆字节，G 表示千兆字节。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">curl --limt-rate 200K http://example.com<br></code></pre></td></tr></table></figure></li><li><p>指定的限定速率是指整个传输过程的最大平均速率，也就是说，curl 有可能会在某些很短的时间段内使用高于指定速率的传输速率，但平均速率不会超过指定速率。curl 永远不会知道可能的最大速度是多少，它会在允许的范围内尽快完成传输。你可能会知道连接的最大速度，但 curl 不会。</p></li></ul><h4 id="3-3-5-最大文件"><a href="#3-3-5-最大文件" class="headerlink" title="3.3.5 最大文件"></a>3.3.5 最大文件</h4><ul><li><p><code>--max-filesize</code>：可以为 curl 指定可接受的最大下载字节数，如果 curl 可以在传输开始前确定文件的大小，那么它就会在尝试下载更大的文件之前终止传输。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">curl --max-filesize 1024 http://example.com<br></code></pre></td></tr></table></figure></li><li><p>在很多情况下，curl 无法在传输开始前确定文件大小，那么这个选项就不会产生任何影响，即使下载的内容可能大于指定的数量。</p></li></ul><h4 id="3-3-6-Metalink"><a href="#3-3-6-Metalink" class="headerlink" title="3.3.6 Metalink"></a>3.3.6 Metalink</h4><ul><li><p>Metalink 是一种文件描述标准，用于告诉客户端有多个位置保存了相同的内容。然后客户端可以选择从一个或多个位置下载内容。</p></li><li><p><code>--metalink</code>：curl 支持 Metalink 格式，你可以通过–metalink 选项来指定。指定的 URL 应该指向一个 Metalink 文件</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">curl --metalink http://example.com/example.metalink<br></code></pre></td></tr></table></figure></li><li><p>如果出现错误（如文件或服务器不可用）, curl 将使用 Metalink 文件中列出的镜像进行故障转移。下载完成后，它还会验证文件的散列。Metalink 文件会被下载到内存中，并在内存中进行处理，不会保存在本地文件系统中。</p></li></ul><h4 id="3-3-7-在文件系统中保存元数据"><a href="#3-3-7-在文件系统中保存元数据" class="headerlink" title="3.3.7 在文件系统中保存元数据"></a>3.3.7 在文件系统中保存元数据</h4><ul><li><p><code>--xattr</code>：告诉 curl 将某些文件元数据也保存在“扩展文件属性”中。这些扩展属性是保存在文件系统中的标准化的名称和值，前提是文件系统和操作系统支持扩展属性。</p></li><li><p>目前，URL 保存在 xdg.origin.url 属性中，HTTP 的 Content-Type 保存在 mime_type 属性中。如果指定了这个选项，但文件系统不支持扩展属性，则会发出警告。</p></li></ul><h4 id="3-3-8-–raw"><a href="#3-3-8-–raw" class="headerlink" title="3.3.8 –raw"></a>3.3.8 –raw</h4><ul><li><code>--raw</code>：禁用所有内部的 HTTP 内容解码或传输编码，取而代之的是传输未经修改的原始数据。</li></ul><h4 id="3-3-9-失败重试"><a href="#3-3-9-失败重试" class="headerlink" title="3.3.9 失败重试"></a>3.3.9 失败重试</h4><ul><li><p><code>--retry</code>：通常 curl 只会尝试执行一次传输，不成功则返回错误。你可以使用–retry 选项让 curl 重试失败的传输。</p></li><li><p><code>--retry-delay</code>：禁用指数退避算法，并设置自己的重试延迟。</p></li><li><p><code>--retry-max-time</code>：限制所有重试的总时间。</p></li><li><p><code>--max-time</code>：选项用于指定单个传输允许的最长时间。</p></li><li><p>如果尝试执行传输时返回临时错误，那么 curl 将在放弃之前重试指定的次数。如果将数字设为 0（默认值）, curl 将不会进行重试。临时错误可能是：超时、FTP 4xx 响应码或 HTTP 5xx 响应码。</p></li><li><p>curl 在开始重试传输前会先等待一秒，对于后续的重试，等待时间加倍，直到达到 10 分钟，然后剩余的重试延迟就是 10 分钟。–retry-delay 选项可以禁用这种指数退避算法，并设置自己的重试延迟</p></li></ul><h4 id="3-3-10-恢复下载和下载范围"><a href="#3-3-10-恢复下载和下载范围" class="headerlink" title="3.3.10 恢复下载和下载范围"></a>3.3.10 恢复下载和下载范围</h4><ul><li><p>在恢复下载时，curl 会先检查本地已存在的文件的大小，然后向服务器请求剩余的内容，并追加到本地文件中。curl 还允许指定自定义恢复点，这些恢复点对应的内容可能不存在于本地。</p></li><li><p><code>-C</code>或<code>--continu-at</code>：可以告诉 curl 从哪里开始传输，选项的值可以是一个普通的数字字节偏移量，或者使用字符串 - 让 curl 根据它所知道的信息自己决定从哪里开始传输。如果使用-，那么 curl 将基于目标文件确定本地已存在的数据量，并将其作为向服务器请求更多数据的偏移量。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 从字节偏移量为 100 的位置开始下载 FTP 文件</span><br>curl --continue-at 100 ftp://example.com/bigfile<br><span class="hljs-comment"># 继续之前中断的下载</span><br>curl --continue-at - ftp://example.com/bigfile<br></code></pre></td></tr></table></figure></li><li><p><code>--range</code>：向远程服务器请求特定字节范围的内容</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">curl --range 100-1000 ftp://example.com/bigfile<br></code></pre></td></tr></table></figure></li></ul><h3 id="3-4-上传"><a href="#3-4-上传" class="headerlink" title="3.4 上传"></a>3.4 上传</h3><ul><li><p>curl 支持一下上传协议：FILE、FTP、FTPS、HTTP、HTTPS、IMAP、IMAPS、SCP、SFTP、SMB、SMBS、SMTP、SMTPS 和 TFTP。</p></li><li><p><code>-T</code>：发送某个需要上传的文件：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">curl -T filename http://example.com<br></code></pre></td></tr></table></figure></li></ul><h4 id="3-4-1-HTTP-上传"><a href="#3-4-1-HTTP-上传" class="headerlink" title="3.4.1 HTTP 上传"></a>3.4.1 HTTP 上传</h4><ul><li><p>HTTP（和 HTTPS）提供了几种数据上传方式，而 curl 也为上传提供了简单的命令行选项，其中有三种常见的方式，后文将逐一介绍。</p></li><li><p>在 HTTP 中，上传也可以是下载，它们属于同一个操作。事实上，很多下载是通过 HTTP POST 开始的。</p></li><li><p>multipart formpost 通常用于涉及文件上传的 HTML 表单。这种类型的上传也属于 HTTP POST，但会根据一些特殊规则发送格式化的数据，因此被称为“multipart”。因为它以完全不同的方式发送格式化数据，所以你无法自己选择使用哪种类型的 POST，这完全取决于接收服务器期望和可以处理什么内容。详细内容请查看下一部分</p></li><li><p>上传类型 HTTP PUT 会发送一个完整的资源，并将其保持原样放在远程站点，甚至可以替换那里已有的资源。目前，PUT 是 Web 使用得最少的一种 HTTP 上传方式，而且大多数 Web 服务器并没有启用 PUT。</p></li></ul><h4 id="3-4-2-FTP-上传"><a href="#3-4-2-FTP-上传" class="headerlink" title="3.4.2 FTP 上传"></a>3.4.2 FTP 上传</h4><ul><li><p>在使用 FTP 时，你可以看到将要访问的远程文件系统。你可以准确地告诉服务器你想要在哪个目录放置上传文件以及要使用哪个文件名。如果你指定的 URL 尾部是一个斜杠，那么 curl 会将本地文件名附加到 URL 后面，这样它就变成了远程的文件名：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">curl -T filename ftp://example.com/<br>curl -T filename ftp://example.com/hello_filename<br></code></pre></td></tr></table></figure></li></ul><h4 id="3-4-3-SMTP-上传"><a href="#3-4-3-SMTP-上传" class="headerlink" title="3.4.3 SMTP 上传"></a>3.4.3 SMTP 上传</h4><ul><li><p>对于 curl 来说，发送电子邮件其实也是一种“上传”。你将邮件上传到 SMTP 服务器。在使用 SMTP 时，你需要在邮件中指定需要的标头（To:、From:、Date:等），因为 curl 不会自己添加这些东西。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">curl -T mail smtp://mail.example.com/ --mail-from user@example.com<br></code></pre></td></tr></table></figure></li></ul><h3 id="3-5-连接和超时"><a href="#3-5-连接和超时" class="headerlink" title="3.5 连接和超时"></a>3.5 连接和超时</h3><h4 id="3-5-1-主机名解析"><a href="#3-5-1-主机名解析" class="headerlink" title="3.5.1 主机名解析"></a>3.5.1 主机名解析</h4><ul><li><p>HTTP 客户端一般会通过 Host 标头告诉 HTTP 服务器它要连接到哪个服务器，因为通常同一个 HTTP 服务器实例会有多个名字，也就是有多个 A 或者 CNAME 记录，同时也可能会有多个站点。因此，将自定义的 Host 标头传给 curl，就可以让服务器返回目标站点的内容，即使没有使用目标站点的主机名进行连接。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 请求 www.example.com 的 index 页面</span><br>curl -H <span class="hljs-string">&quot;Host: www.example.com&quot;</span> http://localhost/<br></code></pre></td></tr></table></figure></li><li><p><code>-H</code>或<code>--header</code>：指定 HTTP 请求的 Header。</p></li><li><p>如果设置自定义的 Host 标头并使用 cookie，那么 curl 将提取自定义名称，并在匹配 cookie 时将其作为目标主机名。</p></li><li><p>与 HTTPS 服务器通信时，只使用 Host 标头是不够的。TLS 协议中有一个单独的扩展字段，称作 SNI（Server Name Indication，服务器名称指示），客户端用它来告诉服务器它想要与哪台服务器通信。curl 只会从指定的 URL 中提取 SNI。</p></li><li><p><code>--resolve</code>：为 curl 提供一个 IP 地址。将地址插入 curl 的 DNS 缓存中，以便 curl 相信那就是自己解析得到的地址。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 需要指定域名端口，以及对应的 ip 地址</span><br>curl --resolve example.com:80:127.0.0.1 http://example.com<br></code></pre></td></tr></table></figure></li><li><p>如果使用的是 HTTPS，那么将发送 URL 中的 SNI，并且 curl 会验证服务器端的响应，以确保使用的是 URL 中的名字。</p></li><li><p>可以指定多个–resolve 进行多个重定向，如果你的 URL 使用了 HTTP 重定向，或者你希望在命令行中使用多个 URL，那么这么做会很方便。</p></li><li><p><code>--connect-to</code>：–connect-to 选项提供了一个与–resolve 很相近的小变体。当需要连接特定主机名和端口时，可以通过这个选项为 curl 指定替换主机名和端口。它将源主机名和源端口重定向到目标主机名和目标端口。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">curl --connect-to example.com:80:localhost:9394 http://example.com<br></code></pre></td></tr></table></figure></li></ul><h4 id="3-5-2-基于-c-ares-库的域名解析"><a href="#3-5-2-基于-c-ares-库的域名解析" class="headerlink" title="3.5.2 基于 c-ares 库的域名解析"></a>3.5.2 基于 c-ares 库的域名解析</h4><ul><li><p>可以用不同的域名解析器库来构建 curl。其中一个库是 c-ares，如果用 c-ares 构建 curl，则可以获得一些额外的功能，比如，它能够更具体地指定使用哪些 DNS 服务器以及 DNS 流量如何使用网络。</p></li><li><p><code>--dns-servers</code>：指定 curl 使用的 DNS 服务器，而不是使用默认的那个。</p></li><li><p><code>--dns-ipv4-addr</code>和<code>--dns-ipv6-addr</code>：让 curl 将 DNS 通信的本地端“绑定”到特定的 IP 地址。</p></li><li><p><code>--dns-interface</code>：让 curl 为 DNS 请求使用特定的网络接口。</p></li></ul><h4 id="3-5-3-连接超时"><a href="#3-5-3-连接超时" class="headerlink" title="3.5.3 连接超时"></a>3.5.3 连接超时</h4><ul><li><p>curl 通常会与主机建立 TCP 连接，以作为网络传输的初始化部分。如果网络状况不稳定或远程服务器出现故障，TCP 连接可能会失败或速度很慢。要想减少对脚本或其他应用的影响，你可以为 curl 设置允许尝试连接的最长时间（以秒为单位）</p></li><li><p><code>--connect-timeoout</code>：设置 curl 允许尝试连接的最长时间，如果 curl 在指定时间内没有建立连接，则返回错误。建立连接前的所有必要步骤都必须在给定时间内完成。如果未能在给定时间内建立连接，curl 将抛出超时错误码（28）并退出。连接超时可以是亚秒精度的十进制值。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">curl --connect-timeout 2.781 https://example.com<br></code></pre></td></tr></table></figure></li><li><p>连接超时只能限制 curl 在建立连接前花费的时间，一旦成功建立 TCP 连接，则不再受这个时间的限制。如果指定较短的超时时间，则可能会影响 curl 连接远程服务器、慢服务器或通过不可靠网络访问的服务器。</p></li></ul><h4 id="3-5-4-网络接口和本地端口号"><a href="#3-5-4-网络接口和本地端口号" class="headerlink" title="3.5.4 网络接口和本地端口号"></a>3.5.4 网络接口和本地端口号</h4><ul><li><p>在具有多个网络接口并连接到多个网络的计算机上，有时你可以决定使用哪个网络接口来传出网络流量，或者在通信中使用哪个原始 IP 地址（在你拥有的多个 IP 地址之外）。</p></li><li><p><code>--interface</code>：可以告诉 curl 你希望将通信的本地端“绑定”到哪个网络接口、哪个 IP 地址或主机名</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash">curl --interface eth1 http://example.com<br>curl --interface 192.168.0.1 http://example.com<br>curl --interface machine1 http://example.com<br></code></pre></td></tr></table></figure></li><li><p>TCP 连接是在本地的 IP 地址和端口号与远程的 IP 地址和端口号之间建立起来的。你可以在 URL 中指定远程端口号，这样通常有助于识别目标服务。本地端口号通常由网络栈随机分配给 TCP 连接。在某些情况下，你会发现自己处于网络设备、防火墙或类似设备后面，它们对设置传出连接的源端口号施加了约束。对于这种情况，你可以指定 curl 使用哪个本地端口来绑定连接</p></li><li><p>你可以指定单个端口号或端口号区间。建议使用端口号区间，因为端口是稀缺资源，你想用的端口可能已经被占用。如果无法获取指定的本地端口号（或区间）, curl 将返回错误并退出。此外，在大多数操作系统上，如果没有更高权限（root），就无法绑定 1024 以下的端口号。如果可以避免，最好不要以 root 身份运行 curl。</p></li><li><p><code>--local-port</code>：指定本地端口号</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">curl --local-port 4000-4200 http://example.com/<br></code></pre></td></tr></table></figure></li></ul><h4 id="3-5-5-keepalive"><a href="#3-5-5-keepalive" class="headerlink" title="3.5.5 keepalive"></a>3.5.5 keepalive</h4><ul><li><p>空闲时，TCP 连接可以完全没有任何流量。因此，完全空闲的连接与因网络或服务器问题而过时的连接很难明显区分。现在很多网络设备（如防火墙或 NAT）都可以跟踪 TCP 连接，它们可以转换地址，阻止“错误的”传入数据包，等等。这些设备通常将空闲 N 分钟的连接视为已死亡，其中 N 因不同的设备而异，通常是 10 分钟，甚至更短。</p></li><li><p>避免慢连接（或空闲连接）被视为死亡并被错误杀死的其中一种方法是确保使用了 TCP 的 keepalive。keepalive 是 TCP 协议的一项特性，它会来回发送“ping 数据帧”，避免连接进入完全空闲的状态。它帮助空闲连接检测中断（即使在没有流量的情况下），并让中间系统不会认为连接已死亡。因此，curl 默认使用 TCP keepalive</p></li><li><p><code>--no-keepalive</code>：禁用 keepalive</p></li><li><p><code>--keepalive-time</code>：设置 keepalive 的间隔时间，默认是 60 秒</p></li></ul><h4 id="3-5-6-超时、允许的最长时间和允许的最慢速率"><a href="#3-5-6-超时、允许的最长时间和允许的最慢速率" class="headerlink" title="3.5.6 超时、允许的最长时间和允许的最慢速率"></a>3.5.6 超时、允许的最长时间和允许的最慢速率</h4><ul><li><p>网络操作本质上是不可靠的，甚至是脆弱的，因为它们依赖了一系列服务和网络。这些服务的可用性时有时无，性能也可能随着时间的推移发生很大变化。TCP 允许网络在很长一段时间内完全断开连接，传输的参与者不一定会注意到。这导致的结果就是有时网络传输需要很长时间。另外，curl 的大多数操作默认没有设置超时！</p></li><li><p><code>-m</code>或<code>--max-time</code>：在 curl 抛出超时错误码（28）并退出前，可以用-m 或–max-time 选项告诉 curl 最长有多少时间（以秒为单位）可用。当指定的时间耗尽，无论当时发生什么，curl 都会退出，即使它正在传输数据。</p></li><li><p>如果只能为 curl 设定固定的最长操作时间仍然不够灵活，特别是进行脚本传输且文件大小和传输时间变化非常大时，需要将固定超时时间设得很高，这样才能覆盖最坏的情况。</p></li><li><p><code>--speed-time</code>和<code>--speed-limit</code>：作为固定超时时间的替代方案，你可以告诉 curl，如果传输速率低于某个特定值，并且在某个时间段内一直低于这个值，那么就放弃传输。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 如果 15 秒内的传输速率低于 1000 字节/秒，则停止传输</span><br>curl --speed-tim 15 --speed-limit 1000 http://example.com<br></code></pre></td></tr></table></figure></li></ul><h3 id="3-6-netrc"><a href="#3-6-netrc" class="headerlink" title="3.6 netrc"></a>3.6 netrc</h3><ul><li><p>Unix 系统为用户提供了一种存储远程 FTP 服务器用户名和密码的方式，也就是 netrc 文件。FTP 客户端也一直支持这种方式，让用户可以快速登录到已知服务器，无须每次重新手动输入凭证。.netrc 文件通常保存在用户的主目录中。（在 Windows 系统上，curl 会查找一个名为_netrc 的文件。）</p></li><li><p>netrc 是一个已经广泛使用的概念，curl 也支持它。并且，curl 并没有将这项功能局限在 FTP 上，而是可以为任意协议获取凭证。</p></li><li><p>.netrc 的文件格式很简单：先在前面的行指定计算机名，后面的行是与该计算机相关的登录名和密码。主要是三部分：</p><ul><li><p>机器名：用于标识远程机器名。curl 在.netrc 文件中查找与 URL 中指定的远程机器匹配的名称节点。找到匹配的名称后再处理后续的.netrc 节点，直到到达文件末尾或遇到另一个机器名。</p></li><li><p>登录名：远程机器的用户名字符串。</p></li><li><p>密码字符串：登录远程机器的密码。如果存在这个节点，并且远程服务器要求使用密码登录，那么 curl 就会提供这个字符串。注意，如果.netrc 文件中存在这个节点，你需要确保这个文件不会被用户以外的人读取。</p></li></ul></li><li><p>假设主机名为 example.com，用户名为 hello，密码为 world，那么.netrc 的内容如下所示：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs textile">machine example.com<br>login hello<br>password world<br></code></pre></td></tr></table></figure></li><li><p><code>-n</code>或<code>--netrc</code>：告诉 curl 查找并使用.netrc 文件中的信息。</p></li><li><p><code>--netrc-file</code>：与–netrc 类似，只是你还额外提供了文件的实际路径。当你想要提供的信息位于另一个目录或者想要使用其他文件名时，这会非常有用。</p></li><li><p><code>--netrc-optional</code>：与–netrc 类似，只不过.netrc 文件是可选的。</p></li></ul><h3 id="3-7-代理"><a href="#3-7-代理" class="headerlink" title="3.7 代理"></a>3.7 代理</h3><ul><li><p>代理是代表客户端执行某项操作的机器或软件，类似中间人角色。</p></li><li><p>curl 支持几种不同类型的代理。默认代理类型是 HTTP，因此，如果指定没有 scheme（通常为 http:&#x2F;&#x2F;）的代理主机名（或 IP 地址），那么 curl 会假设它就是 HTTP 代理。curl 还提供了多个选项来设置代理类型，而不是使用 scheme 前缀。</p></li></ul><h4 id="3-7-1-PAC"><a href="#3-7-1-PAC" class="headerlink" title="3.7.1 PAC"></a>3.7.1 PAC</h4><ul><li><p>某些网络环境为不同场景提供了不同类型的代理，浏览器为此提供了一种名为“代理自动配置”（Proxy Auto Config, PAC）的定制化处理方式。</p></li><li><p>PAC 文件包含了一个 JavaScript 函数，用于决定给定的网络连接（URL）应该使用哪个代理，或者也可以不使用代理。通常浏览器通过一个 URL 从本地网络读取 PAC 文件。</p></li><li><p>因为 curl 不支持 JavaScript，所以也不支持 PAC 文件。如果你的浏览器和网络使用了 PAC 文件，最简单的办法是手动读取 PAC 文件，并找出需要指定给 curl 的代理。</p></li></ul><h4 id="3-7-2-HTTP-代理和-HTTPS-代理"><a href="#3-7-2-HTTP-代理和-HTTPS-代理" class="headerlink" title="3.7.2 HTTP 代理和 HTTPS 代理"></a>3.7.2 HTTP 代理和 HTTPS 代理</h4><ul><li><p>HTTP 代理是客户端用来通过 HTTP 完成传输的代理。默认情况下，curl 假设你使用-x 或–proxy 选项指定的主机就是 HTTP 代理。另外，除非你还指定了端口号，否则它将默认使用端口 3128（使用这个特定端口号纯粹是历史原因）。</p></li><li><p><code>-x</code>或<code>--proxy</code>：指定 HTTP 代理主机（和端口）</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 用主机 192.168.0.1 端口 8080 上的代理来请求 example.com 网页</span><br>curl -x 192.168.0.1:8080 http://example.com<br></code></pre></td></tr></table></figure></li><li><p>如果在与代理通信时通过-v 启用详细模式，你将看到 curl 连接的是代理而不是远程服务器，而且它使用了稍微不同的请求行。</p></li><li><p>HTTPS 旨在为客户端和服务器（以及后端）提供安全的端到端隐私。为了在使用 HTTP 代理时仍然能够提供这种安全隐私，HTTP 协议提供了一种特殊的请求，curl 可以用它设置一个通道，这个通道经过代理，并可以对流量进行加密和验证。这个 HTTP 方法就是 CONNECT。</p></li><li><p>用 CONNECT 方法设置好通道后，数据流经通道时就会被加密，代理在不破坏加密的情况下是无法查看或修改流量的</p></li></ul><h4 id="3-7-3-MITM-代理"><a href="#3-7-3-MITM-代理" class="headerlink" title="3.7.3 MITM 代理"></a>3.7.3 MITM 代理</h4><ul><li><p>MITM 是 Man-In-The-Middle（中间人）的简写。想要对 TLS 加密流量进行监控的公司通常会在“企业环境”和其他地方部署 MITM 代理。</p></li><li><p>MITM 要求用户在客户端安装自定义“信任根”（CA 证书），代理将会终结来自客户端的所有 TLS 流量，然后模拟远程服务器并充当代理。接下来，代理会返回由自定义 CA 签名的生成证书。这类代理通常会捕获从客户端发到远程计算机 TCP 443 端口的所有流量。在这样的网络中运行 curl 会导致其 HTTPS 流量被捕获。当然，这种做法为中间人窥探和解密 TLS 流量提供了机会。</p></li></ul><h4 id="3-7-4-非-HTTP-协议"><a href="#3-7-4-非-HTTP-协议" class="headerlink" title="3.7.4 非 HTTP 协议"></a>3.7.4 非 HTTP 协议</h4><ul><li><p>“HTTP 代理”意味着代理本身使用的是 HTTP 协议。HTTP 代理主要用于代理 HTTP 流量，但也支持其他协议，比如 FTP。</p></li><li><p>通过 HTTP 代理进行 FTP 传输意味着需要假装其他协议就像 HTTP 一样，然后要求代理“获取某个 URL”，即使这个 URL 不是基于 HTTP 的。这点很重要，因为这意味着通过 HTTP 代理发送流量时，即使指定了 FTP URL, curl 也不会真正使用 FTP，因此 FTP 的相关特性将不起作用</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">curl -x http://proxy.example.com:8080 ftp://ftp.example.com/file.txt<br></code></pre></td></tr></table></figure></li></ul><h4 id="3-7-5-HTTP-代理通道"><a href="#3-7-5-HTTP-代理通道" class="headerlink" title="3.7.5 HTTP 代理通道"></a>3.7.5 HTTP 代理通道</h4><ul><li><p><code>-p</code>或<code>--proxytunnel</code>：让 curl 穿过 HTTP 代理。</p></li><li><p>大多数 HTTP 代理允许客户端“穿过”它，到达另一端的服务器。通过 HTTP 代理执行 HTTPS 传输就是一个很好的示例。</p></li><li><p>通过代理执行 HTTPS 传输时，通常会连接到远程默认的 HTTPS TCP 443 端口。你会发现，大多数 HTTP 代理只允许连接到这个端口，或许还会有其他少数几个端口。大多数代理会拒绝客户端连接到随机端口上。不过，假设 HTTP 代理允许连接到随机端口，那么你可以要求它通过通道连接到远程服务器的任意端口，这样就可以“正常”使用其他协议。可以按照以下方式使用 FTP 通道：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">curl -p -x http://proxy.example.com:8080 ftp://ftp.example.com/file.txt<br></code></pre></td></tr></table></figure></li><li><p><code>--proxy1.0</code>：让 curl 在发送给 HTTP 代理的 CONNECT 请求中使用 HTTP&#x2F;1.0</p></li></ul><h4 id="3-7-6-SOCKS-类型代理"><a href="#3-7-6-SOCKS-类型代理" class="headerlink" title="3.7.6 SOCKS 类型代理"></a>3.7.6 SOCKS 类型代理</h4><ul><li><p>SOCKS 是一种代理协议，curl 支持 SOCKS 4 和 SOCKS 5，每种版本都有两种使用方法。</p></li><li><p>可以通过-x 选项指定 SOCKS 版本，对于这种情况，给定的代理主机的 scheme 部分就是 SOCKS 版本，你也可以使用单独的选项来指定。</p></li><li><p>与 SOCKS4 类似，但是 SOCKS4a 不在本地解析主机名，会将主机名发送给服务器。</p></li><li><p>与 SOCKS5 类似，但是 SOCKS5-hostname 不在本地解析主机名，会将主机名发送给服务器。</p></li><li><p>示例：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># SOCKS4</span><br>curl -x socks4://proxy.example.com http://example.com<br>curl --socks4 proxy.example.com http://example.com<br><span class="hljs-comment"># SOCKS4a</span><br>curl -x socks4a://proxy.example.com http://example.com<br>curl --socks4a proxy.example.com http://example.com<br><span class="hljs-comment"># SOCKS5</span><br>curl -x socks5://proxy.example.com http://example.com<br>curl --socks5 proxy.example.com http://example.com<br><span class="hljs-comment"># SOCKS5a</span><br>curl -x socks5h://proxy.example.com http://example.com<br>curl --socks5-hostname proxy.example.com http://example.com<br></code></pre></td></tr></table></figure></li></ul><h4 id="3-7-7-代理身份验证"><a href="#3-7-7-代理身份验证" class="headerlink" title="3.7.7 代理身份验证"></a>3.7.7 代理身份验证</h4><ul><li><p>HTTP 代理可以要求进行身份验证，因此 curl 需要向代理提供适当的凭证，否则代理将返回 407 HTTP 响应码。代理的身份验证与“普通”的 HTTP 身份验证非常相似，但它与服务器身份验证是分开的，这样客户端就可以单独使用常规的主机身份验证和代理身份验证。</p></li><li><p><code>-U</code>或<code>--proxy-user</code>：设置代理身份验证的用户名和密码</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">curl -U hello:world -x proxy.example.com:80 http://example.com<br></code></pre></td></tr></table></figure></li><li><p><code>--proxy-digest</code>和<code>--proxy-negotiate</code>和<code>--proxy-ntlm</code>：一些代理会要求使用另一种身份验证方案（代理在返回 407 响应码时会在标头中告诉你使用哪个方案），你可以用–proxy-digest、–proxy-negotiate、–proxy-ntlm 指定要使用的方法。</p></li><li><p><code>--proxy-anyauth</code>：你还可以让 curl 找出代理支持的认证方法，然后通过–proxy-anyauth 使用这些方法（可能需要发送额外的请求）。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">curl -U hello:world --proxy-anyauth -x proxy.example.com:80 http://example.com<br></code></pre></td></tr></table></figure></li></ul><h4 id="3-7-8-使用-HTTPS-连接代理"><a href="#3-7-8-使用-HTTPS-连接代理" class="headerlink" title="3.7.8 使用 HTTPS 连接代理"></a>3.7.8 使用 HTTPS 连接代理</h4><ul><li>前面提到的连接代理的所有协议都是明文协议，如 HTTP 和 SOCKS。使用这些方法将导致某些人可以通过代理所在的本地网络窃听你的流量。解决方案之一是使用 HTTPS 连接代理，从而建立一个安全的加密连接，这样就不容易被监视。</li></ul><h4 id="3-7-9-代理环境变量"><a href="#3-7-9-代理环境变量" class="headerlink" title="3.7.9 代理环境变量"></a>3.7.9 代理环境变量</h4><ul><li><p>curl 会在运行前检查是否存在某些特殊的环境变量，然后根据这些变量决定是否使用代理。可以通过设置 [scheme]_proxy 变量来指定代理（与用-x 指定主机名的方式相同）。因此，要想让 curl 访问 HTTP 服务器时使用代理，则需要设置 http_proxy 环境变量，如下所示：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">http_proxy=http://proxy.example.com:80<br>cur; http://example.com<br></code></pre></td></tr></table></figure></li><li><p>也可以设置 ftp_proxy、https_proxy，等等。除 http_proxy 外的所有环境变量名也可以是大写的，如 HTTPS_PROXY。还可以通过单个变量 ALL_PROXY 来设置所有的协议。如果存在某个特定的协议变量，则优先使用这个变量。</p></li><li><p>使用环境变量设置代理时，很容易遇到需要将一个或几个无须使用代理的主机名排除在外的情况。这个时候需要使用 NO_PROXY 变量。我们使用逗号分隔这些不需要使用代理的主机名。你也可以将 NO_PROXY 设置为单个星号（’＊’）以匹配所有主机。</p></li><li><p><code>--noproxy</code>：与 NO_PROXY 变量的作用相同。</p></li></ul><h3 id="3-8-退出状态"><a href="#3-8-退出状态" class="headerlink" title="3.8 退出状态"></a>3.8 退出状态</h3><ul><li><p>curl 在出现问题时返回一个可用的退出码，如果一切正常则返回 0（零）</p></li><li><p>可用的退出码列表：<a href="./curl%E5%8F%AF%E7%94%A8%E7%9A%84%E9%80%80%E5%87%BA%E7%A0%81.md">curl 可用的退出码</a></p></li><li><p>以非零状态码退出时，curl 还会输出一个错误消息（除非使用了–silent 选项）。这个错误消息可能会包含一些额外的信息，因此，相同的错误码可能会与不同的错误消息一起出现。</p></li><li><p>前面的状态码列表包含了很多标记为“未使用”的数字。这些状态码没有用于现在版本的 curl 中，但过去曾经被使用过或打算使用。它们很可能会用于未来的 curl 版本中。</p></li><li><p>另外，状态码列表中最大的错误状态码是 92，但这并不代表未来的 curl 版本不会在这个数字之后添加更多的退出码。</p></li></ul><h3 id="3-9-FTP"><a href="#3-9-FTP" class="headerlink" title="3.9 FTP"></a>3.9 FTP</h3><ul><li><p>FTP 出现在互联网和计算机的一个特殊时代，因此它的工作方式与大多数其他协议略有不同。如果一切运行正常，通常可以忽略这些差异，但如果出现异常，就很有必要了解这些差异了。</p></li><li><p>FTP 协议是一种命令和响应协议（ping-pong），客户端发送命令，服务器做出响应。对于普通的传输，需要发送 5～8 个命令，服务器则需要做出等量响应。如果服务器是在远程，那么开始传输文件前需要花很多时间在 ping-pong 上。对于较小的文件，初始化命令很可能比实际数据传输花费更长的时间。</p></li></ul><h4 id="3-9-1-传输模式"><a href="#3-9-1-传输模式" class="headerlink" title="3.9.1 传输模式"></a>3.9.1 传输模式</h4><ul><li><p>当 FTP 客户端开始传输数据时，它会向服务器指定要使用哪种“传输模式”。curl 支持的两种传输模式是“ASCII”和“BINARY”。ASCII 基本上用于文本，服务器将发送带有换行符的文件，而 BINARY 表示发送未经修改的数据，并假设要发送的文件不是文本文件。</p></li><li><p>curl 将默认使用 FTP 的 BINARY 传输模式，你可以通过-B、–use-ascii 选项或者以；type&#x3D;A 作为 URL 的结尾来切换到 ASCII 模式。</p></li><li><p><code>-B</code>或<code>--use-aciii</code>：对于 FTP 传输，切换为 ASCII 模式</p></li></ul><h4 id="3-9-2-身份验证"><a href="#3-9-2-身份验证" class="headerlink" title="3.9.2 身份验证"></a>3.9.2 身份验证</h4><ul><li><p>访问 FTP 通常需要用户名和密码，否则就无法访问。有些系统允许“匿名”访问，你可以使用自己喜欢的任意用户名和密码登录。</p></li><li><p>在使用 curl 进行 FTP 传输但没有指定用户名或密码的情况下，它将使用用户名 anonymous 和密码 <a href="mailto:&#x66;&#x74;&#x70;&#64;&#101;&#120;&#x61;&#109;&#x70;&#x6c;&#101;&#46;&#x63;&#111;&#109;">&#x66;&#x74;&#x70;&#64;&#101;&#120;&#x61;&#109;&#x70;&#x6c;&#101;&#46;&#x63;&#111;&#109;</a>。</p></li><li><p>要想提供其他用户名和密码，可以通过-u 或–user 选项将它们传给 curl，或者包含在 URL 中。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">curl -u hello:world ftp://example.com/download<br>curl ftp://hello:world@example.com/download<br></code></pre></td></tr></table></figure></li></ul><h4 id="3-9-3-建立连接"><a href="#3-9-3-建立连接" class="headerlink" title="3.9.3 建立连接"></a>3.9.3 建立连接</h4><ul><li><p>FTP 使用两个 TCP 连接！客户端在连接到 FTP 服务器时建立第一个连接，称作控制连接。作为初始连接，它将负责处理身份验证、切换到正确的远程服务器目录，等等。当客户端准备好传输文件时，第二个 TCP 连接将建立，并通过这个连接传输数据。因为各种原因，建立第二个连接会很麻烦。</p></li><li><p>建立用于数据传输的 TCP 连接有两种方式：主动连接和被动连接</p></li><li><p>客户端可以请求服务器回连到客户端来建立连接，即所谓的“主动”连接。这可以通过 PORT 或 EPRT 命令来完成。要想让远程主机回连到客户端端口，它们中间不能有防火墙或其他网络设备，但现实情况并非总是如此。</p></li><li><p><code>-P</code>或<code>--ftp-port</code>：请求进行主动传输。这个选项允许你指定要使用的地址，不过通常可以通过-P -指定当前的地址</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">curl -P - ftp://example.com/download<br></code></pre></td></tr></table></figure></li><li><p><code>--no-eprt</code>：可以通过–no-eprt 选项明确要求 curl 不使用 EPRT（这是一个比 PORT 略新的命令）。</p></li><li><p>curl 默认请求使用“被动”连接，它向服务器发送 PASV 或 EPSV 命令，服务器为第二个连接打开一个新端口，然后 curl 会连接到这个端口上。连接到新端口通常更加容易，对终端用户和客户端的限制也较少，但服务器端所在的网络必须允许这些连接。</p></li><li><p><code>--ftp-pasv</code>：默认情况下，curl 启用的是被动连接，但如果之前已启用了主动连接，可以使用–ftp-pasv 切换回被动连接。</p></li><li><p><code>--ftp-skip-pasv-ip</code>：有时候，因为服务器的一些奇怪设置，当 curl 发出 PASV 命令时，服务器会向 curl 返回一个 IP 地址，但这个地址可能是错误的，以至于 curl 无法建立数据连接。对于这种（很少见的）情况，你可以要求 curl 忽略 PASV 响应中返回的 IP 地址（–ftp-skip-pasv-ip），然后使用与控制连接相同的 IP 地址。</p></li></ul><h4 id="3-9-4-遍历目录"><a href="#3-9-4-遍历目录" class="headerlink" title="3.9.4 遍历目录"></a>3.9.4 遍历目录</h4><ul><li><p>在使用 FTP 命令遍历远程文件系统时，curl 可以通过几种不同的方式来访问目标文件，即用户想要传输的文件，分别为 multicwd、nocwd、singlecwd。</p></li><li><p><code>--ftp-method</code>：指定 FTP 访问文件的方法</p></li><li><p>mulicwd：curl 可以顺着文件树结构的每个目录执行一次更改目录命令（CWD）。如果完整路径是 one&#x2F;two&#x2F;three&#x2F;file.txt，那么请求传输 file.txt 文件前会执行三次 CWD 命令。因此，如果路径深度很深，则需要执行大量的 CWD 命令。早期规范（RFC 1738）强制要求使用这种方法，这也是 curl 的默认行为。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">curl --ftp-method multicwd ftp://example.com/one/two/three/file.txt<br></code></pre></td></tr></table></figure></li><li><p>nocwd：与为每个目录执行一次 CWD 命令相反的做法是不更改目录。这种方法请求服务器一次性使用整个路径，因此速度非常快。但有时在服务器上使用这种方法也会有问题，而且它并不符合标准。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">curl --ftp-method nocwd ftp://example.com/one/two/three/file.txt<br></code></pre></td></tr></table></figure></li><li><p>singlecwd：这种方法介于上述两种 FTP 方法之间。它会向目标目录发出一个 CWD 命令，然后请求指定的文件。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">curl --ftp-method singlecwd ftp://example.com/one/two/three/file.txt<br></code></pre></td></tr></table></figure></li></ul><h4 id="3-9-5-高级特性"><a href="#3-9-5-高级特性" class="headerlink" title="3.9.5 高级特性"></a>3.9.5 高级特性</h4><ul><li><p>你可以让 curl 列出远程 FTP 目录列表，只需要在 URL 末尾添加斜杠。如果 URL 以斜杠结尾，curl 会认为你要列出这个目录。如果它不是目录，你很可能会得到一个错误。</p></li><li><p><code>-l</code>或<code>--list-only</code>：在使用标准的 FTP 命令 LIST 列出目录时，返回的目录结构没有标准的格式。返回的列表通常是可以被人类理解的，但不同的服务器返回的列表结构稍有不同。要想列出目录中的所有内容并避免出现特殊格式，可以使用–list-only（或-l）选项。curl 会发出 FTP 命令 NLST。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">curl --list-only ftp://example.com/dir/<br></code></pre></td></tr></table></figure></li><li><p>NLST 也有一些奇怪的地方，有些 FTP 服务器在响应 NLST 命令时只列出文件部分，不包含目录和符号链接！</p></li><li><p><code>-T</code>或<code>--upload-file</code>：要想上传文件到 FTP 服务器，需要在 URL 中指定整个目标文件的路径和名字，并用-T 或–upload-file 选项指定要上传的本地文件。另外，如果目标 URL 以斜杠结尾，curl 会自动将本地路径中的文件名追加到 URL 中，并将其作为远程文件名。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">curl -T localfile ftp://example.com/dir/path/<br></code></pre></td></tr></table></figure></li><li><p>-T 参数支持通配。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">curl -T localfile[1-100] ftp://example.com/dir/path/<br></code></pre></td></tr></table></figure></li></ul><h3 id="3-10-SCP-和-SFTP"><a href="#3-10-SCP-和-SFTP" class="headerlink" title="3.10 SCP 和 SFTP"></a>3.10 SCP 和 SFTP</h3><ul><li><p>如果用第三方库 libssh2 来构建 curl，那么它就可以支持 SCP 和 SFTP 协议。</p></li><li><p>SCP 和 SFTP 都是建立在 SSH 之上的协议，SSH 是一种类似于 TLS 的安全加密数据协议，但在某些方面有所不同。例如，SSH 不使用任何类型的证书，而是使用公钥和私钥。如果使用得当，SSH 和 TLS 都可以提供强大的安全传输。（SCP 协议通常被认为是二者当中的“害群之马”，因为它的可移植性比较差，通常只能在 Unix 系统之间使用。）</p></li><li><p>SFTP 和 SCP 的 URL 与其他 URL 类似，使用这些协议下载文件的方式与其他协议差不多。如果 URL 尾部是斜杠，那么 SFTP（不是 SCP）可以获取文件列表。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">curl -u user sftp://example.com/file<br></code></pre></td></tr></table></figure></li><li><p>在使用 SFTP 或 SCP URL 请求文件时，给定的文件路径被视为远程服务器上的绝对路径，除非你特别指定要使用用户主目录的相对路径。你可以使用&#x2F;～&#x2F;来指定用户主目录的相对路径。这与 FTP URL 完全相反，因此容易导致用户混淆。</p></li><li><p>安全的网络客户端需要确保远程主机就是它要与之通信的主机。在使用基于 TLS 的协议时，这是通过客户端验证服务器的证书来实现的。SSH 协议不使用服务器证书，但每个服务器都需要提供唯一的密钥。而且与 TLS 不同的是，SSH 没有证书颁发机构，因此客户端需要确保主机的密钥与它已经知道的（通过其他方式获得的）信息相匹配。</p></li><li><p>密钥匹配通常需要用到密钥的散列和客户端用来保存已知服务器散列的文件，这个文件通常叫作 known_hosts，存放在专门的 SSH 目录中。在 Linux 系统上，通常是～&#x2F;.ssh 目录。</p></li><li><p>当连接到 SFTP 或 SCP 主机时，curl 会先确认主机的密钥散列已存在于已知主机的文件中，否则它将拒绝后续操作，因为它不相信现在连接的服务器就是真正的目标主机。如果 known_hosts 中存在正确的散列，curl 就会开始执行传输。</p></li><li><p><code>-k</code>或<code>--insecure</code>：要想强制 curl 跳过检查，可以使用-k 或–insecure 选项。在使用这两个选项时必须非常小心，因为这样有可能检测不到中间人的攻击。</p></li></ul><h3 id="3-11-IMAP-和-POP3"><a href="#3-11-IMAP-和-POP3" class="headerlink" title="3.11 IMAP 和 POP3"></a>3.11 IMAP 和 POP3</h3><ul><li><p>在互联网领域，从服务器读取或下载电子邮件（如果不把基于 Web 的读取方式算在内）的协议主要有两种，它们是 IMAP 和 POP3。前者稍微更加现代一些。curl 同时支持这两种协议。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 列出邮件编号和大小</span><br>curl pop3://mail.example.com/<br><span class="hljs-comment"># 下载邮件</span><br>curl pop3://mail.example.com/1<br><span class="hljs-comment"># 删除邮件</span><br>curl --reuqest pop3://mail.example.com/1<br></code></pre></td></tr></table></figure></li></ul><h3 id="3-12-SMTP"><a href="#3-12-SMTP" class="headerlink" title="3.12 SMTP"></a>3.12 SMTP</h3><ul><li><p>SMTP 是简单邮件传输协议（Simple Mail Transfer Protocol）的简写。curl 支持将数据发送到 SMTP 服务器，可以通过一系列命令行选项将电子邮件发送给指定的一组收件人。</p></li><li><p><code>--mail-rcpt</code>：通过该选项告诉服务器收件人的邮件地址（至少一个）。可以多次使用这个选项，curl 会告诉服务器所有指定的收件人都应该收到这封电子邮件。</p></li><li><p><code>--mail-from</code>：通过该选项告诉服务器哪个是发件人的邮件地址。这个电子邮件地址与显示在邮件正文中的 From：不一定相同。</p></li><li><p>使用 curl 发送 SMTP 时，以上两个命令行选项是必选项。然后，你需要提供要发送的电子邮件数据。它应该是一个使用 RFC 5322 指定格式的（文本）文件。它由一组标头和正文组成。标头和正文都需要进行正确编码。标头通常包括 To:、From:、Subject:、Date：等。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs bash">curl smtp://mail.example.com \<br> --mail-from myself@example.com \<br> --mail-rcpt receiver@example.com \<br> --upload-file email.txt<br></code></pre></td></tr></table></figure></li><li><p>有些邮件提供商允许或要求使用 SSL 进行 SMTP 传输。他们可能为 SSL 分配了专门的端口，或允许从明文连接升级到 SSL 连接。如果你的邮件提供商提供了专门的 SSL 端口，则可以用 smtps:&#x2F;&#x2F; 代替 smtp:&#x2F;&#x2F;，默认的 SMTP SSL 端口为 465，并且整个连接都是基于 SSL，如 smtps:&#x2F;&#x2F;smtp.gmail.com&#x2F;。</p></li><li><p><code>--ssl</code>：尝试使用 SSL&#x2F;TLS（FTP、IMAP、POP3、SMTP）。</p></li><li><p><code>--ssl-reqd</code>：要求使用 SSL&#x2F;TLS（FTP、IMAP、POP3、SMTP）。</p></li><li><p>如果你的提供商允许从明文升级到安全传输，则可以使用以上两个选项。</p></li><li><p>可以通过–ssl 选项让 curl 尝试但不一定要升级到安全传输：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs bash">curl --ssl smtp://mail.example.com<br> --mail-from myself@example.com \<br> --mail-rcpt receiver@example.com \<br> --upload-file email.txt<br></code></pre></td></tr></table></figure></li><li><p>也可以通过–ssl-reqd 选项让 curl 一定要升级到安全传输：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs bash">curl --ssl smtp://mail.example.com<br> --mail-from myself@example.com \<br> --mail-rcpt receiver@example.com \<br> --upload-file email.txt<br></code></pre></td></tr></table></figure></li><li><p>SMTP 请求的路径部分指定了与邮件服务器通信期间显示的主机名。如果省略了路径，那么 curl 将尝试使用本地计算机的主机名。不过，这样可能不会得到某些邮件服务器要求的完全限定名。你可以在路径中指定其他名字，例如计算机的完全限定名，完全限定名可以通过外部函数获取，例如 gethostname 或 getaddrinfo。</p></li><li><p>要想 curl 在 HELO 或 EHLO 命令中将 client.example.com 发送到邮件服务器 mail.example.com，参见以下方式：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">curl smtp://example.com/client.example.com<br></code></pre></td></tr></table></figure></li><li><p>用普通邮件客户端发送电子邮件时，它首先会检查目标域名的 MX 记录。如果向 <a href="mailto:&#106;&#x6f;&#x65;&#64;&#101;&#120;&#97;&#x6d;&#112;&#108;&#x65;&#46;&#x63;&#x6f;&#x6d;">&#106;&#x6f;&#x65;&#64;&#101;&#120;&#97;&#x6d;&#112;&#108;&#x65;&#46;&#x63;&#x6f;&#x6d;</a> 发送电子邮件，客户端将获取 example.com 的 MX 记录，以便找出向 example.com 发送电子邮件时需要用到的邮件服务器。</p></li><li><p>curl 本身不进行 MX 查找。如果想要指定向某个服务器发送电子邮件，需要先将它们找出来，然后在 curl 中指定这些服务器。</p></li></ul><h3 id="3-13-TLS"><a href="#3-13-TLS" class="headerlink" title="3.13 TLS"></a>3.13 TLS</h3><ul><li><p>TLS 是传输层安全（Transport Layer Security）的简写，这项技术之前叫作 SSL。不过 SSL 这个术语并没有真正消失，现在 TLS 和 SSL 这两个术语经常互换使用，实际上它们指的是同一个东西。TLS 是 TCP“之上”的一个加密安全层，基于强大的公钥加密和数字签名实现数据防篡改，并确保服务器的可靠性。</p></li><li><p>当 curl 连接到 TLS 服务器时，它们会协商如何使用协议，协商过程涉及一些参数和变量，双方需要在这些参数和变量上达成一致。</p></li><li><p>协商的其中一个参数是关于使用哪种加密算法，即所谓的密码。随着时间的推移，安全研究人员会发现现有密码存在缺陷和弱点，因此它们会逐渐被淘汰。</p></li><li><p><code>--ciphers</code>：可以通过-v 选项获得协商过程中确定的密码和 TLS 版本，也可以通过–ciphers 选项更改协商中优先使用的密码</p></li></ul><h4 id="3-13-1-启用-TLS"><a href="#3-13-1-启用-TLS" class="headerlink" title="3.13.1 启用 TLS"></a>3.13.1 启用 TLS</h4><ul><li><p>curl 支持很多协议的 TLS 版本。HTTP 有 HTTPS、FTP 有 FTPS、LDAP 有 LDAPS、POP3 有 POP3S、IMAP 有 IMAPS、SMTP 有 SMTPS。如果服务器端也支持，则可以在 curl 中使用这些协议的 TLS 版本。</p></li><li><p>启用 TLS 的方法有两种。</p><ul><li><p>一种是从第一次进行连接握手时就使用 TLS；</p></li><li><p>另一种是用协议特定指令将连接从明文“升级”到 TLS；</p></li></ul></li><li><p><code>--ssl</code>：尝试将非 TLS 连接升级到基于 TLS 的连接。</p></li><li><p><code>--ssl-reqd</code>：要求将非 TLS 连接升级到基于 TLS 的连接。</p></li><li><p>如果在 URL 中明确指定了协议的 TLS 版本（以“S”字符结尾）, curl 将尝试从一开始就建立 TLS 连接，而如果指定了非 TLS 版本，通常可以用–ssl 选项将连接升级到基于 TLS 的连接。</p></li><li><p>使用–ssl 选项意味着 curl 会尝试将连接升级到 TLS，但如果失败，它仍将继续使用明文协议来执行传输。如果一定要使用 TLS 连接，可以使用–ssl-reqd 选项，使用这个选项时，如果 curl 无法成功进行 TLS 协商，传输就会失败。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">curl --ssl-reqd ftp://ftp.example.com/file.txt<br></code></pre></td></tr></table></figure></li></ul><h4 id="3-13-2-SSL-和-TLS-版本"><a href="#3-13-2-SSL-和-TLS-版本" class="headerlink" title="3.13.2 SSL 和 TLS 版本"></a>3.13.2 SSL 和 TLS 版本</h4><ul><li><p>SSL 是在 20 世纪 90 年代中期发明并发展起来的。SSL 2 是第一个在互联网上广泛使用的版本，但很久以前就被认为是不安全的。然后就有了 SSL 3，但它也被认为不够安全。</p></li><li><p>TLS 1.0 是第一个“标准”。RFC 2246 于 1999 年发布。TLS 1.1 于 2006 年问世，此版进一步提高了安全性，然后是 2008 年的 TLS 1.2。十年来，TLS 1.2 一直是 TLS 的黄金标准。</p></li><li><p>2018 年 8 月，IETF 最终确定了 TLS 1.3（RFC 8446），并将其作为标准发布。这是迄今为止最安全、最快的 TLS 版本。但因为刚发布不久，很多软件、工具和库尚不支持它。</p></li><li><p>curl 默认使用 SSL&#x2F;TLS 的“安全版本”，也就是说，除非特别说明，否则它不会进行 SSL 2 或 SSL 3 协商。实际上，一些 TLS 库不再支持这些协议，因此，在很多情况下，除非你费了很大劲，否则 curl 甚至无法使用这些协议版本。</p></li></ul><h4 id="3-13-3-验证服务器证书和-CA-存储"><a href="#3-13-3-验证服务器证书和-CA-存储" class="headerlink" title="3.13.3 验证服务器证书和 CA 存储"></a>3.13.3 验证服务器证书和 CA 存储</h4><ul><li><p>如果不确定是否正在与正确的主机通信，那么就没有必要与服务器建立安全连接。如果不知道这一点，就有可能是在与一个冒名顶替者通信。为了确认是否与正确的 TLS 服务器通信，curl 会使用一组存储在本地的 CA 证书来验证服务器的证书签名。作为 TLS 握手的一部分，所有服务器都需要向客户端提供证书，并且所有使用 TLS 的公共服务器都会从证书颁发机构获取证书。</p></li><li><p><code>-k</code>或<code>--insecure</code>：降低安全级别。在极少数情况下，即使证书验证失败，你可能仍然希望与 TLS 服务器展开通信。如果是这样，则必须接受你的通信可能受到中间人攻击的事实。</p></li><li><p>curl 需要一个“CA 存储”（包含了一组 CA 证书）来验证 TLS 服务器。如果使用某个平台的“本地”TLS 库来构建 curl，那么这个库很可能使用了本地的 CA 存储。如果不是，那么必须让 curl 知道本地 CA 存储的位置，或者用户在调用 curl 时需要提供指向 CA 存储的路径。</p></li><li><p><code>--cacert</code>：指定要在 TLS 握手中使用的 CA 捆绑包，这个捆绑包需要采用 PEM 格式，也可以通过环境变量 CURL_CA_BUNDLE 设置捆绑包的完整路径。</p></li><li><p>在 Windows 上，没有用本地 TLS 库（Schannel）构建的 curl 需要按照一定顺序来查找和使用 CA 存储。curl 将按以下顺序在这些目录中搜索名为“curl-ca-bundle.crt”的 CA 证书文件。</p><ul><li><p>应用的目录。</p></li><li><p>当前工作目录。</p></li><li><p>Windows 系统目录（如 C:\windows\system32）。</p></li><li><p>Windows 目录（如 C:\windows）。</p></li><li><p>%PATH%中的所有目录。</p></li></ul></li></ul><h4 id="3-13-4-证书固定"><a href="#3-13-4-证书固定" class="headerlink" title="3.13.4 证书固定"></a>3.13.4 证书固定</h4><ul><li><p>TLS 证书固定用于验证签署服务器证书的公钥是否保持不变，即公钥是否是“固定”的。在进行 TLS 或 SSL 协商时，服务器会发送一个证明其身份的证书。如果从证书中提取的公钥与命令行给定的公钥不完全匹配，curl 将在开始发送或接收数据前中止连接。</p></li><li><p>可以为 curl 指定一个文件，让它从这个文件中读取 sha256 值，或者直接在命令行中用“sha256&#x2F;&#x2F;”前缀指定 base64 编码的散列。可以指定一个或多个这样的散列，用分号（;）分隔。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">curl --pinnedpubkey <span class="hljs-string">&quot;sha//&quot;</span> https://example.com<br></code></pre></td></tr></table></figure></li><li><p>并不是所有的 TLS 后端都支持这个特性。</p></li></ul><h4 id="3-13-5-OCSP-装订"><a href="#3-13-5-OCSP-装订" class="headerlink" title="3.13.5 OCSP 装订"></a>3.13.5 OCSP 装订</h4><ul><li><p>OCSP 装订是指通过 TLS 扩展（证书状态请求，Certificate Status Request）要求服务器在握手过程中提供新的“证据”，即返回的证书仍然有效。这是一种确保服务器证书未被撤销的方法。如果服务器不支持这个扩展，那么测试将会失败，curl 将返回错误。服务器不支持这种扩展的情况太常见了。</p></li><li><p><code>--cert-status</code>：要求在握手时使用装台请求</p></li><li><p>只有 OpenSSL、GnuTLS 和 NSS 后端支持这个特性。</p></li></ul><h4 id="3-13-6-客户端证书"><a href="#3-13-6-客户端证书" class="headerlink" title="3.13.6 客户端证书"></a>3.13.6 客户端证书</h4><ul><li><p>TLS 客户端证书是客户端以加密的方式向服务器证明自己就是真正对等方的一种方式。在命令行中指定证书和相应的密钥，然后在与服务器进行 TLS 握手时传递它们。密钥通常有密码保护，你需要提供密码或者以交互式的方式输入密码。</p></li><li><p><code>--cert</code>和<code>--key</code>：curl 提供了一些选项让你可以指定单个文件，这些文件既是客户端证书又是私钥（通过–cert 选项连接在一起），也可以用–key 单独指定密钥文件：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">curl --cert mycert:mypassword https://example.com<br>curl --cert mycert:mypassword --key mykey https://example.com<br></code></pre></td></tr></table></figure></li><li><p>对于某些 TLS 后端，也可以传递不同类型的密钥和证书：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash">curl --certmycert:mypassword --cert-type PEM \<br> --key mykey --key-type PEM<br> https://example.com<br></code></pre></td></tr></table></figure></li></ul><h2 id="第四章-用-curl-执行-HTTP-操作"><a href="#第四章-用-curl-执行-HTTP-操作" class="headerlink" title="第四章 用 curl 执行 HTTP 操作"></a>第四章 用 curl 执行 HTTP 操作</h2><h3 id="4-1-协议基础"><a href="#4-1-协议基础" class="headerlink" title="4.1 协议基础"></a>4.1 协议基础</h3><ul><li><p>每个 HTTP 请求都包含了一个方法，有时也被称为动词。最常用的方法是 GET、POST、HEAD 和 PUT。不过，通常不会在命令行中指定方法，具体使用哪个方法取决于使用的选项。默认方法是 GET, -d 或-F 选项对应 POST 方法，-I 对应 HEAD 方法，-T 对应 PUT 方法。</p></li><li><p><code>-G</code>或<code>--get</code>：使用 GET 方法。</p></li><li><p>-<code>d</code>或<code>--data</code>：使用 POST 方法。</p></li><li><p><code>-F</code>：使用 POST 方法。</p></li><li><p><code>-I</code>：使用 HEAD 方法。</p></li><li><p><code>-T</code>：使用 PUT 方法。</p></li><li><p>如果 HTTP URL 路径中包含&#x2F;..&#x2F;或&#x2F;.&#x2F;这样的字符串，curl 会在将路径发送到服务器前自动压缩它们，这些字符串的含义与本地文件系统中的路径含义是一样的。&#x2F;..&#x2F;前面的部分会被移除，因此&#x2F;hello&#x2F;sir&#x2F;..&#x2F;会变成&#x2F;hello&#x2F;, &#x2F;.&#x2F;会直接被移除，因此&#x2F;hello&#x2F;.&#x2F;sir&#x2F;会变成&#x2F;hello&#x2F;sir&#x2F;。</p></li><li><p><code>--path-as-is</code>：防止 curl 在将这些路径字符串发送到服务器前压缩它们</p></li></ul><h3 id="4-2-响应"><a href="#4-2-响应" class="headerlink" title="4.2 响应"></a>4.2 响应</h3><ul><li><p>当 HTTP 客户端与服务器进行 HTTP 对话时，服务器将返回 HTTP 响应消息，否则 curl 会认为服务器出了问题，然后返回 (52) 错误码，并显示错误消息“Emptyreply from server”。</p></li><li><p>HTTP 响应消息具有一定的大小，curl 需要知道它是多少。HTTP 响应消息的结束可以通过几种不同的方式来表示，其中最基本的方法是在消息中使用 Content-Length：标头，并在标头中指定响应正文的字节数。</p></li><li><p><code>--ignore-content-length</code>：一些早期的 HTTP 服务器在文件大小超过 2GB 时会有问题，并在 Content-Length：标头中发送负的字节数，或者发送错误的数据。可以通过–ignore-content-length 选项让 curl 完全忽略 Content-Length：标头。这样做可能会产生一些负作用，但至少可以获取到数据。</p></li><li><p>HTTP 响应消息的第一行有一个 3 位数的响应码。响应码是服务器用来告诉客户端它是如何处理请求的一种方式。注意，即使响应码表明无法获取所请求的文档（或类似情况）, curl 也不会将其视为错误。只要 HTTP 发送和接收成功，curl 都将其视为正常情况。</p></li><li><p>因为同一个 curl 传输中可能存在一个 HTTP 请求和一个 CONNECT 请求，所以我们通常需要将 CONNECT 响应（来自代理）与远程服务器的 HTTP 响应区分开。CONNECT 也是一个 HTTP 请求，因此它将获得相同数值范围的响应码，可以用–write-out 获取这个响应码。</p></li><li><p>HTTP 1.1 服务器可以进行“分块”编码响应，但 HTTP 1.0 不支持这种特性。在发送分块响应时，响应消息中不包含用于指示内容大小的 Content-Length：标头。相反，消息中包含了 Transfer-Encoding: chunked 标头，用于告诉 curl 后面还有其他数据块，数据将以一系列“块”的形式出现。每个数据块都以块的大小（十六进制）开头，然后是换行符，然后是块的内容。这个过程会一直重复，直到响应结束，并以大小为零的块作为结束。对于这种响应方式，客户端能够知道响应何时结束，即使服务器在开始发送数据之前不知道内容的大小。出现这种情况通常是因为响应是动态的，并且是在请求到来时生成的。当然，像 curl 这样的客户端会对块进行解码，并且不会向用户显示块大小。</p></li><li><p>与 HTTP 1.1 服务器通信时，可以让 curl 在不使用 Content-Length：标头的情况下发送请求正文。通过使用分块传输编码，curl 将逐块发送 POST 数据，每个数据块中会包含块的大小。</p></li><li><p>HTTP 响应消息能够以压缩的格式进行传输。服务器通常会在响应中包含 Content-Encoding:gzip 标头，以告诉客户端内容经过了压缩。在发送静态资源（提前进行压缩）或 CPU 资源大于带宽的情况下，使用压缩是很有意义的。</p></li><li><p><code>--compressed</code>：让 curl 请求压缩数据，并在接收 gzip（或 curl 可以理解的任意其他压缩算法）压缩的内容后自动对其进行解压</p></li><li><p>压缩是与传输编码一起使用的一个不太常见的特性。压缩本身是很常见的。随着时间的推移，前面提到的 Content-Encoding 已经成为 HTTP 压缩的主要方式。HTTP 最初的目的是允许将压缩作为传输编码，而 curl 也支持这个特性。客户端要求服务器进行压缩传输编码，如果服务器接受了，它将做出响应，并通过一个标头指明它将进行压缩编码，curl 将在接收到数据时对其进行解压。</p></li><li><p><code>--tr-encoding</code>：-请求服务器进行压缩传输编码</p></li><li><p>可以通过–raw 选项要求 curl 直接传递所收到的数据，不对齐进行解码</p></li></ul><h3 id="4-3-HTTP-身份验证"><a href="#4-3-HTTP-身份验证" class="headerlink" title="4.3 HTTP 身份验证"></a>4.3 HTTP 身份验证</h3><ul><li><p>每个 HTTP 请求都可以进行身份验证。如果服务器或代理希望用户证明他们具有访问某些 URL 或执行某些操作的凭证，则可以向客户端发送 HTTP 响应码，告诉客户端要在请求中提供正确的 HTTP 身份验证标头。</p></li><li><p>需要身份验证的服务器会发回 401 响应码和 WWW-Authenticate：标头，这个标头列出了服务器支持的所有身份验证方法。</p></li><li><p>需要身份验证的 HTTP 代理会发回 407 响应码和 Proxy-Authenticate：标头，这个标头列出了代理支持的所有身份验证方法。</p></li><li><p>需要注意的是，现在的大多数网站在登录时都不使用 HTTP 身份验证，但会要求用户登录网页，浏览器会发出带有用户名和密码等信息的 POST 请求，然后为会话保持 cookie。</p></li><li><p>要让 curl 发出带有身份验证的 HTTP 请求，可以用-u 或–user 选项提供用户名和密码（用冒号分隔）</p></li><li><p>curl 将使用默认的“Basic” HTTP 身份验证方法。这个方法确实非常基础。</p></li><li><p><code>--basic</code>：明确指定使用“Basic”HTTP 身份验证方法</p></li><li><p>因为 Basic 身份验证方法通过网络（经过 base64 编码）发送明文的用户名和密码，所以应该避免在 HTTP 传输中使用这种方法。</p></li><li><p>当被要求用（指定或隐含的）单个身份验证方法进行 HTTP 传输时，curl 将在第一个请求中插入身份验证标头。</p></li><li><p><code>--anyauth</code>：如果要让 curl 先确认服务器是否真的需要身份验证，可以使用–anyauth 选项，它会自动使用 curl 所知道的最安全的身份验证方法。curl 将尝试无须身份验证的请求，然后在必要时使用身份验证：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">curl --anyauth --user hello:world http://example.com<br></code></pre></td></tr></table></figure></li><li><p>curl 通常（取决于它是如何构建的）也支持其他几种身份验证方法，包括 Digest、Negotiate 和 NTLM。</p></li></ul><h3 id="4-4-HTTP-区间"><a href="#4-4-HTTP-区间" class="headerlink" title="4.4 HTTP 区间"></a>4.4 HTTP 区间</h3><ul><li><p>HTTP 允许客户端请求特定区间的数据。客户端可以向服务器请求起始偏移量和结束偏移量区间内的数据。它甚至可以在同一个请求中请求几个区间内的数据，并进行组合让这些片段并排发回。服务器发回多个独立的片段作为响应，并用 mime 边界字符串进行分隔，如何处理它们取决于用户的应用。curl 不会进一步对这样的响应进行分隔。</p></li><li><p>不过，获取数据区间也只是对服务器的一种请求。服务器不一定会满足所有这样的请求，在很多情况下，例如服务器动态生成内容时，它将拒绝执行这种区间请求，而是返回完整的内容。</p></li><li><p><code>-r</code>或<code>--range</code>：让 curl 发起区间请求。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">curl -r 0-199 http://example.com<br>curl -r 0-199,1000-1999 http://example.com<br></code></pre></td></tr></table></figure></li></ul><h3 id="4-5-HTTP-版本"><a href="#4-5-HTTP-版本" class="headerlink" title="4.5 HTTP 版本"></a>4.5 HTTP 版本</h3><ul><li><p>从 2016 年年中开始，curl 默认用 HTTP&#x2F;1.1 连接 HTTP 服务器。如果要连接到 HTTPS 服务器，并且你的 libcurl 内置了 HTTP&#x2F;2 功能，那么 curl 将尝试使用 HTTP&#x2F;2，或在协商失败时降级至 HTTP&#x2F;1.1。默认情况下，不支持 HTTP&#x2F;2 的 curl 将使用 HTTP&#x2F;1.1。</p></li><li><p>如果默认值对于你来说还不够好，可以考虑使用 CURLOPT_HTTP_VERSION 选项直接指定 HTTP 版本。</p></li></ul><h3 id="4-6-HTTP-POST"><a href="#4-6-HTTP-POST" class="headerlink" title="4.6 HTTP POST"></a>4.6 HTTP POST</h3><ul><li><p>POST 是为将数据发送到 Web 应用而发明的 HTTP 方法，也是 HTML 表单中最常用的方法。它通常会向接收者发送相对少量的数据块。</p></li><li><p>在表单中填充好数据后，浏览器以“URL 编码”的形式（以 &amp; 符号分隔的一系列键值对）将数据发送出去</p></li><li><p><code>-d</code>或<code>--data</code>：发送 POST 数据</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">curl -d <span class="hljs-string">&#x27;name=admin&amp;num=12&#x27;</span> http://example.com<br></code></pre></td></tr></table></figure></li><li><p>在命令行上指定多个-d 选项时，curl 会将它们串联起来，并在它们之间插入 &amp; 符号。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">curl -d <span class="hljs-string">&#x27;name=admin&#x27;</span> -d <span class="hljs-string">&quot;num=12&quot;</span> http://example.com<br></code></pre></td></tr></table></figure></li><li><p>如果要发送的数据量不适合作为字符串放在命令行中，还可以从文件中读取</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">curl -d @filename http://example.com<br></code></pre></td></tr></table></figure></li><li><p><code>--data-binary</code>：用-d 选项从文件读取内容时，回车符和换行符将被移除。如果想让 curl 从文件读取二进制内容，可以使用–data-binary。</p></li><li><p>curl 的-d 选项不会改变数据，也不会对数据进行编码，它只会发送你要它发送的内容。注意-d 选项默认使用的 Content-Type，因为它可能不是你想要的。</p></li></ul><h4 id="4-6-1-Content-Type"><a href="#4-6-1-Content-Type" class="headerlink" title="4.6.1 Content-Type"></a>4.6.1 Content-Type</h4><ul><li><p>用 curl 的-d 选项发送 POST 请求时，请求中默认会包含一个类似 Content-Type:application&#x2F;x-www-form-urlencoded 这样的标头。典型的浏览器在发送 POST 请求时也会使用这个标头。</p></li><li><p>如果默认标头对你来说还不够好，则可以用其他标头来代替。例如，如果想将 JSON POST 到服务器，并且准确地告诉服务器你发送的内容是什么类型，可以用-H 选项修改标头。</p></li></ul><h4 id="4-6-2-URL-编码"><a href="#4-6-2-URL-编码" class="headerlink" title="4.6.2 URL 编码"></a>4.6.2 URL 编码</h4><ul><li><p>URL 编码（也称为百分号编码）是一种编码数据的方式，这种方式允许数据以合法的形式出现在 URL 中。用 application&#x2F;x-www-form-urlencoded 发送 POST 请求时通常会使用这种编码方式，curl 用–data 和–data-binary 选项发送内容时就是这样。该种编码可以顺利解决汉字、特殊符号等内容的问题</p></li><li><p><code>--data-urlencode</code>：为了能够发送未经编码的数据，curl 提供了–data-urlencode 选项。这个选项提供了几种不同的方式对提供的数据进行 URL 编码。</p></li><li><p>可以像使用其他–data 选项那样使用–data-urlencode data。为了与 CGI 兼容，data 部分应该以名字开头，后面跟上分隔符和内容。可以用以下几种语法将数据传给 curl。</p><ul><li><p>“content”：curl 将对内容进行 URL 编码并发送数据。确保内容中不包含任何&#x3D;或 @符号，否则就会变成下面的其他情况之一！</p></li><li><p>“&#x3D;content”：curl 将对内容进行 URL 编码并发送数据。开头的“&#x3D;”符号不包含在数据中。</p></li><li><p>“name&#x3D;content”：curl 将对内容进行 URL 编码并发送数据。注意，name 部分应该已经经过 URL 编码。</p></li><li><p>“@filename”：curl 将从给定文件加载数据（包括换行符），对数据进行 URL 编码并在 POST 中发送数据。</p></li><li><p>“name@filename”：curl 将从给定文件加载数据（包括换行符），对数据进行 URL 编码并在 POST 中发送数据。name 部分会附加一个等号，变成 name&#x3D;urlencoded-file-content。注意，name 应该已经经过 URL 编码。</p></li></ul></li><li><p>示例：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 会被编码成为 name=%E4%BD%A0%20%E5%A5%BD</span><br>curl --dat-urlencode <span class="hljs-string">&quot;name=你 好&quot;</span> http://example.com<br><span class="hljs-comment"># 如果想对 name 进行 URL 编码，比如想要发送“user name”字段名，</span><br><span class="hljs-comment"># 那么你可以让 curl 在字段前面添加一个等号来编码整个字符串（等号不会被发送）</span><br>curl --dat-urlencode <span class="hljs-string">&quot;=user name=你 好&quot;</span> http://example.com<br></code></pre></td></tr></table></figure></li></ul><h4 id="4-6-3-转换为-GET"><a href="#4-6-3-转换为-GET" class="headerlink" title="4.6.3 转换为 GET"></a>4.6.3 转换为 GET</h4><ul><li>使用-G 或–get 选项可以将-d 选项指定的数据附加到 URL 右边，并使用“? ”分隔，然后让 curl 用 GET 方法发送数据。使用这个选项可以在 POST 和 GET 之间轻松切换。</li></ul><h4 id="4-6-5-Expect-100-continue"><a href="#4-6-5-Expect-100-continue" class="headerlink" title="4.6.5 Expect: 100-continue"></a>4.6.5 Expect: 100-continue</h4><ul><li><p>HTTP 无法在保持连接的情况下停止正在进行的传输（不管是哪个方向）。因此，如果在传输开始后发现需要停止传输，只有两种方法：关闭当前连接并为下一个请求重新建立连接，或者继续传输，这样会浪费带宽，但进行下一次传输时可以重用连接。当通过 HTTP 发送大型文件，却发现服务器需要身份验证并发回 401 响应码时，就会发生这种情况。</p></li><li><p>要想缓解这个问题，可以让 curl 传递一个额外的标头，即 Expect: 100-continue，这让服务器在客户端发送大量数据前有机会拒绝请求。如果 POST 请求的大小是已知的或者可能比较大，那么 curl 就会发送这个 Expect：标头。PUT 请求也是如此。当服务器收到包含 100-continue 的请求并允许这个请求，它将返回 100 响应码，客户端就可以继续发送数据。如果服务器不允许这个请求，它会返回错误响应码。遗憾的是，很多服务器对 Expect：标头的支持并不好，或者没能正确处理，因此 curl 只会在收到第一个响应前等待 1000 毫秒，然后继续发送数据。</p></li><li><p>等待的那 1000 毫秒可能就被浪费了。你可以从请求中移除 Expect:，并通过-H 选项来避免等待：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">curl -H Expect: -d <span class="hljs-string">&quot;hello&quot;</span> http://example.com<br></code></pre></td></tr></table></figure></li><li><p>在某些情况下，如果要发送的内容非常少（例如低于 1 千字节）, curl 将禁止使用 Expect:标头，因为“浪费”这么小的数据块并不是个大问题。</p></li></ul><h3 id="4-7-HTTP-multipart-formpost"><a href="#4-7-HTTP-multipart-formpost" class="headerlink" title="4.7 HTTP multipart formpost"></a>4.7 HTTP multipart formpost</h3><ul><li><p>multipart formpost 是指 HTTP 客户端在 HTML 表单的 enctype 属性被设置为“multipart&#x2F;form-data”时所发送的内容。它是一个 HTTP POST 请求，其中请求正文被格式化为一系列“part”，并以 MIME 边界字符串为分隔。</p></li><li><p><code>-F</code>或<code>--form</code>：可以通过该选项添加每个单独的 multipart，然后继续为表单的每个字段添加一个-F。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">curl -F person=hello -F secret=@file.txt http://example.com<br></code></pre></td></tr></table></figure></li><li><p>用 curl 的-F 选项进行 POST 时，请求中会包含默认的 Content-Type 标头。标头的值是 multipart&#x2F;form-data，后面是 MIME 边界字符串。multipart formpost 使用默认的 Content-Type，当然你也可以自行修改，如果你做了修改，curl 会自动将边界字符串附加到被替换的标头中。你无法修改边界字符串，因为 curl 需要用它来生成 POST 数据。</p></li><li><p>-d 和-F 两个选项都会将指定的数据发送到服务器。不同之处在于如何格式化数据。大多数情况下，接收端会接收特定格式的数据，并期望发送方可以正确格式化数据。客户端无法只使用自己选定的格式。</p></li><li><p>使用浏览器和 HTML 时，一般会向用户提供一个表单，并在用户填好表单后将数据发送出去。</p><form>标签用于网页，告诉浏览器如何格式化 POST 请求。如果<form>标签包含了 enctype&#x3D;multipart&#x2F;form-data，那就是要浏览器将数据作为 multipartformpost 发送，这与 curl 中的-F 选项等效。当表单中包含（用于文件上载的）<input type="file">标签时，通常会使用这个方法。<p></p></form></form></li><li><p>表单默认的 enctype 是 application&#x2F;x-www-form-urlencoded（因为是默认值，所以很少在 HTML 中显式指定）。浏览器将输入字段“URL 编码”成键值对，避免出现不安全的字符。我们通常将其称为常规 POST，在 curl 中可以通过-d 选项实现。</p></li><li><p>如果这些服务需要“原始”数据或格式化为 JSON 的数据，那么可以使用常规的 POST 方法。</p></li></ul><h3 id="4-8-重定向"><a href="#4-8-重定向" class="headerlink" title="4.8 重定向"></a>4.8 重定向</h3><ul><li><p><code>-L</code>或<code>--location</code>：一般来说，curl 只会做一些基本的操作，除非你告诉它，否则默认情况下它不会遵循 HTTP 重定向。可以通过-L 或–location 选项让它遵循 HTTP 重定向。</p></li><li><p><code>--max-redirs</code>：指定遵循重定向的选项后，curl 默认最多会执行 50 次重定向。设置最大次数限制是为了避免陷入无限循环。如果 50 次对你来说还不够，可以通过–max-redirs 选项修改最大重定向次数。</p></li><li><p>可以通过–post301、–post302 和–post303 三个选项让 curl 在收到 30x 响应后不将非 GET 请求方法改为 GET。如果你在开发基于 libcurl 的应用，那么可以使用 CURLOPT_POSTREDIR 选项来控制这种行为。</p></li><li><p>在使用 curl 时，你可能会为特定网站提供用户名和密码等凭证，但由于 HTTP 重定向可能会转移到其他主机，curl 会对发送给其他主机的内容加以限制。如果你希望凭证也被发送到后面的主机，即使与原始主机不同（这么做大概是因为你信任它们并且知道没有任何害处），则可以使用–location-trusted 选项。</p></li></ul><h3 id="4-9-修改-HTTP-请求"><a href="#4-9-修改-HTTP-请求" class="headerlink" title="4.9 修改 HTTP 请求"></a>4.9 修改 HTTP 请求</h3><h4 id="4-9-1-请求方法"><a href="#4-9-1-请求方法" class="headerlink" title="4.9.1 请求方法"></a>4.9.1 请求方法</h4><ul><li><p><code>-X</code>或<code>--request</code>：该选项后面跟上方法名，让 curl 使用其他方法。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">curl -X DELETE http://example.com<br></code></pre></td></tr></table></figure></li><li><p>-X 选项会修改请求的文本，但不会改变它的行为。知道这一点很重要，如果通过-X 选项要求 curl 发送 HEAD 请求，HEAD 请求将收到与 GET 响应相同的标头，但不会收到响应正文，即使标头表明可能会有。因此，将-X HEAD 添加到命令行将导致 curl 挂起，一直等待不会到来的响应正文。</p></li><li><p>用 curl 执行 HTTP 传输时，它会根据选项选择正确的方法，因此没必要用-X 来指定。还需要注意的是，如果用-L 选项要求 curl 遵循重定向，那么使用-X 设置的请求方法也会出现在后续的重定向请求中。</p></li></ul><h4 id="4-9-2-自定义标头"><a href="#4-9-2-自定义标头" class="headerlink" title="4.9.2 自定义标头"></a>4.9.2 自定义标头</h4><ul><li><p>curl 设置的所有标头都是可以被覆盖的，如果愿意，还可以替换它们。可以通过-H 或–header 选项让 curl 使用新的标头，如果指定的标头字段与内部字段匹配，它将替换内部标头，否则它会将指定的标头添加到标头列表中</p></li><li><p>如果想要删除内部标头，只要向 curl 提供标头名称但不提供值即可，即冒号右侧没有任何内容。</p></li><li><p>如果真的想要在冒号右侧添加一个没有内容的标头（这种情况很罕见），那么可以在标头后面加个分号，如下所示：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">curl -H <span class="hljs-string">&quot;Empty; &quot;</span> http://example.com<br></code></pre></td></tr></table></figure></li></ul><h4 id="4-9-3-referer"><a href="#4-9-3-referer" class="headerlink" title="4.9.3 referer"></a>4.9.3 referer</h4><ul><li><p>当用户点击网页上的链接时，浏览器会将用户带到下一个 URL，它会在新的请求中添加 referer 标头，表明请求的来源。虽然 referer 拼写错误，但它就是这个意思！</p></li><li><p><code>-e</code>或<code>--referer</code>：设置 referer 标头</p></li></ul><h4 id="4-9-4-User-Agent"><a href="#4-9-4-User-Agent" class="headerlink" title="4.9.4 User-Agent"></a>4.9.4 User-Agent</h4><ul><li><p>客户端可以在请求中设置 User-Agent 标头，用于告诉服务器它属于哪种用户代理。有时服务器会检查这个标头，并根据标头内容决定如何做出响应。这个标头的默认值为“curl&#x2F;[version]”, curl 7.54.1 的值为 User-Agent:curl&#x2F;7.54.1。</p></li><li><p><code>-A</code>或<code>--user-agnet</code>：可以用-A 或–user-agent 选项加上要使用的字符串来设置你喜欢的值。</p></li></ul><h4 id="4-9-5-时间条件"><a href="#4-9-5-时间条件" class="headerlink" title="4.9.5 时间条件"></a>4.9.5 时间条件</h4><ul><li><p>HTTP 支持“条件请求”。条件请求是指包含条件的请求，它请求服务器只在相关条件为 true 时才返回响应正文。时间是一个有用的条件。</p></li><li><p><code>--time-cond</code>：设置时间请求。</p></li><li><p>curl 可以直接从本地文件中获取时间戳。如果服务器的文件没有发生变更，那么就无须再次下载，如果字符串与时间或日期格式不匹配，curl 会检查是否存在同名文件，如果存在，就使用文件的修改时间。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">curl --time-cond file http://example.com/file -O<br></code></pre></td></tr></table></figure></li></ul><h3 id="4-10-PUT"><a href="#4-10-PUT" class="headerlink" title="4.10 PUT"></a>4.10 PUT</h3><ul><li><p>PUT 和 POST 之间的区别很微妙。除了方法名不同之外，其他几乎都是一样的。POST 是指将数据传给现有的远程资源，而 PUT 是指创建新的资源。在这方面，PUT 类似于其他协议的文件上传。你可以用 PUT 上传新的资源，用 URL 指定远程资源，并指定要发送的本地文件。</p></li><li><p>因为 POST 和 PUT 非常相似，所以你也可以用-d 加上字符串来发送 PUT 请求。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">curl -d <span class="hljs-string">&quot;Hello&quot;</span> -X PUT http://example.com<br></code></pre></td></tr></table></figure></li></ul><h3 id="4-11-cookie"><a href="#4-11-cookie" class="headerlink" title="4.11 cookie"></a>4.11 cookie</h3><ul><li><p>HTTP cookie 是存储在客户端的键值对。在后续请求中，它们被发回服务器，用于保持请求间的状态。HTTP 本身是没有状态的，客户端必须在后续请求中重新发送需要服务器知道的所有数据。</p></li><li><p>服务器用 Set-Cookie：标头来设置 cookie，并在每个 cookie 中发送一堆额外的属性，客户端在发回 cookie 时需要匹配这些属性。这些属性包括域名、路径，以及最重要的 cookie 应该保留多长时间</p></li><li><p>cookie 的到期时间要么设置为未来的某个固定时刻（或者存活几秒），要么永不过期。没有过期时间的 cookie 称为“会话 cookie”，只在“会话”期间存活。会话通常被认为是浏览器在浏览网站时的生命周期。关闭浏览器后，会话也将结束。</p></li><li><p>curl 通常只做最少的事情，除非你告诉它，否则默认情况下它不会使用 cookie。你需要打开“cookie 引擎”才能让 curl 跟踪它接收到的 cookie，然后在后续的请求中发送它们。</p></li><li><p>可以让 curl 读取或写入 cookie，以此来启用 cookie 引擎。如果让 curl 从一个不存在的文件中读取 cookie，那么它只会打开引擎，但内部的 cookie 存储是空的。</p></li><li><p><code>-b</code>：指定 cookie 内容</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">curl -b name=hello http://example.com<br>curl -b cookie.txt http://example.com<br></code></pre></td></tr></table></figure></li><li><p>记住，-b 只是从文件中读取 cookie。如果服务器更新了响应中的 cookie，那么 curl 会更新内存的 cookie 存储，并在退出时将它们全部丢弃。如果后续读取相同的输入文件，则会使用与原来相同的 cookie。</p></li><li><p>curl 使用的 cookie 文件格式叫作 Netscape cookie 格式，因为浏览器曾经也使用了这种格式，所以 curl 可以很轻松地处理浏览器 cookie！出于便利性方面的考虑，curl 还支持一种特殊的 cookie 文件，文件的内容是一组用于设置 cookie 的 HTTP 标头。它是一种次优的格式，但也可能是你唯一可以修改的格式。</p></li><li><p>cookie 存储有时称为“cookie jar”。当你启用了 curl 的 cookie 引擎，并且它接收到了 cookie，那么可以让 curl 在退出之前将所有已知的 cookie 写入文件（也就是 cookie jar）中。curl 只会在退出时（而不是生命周期内）更新 cookie jar，无论处理输入需要多长时间。</p></li><li><p><code>-c</code>：指定 cookie-jar 文件</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">curl -c cookie-jar.txt http://example.com<br></code></pre></td></tr></table></figure></li><li><p>-c 指示 curl 将 cookie 写入文件，-b 指示 curl 从文件读取 cookie。通常需要同时使用它们。将 cookie 写入文件时，curl 将保存所有已知的 cookie，包括会话 cookie（没有过期时间）。curl 本身没有会话的概念，它不知道会话什么时候结束，因此不会刷新会话 cookie，除非你告诉它要这么做。</p></li><li><p><code>-j</code>或<code>--junk-session-cookies</code>：为了刷新会话 cookie，并向服务器发出开始新会话的信号，curl 提供了一个选项，以便用户可以决定新会话何时开始。新的 cookie 会话意味着所有会话 cookie 都将被丢弃，这相当于重启浏览器。可以通过-j 或–junk-session-cookies 选项让 curl 开始新的 cookie 会话：</p></li></ul><h3 id="4-12-HTTP-x2F-2"><a href="#4-12-HTTP-x2F-2" class="headerlink" title="4.12 HTTP&#x2F;2"></a>4.12 HTTP&#x2F;2</h3><ul><li><p>curl 同时为 HTTP:&#x2F;&#x2F; 和 HTTPS:&#x2F;&#x2F; 类型的 URL 提供 HTTP&#x2F;2 支持（前提是用相关依赖项构建 curl）。如果指定了 HTTPS URL，那么它会默认使用 HTTP&#x2F;2。如果用 curl 访问不支持 HTTP&#x2F;2 的网站，则发出的请求将进行 HTTP&#x2F;1.1 协商。</p></li><li><p>如果使用的是 HTTP:&#x2F;&#x2F; 类型的 URL，则需要使用 Upgrade：标头升级到 HTTP&#x2F;2，但这可能会导致额外的网络往返。更麻烦的是，相当多的旧服务器遇到这种情况时会返回 400 响应码。</p></li><li><p>还需要注意的是，一些（可能是大多数）支持 HTTP&#x2F;2 的服务器（本身并非都是服务器）无法识别 POST 请求中的 Upgrade：标头。</p></li><li><p>如果你的 curl 不支持 HTTP&#x2F;2，那么命令行将返回错误。运行 curl -V 就可以知道你的 curl 版本是否支持 HTTP&#x2F;2。</p></li><li><p>HTTP&#x2F;2 协议的主要特性之一是能够在同一物理连接上复用多个逻辑流。在使用 curl 命令行工具时，你无法利用这个很酷的特性，因为 curl 严格按照串行的方式执行网络请求，一个接一个，后一个要在前一个结束后才能开始。</p></li></ul></div><hr><div><div class="post-metas my-3"><div class="post-meta mr-3 d-flex align-items-center"><i class="iconfont icon-category"></i> <span class="category-chains"><span class="category-chain"><a href="/categories/%E7%AC%94%E8%AE%B0/" class="category-chain-item">笔记</a></span></span></div><div class="post-meta"><i class="iconfont icon-tags"></i> <a href="/tags/%E5%B7%A5%E5%85%B7%E8%AF%A6%E8%A7%A3/">#工具详解</a></div></div><div class="license-box my-3"><div class="license-title"><div>【笔记】cURL必知必会</div><div>https://tivnantu.github.io/posts/9f5d61d7</div></div><div class="license-meta"><div class="license-meta-item"><div>作者</div><div>tivnantu</div></div><div class="license-meta-item license-meta-date"><div>发布于</div><div>2021年12月29日</div></div><div class="license-meta-item"><div>许可协议</div><div><a target="_blank" href="https://creativecommons.org/licenses/by/4.0/"><span class="hint--top hint--rounded" aria-label="BY - 署名"><i class="iconfont icon-by"></i></span></a></div></div></div><div class="license-icon iconfont"></div></div><div class="post-prevnext my-3"><article class="post-prev col-6"><a href="/posts/a02f89c0" title="【笔记】程序是怎样跑起来的（上）"><i class="iconfont icon-arrowleft"></i> <span class="hidden-mobile">【笔记】程序是怎样跑起来的（上）</span> <span class="visible-mobile">上一篇</span></a></article><article class="post-next col-6"><a href="/posts/c1870777" title="【阅读】网络是怎样连接的？"><span class="hidden-mobile">【阅读】网络是怎样连接的？</span> <span class="visible-mobile">下一篇</span> <i class="iconfont icon-arrowright"></i></a></article></div></div></article></div></div></div><div class="side-col d-none d-lg-block col-lg-2"><aside class="sidebar" style="margin-left:-1rem"><div id="toc"><p class="toc-header"><i class="iconfont icon-list"></i> <span>目录</span></p><div class="toc-body" id="toc-body"></div></div></aside></div></div></div><a id="scroll-top-button" aria-label="TOP" href="#" role="button"><i class="iconfont icon-arrowup" aria-hidden="true"></i></a><div class="modal fade" id="modalSearch" tabindex="-1" role="dialog" aria-labelledby="ModalLabel" aria-hidden="true"><div class="modal-dialog modal-dialog-scrollable modal-lg" role="document"><div class="modal-content"><div class="modal-header text-center"><h4 class="modal-title w-100 font-weight-bold">搜索</h4><button type="button" id="local-search-close" class="close" data-dismiss="modal" aria-label="Close"><span aria-hidden="true">&times;</span></button></div><div class="modal-body mx-3"><div class="md-form mb-5"><input type="text" id="local-search-input" class="form-control validate"> <label data-error="x" data-success="v" for="local-search-input">关键词</label></div><div class="list-group" id="local-search-result"></div></div></div></div></div></main><footer><div class="footer-inner"><div class="footer-content"><i class="iconfont icon-code"></i> <i class="iconfont icon-love"></i> <i class="iconfont icon-books"></i></div><div class="statistics"><span id="busuanzi_container_site_pv" style="display:none">总访问量 <span id="busuanzi_value_site_pv"></span> 次 </span><span id="busuanzi_container_site_uv" style="display:none">总访客数 <span id="busuanzi_value_site_uv"></span> 人</span></div></div></footer><script src="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.js"></script><link rel="stylesheet" href="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.css"><script>NProgress.configure({showSpinner:!1,trickleSpeed:100}),NProgress.start(),window.addEventListener("load",function(){NProgress.done()})</script><script src="https://lib.baomitu.com/jquery/3.6.0/jquery.min.js"></script><script src="https://lib.baomitu.com/twitter-bootstrap/4.6.1/js/bootstrap.min.js"></script><script src="/js/events.js"></script><script src="/js/plugins.js"></script><script src="https://lib.baomitu.com/typed.js/2.0.12/typed.min.js"></script><script>!function(t){var e=Fluid.plugins.typing,t=t.getElementById("subtitle");t&&e&&e(t.getAttribute("data-typed-text"))}((window,document))</script><script src="/js/img-lazyload.js"></script><script>Fluid.utils.createScript("https://lib.baomitu.com/tocbot/4.18.2/tocbot.min.js",function(){var t,o=jQuery("#toc");0!==o.length&&window.tocbot&&(t=jQuery("#board-ctn").offset().top,window.tocbot.init(Object.assign({tocSelector:"#toc-body",contentSelector:".markdown-body",linkClass:"tocbot-link",activeLinkClass:"tocbot-active-link",listClass:"tocbot-list",isCollapsedClass:"tocbot-is-collapsed",collapsibleClass:"tocbot-is-collapsible",scrollSmooth:!0,includeTitleTags:!0,headingsOffset:-t},CONFIG.toc)),0<o.find(".toc-list-item").length&&o.css("visibility","visible"),Fluid.events.registerRefreshCallback(function(){var t;"tocbot"in window&&(tocbot.refresh(),0!==(t=jQuery("#toc")).length)&&tocbot&&0<t.find(".toc-list-item").length&&t.css("visibility","visible")}))})</script><script src="https://lib.baomitu.com/clipboard.js/2.0.11/clipboard.min.js"></script><script>Fluid.plugins.codeWidget()</script><script>Fluid.utils.createScript("https://lib.baomitu.com/anchor-js/4.3.1/anchor.min.js",function(){window.anchors.options={placement:CONFIG.anchorjs.placement,visible:CONFIG.anchorjs.visible},CONFIG.anchorjs.icon&&(window.anchors.options.icon=CONFIG.anchorjs.icon);var n,o=[];for(n of(CONFIG.anchorjs.element||"h1,h2,h3,h4,h5,h6").split(","))o.push(".markdown-body > "+n.trim());"left"===CONFIG.anchorjs.placement&&(window.anchors.options.class="anchorjs-link-left"),window.anchors.add(o.join(", ")),Fluid.events.registerRefreshCallback(function(){if("anchors"in window){anchors.removeAll();var n,o=[];for(n of(CONFIG.anchorjs.element||"h1,h2,h3,h4,h5,h6").split(","))o.push(".markdown-body > "+n.trim());"left"===CONFIG.anchorjs.placement&&(anchors.options.class="anchorjs-link-left"),anchors.add(o.join(", "))}})})</script><script>Fluid.utils.createScript("https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.js",function(){Fluid.plugins.fancyBox()})</script><script>Fluid.plugins.imageCaption()</script><script src="/js/local-search.js"></script><script defer src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><script src="/js/boot.js"></script><noscript><div class="noscript-warning">博客在允许 JavaScript 运行的环境下浏览效果更佳</div></noscript></body></html>