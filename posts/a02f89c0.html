<!DOCTYPE html><html lang="zh-CN" data-default-color-scheme="light"><head><meta charset="UTF-8"><link rel="apple-touch-icon" sizes="76x76" href="/image/theme/favicon.png"><link rel="icon" href="/image/theme/favicon.png"><meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=5,shrink-to-fit=no"><meta http-equiv="x-ua-compatible" content="ie=edge"><meta name="theme-color" content="#2f4154"><meta name="author" content="tivnantu"><meta name="keywords" content="code"><meta name="description" content="要知道程序员怎样跑起来的，也要知道程序怎样跑起来的"><meta property="og:type" content="article"><meta property="og:title" content="【笔记】程序是怎样跑起来的（上）"><meta property="og:url" content="https://tivnantu.github.io/posts/a02f89c0"><meta property="og:site_name" content="tivnantu"><meta property="og:description" content="要知道程序员怎样跑起来的，也要知道程序怎样跑起来的"><meta property="og:locale" content="zh_CN"><meta property="og:image" content="https://tivnantu.github.io/image/%E7%A8%8B%E5%BA%8F%E6%98%AF%E6%80%8E%E6%A0%B7%E8%B7%91%E8%B5%B7%E6%9D%A5%E7%9A%84/%E7%A8%8B%E5%BA%8F%E6%98%AF%E6%80%8E%E6%A0%B7%E8%B7%91%E8%B5%B7%E6%9D%A5%E7%9A%84.jpg"><meta property="article:published_time" content="2022-03-17T11:47:44.000Z"><meta property="article:modified_time" content="2022-03-17T11:47:44.000Z"><meta property="article:author" content="tivnantu"><meta property="article:tag" content="基础体系"><meta name="twitter:card" content="summary_large_image"><meta name="twitter:image" content="https://tivnantu.github.io/image/%E7%A8%8B%E5%BA%8F%E6%98%AF%E6%80%8E%E6%A0%B7%E8%B7%91%E8%B5%B7%E6%9D%A5%E7%9A%84/%E7%A8%8B%E5%BA%8F%E6%98%AF%E6%80%8E%E6%A0%B7%E8%B7%91%E8%B5%B7%E6%9D%A5%E7%9A%84.jpg"><meta name="referrer" content="no-referrer-when-downgrade"><title>【笔记】程序是怎样跑起来的（上） &lt; tivnantu</title><link rel="stylesheet" href="https://lib.baomitu.com/twitter-bootstrap/4.6.1/css/bootstrap.min.css"><link rel="stylesheet" href="https://lib.baomitu.com/github-markdown-css/4.0.0/github-markdown.min.css"><link rel="stylesheet" href="https://lib.baomitu.com/hint.css/2.7.0/hint.min.css"><link rel="stylesheet" href="https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.css"><link rel="stylesheet" href="//at.alicdn.com/t/font_1749284_hj8rtnfg7um.css"><link rel="stylesheet" href="//at.alicdn.com/t/font_1736178_lbnruvf0jn.css"><link rel="stylesheet" href="/css/main.css"><link id="highlight-css" rel="stylesheet" href="/css/highlight.css"><link id="highlight-css-dark" rel="stylesheet" href="/css/highlight-dark.css"><script id="fluid-configs">var dntVal,Fluid=window.Fluid||{},CONFIG=(Fluid.ctx=Object.assign({},Fluid.ctx),{hostname:"tivnantu.github.io",root:"/",version:"1.9.4",typing:{enable:!0,typeSpeed:70,cursorChar:"",loop:!1,scope:[]},anchorjs:{enable:!0,element:"h1,h2,h3,h4,h5,h6",placement:"right",visible:"hover",icon:"§"},progressbar:{enable:!0,height_px:3,color:"#29d",options:{showSpinner:!1,trickleSpeed:100}},code_language:{enable:!0,default:"TEXT"},copy_btn:!0,image_caption:{enable:!0},image_zoom:{enable:!0,img_url_replace:["",""]},toc:{enable:!0,placement:"right",headingSelector:"h1,h2,h3,h4,h5,h6",collapseDepth:0},lazyload:{enable:!0,loading_img:"/image/theme/loading.gif",onlypost:!1,offset_factor:2},web_analytics:{enable:!1,follow_dnt:!0,baidu:null,google:null,gtag:null,tencent:{sid:null,cid:null},woyaola:null,cnzz:null,leancloud:{app_id:null,app_key:null,server_url:null,path:"window.location.pathname",ignore_local:!1}},search_path:"/local-search.xml"});CONFIG.web_analytics.follow_dnt&&(dntVal=navigator.doNotTrack||window.doNotTrack||navigator.msDoNotTrack,Fluid.ctx.dnt=dntVal&&(dntVal.startsWith("1")||dntVal.startsWith("yes")||dntVal.startsWith("on")))</script><script src="/js/utils.js"></script><script src="/js/color-schema.js"></script><meta name="generator" content="Hexo 6.3.0"></head><body><header><div class="header-inner" style="height:70vh"><nav id="navbar" class="navbar fixed-top navbar-expand-lg navbar-dark scrolling-navbar"><div class="container"><a class="navbar-brand" href="/"><strong>tivnantu</strong> </a><button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarSupportedContent" aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation"><div class="animated-icon"><span></span><span></span><span></span></div></button><div class="collapse navbar-collapse" id="navbarSupportedContent"><ul class="navbar-nav ml-auto text-center"><li class="nav-item"><a class="nav-link" href="/"><i class="iconfont icon-home-fill"></i> <span>首页</span></a></li><li class="nav-item"><a class="nav-link" href="/archives/"><i class="iconfont icon-archive-fill"></i> <span>归档</span></a></li><li class="nav-item"><a class="nav-link" href="/categories/"><i class="iconfont icon-category-fill"></i> <span>分类</span></a></li><li class="nav-item"><a class="nav-link" href="/tags/"><i class="iconfont icon-tags-fill"></i> <span>标签</span></a></li><li class="nav-item"><a class="nav-link" href="/about/"><i class="iconfont icon-user-fill"></i> <span>关于</span></a></li><li class="nav-item" id="search-btn"><a class="nav-link" target="_self" href="javascript:;" data-toggle="modal" data-target="#modalSearch" aria-label="Search"><i class="iconfont icon-search"></i></a></li><li class="nav-item" id="color-toggle-btn"><a class="nav-link" target="_self" href="javascript:;" aria-label="Color Toggle"><i class="iconfont icon-dark" id="color-toggle-icon"></i></a></li></ul></div></div></nav><div id="banner" class="banner" parallax="true" style="background:url(/image/%E7%A8%8B%E5%BA%8F%E6%98%AF%E6%80%8E%E6%A0%B7%E8%B7%91%E8%B5%B7%E6%9D%A5%E7%9A%84/banner1.jpg) no-repeat center center;background-size:cover"><div class="full-bg-img"><div class="mask flex-center" style="background-color:rgba(0,0,0,.3)"><div class="banner-text text-center fade-in-up"><div class="h2"><span id="subtitle" data-typed-text="【笔记】程序是怎样跑起来的（上）"></span></div><div class="mt-3"><span class="post-meta"><i class="iconfont icon-date-fill" aria-hidden="true"></i> <time datetime="2022-03-17 19:47" pubdate>2022年3月17日 晚上</time></span></div><div class="mt-1"><span class="post-meta mr-2"><i class="iconfont icon-chart"></i> 24k 字 </span><span class="post-meta mr-2"><i class="iconfont icon-clock-fill"></i> 101 分钟 </span><span id="busuanzi_container_page_pv" style="display:none"><i class="iconfont icon-eye" aria-hidden="true"></i> <span id="busuanzi_value_page_pv"></span> 次</span></div></div></div></div></div></div></header><main><div class="container-fluid nopadding-x"><div class="row nomargin-x"><div class="side-col d-none d-lg-block col-lg-2"></div><div class="col-lg-8 nopadding-x-md"><div class="container nopadding-x-md" id="board-ctn"><div id="board"><article class="post-content mx-auto"><h1 style="display:none">【笔记】程序是怎样跑起来的（上）</h1><div class="markdown-body"><div class="note note-success"><p>《程序是怎样跑起来的》由日本作家矢泽久雄编撰而成，和户根勤《网络是怎样链接的？》等书籍收录于图灵程序设计丛书·图解与入门系列。</p><p>从我个人角度来说，《程序》比《网络》逊色。《网络》一书条理清晰，简单易懂，由客户端发起网络请求开始，直到服务器处理请求结束，一层层深入，抽丝剥茧，可以让读者对网络整体结构有比较好的理解记忆。《程序》一书中有较多口语化的句子，知识密度不及《网络》，既没有深挖技术细节，也没有见缝插针扩展知识，且插画水平也远不及该图书系列的一贯水准。</p><p>但是我还是很推荐想要入门 CS 的同学把这本书拿来做辅助阅读资料的！《程序》相当于《计算机科学导论》、《计算机组成原理》、《计算机组成与嵌入式系统》的简易组合阅读版，《深入理解计算机系统》的极致压缩板。读起来会比读黑皮书轻松的多，也快的多。非常适合用做打基础前的快速了解书籍，或者你把它用来当做复习书也行。</p><p>《程序》的每一章节扩展开来都可以写成一本书，但是为了平衡整本书的情况，且不偏离“给普通人看的技术书”主题，于是只能挑选最最最重要的核心部分填充其中，于是就造成了读不过瘾、内容断断续续的情况。例如第一章，CPU 的结构没有很好地向读者说明，也没有稍微探讨一下结构划分的原理，读到后面还得自己去上网查资料。</p><p>不过这也怪不得作者，只能说是篇幅受限，不得已而为之。“功夫在诗外”，书中没写出来的，读者应该尽量去“补全”。我在笔记中也加了不少附加链接，基本都是我觉得可以对书籍章节做很好补充的内容，希望你看的舒服。</p><p>总的来说，做引子不错。</p></div><p>剩下的笔记：</p><blockquote><p><a href="1893eea5">【笔记】程序是怎样跑起来的（下）</a></p></blockquote><h2 id="第一章-对程序员来说-CPU-是什么"><a href="#第一章-对程序员来说-CPU-是什么" class="headerlink" title="第一章 对程序员来说 CPU 是什么"></a>第一章 对程序员来说 CPU 是什么</h2><h3 id="1-1-CPU-的内部结构解析"><a href="#1-1-CPU-的内部结构解析" class="headerlink" title="1.1 CPU 的内部结构解析"></a>1.1 CPU 的内部结构解析</h3><ul><li><p>CPU：Central Processing Unit，中央处理器</p><ul><li><p>CPU 在程序运行流程中所负责的是解释和运行最终转换成机器语言的程序内容</p></li><li><p>CPU 是用来表示计算机内部元件功能的术语。另一方面，奔腾等半导体芯片，通常称为微处理器。不过，由于大部分计算机通常只有一个微处理器来承担 CPU 的功能，所以本章不对此进行区分，统一使用 CPU 这一称呼</p></li><li><p>CPU 由具有 ON&#x2F;OFF 开关功能的晶体管构成。有的 CPU 在一个集成电路中集成了两个 CPU 芯片，我们称之为双核（dual core）CPU</p></li></ul></li><li><p>CPU 和内存是由许多晶体管组成的电子部件，通常称为 IC（Integrated Circuit，集成电路）</p></li><li><p>从功能方面来看，CPU 的内部由寄存器、控制器、运算器和时钟四个部分构成，各部分之间由电流信号相互连通。</p><ul><li><p>寄存器：用于暂存指令、数据等处理对象，可以将其看作是内存的一种。根据种类的不同，一个 CPU 内部会有 20～100 个寄存器</p></li><li><p>控制器：控制指令执行的顺序；控制指令的具体执行</p></li><li><p>运算器：运算器负责运算从内存读入寄存器的数据</p></li><li><p>时钟：负责发出 CPU 开始计时的时钟信号。不过，也有些计算机的时钟位于 CPU 的外部</p></li></ul></li><li><p>CPU 的功能构成：（CPU 的结构不是本书的重点，所以书中只是简单地对 CPU 的功能进行抽象，视为几部分结构，图中几部分并不是相互独立的存在，例如控制器实际上是包含程序计数器、指令寄存器、时序产生器等部分的，运算器包含 ACC、MQ 等寄存器）</p><p><img src="/image/%E7%A8%8B%E5%BA%8F%E6%98%AF%E6%80%8E%E6%A0%B7%E8%B7%91%E8%B5%B7%E6%9D%A5%E7%9A%84/35db82c98d462daabbcae4dde427497c0c48cad5.jpeg" srcset="/image/theme/loading.gif" lazyload alt="epub9077616jpeg"></p></li><li><p>时钟：clock puzzle。Pentium 2 GHz 表示时钟信号的频率为 2 GHz（1 GHz&#x3D;10 亿次&#x2F;秒）。也就是说，时钟信号的频率越高，CPU 的运行速度越快。</p></li><li><p>内存：通常指的是计算机的主存储器（mainmemory），简称主存</p><ul><li><p>主存位于计算机机体内部，是负责存储程序、数据等的装置</p></li><li><p>主存通常使用 DRAM（Dynamic Random Access Memory，动态随机存取存储器）芯片。详情可参阅第 4 章</p><ul><li>DRAM 可以对任何地址进行数据的读写操作，但需要保持稳定的电源供给并时常刷新（确保是最新数据），关机后内容将自动清除</li></ul></li><li><p>主存通过控制芯片等与 CPU 相连，主要负责存储指令和数据</p></li><li><p>主存由可读写的元素构成，每个字节（1 字节&#x3D;8 位）都带有一个地址编号。CPU 可以通过该地址读取主存中的指令和数据，当然也可以写入数据</p></li><li><p>主存中存储的指令和数据会随着计算机的关机而自动清除</p></li></ul></li><li><p>“控制器”的控制指的是数据运算以外的处理（主要是数据输入输出的时机控制）。比如内存和磁盘等媒介的输入输出、键盘和鼠标的输入、显示器和打印机的输出等，这些都是控制的内容</p></li></ul><h3 id="1-2-CPU-是寄存器的集合体"><a href="#1-2-CPU-是寄存器的集合体" class="headerlink" title="1.2 CPU 是寄存器的集合体"></a>1.2 CPU 是寄存器的集合体</h3><ul><li><p>程序是把寄存器作为对象来描述的</p></li><li><p>汇编语言：assembly</p><ul><li>汇编语言采用助记符（memonic）来编写程序，每一个原本是电气信号的机器语言指令都会有一个与其相应的助记符，助记符通常为指令功能的英语单词的简写</li><li>把汇编语言转化成机器语言的程序称为汇编器（assembler）。有时汇编语言也称为汇编。详情可参阅第 10 章</li><li>通常将汇编语言编写的程序转化成机器语言的过程称为汇编</li><li>将机器语言程序转化成汇编语言程序的过程则称为反汇编</li></ul></li><li><p>机器语言指的是 CPU 可以直接解释和执行的语言</p></li><li><p>高级编程语言：指能够使用类似于人类语言（主要是英语）的语法来记述的编程语言的总称</p><ul><li>BASIC、C、C++、Java、Pascal、FORTRAN、COBOL 等语言都是高级编程语言</li><li>使用高级编程语言编写的程序，经过编译转换成机器语言后才能运行</li><li>与高级编程语言相对，机器语言和汇编语言称为低级编程语言。</li></ul></li><li><p>机器语言级别的程序是通过寄存器来处理的。也就是说，在程序员看来，“CPU 是寄存器的集合体”。至于控制器、运算器和时钟，程序员只需要知道 CPU 中还有这几部分就足够了</p></li><li><p>汇编语言是 80386 以上的 CPU 所使用的语言。eax 和 ebp 是 CPU 内部的寄存器的名称。内存的存储场所通过地址编号来区分，而寄存器的种类则通过名字来区分</p><ul><li>80386 是美国英特尔公司开发的微处理器的产品名。“80386 以上”是指 80386、80486、奔腾等微处理器</li></ul></li><li><p>不同类型的 CPU，其内部寄存器的数量、种类以及寄存器存储的数值范围都是不同的。不过，根据功能的不同，我们可以将寄存器大致划分为八类</p><p><img src="/image/%E7%A8%8B%E5%BA%8F%E6%98%AF%E6%80%8E%E6%A0%B7%E8%B7%91%E8%B5%B7%E6%9D%A5%E7%9A%84/142de7d5b1a81c32e345057adc1ca58f55851671.jpeg" srcset="/image/theme/loading.gif" lazyload alt="epub90776113jpeg"></p></li><li><p>可以看出，寄存器中存储的内容既可以是指令也可以是数据。其中，数据分为“用于运算的数值”和“表示内存地址的数值”两种。数据种类不同，存储该数值的寄存器也不同</p></li><li><p>CPU 中每个寄存器的功能都是不同的。用于运算的数值放在累加寄存器中存储，表示内存地址的数值则放在基址寄存器和变址寄存器中存储</p></li><li><p>CPU 是具有各种功能的寄存器的集合体。其中，程序计数器、累加寄存器、标志寄存器、指令寄存器和栈寄存器都只有一个，其他的寄存器一般有多个。另外，存储指令的指令寄存器、栈寄存器，由于不需要程序员做多关注，因此下图图中没有提到</p><p><img src="/image/%E7%A8%8B%E5%BA%8F%E6%98%AF%E6%80%8E%E6%A0%B7%E8%B7%91%E8%B5%B7%E6%9D%A5%E7%9A%84/c01dc5ad32acc0ede36852df40430196adfe7b25.jpeg" srcset="/image/theme/loading.gif" lazyload alt="epub90776114jpeg"></p></li></ul><h3 id="1-3-决定程序流程的程序计数器"><a href="#1-3-决定程序流程的程序计数器" class="headerlink" title="1.3 决定程序流程的程序计数器"></a>1.3 决定程序流程的程序计数器</h3><ul><li><p>用户发出启动程序的指示后，Windows 等操作系统会把硬盘中保存的程序复制到内存中</p></li><li><p>Windows 等操作系统把程序从硬盘复制到内存后，会将程序计数器（CPU 寄存器的一种）设定为指令起始值，然后程序便开始运行</p></li><li><p>CPU 每执行一个指令，程序计数器的值就会自动加 1。当执行的指令占据多个内存地址时，增加与指令长度相应的数值</p></li><li><p>CPU 的控制器就会参照程序计数器的数值，从内存中读取命令并执行。也就是说，程序计数器决定着程序的流程</p></li></ul><h3 id="1-4-条件分支和循环机制"><a href="#1-4-条件分支和循环机制" class="headerlink" title="1.4 条件分支和循环机制"></a>1.4 条件分支和循环机制</h3><ul><li><p>程序的流程分为顺序执行、条件分支和循环三种</p><ul><li><p>顺序执行是指按照地址内容的顺序执行指令</p></li><li><p>条件分支是指根据条件执行任意地址的指令</p></li><li><p>循环是指重复执行同一地址的指令</p></li></ul></li><li><p>条件分支和循环中使用的跳转指令，会参照当前执行的运算结果来判断是否跳转</p></li><li><p>无论当前累加寄存器的运算结果是负数、零还是正数，标志寄存器都会将运算所产生的标志保存下来（也负责存放溢出和奇偶校验的结果)。CPU 在进行运算时，标志寄存器的数值会根据运算结果自动设定。运算结果的正、零、负三种状态由标志寄存器的三个位表示</p><p><img src="/image/%E7%A8%8B%E5%BA%8F%E6%98%AF%E6%80%8E%E6%A0%B7%E8%B7%91%E8%B5%B7%E6%9D%A5%E7%9A%84/0918c8a589e132dd5c5bbe006bdc8262364512d5.jpeg" srcset="/image/theme/loading.gif" lazyload alt="epub90776121jpeg"></p></li><li><p>条件分支在跳转指令前会进行比较运算。至于是否执行跳转指令，则由 CPU 在参考标志寄存器的数值后进行判断</p></li></ul><h3 id="1-5-函数的调用机制"><a href="#1-5-函数的调用机制" class="headerlink" title="1.5 函数的调用机制"></a>1.5 函数的调用机制</h3><ul><li><p>函数调用处理也是通过把程序计数器的值设定成函数的存储地址来实现的</p></li><li><p>和条件分支、循环的机制有所不同，单纯的跳转指令无法实现函数的调用。函数的调用需要在完成函数内部的处理后，处理流程需要再返回到函数调用点（函数调用指令的下一个地址）。因此，如果只是跳转到函数的入口地址，处理流程就不知道应该返回至哪里了</p></li><li><p>函数调用使用的是 call 指令，而不是跳转指令。在将函数的入口地址设定到程序计数器之前，call 指令会把调用函数后要执行的指令地址存储在名为栈的主存内。函数处理完毕后，再通过函数的出口来执行 return 命令。return 命令的功能是把保存在栈中的地址设定到程序计数器中</p></li></ul><h3 id="1-6-通过地址和索引实现数组"><a href="#1-6-通过地址和索引实现数组" class="headerlink" title="1.6 通过地址和索引实现数组"></a>1.6 通过地址和索引实现数组</h3><ul><li>通过基址寄存器和变址寄存器，可以对主内存上特定的内存区域进行划分，从而实现类似于数组的操作</li></ul><h3 id="1-7-CPU-的处理其实很简单"><a href="#1-7-CPU-的处理其实很简单" class="headerlink" title="1.7 CPU 的处理其实很简单"></a>1.7 CPU 的处理其实很简单</h3><ul><li><p><a target="_blank" rel="noopener" href="https://www.zhihu.com/question/22471643">64 位的处理器的地址总线一定也是 64 位吗？</a>、<a target="_blank" rel="noopener" href="https://blog.csdn.net/wwwlyj123321/article/details/99940786">cpu 的位宽、操作系统的位宽和寻址能力的关系</a></p><ul><li><p>cpu 的位宽暂时没有严格的定义，但是一般从数值上来讲：cpu 的位宽 &#x3D; 数据总线的位宽 &#x3D; cpu 内部通用寄存器的位宽 &#x3D; 机器字长</p></li><li><p>也就是说 32&#x2F;64 位 CPU，实际上指的是 CPU 内通用寄存器的位宽为 32&#x2F;64</p></li><li><p>通用寄存器为 32&#x2F;64 位，也就意味着数据总线也是 32&#x2F;64 位，因为是需要一次读入 32&#x2F;64 位数据，一次处理 32&#x2F;64 位数据</p></li><li><p>CPU 的寻址能力与它的地址总线位宽有关，与数据总线宽度（CPU 位宽&#x3D;数据总线位宽）无关。16 位 CPU 的地址总线位宽可以是 20 位，32 位 CPU 的地址总线可以是 36 位，64 位 CPU 的地址总线位宽可以是 40 位</p></li></ul></li><li><p>机器语言指令的主要类型和功能</p><p><img src="/image/%E7%A8%8B%E5%BA%8F%E6%98%AF%E6%80%8E%E6%A0%B7%E8%B7%91%E8%B5%B7%E6%9D%A5%E7%9A%84/bde49b7a9fdbaf10f4661f6760a32dd1075555c8.jpeg" srcset="/image/theme/loading.gif" lazyload alt="epub90776129jpeg"></p></li></ul><h2 id="第二章-数据是用二进制数表示的"><a href="#第二章-数据是用二进制数表示的" class="headerlink" title="第二章 数据是用二进制数表示的"></a>第二章 数据是用二进制数表示的</h2><h3 id="2-1-用二进制数表示计算机信息的原因"><a href="#2-1-用二进制数表示计算机信息的原因" class="headerlink" title="2.1 用二进制数表示计算机信息的原因"></a>2.1 用二进制数表示计算机信息的原因</h3><ul><li><p>IC 是集成电路（Integrated Circuit）的简称，有模拟 IC 和数字 IC 两种。本章介绍的是数字 IC。关于内存 IC，我们会在第 4 章详细说明</p></li><li><p>IC 的所有引脚，只有直流电压 0V 或 5V 两个状态。也就是说，IC 的一个引脚，只能表示两个状态。IC 的这个特性，决定了计算机的信息数据只能用二进制数来处理</p><ul><li>大部分 IC 的电源电压都是 +5V。不过，为了控制电量的消耗，有的 IC 也会使用 +5V 以下的电压。如果 IC 使用的电源电压为 +5V，那么引脚状态就不只是 0V 和 +5V，还存在不接收电流信号的高阻抗（high impedance）状态。但在本书中，我们暂时不考虑高阻抗状态</li></ul></li><li><p>计算机处理信息的最小单位——位，就相当于二进制中的一位。位的英文 bit 是二进制数位（binary digit）的缩写</p></li><li><p>二进制数的位数一般是 8 位、16 位、32 位……也就是 8 的倍数，这是因为计算机所处理的信息的基本单位是 8 位二进制数</p></li><li><p>8 位二进制数被称为一个字节，字节是最基本的信息计量单位</p><ul><li>字节是由 bite（咬）一词而衍生出来的词语。8 位（8 bit）二进制数，就类似于“咬下的一口”，因此被视为信息的基本单位。</li></ul></li><li><p>位是最小单位，字节是基本单位。内存和磁盘都使用字节单位来存储和读写数据，使用位单位则无法读写数据。因此，字节是信息的基本单位</p></li><li><p>用字节单位处理数据时，如果数字小于存储数据的字节数（&#x3D;二进制数的位数），那么高位上就用 0 填补</p></li><li><p>奔腾等 32 位微处理器，具有 32 个引脚以用于信息的输入和输出。也就是说，奔腾一次可以处理 32 位（32 位&#x3D;4 字节）的二进制数信息</p></li><li><p>程序中，即使是用十进制数和文字等记述信息，在编译后也会转换成二进制数的值，所以，程序运行时计算机内部处理的也是用二进制数表示的信息</p></li><li><p>对于用二进制数表示的信息，计算机不会区分它是数值、文字，还是某种图片的模式等，而是根据编写程序的各位对计算机发出的指示来进行信息的处理（运算）</p><ul><li>例如 00100111 这样的二进制数，既可以视为纯粹的数值作加法运算，也可以视为”‘“（单引号，single quotation）文字而显示在显示器上，或者视为■■□■■□□□这一图形模式印刷出来。具体进行何种处理，取决于程序的编写方式</li></ul></li></ul><h3 id="2-2-什么是二进制数"><a href="#2-2-什么是二进制数" class="headerlink" title="2.2 什么是二进制数"></a>2.2 什么是二进制数</h3><ul><li><p>十进制数是以 10 为基数的计数方法，二进制数则是以 2 为基数的计数方法</p></li><li><p>位权&#x3D;基数^位数^</p></li></ul><h3 id="2-3-移位运算和乘除运算的关系"><a href="#2-3-移位运算和乘除运算的关系" class="headerlink" title="2.3 移位运算和乘除运算的关系"></a>2.3 移位运算和乘除运算的关系</h3><ul><li><p>移位运算指的是将二进制数值的各数位进行左右移位（shift&#x3D;移位）的运算。移位有左移（向高位方向）和右移（向低位方向）两种。在一次运算中，可以进行多个数位的移位操作</p></li><li><p>左移后空出来的低位要进行补 0 操作。这一规则只适用于左移运算</p></li><li><p>移位运算也可以通过数位移动来代替乘法运算和除法运算</p></li></ul><h3 id="2-4-便于计算机处理的“补数”"><a href="#2-4-便于计算机处理的“补数”" class="headerlink" title="2.4 便于计算机处理的“补数”"></a>2.4 便于计算机处理的“补数”</h3><ul><li><p>用来填充右移后空出来的高位的数值，有 0 和 1 两种形式</p></li><li><p>二进制数中表示负数值时，一般会把最高位作为符号来使用，因此我们把这个最高位称为符号位。符号位是 0 时表示正数，符号位是 1 时表示负数</p></li><li><p>计算机在做减法运算时，实际上内部是在做加法运算。用加法运算来实现减法运算，为此，在表示负数时就需要使用“二进制的补数”。补数就是用正数来表示负数</p></li><li><p>补数求解的变换方法就是“取反 + 1”</p></li><li><p>仔细思考一下补数的机制，大家就会明白像-32768～32767 这样负数比正数多一个的原因了。最高位是 0 的正数，有 0～32767 共 32768 个，这其中也包含 0。最高位是 1 的负数，有-1～- 32768 共 32768 个，这其中不包含 0。也就是说，0 包含在正数范围内，所以负数就要比正数多 1 个。虽然 0 不是正数，但考虑到符号位，就将其划分到了正数中</p></li></ul><h3 id="2-5-逻辑右移和算术右移的区别"><a href="#2-5-逻辑右移和算术右移的区别" class="headerlink" title="2.5 逻辑右移和算术右移的区别"></a>2.5 逻辑右移和算术右移的区别</h3><ul><li><p>当二进制数的值表示图形模式而非数值时，移位后需要在最高位补 0，这就称为逻辑右移</p></li><li><p>将二进制数作为带符号的数值进行运算时，移位后要在最高位填充移位前符号位的值（0 或 1）。这就称为算术右移</p><ul><li>如果数值是用补数表示的负数值，那么右移后在空出来的最高位补 1，就可以正确地实现 1&#x2F;2、1&#x2F;4、1&#x2F;8 等的数值运算。如果是正数，只需在最高位补 0 即可</li></ul></li><li><p>只有在右移时才必须区分逻辑位移和算术位移。左移时，无论是图形模式（逻辑左移）还是相乘运算（算术左移），都只需在空出来的低位补 0 即可</p></li><li><p>以 8 位二进制数为例，符号扩充就是指在保持值不变的前提下将其转换成 16 位和 32 位的二进制数</p></li><li><p>不管是正数还是用补数表示的负数，都只需用符号位的值（0 或者 1）填充高位即可。这就是符号扩充的方法</p></li></ul><h3 id="2-6-掌握逻辑运算的窍门"><a href="#2-6-掌握逻辑运算的窍门" class="headerlink" title="2.6 掌握逻辑运算的窍门"></a>2.6 掌握逻辑运算的窍门</h3><ul><li><p>在运算中，与逻辑相对的术语是算术。我们不妨这样考虑，将二进制数表示的信息作为四则运算的数值来处理就是算术。而像图形模式那样，将数值处理为单纯的 0 和 1 的罗列就是逻辑</p></li><li><p>计算机能处理的运算，大体可分为算术运算和逻辑运算</p><ul><li><p>算术运算是指加减乘除四则运算</p></li><li><p>逻辑运算是指对二进制数各数字位的 0 和 1 分别进行处理的运算</p></li></ul></li><li><p>逻辑运算包括</p><ul><li><p>逻辑非（NOT 运算）：逻辑非指的是 0 变成 1、1 变成 0 的取反操作</p></li><li><p>逻辑与（AND 运算）：逻辑与指的是“两个都是 1”时，运算结果为 1，其他情况下运算结果都为 0 的运算</p></li><li><p>逻辑或（OR 运算）：逻辑或指的是“至少有一方是 1”时，运算结果为 1，其他情况下运算结果都是 0 的运算</p></li><li><p>逻辑异或（XOR 运算）：XOR 是英语 exclusive or 的缩写。有时也将 XOR 称为 EOR。逻辑异或指的是排斥相同数值的运算。“两个数值不同”，也就是说，当“其中一方是 1，另一方是 0”时运算结果是 1，其他情况下结果都是 0</p></li></ul></li></ul><h2 id="第三章-计算机进行小数运算时出错的原因"><a href="#第三章-计算机进行小数运算时出错的原因" class="headerlink" title="第三章 计算机进行小数运算时出错的原因"></a>第三章 计算机进行小数运算时出错的原因</h2><h3 id="3-1-将-0-1-累加-100-次也得不到-10"><a href="#3-1-将-0-1-累加-100-次也得不到-10" class="headerlink" title="3.1 将 0.1 累加 100 次也得不到 10"></a>3.1 将 0.1 累加 100 次也得不到 10</h3><h3 id="3-2-用二进制数表示小数"><a href="#3-2-用二进制数表示小数" class="headerlink" title="3.2 用二进制数表示小数"></a>3.2 用二进制数表示小数</h3><ul><li>由于计算机内部所有的信息都是以二进制数的形式来处理的，因此在这一点上，整数和小数并无差别。不过，使用二进制数来表示整数和小数的方法却有很大的不同</li></ul><h3 id="3-3-计算机运算出错的原因"><a href="#3-3-计算机运算出错的原因" class="headerlink" title="3.3 计算机运算出错的原因"></a>3.3 计算机运算出错的原因</h3><ul><li><p>计算机之所以会出现运算错误，是因为“有一些十进制数的小数无法转换成二进制数”</p></li><li><p>小数点后 4 位用二进制数表示时的数值范围为 0.0000～0.1111。因此，这里只能表示 0.5、0.25、0.125、0.0625 这四个二进制数小数点后面的位权组合而成（相加总和）的小数</p></li><li><p>无法正确表示的数值，在计算机中最后都变成了近似值</p></li><li><p>计算机这个功能有限的机器设备，是无法处理无限循环的小数的。因此，在遇到循环小数时，计算机就会根据变量数据类型所对应的长度将数值从中间截断或者四舍五入。我们知道，将 0.3333…这样的循环小数从中间截断会变成 0.333333，这时它的 3 倍是无法得出 1 的（结果是 0.999999），计算机运算出错的原因也是同样的道理</p></li></ul><h3 id="3-4-什么是浮点数"><a href="#3-4-什么是浮点数" class="headerlink" title="3.4 什么是浮点数"></a>3.4 什么是浮点数</h3><ul><li><p>很多编程语言中都提供了两种表示小数的数据类型，分别是双精度浮点数和单精度浮点数</p><ul><li><p>双精度浮点数类型用 64 位、单精度浮点数类型用 32 位来表示全体小数</p></li><li><p>在 C 语言中，双精度浮点数类型和单精度浮点数类型分别用 double 和 float 来表示</p></li><li><p>这些数据类型都采用浮点数来表示小数</p></li><li><p>双精度浮点数能够表示的正数范围是 4.94065645841247×10^-324^～1.79769313486232×10^308^，负数范围是-1.79769313486232×10^308^～-4.94065645841247×10^-324^。单精度浮点数能够表示的正数范围是 1.401298×10^-45^～3.402823×10^38^，负数范围是-3.402823×10^38^～-1.401298×10^-45^。在这些范围中，有些数值是无法正确表示的</p></li></ul></li><li><p>浮点数是指用符号、尾数、基数和指数这四部分来表示的小数</p><ul><li>像 0.12345×10^3^和 0.12345×10^-1^这样使用与实际小数点位置不同的书写方法来表示小数的形式称为浮点数。与浮点数相对的是定点数，使用定点数表示小数时，小数点的实际位置固定不变。例如，0.12345×103 和 0.12345 ×10-1 用定点数来表示的话即为 123.45 和 0.012345</li></ul></li><li><p>浮点数表现形式</p><p><img src="/image/%E7%A8%8B%E5%BA%8F%E6%98%AF%E6%80%8E%E6%A0%B7%E8%B7%91%E8%B5%B7%E6%9D%A5%E7%9A%84/68a36c8af4982482b742136c9de96760164f4964.jpeg" srcset="/image/theme/loading.gif" lazyload alt="epub90776161jpeg"></p></li><li><p>因为计算机内部使用的是二进制数，所以基数自然就是 2。因此，实际的数据中往往不考虑基数，只用符号、尾数、指数这三部分即可表示浮点数。也就是说，64 位（双精度浮点数）和 32 位（单精度浮点数）的数据，会被分为三部分来使用</p></li><li><p>浮点数的内部构造（IEEE 的规定）</p><p><img src="/image/%E7%A8%8B%E5%BA%8F%E6%98%AF%E6%80%8E%E6%A0%B7%E8%B7%91%E8%B5%B7%E6%9D%A5%E7%9A%84/62669bc90c0678387d9685b2f00e03534194f868.jpeg" srcset="/image/theme/loading.gif" lazyload alt="epub90776162jpeg"></p></li><li><p>双精度浮点数和单精度浮点数在表示同一个数值时使用的位数不同。此外，双精度浮点数能够表示的数值范围要大于单精度浮点数</p></li><li><p>符号部分是指使用一个数据位来表示数值的符号。该数据位是 1 时表示负，为 0 时则表示“正或者 0”。这和用二进制数来表示整数时的符号位是同样的。数值的大小用尾数部分和指数部分来表示。例如，小数就是用“尾数部分× 2 的指数部分次幂”这样的形式来表示的</p></li><li><p>尾数部分和指数部分并不只是单单存储着用整数表示的二进制数。尾数部分用的是“将小数点前面的值固定为 1 的正则表达式”，而指数部分用的则是“EXCESS 系统表现”</p></li></ul><h3 id="3-5-正则表达式和-EXCESS-系统"><a href="#3-5-正则表达式和-EXCESS-系统" class="headerlink" title="3.5 正则表达式和 EXCESS 系统"></a>3.5 正则表达式和 EXCESS 系统</h3><ul><li><p>尾数部分使用正则表达式，可以将表现形式多样的浮点数统一为一种表现形式</p><ul><li>按照特定的规则来表示数据的形式即为正则表达式。除小数之外，字符串以及数据库等，也都有各自的正则表达式</li></ul></li><li><p>在二进制数中，我们使用的是“将小数点前面的值固定为 1 的正则表达式”。具体来讲，就是将二进制数表示的小数左移或右移（这里是逻辑移位。因为符号位是独立的）数次后，整数部分的第 1 位变为 1，第 2 位之后都变为 0（这样是为了消除第 2 位以上的数位）。而且，第 1 位的 1 在实际的数据中不保存。由于第 1 位必须是 1，因此，省略该部分后就节省了一个数据位，从而也就可以表示更多的数据范围（虽不算太多）</p></li><li><p>指数部分中使用的 EXCESS 系统，使用这种方法主要是为了表示负数时不使用符号位</p><ul><li><p>在某些情况下，在指数部分，需要通过“负 x 次幂”的形式来表示负数</p></li><li><p>EXCESS 系统表现是指，通过将指数部分表示范围的中间值设为 0，使得负数不需要用符号来表示</p></li><li><p>也就是说，当指数部分是 8 位单精度浮点数时，最大值 11111111&#x3D;255 的 1&#x2F;2，即 01111111&#x3D;127（小数部分舍弃）表示的是 0，指数部分是 11 位双精度浮点数时，11111111111&#x3D;2047 的 1&#x2F;2，即 01111111111&#x3D;1023（小数部分舍弃）表示的是 0</p></li></ul></li><li><p>单精度浮点数指数部分的 EXCESS 系统表现</p><p><img src="/image/%E7%A8%8B%E5%BA%8F%E6%98%AF%E6%80%8E%E6%A0%B7%E8%B7%91%E8%B5%B7%E6%9D%A5%E7%9A%84/97f6ba27e3286bf8cd4b7616e285d69c7dbc7d5d.jpeg" srcset="/image/theme/loading.gif" lazyload alt="epub90776168jpeg"></p></li><li><p>作为单精度浮点数的示例，上图中列出了指数部分的实际值和用 EXCESS 系统表现后的值。例如，指数部分为二进制数 11111111（十进制数 255），那么在 EXCESS 系统中则表示为 128 次幂。这是因为 255- 127&#x3D;128。因此，8 位的情况下，表示的范围就是-127 次幂～128 次幂</p></li></ul><h3 id="3-7-如何避免计算机计算出错"><a href="#3-7-如何避免计算机计算出错" class="headerlink" title="3.7 如何避免计算机计算出错"></a>3.7 如何避免计算机计算出错</h3><ul><li><p>计算机计算出错的原因之一是，采用浮点数来处理小数（另外，也有因“位溢出”而造成计算错误的情况）。作为程序的数据类型，不管是使用单精度浮点数还是双精度浮点数，都存在计算出错的可能性</p></li><li><p>可以采取以下两种避免该问题的方法</p><ul><li><p>首先是回避策略，即无视这些错误。根据程序目的的不同，有时一些微小的偏差并不会造成什么问题</p><ul><li>例如，假设使用计算机设计工业制品。将 100 个长 0.1 毫米的零件连接起来后，其长度并非一定要是 10 毫米，10.000002 毫米也没有任何问题。一般来讲，在科学技术计算领域，计算机的计算结果只要能得到近似值就足够了。那些微小的误差完全可以忽略掉</li></ul></li><li><p>另一个策略是把小数转换成整数来计算。计算机在进行小数计算时可能会出错，但进行整数计算（只要不超过可处理的数值范围）时一定不会出现问题。因此，进行小数的计算时可以暂时使用整数，然后再把计算结果用小数表示出来即可</p><ul><li>例如，本章一开头讲过的将 0.1 相加 100 次这一计算，就可以转换为将 0.1 扩大 10 倍后再将 1 相加 100 次的计算，最后把结果除以 10 就可以了</li></ul></li></ul></li><li><p>除此之外，BCD（Binary Coded Decimal）也是一种使用二进制表示十进制的方法。简单来讲，BCD 就是用 4 位来表示 0～9 的 1 位数字的处理方法，这里不再做详细说明</p><ul><li>计算机中用到的数据表现形式中，有一种叫作 BCD（Binary Coded Decimal，二进制化十进制数）的方法。这种方法常被用于老式的大型计算机中。编程语言中，COBOL 也会使用 BCD。BCD 分为 Zone 十进制数形式和 Pack 十进制数形式两种。</li></ul></li><li><p>在涉及财务计算等不允许出现误差的情况下，一定要将小数转换成整数或者采用 BCD 方法，以确保最终得到准确的数值</p></li></ul><h3 id="3-8-二进制数和十六进制数"><a href="#3-8-二进制数和十六进制数" class="headerlink" title="3.8 二进制数和十六进制数"></a>3.8 二进制数和十六进制数</h3><ul><li><p>在以位为单位表示数据时，使用二进制数很方便，但如果位数太多，看起来就比较麻烦。因此，在实际程序中，也经常会用十六进制数来代替二进制数。在 C 语言程序中，只需在数值的开头加上 0x（0 和 x）就可以表示十六进制数</p></li><li><p>二进制数的 4 位，正好相当于十六进制数的 1 位，通过使用十六进制数，二进制数的位数能够缩短至原来的 1&#x2F;4</p></li><li><p>用十六进制数来表示二进制小数时，小数点后的二进制数的 4 位也同样相当于十六进制数的 1 位。不够 4 位时用 0 填补二进制数的低位即可</p></li></ul><h2 id="第四章-熟练使用有棱有角的内存"><a href="#第四章-熟练使用有棱有角的内存" class="headerlink" title="第四章 熟练使用有棱有角的内存"></a>第四章 熟练使用有棱有角的内存</h2><h3 id="4-1-内存的物理机制很简单"><a href="#4-1-内存的物理机制很简单" class="headerlink" title="4.1 内存的物理机制很简单"></a>4.1 内存的物理机制很简单</h3><ul><li><p>内存实际上是一种名为内存 IC 的电子元件。虽然内存 IC 包括 DRAM、SRAM、ROM 等多种形式，但从外部来看，其基本机制都是一样的。内存 IC 中有电源、地址信号、数据信号、控制信号等用于输入输出的大量引脚（IC 的引脚），通过为其指定地址（address），来进行数据的读写</p><ul><li>DRAM（Dynamic Random Access Memory）动态随机存取存储器，需要周期性充电，定期刷新</li><li>SRAM（Static Random-Access Memory）静态随机存取存储器，所谓的“静态”，是指这种存储器只要保持通电，里面储存的数据就可以恒常保持，当电力供应停止时，SRAM 储存的数据还是会消失（被称为 volatile memory），这与在断电后还能储存资料的 ROM 或闪存是不同的</li><li>ROM（Read Only Memory）是一种只能用来读取的内存，以非破坏性读出方式工作，只能读出无法写入信息。信息一旦写入后就固定下来，即使切断电源，信息也不会丢失，所以又称为固定存储器</li></ul></li><li><p>内存 IC 的引脚配置示例：虽然这是一个虚拟的内存 IC，但它的引脚和实际的内存 IC 是一样的。VCC 和 GND 是电源，A0～A9 是地址信号的引脚，D0～D7 是数据信号的引脚，RD 和 WR 是控制信号的引脚。将电源连接到 VCC 和 GND 后，就可以给其他引脚传递比如 0 或者 1 这样的信号。大多数情况下，+ 5V 的直流电压表示 1，0V 表示 0</p><p><img src="/image/%E7%A8%8B%E5%BA%8F%E6%98%AF%E6%80%8E%E6%A0%B7%E8%B7%91%E8%B5%B7%E6%9D%A5%E7%9A%84/993b9220a8ec6d91dc652478d30547613d32cb84.jpeg" srcset="/image/theme/loading.gif" lazyload alt="epub90776176jpeg"></p></li><li><p>为了向该内存 IC 中写入 1 字节的数据，可以给 VCC 接入 +5V，给 GND 接入 0V 的电源，并使用 A0～A9 的地址信号来指定数据的存储场所，然后再把数据的值输入给 D0～D7 的数据信号，并把 WR（write&#x3D;写入的简写）信号设定成 1。执行完这些操作，就可以在内存 IC 内部写入数据了</p></li><li><p>读出数据时，只需通过 A0～A9 的地址信号指定数据的存储场所，然后再将 RD（read&#x3D;读出的简写）信号设成 1 即可。执行完这些操作，指定地址中存储的数据就会被输出到 D0～D7 的数据信号引脚中</p></li><li><p>向内存 IC 中写入和读出数据的方法</p><p><img src="/image/%E7%A8%8B%E5%BA%8F%E6%98%AF%E6%80%8E%E6%A0%B7%E8%B7%91%E8%B5%B7%E6%9D%A5%E7%9A%84/de9ee9258b27057f128deb1aaca5a85f11bd782e.jpeg" srcset="/image/theme/loading.gif" lazyload alt="epub90776178jpeg"></p></li><li><p>像 WR 和 RD 这样可以让 IC 运行的信号称为控制信号。其中，当 WR 和 RD 同时为 0 时，写入和读出的操作都无法进行</p></li></ul><h3 id="4-2-内存的逻辑模型是楼房"><a href="#4-2-内存的逻辑模型是楼房" class="headerlink" title="4.2 内存的逻辑模型是楼房"></a>4.2 内存的逻辑模型是楼房</h3><ul><li><p>虽然内存的实体是内存 IC，不过从程序员的角度来看，也可以把它假想成每层都存储着数据的楼房，并不需要过多地关注内存 IC 的电源和控制信号等</p></li><li><p>不过，程序员眼里的内存模型中，还包含着物理内存中不存在的概念，那就是数据类型</p></li><li><p>编程语言中的数据类型表示存储的是何种类型的数据。从内存来看，就是占用的内存大小（占有的楼层数）的意思。即使是物理上以 1 个字节为单位来逐一读写数据的内存，在程序中，通过指定其类型（变量的数据类型等），也能实现以特定字节数为单位来进行读写</p></li><li><p><a target="_blank" rel="noopener" href="https://blog.csdn.net/qq_39400113/article/details/119463013">大端模式、小端模式、高字节序、低字节序、MSB、LSB</a></p><ul><li><p>内存的读写永远从低地址开始读&#x2F;写</p></li><li><p>大端模式（Big-Endian）：高位字节存放在低地址中，低位字节存放在高地址中</p></li><li><p>小端模式（Little-Endian）：高位字节存放在高地址中，低位字节存放在低地址中</p></li><li><p>x86 平台是小端的，ARM 平台是小端的，而 PowerPC 平台是大端的</p></li><li><p>字节高低位： 一般左边为高位，右边为低位</p></li></ul></li></ul><h3 id="4-3-简单的指针"><a href="#4-3-简单的指针" class="headerlink" title="4.3 简单的指针"></a>4.3 简单的指针</h3><ul><li><p>指针也是一种变量，它所表示的不是数据的值，而是存储着数据的内存的地址。通过使用指针，就可以对任意指定地址的数据进行读写</p></li><li><p>虽然前面所提到的假想内存 IC 中仅有 10 位地址信号，但大家在 Windows 计算机上使用的程序通常都是 32 位（4 字节）的内存地址。这种情况下，指针变量的长度也是 32 位</p></li><li><p>下面代码定义了 d、e、f 这 3 个指针变量的 C 语言程序。和通常的变量定义有所不同，在定义指针时，我们通常会在变量名前加一个星号（*）</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">char</span> *d;<br><span class="hljs-type">short</span> *e;<br><span class="hljs-type">long</span> *f;<br></code></pre></td></tr></table></figure><ul><li><p>d、e、f 都是用来存储 32 位（4 字节）的地址的变量。然而，为什么这里又用来指定 char（1 字节）、short（2 字节）、long（4 字节）这些数据类型呢？、实际上，这些数据类型表示的是从指针存储的地址中一次能够读写的数据字节数</p></li><li><p>假设 d、e、f 的值都是 100。在这种情况下，使用 d 时就能够从编号 100 的地址中读写 1 个字节的数据，使用 e 时就是 2 个字节（100 地址和 101 地址）的数据，使用 f 时就是 4 个字节（100 地址～103 地址）的数据</p></li></ul></li></ul><h3 id="4-4-数组是高效使用内存的基础"><a href="#4-4-数组是高效使用内存的基础" class="headerlink" title="4.4 数组是高效使用内存的基础"></a>4.4 数组是高效使用内存的基础</h3><ul><li><p>数组是指多个同样数据类型的数据在内存中连续排列的形式。作为数组元素的各个数据会通过连续的编号被区分开来，这个编号称为索引（index）。指定索引后，就可以对该索引所对应地址的内存进行读写操作。而索引和内存地址的变换工作则是由编译器自动实现的</p></li><li><p>数组的定义中所指定的数据类型，也表示一次能够读写的内存大小。char 类型的数组以 1 个字节为单位对内存进行读写，而 short 类型和 long 类型的数组则分别以 2 个字节、4 个字节为单位对内存进行读写</p></li><li><p>之所以说数组是内存的使用方法的基础，是因为数组和内存的物理构造是一样的。特别是 1 字节类型的数组，它和内存的物理构造完全一致。不过，如果只能逐个字节地来读写，程序就会变得比较麻烦，因而可以指定任意数据类型来定义数组</p></li></ul><h3 id="4-5-栈、队列以及环形缓冲区"><a href="#4-5-栈、队列以及环形缓冲区" class="headerlink" title="4.5 栈、队列以及环形缓冲区"></a>4.5 栈、队列以及环形缓冲区</h3><ul><li><p>栈和队列，都可以不通过指定地址和索引来对数组的元素进行读写。需要临时保存计算过程中的数据、连接在计算机上的设备或者输入输出的数据时，都可以通过这些方法来使用内存。如果每次保存临时数据都需指定地址和索引，程序就会变得比较麻烦，因此要加以改进</p></li><li><p>栈和队列的区别在于数据出入的顺序是不同的。在对内存数据进行读写时，栈用的是 LIFO（LastInput First Out，后入先出）方式，而队列用的则是 FIFO（First Input First Out，先入先出）方式。如果在内存中预留出栈和队列所需要的空间，并确定好写入和读出的顺序，就不用再指定地址和索引了</p></li><li><p>通常情况下，往栈写入数据称为 Push（入栈），从栈中读出数据称为 Pop（出栈）。往队列中写入数据称为 EnQueue（入列），从队列中读出数据称为 DeQueue（出列）</p></li><li><p>队列一般是以环状缓冲区（ring buffer）的方式来实现的</p></li></ul><h3 id="4-6-链表使元素的追加和删除更容易"><a href="#4-6-链表使元素的追加和删除更容易" class="headerlink" title="4.6 链表使元素的追加和删除更容易"></a>4.6 链表使元素的追加和删除更容易</h3><ul><li>链表和二叉查找树，都是不用考虑索引的顺序就可以对数组元素进行读写的方式。通过使用链表，可以更加高效地对数组数据（元素）进行追加和删除处理。而通过使用二叉查找树，则可以更加高效地对数组数据进行检索</li></ul><h3 id="4-7-二叉查找树使数据搜索更有效"><a href="#4-7-二叉查找树使数据搜索更有效" class="headerlink" title="4.7 二叉查找树使数据搜索更有效"></a>4.7 二叉查找树使数据搜索更有效</h3><ul><li>二叉查找树是指在链表的基础上往数组中追加元素时，考虑到数据的大小关系，将其分成左右两个方向的表现形式</li></ul><h2 id="第五章-内存和磁盘的亲密关系"><a href="#第五章-内存和磁盘的亲密关系" class="headerlink" title="第五章 内存和磁盘的亲密关系"></a>第五章 内存和磁盘的亲密关系</h2><ul><li><p>从都具有存储程序命令和数据这点来看，内存和磁盘的功能是相同的</p></li><li><p>在计算机的 5 大部件中，内存和磁盘也都被归类为存储部件</p></li><li><p>不过，利用电流来实现存储的内存，同利用磁效应来实现存储的磁盘，还是有差异的</p></li><li><p>从存储容量来看，内存是高速高价，而磁盘则是低速廉价</p></li></ul><h3 id="5-1-不读入内存就无法运行"><a href="#5-1-不读入内存就无法运行" class="headerlink" title="5.1 不读入内存就无法运行"></a>5.1 不读入内存就无法运行</h3><ul><li><p>程序保存在存储设备中，通过有序地被读出来实现运行，这一机制称为存储程序方式（程序内置方式），它的提出是一个里程碑，在此以前的程序都是通过改变计算机的布线等来变更程序的</p></li><li><p>计算机中主要的存储部件是内存和磁盘。磁盘中存储的程序，必须要加载到内存后才能运行。在磁盘中保存的原始程序是无法直接运行的。这是因为，负责解析和运行程序内容的 CPU，需要通过内部程序计数器来指定内存地址，然后才能读出程序</p></li><li><p>即使 CPU 可以直接读出并运行磁盘中保存的程序，由于磁盘读取速度慢，程序的运行速度还是会降低</p></li><li><p>总之，存储在磁盘中的程序需要读入到内存后才能运行</p></li><li><p>CPU 不能直接读取磁盘的数据</p></li></ul><h3 id="5-2-磁盘缓存加快了磁盘访问速度"><a href="#5-2-磁盘缓存加快了磁盘访问速度" class="headerlink" title="5.2 磁盘缓存加快了磁盘访问速度"></a>5.2 磁盘缓存加快了磁盘访问速度</h3><ul><li><p>磁盘缓存指的是把从磁盘中读出的数据存储到内存空间中的方式。这样一来，当接下来需要读取同一数据时，就不用通过实际的磁盘，而是从磁盘缓存中把内容读出。使用磁盘缓存可以大大改善磁盘数据的访问速度</p></li><li><p>磁盘缓存位于内存中</p></li></ul><h3 id="5-3-虚拟内存把磁盘作为部分内存来使用"><a href="#5-3-虚拟内存把磁盘作为部分内存来使用" class="headerlink" title="5.3 虚拟内存把磁盘作为部分内存来使用"></a>5.3 虚拟内存把磁盘作为部分内存来使用</h3><ul><li><p>虚拟内存（virtual memory）是指把磁盘的一部分作为假想的内存来使用。这与磁盘缓存是假想的磁盘（实际上是内存）相对，虚拟内存是假想的内存（实际上是磁盘）</p></li><li><p>通过借助虚拟内存，在内存不足时也可以运行程序。例如，在只剩下 5MB 内存空间的情况下也能运行 10MB 大小的程序。不过，就如本章开头所讲述的那样，CPU 只能执行加载到内存中的程序。虚拟内存虽说是把磁盘作为内存的一部分来使用，但实际上正在运行的程序部分，在这个时间点上是必须存在在内存中的</p></li><li><p>为了实现虚拟内存，就必须把实际内存（也可称为物理内存）的内容，和磁盘上的虚拟内存的内容进行部分置换（swap），并同时运行程序</p></li><li><p>虚拟内存的方法有分页式和分段式两种。Windows 采用的是分页式。该方式是指，在不考虑程序构造的情况下，把运行的程序按照一定大小的页（page）进行分割，并以页为单位在内存和磁盘间进行置换</p></li><li><p>分段式虚拟内存是指，把要运行的程序分割成以处理集合及数据集合等为单位的段落，然后再以分割后的段落为单位在内存和磁盘之间进行数据置换</p></li><li><p>在分页式中，我们把磁盘的内容读出到内存称为 Page In，把内存的内容写入磁盘称为 Page Out。一般情况下，Windows 计算机的页的大小是 4KB。也就是说，把大程序用 4KB 的页来进行切分，并以页为单位放入磁盘（虚拟内存）或内存中</p></li><li><p>分页式虚拟内存的机制</p><p><img src="/image/%E7%A8%8B%E5%BA%8F%E6%98%AF%E6%80%8E%E6%A0%B7%E8%B7%91%E8%B5%B7%E6%9D%A5%E7%9A%84/05aded30366c614389d68aa1e78f478376ea4ea0.jpeg" srcset="/image/theme/loading.gif" lazyload alt="epub907761108jpeg"></p></li><li><p>为了实现虚拟内存功能，Windows 在磁盘上提供了虚拟内存用的文件（page file，页文件）。该文件由 Windows 自动做成和管理。文件的大小也就是虚拟内存的大小，通常是实际内存的相同程度至两倍程度。通过 Windows 的控制面板，可以查看或变更当前虚拟内存的设定</p></li></ul><h3 id="5-4-节约内存的编程方法"><a href="#5-4-节约内存的编程方法" class="headerlink" title="5.4 节约内存的编程方法"></a>5.4 节约内存的编程方法</h3><ul><li><p>许多人可能会认为，通过借助磁盘虚拟内存就可以解决内存不足的问题。而虚拟内存也确实能避免因内存不足导致的应用无法启动。不过，由于使用虚拟内存时发生的 Page In 和 Page Out 往往伴随着低速的磁盘访问，因此在这个过程中应用的运行会变得迟钝起来</p></li><li><p>为了从根本上解决内存不足的问题，需要增加内存的容量，或者尽量把运行的应用文件变小，以下介绍两种把应用文件变小的编程方法</p></li><li><p>通过 DLL 文件实现函数共有</p><ul><li><p>DLL（Dynamic Link Library）文件，是在程序运行时可以动态加载 Library（函数和数据的集合）的文件</p></li><li><p>多个应用可以共有同一个 DLL 文件。而通过共有同一个 DLL 文件则可以达到节约内存的效果</p></li><li><p>例如，假设我们编写了一个具有某些处理功能的函数 MyFunc()。应用 A 和应用 B 都会使用这个函数。在各个应用的运行文件中内置函数 MyFunc()（这个称为 Static Link，静态链接）后同时运行这两个应用，内存中就存在了具有同一函数的两个程序。但这会导致内存的利用效率降低。如果函数 MyFunc() 是独立的 DLL 文件而不是应用的执行文件（EXE 文件），那结果会怎样呢？由于同一个 DLL 文件的内容在运行时可以被多个应用共有，因此内存中存在的函数 MyFunc() 的程序就只有 1 个。这样一来，内存的利用效率也就提高了</p></li><li><p>Windows 的操作系统本身也是多个 DLL 文件的集合体。有时在安装新应用时，DLL 文件也会被追加。应用则会通过利用这些 DLL 文件的功能来运行。像这样，之所以要利用多个 DLL 文件，其中一个原因就是可以节约内存。而且 DLL 文件还有一个优点就是，在不变更 EXE 文件的情况下，只通过升级 DLL 文件就可以更新</p></li></ul></li><li><p>通过调用_stdcall 来减小程序文件的大小</p><ul><li><p>_stdcall 是 standard call（标准调用）的略称。Windows 提供的 DLL 文件内的函数，基本上都是_stdcall 调用方式。这主要是为了节约内存。另一方面，用 C 语言编写的程序内的函数，默认设置都不是_stdcall。C 语言特有的调用方式称为 C 调用。C 语言之所以默认不使用_stdcall，是因为 C 语言所对应的函数的传入参数是可变的（可以设定任意参数），只有函数调用方才能知道到底有多少个参数，而这种情况下，栈的清理作业便无法进行。不过，在 C 语言中，如果函数的参数数量固定的话，指定_stdcall 是没有任何问题的。</p></li><li><p>通过调用_stdcall 来减小程序文件的方法，是用 C 语言编写应用时可以利用的高级技巧。不过，这一思路应该也可以应用在其他编程语言中</p></li><li><p>C 语言中，在调用函数后，需要执行栈清理处理指令。栈清理处理是指，把不需要的数据从接收和传递函数的参数时使用的内存上的栈区域中清理出去。该命令不是程序记述的，而是在程序编译时由编译器自动附加到程序中的。编译器默认将该处理附加在函数调用方</p></li></ul></li><li><p>_stdcall 的一个例子</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// 函数调用方</span><br><span class="hljs-type">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span><br>&#123;<br>    <span class="hljs-type">int</span> a;<br>    a=MyFunc(<span class="hljs-number">123</span>, <span class="hljs-number">456</span>);<br>&#125;<br><br><span class="hljs-comment">// 被调用方</span><br><span class="hljs-type">int</span> <span class="hljs-title function_">MyFunc</span><span class="hljs-params">(<span class="hljs-type">int</span> a, <span class="hljs-type">int</span> b)</span>&#123;<br>    <span class="hljs-comment">//……</span><br>&#125;<br></code></pre></td></tr></table></figure><ul><li><p>虽然通过调查编译器生成的机器语言执行文件就可以得知栈清理的处理内容，不过鉴于原始的机器语言不太容易理解，所以这里我们用汇编语言的代码清单将其显示了出来。将调用函数 MyFunc() 的部分用汇编语言来表示，就如下面代码所示。最后 1 行的处理就是清理处理</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs nasm">push 1C8h                        参数 456 入栈<br>push 7Bh                         参数 123 入栈<br>call @LTD+15 (MyFunc)(00401014)  调用 MyFunc 函数<br>add esp, 8                       运行栈清理<br></code></pre></td></tr></table></figure></li><li><p>C 语言通过栈来传递函数的参数。push 是往栈中存入数据的指令。32 位 CPU 中，1 次 push 指令可以存储 4 个字节的数据。代码清单 5-2 中，由于使用了两次 push 指令把两个参数（456 和 123）存入到了栈中，因此总的来说就是存储了 8 字节的数据。通过 call 指令调用函数 MyFunc() 后，栈中存储的数据就不再需要了。于是这时就通过 add esp, 8 这个指令，使存储着栈数据的 esp 寄存器前进 8 位（设定为指向高 8 位字节地址），来进行数据清理。由于栈是在各种情况下都可以再利用的内存领域，因此使用完毕后有必要将其恢复到原状态。上述这些操作就是栈的清理处理。另外，在 C 语言中，函数的返回值，是通过寄存器而非栈来返回的</p><ul><li>CPU 中，栈中堆积的最高位的数据地址是保存在 esp（esp 是 Pentium 系列 CPU 的栈指针名）中的。连续运行两次 pop 指令，可以消除两个存储在栈中的 4 字节数据，而同样的功能也可以通过把 esp 的数值加 8 来实现。</li></ul></li><li><p>栈清理处理，比起在函数调用方进行，在反复被调用的函数一方进行时，程序整体要小一些。这时所使用的就是_stdcall。在函数前加上_stdcall，就可以把栈清理处理变为在被调用函数一方进行。把代码清单 5-1 中的 int MyFunc(int a, int b) 部分转成 int _stdcall MyFunc(int a, int b) 进行再编译后，和代码清单 5-2 中 add esp, 8 同样的处理就会在函数 MyFunc() 一方执行。虽然该处理只能节约 3 个字节（add esp, 8 是机器语的 3 个字节）的程序大小，不过在整个程序中还是有效果的</p><p><img src="/image/%E7%A8%8B%E5%BA%8F%E6%98%AF%E6%80%8E%E6%A0%B7%E8%B7%91%E8%B5%B7%E6%9D%A5%E7%9A%84/b0666c9f4fe2e5b76672fff33c0e5ba9ce4b0e02.jpeg" srcset="/image/theme/loading.gif" lazyload alt="epub907761118jpeg"></p></li></ul></li></ul><h3 id="5-5-磁盘的物理结构"><a href="#5-5-磁盘的物理结构" class="headerlink" title="5.5 磁盘的物理结构"></a>5.5 磁盘的物理结构</h3><ul><li><p>磁盘的物理结构是指磁盘存储数据的形式</p></li><li><p>磁盘是通过把其物理表面划分成多个空间来使用的。划分的方式有扇区方式和可变长方式两种，前者是指将磁盘划分为固定长度的空间，后者则是指把磁盘划分为长度可变的空间</p></li><li><p>一般的 Windows 计算机所使用的硬盘和软盘，采用的都是扇区方式</p></li><li><p>扇区方式中，把磁盘表面分成若干个同心圆的空间就是磁道，把磁道按照固定大小（能存储的数据长度相同）划分而成的空间就是扇区</p><p><img src="/image/%E7%A8%8B%E5%BA%8F%E6%98%AF%E6%80%8E%E6%A0%B7%E8%B7%91%E8%B5%B7%E6%9D%A5%E7%9A%84/9cc43058a57e8d3608d176339d16aced306b5842.jpeg" srcset="/image/theme/loading.gif" lazyload alt="epub907761119jpeg"></p></li><li><p>扇区是对磁盘进行物理读写的最小单位</p></li><li><p>Windows 中使用的磁盘，一般 1 个扇区是 512 字节。不过，Windows 在逻辑方面（软件方面）对磁盘进行读写的单位是扇区整数倍簇</p></li><li><p>根据磁盘容量的不同，1 簇可以是 512 字节（1 簇&#x3D;1 扇区）、1KB（1 簇&#x3D;2 扇区）、2KB、4KB、8KB、16KB、32KB（1 簇&#x3D;64 扇区）</p></li><li><p>磁盘的容量越大，簇的容量也越大</p></li><li><p>在软盘中，1 簇&#x3D;512 字节&#x3D;1 扇区，簇和扇区的大小是相等的</p></li><li><p>不管是硬盘还是软盘，不同的文件是不能存储在同一个簇中的，否则就会导致只有一方的文件不能被删除。因此，不管是多么小的文件，都会占用 1 簇的空间。这样一来，所有的文件都会占用 1 簇的整数倍的磁盘空间</p></li></ul><h2 id="第六章-亲自尝试压缩数据"><a href="#第六章-亲自尝试压缩数据" class="headerlink" title="第六章 亲自尝试压缩数据"></a>第六章 亲自尝试压缩数据</h2><h3 id="6-1-文件以字节为单位保存"><a href="#6-1-文件以字节为单位保存" class="headerlink" title="6.1 文件以字节为单位保存"></a>6.1 文件以字节为单位保存</h3><ul><li><p>文件是将数据存储在磁盘等存储媒介中的一种形式。程序文件中存储数据的单位是字节。文件的大小之所以用××KB、××MB 等来表示，就是因为文件是以字节（B&#x3D;Byte）为单位来存储的</p></li><li><p>正如本书第 5 章所述，从物理上对磁盘进行读写时是以扇区（512 字节）为单位的。但另一方面，程序则可以在逻辑上以字节为单位对文件的内容进行读写。</p></li><li><p>文件就是字节数据的集合。用 1 字节（&#x3D;8 位）表示的字节数据有 256 种，用二进制数来表示的话，其范围就是 00000000～11111111。如果文件中存储的数据是文字，那么该文件就是文本文件。如果是图形，那么该文件就是图像文件</p></li><li><p>在任何情况下，文件中的字节数据都是连续存储的</p></li></ul><h3 id="6-2-RLE-算法的机制"><a href="#6-2-RLE-算法的机制" class="headerlink" title="6.2 RLE 算法的机制"></a>6.2 RLE 算法的机制</h3><ul><li><p><a target="_blank" rel="noopener" href="https://blog.csdn.net/LJH_Gemini/article/details/83832836">全角&#x2F;半角字符？</a></p><ul><li><p>全角：指一个字符占用两个标准字符位置；汉字字符和规定了全角的英文字符及国标 GB2312-80 中的图形符号和特殊字符都是全角字符。一般的系统命令是不用全角字符的，只是在作文字处理时才会使用全角字符</p></li><li><p>半角：值一个字符占用一个标准字符位置；通常的英文字母、数字键、符号键都是半角的，半角的显示内码都是一个字节。在系统内部，以上三种字符是作为基本代码处理的，所以用户输入命令和参数时一般都使用半角</p></li><li><p>全角占两个字节，半角占一个字节。半角全角主要是针对标点符号来说的，全角标点占两个字节，半角占一个字节，而不管是半角还是全角，汉字都还是要占两个字节</p></li><li><p>在编程序的源代码中只能使用半角标点（不包括字符串内部的数据）<br>在不支持汉字等语言的计算机上只能使用半角标点（其实这种情况根本就不存在半角全角的概念）</p></li><li><p>对于大多数字体来说，全角看起来比半角大，当然这不是本质区别了</p></li><li><p>全角就是字母和数字等与汉字占等宽位置的字。半角就是 ASCII 方式的字符，在没有汉字输入法起做用的时候输入的字母数字和字符都是半角的。在汉字输入法出现的时候，输入的字母数字默认为半角，但是标点则是默认为全角，可以通过鼠标点击输入法工具条上的相应按钮来改变</p></li><li><p>全角：是指中 GB2312-80（《信息交换用汉字编码字符集·基本集》）中的各种符号</p></li><li><p>半角：是指英文件 ASCII 码中的各种符号</p></li></ul></li><li><p>把文件内容用“数据×重复次数”的形式来表示的压缩方法称为 RLE（Run LengthEncoding，行程长度编码）算法。RLE 算法是一种很好的压缩方法，经常被用于压缩传真的图像等。因为图像文件本质上也是字节数据的集合体，所以可以用 RLE 算法来压缩</p></li><li><p>RLE 算法示例</p><p><img src="/image/%E7%A8%8B%E5%BA%8F%E6%98%AF%E6%80%8E%E6%A0%B7%E8%B7%91%E8%B5%B7%E6%9D%A5%E7%9A%84/21b083b388aa88c0a3ecc2d4fb538156db7209fa.jpeg" srcset="/image/theme/loading.gif" lazyload alt="epub907761128jpeg"></p></li><li><p>RLE 算法经常被用于传真 FAX 等。G3 类传真机是把文字和图形都作为黑白图像来发送的。由于黑白图像的数据中，白或黑通常是部分连续的，因此就没有必要再发送这部分数据的值（白或者黑），而只需附带上重复次数即可，这样压缩效率就得到了大幅提升。例如，像白色部分重复 5 次，黑色部分重复 7 次，白色部分重复 4 次，黑色部分重复 6 次这样的部分图像，就可以用 5746 这样的重复次数数字来进行压缩。</p></li></ul><h3 id="6-3-RLE-算法的缺点"><a href="#6-3-RLE-算法的缺点" class="headerlink" title="6.3 RLE 算法的缺点"></a>6.3 RLE 算法的缺点</h3><ul><li>在实际的文本文件中，同样字符多次重复出现的情况并不多见。虽然针对相同数据经常连续出现的图像、文件等，RLE 算法可以发挥不错的效果，但它并不适合文本文件的压缩</li></ul><h3 id="6-4-通过莫尔斯编码来看哈夫曼算法的基础"><a href="#6-4-通过莫尔斯编码来看哈夫曼算法的基础" class="headerlink" title="6.4 通过莫尔斯编码来看哈夫曼算法的基础"></a>6.4 通过莫尔斯编码来看哈夫曼算法的基础</h3><ul><li><p>哈夫曼算法是哈夫曼（D. A. Huffman）于 1952 年提出来的压缩算法。日本人比较常用的压缩软件 LHA，使用的就是哈夫曼算法</p></li><li><p>文本文件是由不同类型的字符组合而成的，而且不同的字符出现的次数也是不同的。例如，在某一个文本文件中，A 出现了 100 次左右，Q 仅用到了 3 次，类似这样的情况是很常见的。而哈夫曼算法的关键就在于“多次出现的数据用小于 8 位的字节数来表示，不常用的数据则可以用超过 8 位的字节数来表示”</p></li><li><p>不过有一点需要注意，不管是不满 8 位的数据，还是超过 8 位的数据，最终都要以 8 位为单位保存到文件中。这是因为磁盘是以字节为单位来保存数据的。为了实现这一处理，压缩程序的内容会复杂很多，不过作为回报，最终得到的压缩率也是相当高的</p></li><li><p><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/67855882">哈夫曼编码</a></p></li></ul><h3 id="6-5-用二叉树实现哈夫曼编码"><a href="#6-5-用二叉树实现哈夫曼编码" class="headerlink" title="6.5 用二叉树实现哈夫曼编码"></a>6.5 用二叉树实现哈夫曼编码</h3><ul><li><p>哈夫曼算法是指，为各压缩对象文件分别构造最佳的编码体系，并以该编码体系为基础来进行压缩。因此，用什么样式的编码（哈夫曼编码）对数据进行分割，就要由各个文件而定。用哈夫曼算法压缩过的文件中，存储着哈夫曼编码信息和压缩过的数据</p></li><li><p>用哈夫曼算法压缩的文件的构造</p><p><img src="/image/%E7%A8%8B%E5%BA%8F%E6%98%AF%E6%80%8E%E6%A0%B7%E8%B7%91%E8%B5%B7%E6%9D%A5%E7%9A%84/6e3651044f039a2507942b7ee0e45ce5ab159c89.jpeg" srcset="/image/theme/loading.gif" lazyload alt="epub907761134jpeg"></p></li><li><p>而在哈夫曼算法中，通过借助哈夫曼树构造编码体系，即使在不使用字符区分符号的情况下，也可以构建能够明确进行区分的编码体系。也就是说，利用哈夫曼树后，就算表示各字符的数据位数不同，也能够做成可以明确区分的编码</p></li><li><p>哈夫曼树的编码顺序</p><p><img src="/image/%E7%A8%8B%E5%BA%8F%E6%98%AF%E6%80%8E%E6%A0%B7%E8%B7%91%E8%B5%B7%E6%9D%A5%E7%9A%84/8b5747d5328c5b906aa977b72d823dda14d36539.jpeg" srcset="/image/theme/loading.gif" lazyload alt="epub907761136jpeg"></p></li></ul><h3 id="6-6-哈夫曼算法能够大幅提升压缩比率"><a href="#6-6-哈夫曼算法能够大幅提升压缩比率" class="headerlink" title="6.6 哈夫曼算法能够大幅提升压缩比率"></a>6.6 哈夫曼算法能够大幅提升压缩比率</h3><ul><li>通过上图的步骤 2 可以发现，在用枝条连接数据时，我们是从出现频率较低的数据开始的，这就意味着出现频率越低的数据到达根部的枝条数就越多。而枝条数越多，编码的位数也就随之增多了</li></ul><h3 id="6-7-可逆压缩和非可逆压缩"><a href="#6-7-可逆压缩和非可逆压缩" class="headerlink" title="6.7 可逆压缩和非可逆压缩"></a>6.7 可逆压缩和非可逆压缩</h3><ul><li><p>图像文件的使用目的通常是把图像数据输出到显示器、打印机等设备上。Windows 的标准图像数据形式为 BMP，是完全未压缩的。由于显示器及打印机输出的 bit（点）是可以直接映射（mapping）的，因此便有了 BMP&#x3D;bitmap 这一名称</p></li><li><p>除 BMP 格式以外，还有其他各种格式的图像数据形式。比如 JPEG 格式、TIFF 格式、GIF 格式等。与 BMP 格式不同的是，这些图像数据都会用一些技法来对数据进行压缩</p></li><li><p>图像文件还可以使用与前文介绍的 RLE 算法、哈夫曼算法不同的其他压缩算法。这是因为，多数情况下，并不要求压缩后的图像文件必须还原到与压缩前同等的质量。与之相比，程序的 EXE 文件以及每个字符、数值都有具体含义的文本文件则必须要还原到和压缩前同样的内容。而对于图像文件来说，即使有时无法还原到压缩前那样鲜明的图像状态，但只要肉眼看不出什么区别，有一些模糊也勉强可以接受</p></li><li><p>把能还原到压缩前状态的压缩称为可逆压缩，无法还原到压缩前状态的压缩称为非可逆压缩</p></li><li><p>JPEG 格式 [插图] 的文件是非可逆压缩，因此还原后的图像信息有一部分是模糊的，数码相机中经常用到的 JPEG 格式文件，有 3 种压缩方式</p><ul><li><p>把构成图像的点阵的颜色信息由 RGB（红色、绿色、蓝色）形式转化成 YCbCr（亮度、蓝色色度、红色色度）形式。我们知道，人眼对亮度很敏感，但对颜色的变化却有些迟钝。因此，人眼比较敏感的亮度 Y 就是一个很重要的参数，而表示颜色的 Cb、Cr 则没有那么重要。于是我们就可以通过减少 Cb 和 Cr 的信息间距来缩小图像数据的大小</p></li><li><p>将每个点的色素变化看作是波形的信号变化，进行傅里叶变换。傅里叶变换是指将波形按照频率分量进行分解。照片等图像文件的特点是低频率（柔和的颜色变化）的部分较多，高频率（强烈的颜色变化）的部分较少。因此，这里我们就可以把高频率的部分剪切掉。这样一来，图像数据也就会缩小。虽然剪切掉了高频率部分，但人眼分辨不出什么差别。不过，如果是用 Windows 画笔描绘的简单图形，其中颜色变化强烈的部分就会出现模糊现象。大家不妨使用 Windows 画笔做一个圆形或者四方形的图形，并将其保存成 JPEG 格式。然后再打开这个 JPEG 文件，你就会发现颜色变化强烈的部分变模糊了</p></li><li><p>最后，将已经瘦身的图像数据通过哈夫曼算法进行压缩。这样就可以使图像数据进一步缩小。</p></li></ul></li><li><p>而 GIF 格式的文件虽然是可逆压缩，但因为有色数不能超过 256 色的限制，所以还原后颜色信息会有一些缺失，进而导致了图像模糊</p></li><li><p>TIFF 格式的图像文件可以做到不模糊，但是却会比原始的 BMP 格式的文件还要大。TIFF 格式的文件中带有各种标签信息，是可以选择压缩格式的，当选择的是与 BMP 同样的无压缩方式时，由于与原始的图像数据相比，TIFF 格式的文件中附加了标签信息，所以结果就比 BMP 格式的文件更大了</p></li><li><p>压缩算法的种类大概有一二十种。之所以会存在如此多的压缩算法，是因为压缩比率、压缩需要的处理时间（程序的复杂程度）以及各种文件的需求等是不一样的</p></li></ul><h2 id="第七章-程序是在何种环境中运行的"><a href="#第七章-程序是在何种环境中运行的" class="headerlink" title="第七章 程序是在何种环境中运行的"></a>第七章 程序是在何种环境中运行的</h2><ul><li><p>需要理解清楚跨平台的含义</p><ul><li><p><a target="_blank" rel="noopener" href="https://www.zhihu.com/question/386866683">为什么说 c,c++ 不能跨平台，编译器是在计算机操作系统上吗，难道说编译器不是在 c,c++ 程序里吗？</a></p></li><li><p><a target="_blank" rel="noopener" href="https://blog.csdn.net/weixin_39524574/article/details/109971637">python 跨平台原理_为什么 Python 跨平台</a></p></li><li><p>源代码作为文本文件，除了编码的限制，实际上就是跨平台的</p></li><li><p>C&#x2F;C++ 的跨平台是代码级别的，生成的二进制不能跨平台，但是可以跨平台编译部署。这个“跨平台”说的是不修改源码的前提下，可以编译成不同平台的版本。也就是说不用改 C 语言代码，但是要换编译器重新编译一次。</p></li><li><p>对于 Java 这类语言，在源代码和机器代码之间，还有字节码这一层的存在，字节码跨平台，也就是说，只要有 jvm 虚拟机，在任何系统平台上，基本都可以无缝运行字节码</p></li></ul></li></ul><h3 id="7-1-运行环境-x3D-操作系统-硬件"><a href="#7-1-运行环境-x3D-操作系统-硬件" class="headerlink" title="7.1 运行环境&#x3D;操作系统 + 硬件"></a>7.1 运行环境&#x3D;操作系统 + 硬件</h3><ul><li><p>操作系统和硬件决定了程序的运行环境</p></li><li><p>AT 兼容机是指，可以和 IBM 开发的 PC&#x2F;AT 在硬件上相互兼容的计算机的总称。称为“PC&#x2F;AT 兼容机”和“DOS&#x2F;V 机”。现在市面上销售的大部分计算机都是 AT 兼容机。另外，IBM 现在已经把计算机事业部卖给了联想</p></li><li><p>从程序的运行环境这一角度来考量硬件时，CPU 的种类是特别重要的参数。为了保证 Office 2007 的正常运行，需要具备 Pentium 等被称为 x86 的 CPU（微处理器）</p></li><li><p>美国 Intel 的微处理器，是按照 8086、80286、80386、80486、Pentium……这样的顺序不断升级的。因为这些型号的后面都带有 86，所以总称为 x86。32 位处理器也称为“IA-32”。</p></li><li><p><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/113157931">x86，x64，x86-64，amd64，arm 指令集架构之间的关系</a></p></li><li><p><a target="_blank" rel="noopener" href="https://www.jianshu.com/p/2753c45af9bf">【CPU】关于 x86、x86_64&#x2F;x64、amd64 和 arm64&#x2F;aarch64</a></p><ul><li><p>AMD，中文名（超威）超微半导体，是除了英特尔以外最大的 x86 架构微处理供应商，也是除了英伟达以外仅有的独立图形处理供应商</p></li><li><p>x86 泛指一系列由英特尔公司开发的处理器的架构，最早为 1978 年面世的“Intel 8086”CPU。早期的处理器均是以此格式来命名，如 Intel 8086，80186，80286，80386，80486，这些架构被统称为 x86。由于数字不能被注册成为商标，因此公司每当有新的处理器使用，均会采用可注册的名称，如 Pentium</p></li><li><p>基于 x86 的 32 位架构，IA-32 常被称为 i386，x86</p></li><li><p>基于 x86 的 64 位架构，x86-64 常称为 AMD64 或 Intel64。最早是由 AMD 公司首先根据 x86 的架构生产出了 64 位的处理器，但是由于是竞争关系，Intel 公司不愿意承认 AMD64，近些年才推出了 Intel 64</p></li><li><p>ARM（英文为 Advanced RISC Machine，或 Acorn RISC Machine）也是一个架构，非常适用于移动通信这种低成本，高性能，低耗电的领域</p></li><li><p>ARM 的公司为安谋控股（ARM Holding plc），又称为 ARM 公司，总部位于剑桥的设计与软件公司，现在已被日本的软银公司收购，后者同时也是国内互联网巨头阿里巴巴的最大股东</p></li><li><p>AArch64 是 ARMv8 的一种执行状态。AArch64 不是一个单纯的 32 位 ARM 构架扩展，而是 ARMv8 内全新的构架，完全使用全新的 A64 指令集。这些都源自于多年对现代构架设计的深入研究。更重要的是， AArch64 作为一个分离出的执行状态，意味着一些未来的处理器可能不支持旧的 AArch32 执行状态</p></li></ul></li><li><p>几家比较知名的微处理器厂商：Intel、AMD、高通、联发科、海思……</p></li><li><p>CPU 只能解释其自身固有的机器语言。不同的 CPU 能解释的机器语言的种类也是不同的。例如，CPU 有 x86、MIPS、SPARC、PowerPC 等几种类型，它们各自的机器语言是完全不同的</p><ul><li><p>MIPS 是美国 MIPS 科技公司开发的 CPU。曾出现过面向 MIPS 工作站的 Windows，不过现在市面上已经不再出售了</p></li><li><p>SPARC 是美国 SUN 系统开发的 CPU。很多工作站都采用了该 CPU</p></li><li><p>PowerPC 是美国苹果、IBM、摩托罗拉共同开发的 CPU。苹果的 Power Mac 及 IBM 的工作站都采用了该 CPU。不过 Mac 后来采用的是 Intel 的 x86 系列 CPU，现在正在使用基于 arm 的自研 M 系列芯片</p></li></ul></li><li><p>机器语言的程序称为本地代码（native code）。程序员用 C 语言等编写的程序，在编写阶段仅仅是文本文件。文本文件（排除文字编码的问题）在任何环境下都能显示和编辑。我们称之为源代码。通过对源代码进行编译，就可以得到本地代码。在市面上出售的用于 Windows 的应用软件包 CD-ROM 中，收录的就不是源代码，而是本地代码</p></li></ul><h3 id="7-2-Windows-克服了-CPU-以外的硬件差异"><a href="#7-2-Windows-克服了-CPU-以外的硬件差异" class="headerlink" title="7.2 Windows 克服了 CPU 以外的硬件差异"></a>7.2 Windows 克服了 CPU 以外的硬件差异</h3><ul><li><p>MS-DOS（Microsoft Disk Operating System）是 20 世纪 80 年代普遍使用的计算机操作系统，也是 Windows 的前身操作系统</p></li><li><p>在 20 年前的 MS-DOS 时代，日本国内市场上有 NEC 的 PC-9801、富士通的 FMR、东芝的 Dynabook 等各种机型的计算机。Windows3.0 及 3.1 问世前后，AT 兼容机开始普及，并开始同 PC-9801 争夺市场份额。这些机型虽然都搭载了 486 及 Pentiunm 等 x86 系列的 CPU，不过内存和 I&#x2F;O 地址的构成等都是不同的，因此每个机型都需要有专门的 MS-DOS 应用。x86 提供有专门用来同外围设备进行输入输出的 I&#x2F;O 地址空间（I&#x2F;O 地址分配）。至于各外围设备会分配到什么样的地址，则要由计算机的机型来定</p></li><li><p>为什么 MS-DOS 时代，软件需要提供各个机型专用的软件？这是因为，应用软件的功能中，存在着直接操作计算机硬件的部分。而这又是为什么呢？原因主要有两点，一是当时 MS-DOS 的功能尚不完善，二是为了提高程序的运行速度</p></li><li><p>随着 Windows 的广泛使用，这样的局面也得到了大幅改善。因为只要 Windows 能正常运行，同样的应用（本地代码）在任何机型上都是可以运行的</p></li><li><p>在 Windows 的应用软件中，键盘输入、显示器输出等并不是直接向硬件发送指令，而是通过向 Windows 发送指令来间接实现的。因此，程序员就不用注意内存和 I&#x2F;O 地址的不同构成了</p></li><li><p>因为 Windows 操作的是硬件而非应用软件，而且针对不同的机型，这些硬件的构成也是有差异的。不过，Windows 本身则需要为不同的机型分别提供专用的版本，比如用于 AT 兼容机的 Windows、用于 PC-9081 的 Windows 等</p></li><li><p>而即便是 Windows，也依然无法吸收 CPU 类型的差异。这是因为，市面上销售的 Windows 应用软件，都是用特定的 CPU 的本地代码来完成的</p></li><li><p>MS-DOS 应用大多都是不经过操作系统而直接控制硬件的，而 Windows 应用则基本上都由 Windows 来完成对硬件的控制</p><p><img src="/image/%E7%A8%8B%E5%BA%8F%E6%98%AF%E6%80%8E%E6%A0%B7%E8%B7%91%E8%B5%B7%E6%9D%A5%E7%9A%84/acaa00c7b8963cfb07d69ed25fa2d1a70ebf69fa.jpeg" srcset="/image/theme/loading.gif" lazyload alt="epub907761157jpeg"></p></li></ul><h3 id="7-3-不同操作系统的-API-不同"><a href="#7-3-不同操作系统的-API-不同" class="headerlink" title="7.3 不同操作系统的 API 不同"></a>7.3 不同操作系统的 API 不同</h3><ul><li><p>同样机型的计算机，可安装的操作系统类型也会有多种选择。例如，AT 兼容机的情况下，除 Windows 之外，还可以采用 Unix 系列的 Linux 及 FreeBSD 等多个操作系统。当然，应用软件则必须根据不同的操作系统类型来专门开发</p></li><li><p>CPU 的类型不同，所对应的机器语言也不同，同样的道理，操作系统的类型不同，应用程序向操作系统传递指令的途径也是不同的</p></li><li><p>应用程序向操作系统传递指令的途径称为 API（Application Programming Interface）</p><ul><li><p>API 也称为“系统调用”，是应用调用操作系统功能的手段</p></li><li><p>Windows 及 Unix 系列操作系统的 API，提供了任何应用程序都可以利用的函数组合</p></li></ul></li><li><p>因为不同操作系统的 API 是有差异的，因此，将同样的应用程序移植到其他操作系统时，就必须要重写应用中利用到 API 的部分</p></li><li><p>像键盘输入、鼠标输入、显示器输出、文件输入输出等同外围设备进行输入输出操作的功能，都是通过 API 提供的</p></li><li><p>在同类型操作系统下，不管硬件如何，API 基本上没有差别。因而，针对某特定操作系统的 API 所编写的程序，在任何硬件上都可以运行。当然，由于 CPU 种类不同，机器语言也不相同，因此本地代码当然也是不同的。这种情况下，就需要利用能够生成各 CPU 专用的本地代码的编译器，来对源代码进行重新编译了</p></li></ul><h3 id="7-4-FreeBSD-Port-帮你轻松使用源代码"><a href="#7-4-FreeBSD-Port-帮你轻松使用源代码" class="headerlink" title="7.4 FreeBSD Port 帮你轻松使用源代码"></a>7.4 FreeBSD Port 帮你轻松使用源代码</h3><ul><li><p>Unix 系列操作系统 FreeBSD 中，存在一种名为 Ports 的机制。该机制能够结合当前运行的硬件环境来编译应用的源代码，进而得到可以运行的本地代码系统。如果目标应用的源代码没有在硬件上的话，Ports 就会自动使用 FTP 连接到相关站点来下载代码</p></li><li><p>全球很多站点都提供适用于 FreeBSD 的应用源代码。通过使用 Ports 可以利用的程序源代码，大约有 16000 种。这些代码还被按照不同的领域进行了分类整理，可以随时拿来使用</p></li><li><p>FreeBSD 上应用的源代码，大部分都是用 C 语言来记述的。FreeBSD 等 Unix 系列操作系统中，都带有标准的 C 编译器。C 编译器可以结合 FreeBSD 的运行环境生成合适的本地代码。因而，使用 FreeBSD 的同时，肯定也会享受到 Ports 带来的益处。可以说 Ports 能够克服包含 CPU 在内的所有硬件差异的系统。而且，Ports 这个术语，表示的是 porting（移植）的意思。而根据不同的运行环境来重新调整程序，一般也称为“移植”</p></li></ul><h3 id="7-5-利用虚拟机获得其他操作系统环境"><a href="#7-5-利用虚拟机获得其他操作系统环境" class="headerlink" title="7.5 利用虚拟机获得其他操作系统环境"></a>7.5 利用虚拟机获得其他操作系统环境</h3><ul><li><p>即使不通过移植，也可以利用虚拟机软件来运行其他操作系统的应用</p></li><li><p>Virtual PC for MAC 可以使 Macintosh 这一硬件变得同 AT 兼容机一样，从而能在该硬件上安装 Windows。这样一来，Windows 下的所有应用就都可以正常运行了。Windows 应用利用的是 Windows 操作系统的 API。虽然表面上是 Windows 将硬件处理为了 AT 兼容机，但由于 Virtual PC forMAC 的作用，实际上运行的是 Macintosh 这一硬件</p></li></ul><h3 id="7-6-提供相同运行环境的-Java-虚拟机"><a href="#7-6-提供相同运行环境的-Java-虚拟机" class="headerlink" title="7.6 提供相同运行环境的 Java 虚拟机"></a>7.6 提供相同运行环境的 Java 虚拟机</h3><ul><li><p>除虚拟机的方法之外，还有一种方法能够提供不依赖于特定硬件及操作系统的程序运行环境，那就是 Java</p></li><li><p>大家说的 Java，有两个层面的意思。一个是作为编程语言的 Java，另一个是作为程序运行环境的 Java</p></li><li><p>同其他编程语言相同，Java 也是将 Java 语法记述的源代码编译后运行。不过，编译后生成的并不是特定 CPU 使用的本地代码，而是名为字节代码的程序。字节代码的运行环境就称为 Java 虚拟机（JavaVM, Java Virtual Machine）。Java 虚拟机是一边把 Java 字节代码逐一转换成本地代码一边运行的</p></li><li><p>Windows 有 Windows 专用的 Java 虚拟机，Macintosh 也有 Macintosh 专用的 Java 虚拟机。从操作系统方面来看，Java 虚拟机是一个应用，而从 Java 应用方面来看，Java 虚拟机就是运行环境</p></li><li><p>Java 虚拟机也存在不少问题</p><ul><li><p>其中一点就是，不同的 Java 虚拟机之间无法进行完整互换。这是因为，想让所有字节代码在任意 Java 虚拟机上都能运行是比较困难的。而且，当我们使用只适用于某些特定硬件的功能时，就会出现在其他 Java 虚拟机上无法运行，或者功能使用受限等情况</p></li><li><p>另一点就是运行速度的问题。Java 虚拟机每次运行时都要把字节代码变换成本机代码，这一机制是造成运行速度慢的原因。为此，目前业界也在努力改善这一问题，比如把首次变换后的本地代码保存起来，第 2 次以后直接利用本地代码，或是对字节代码中处理较为费时的部分进行优化（改善生成的本地代码质量）等</p></li></ul></li></ul><h3 id="7-7-BIOS-和引导"><a href="#7-7-BIOS-和引导" class="headerlink" title="7.7 BIOS 和引导"></a>7.7 BIOS 和引导</h3><ul><li><p>程序的运行环境中，存在着名为 BIOS（Basic Input&#x2F;Output System）的系统。BIOS 存储在 ROM 中，是预先内置在计算机主机内部的程序。BIOS 除了键盘、磁盘、显卡等基本控制程序外，还有启动“引导程序”的功能</p></li><li><p>引导程序是存储在启动驱动器起始区域的小程序。操作系统的启动驱动器一般是硬盘，不过有时也可以是 CD-ROM 或软盘</p></li><li><p>开机后，BIOS 会确认硬件是否正常运行，没有问题的话就会启动引导程序。引导程序的功能是把在硬盘等记录的 OS 加载到内存中运行。虽然启动应用是 OS 的功能，但 OS 并不能自己启动自己，而是通过引导程序来启动</p></li><li><p>Bootstrap 的原意是指靴子上部的“拔靴带”。BIOS 这样小的程序（拔靴带），可以带动（启动）操作系统这样的大程序（靴子），所以由此得名</p></li></ul></div><hr><div><div class="post-metas my-3"><div class="post-meta mr-3 d-flex align-items-center"><i class="iconfont icon-category"></i> <span class="category-chains"><span class="category-chain"><a href="/categories/%E7%AC%94%E8%AE%B0/" class="category-chain-item">笔记</a></span></span></div><div class="post-meta"><i class="iconfont icon-tags"></i> <a href="/tags/%E5%9F%BA%E7%A1%80%E4%BD%93%E7%B3%BB/">#基础体系</a></div></div><div class="license-box my-3"><div class="license-title"><div>【笔记】程序是怎样跑起来的（上）</div><div>https://tivnantu.github.io/posts/a02f89c0</div></div><div class="license-meta"><div class="license-meta-item"><div>作者</div><div>tivnantu</div></div><div class="license-meta-item license-meta-date"><div>发布于</div><div>2022年3月17日</div></div><div class="license-meta-item"><div>许可协议</div><div><a target="_blank" href="https://creativecommons.org/licenses/by/4.0/"><span class="hint--top hint--rounded" aria-label="BY - 署名"><i class="iconfont icon-by"></i></span></a></div></div></div><div class="license-icon iconfont"></div></div><div class="post-prevnext my-3"><article class="post-prev col-6"><a href="/posts/1893eea5" title="【笔记】程序是怎样跑起来的（下）"><i class="iconfont icon-arrowleft"></i> <span class="hidden-mobile">【笔记】程序是怎样跑起来的（下）</span> <span class="visible-mobile">上一篇</span></a></article><article class="post-next col-6"><a href="/posts/9f5d61d7" title="【笔记】cURL必知必会"><span class="hidden-mobile">【笔记】cURL必知必会</span> <span class="visible-mobile">下一篇</span> <i class="iconfont icon-arrowright"></i></a></article></div></div></article></div></div></div><div class="side-col d-none d-lg-block col-lg-2"><aside class="sidebar" style="margin-left:-1rem"><div id="toc"><p class="toc-header"><i class="iconfont icon-list"></i> <span>目录</span></p><div class="toc-body" id="toc-body"></div></div></aside></div></div></div><a id="scroll-top-button" aria-label="TOP" href="#" role="button"><i class="iconfont icon-arrowup" aria-hidden="true"></i></a><div class="modal fade" id="modalSearch" tabindex="-1" role="dialog" aria-labelledby="ModalLabel" aria-hidden="true"><div class="modal-dialog modal-dialog-scrollable modal-lg" role="document"><div class="modal-content"><div class="modal-header text-center"><h4 class="modal-title w-100 font-weight-bold">搜索</h4><button type="button" id="local-search-close" class="close" data-dismiss="modal" aria-label="Close"><span aria-hidden="true">&times;</span></button></div><div class="modal-body mx-3"><div class="md-form mb-5"><input type="text" id="local-search-input" class="form-control validate"> <label data-error="x" data-success="v" for="local-search-input">关键词</label></div><div class="list-group" id="local-search-result"></div></div></div></div></div></main><footer><div class="footer-inner"><div class="footer-content"><i class="iconfont icon-code"></i> <i class="iconfont icon-love"></i> <i class="iconfont icon-books"></i></div><div class="statistics"><span id="busuanzi_container_site_pv" style="display:none">总访问量 <span id="busuanzi_value_site_pv"></span> 次 </span><span id="busuanzi_container_site_uv" style="display:none">总访客数 <span id="busuanzi_value_site_uv"></span> 人</span></div></div></footer><script src="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.js"></script><link rel="stylesheet" href="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.css"><script>NProgress.configure({showSpinner:!1,trickleSpeed:100}),NProgress.start(),window.addEventListener("load",function(){NProgress.done()})</script><script src="https://lib.baomitu.com/jquery/3.6.0/jquery.min.js"></script><script src="https://lib.baomitu.com/twitter-bootstrap/4.6.1/js/bootstrap.min.js"></script><script src="/js/events.js"></script><script src="/js/plugins.js"></script><script src="https://lib.baomitu.com/typed.js/2.0.12/typed.min.js"></script><script>!function(t){var e=Fluid.plugins.typing,t=t.getElementById("subtitle");t&&e&&e(t.getAttribute("data-typed-text"))}((window,document))</script><script src="/js/img-lazyload.js"></script><script>Fluid.utils.createScript("https://lib.baomitu.com/tocbot/4.18.2/tocbot.min.js",function(){var t,o=jQuery("#toc");0!==o.length&&window.tocbot&&(t=jQuery("#board-ctn").offset().top,window.tocbot.init(Object.assign({tocSelector:"#toc-body",contentSelector:".markdown-body",linkClass:"tocbot-link",activeLinkClass:"tocbot-active-link",listClass:"tocbot-list",isCollapsedClass:"tocbot-is-collapsed",collapsibleClass:"tocbot-is-collapsible",scrollSmooth:!0,includeTitleTags:!0,headingsOffset:-t},CONFIG.toc)),0<o.find(".toc-list-item").length&&o.css("visibility","visible"),Fluid.events.registerRefreshCallback(function(){var t;"tocbot"in window&&(tocbot.refresh(),0!==(t=jQuery("#toc")).length)&&tocbot&&0<t.find(".toc-list-item").length&&t.css("visibility","visible")}))})</script><script src="https://lib.baomitu.com/clipboard.js/2.0.11/clipboard.min.js"></script><script>Fluid.plugins.codeWidget()</script><script>Fluid.utils.createScript("https://lib.baomitu.com/anchor-js/4.3.1/anchor.min.js",function(){window.anchors.options={placement:CONFIG.anchorjs.placement,visible:CONFIG.anchorjs.visible},CONFIG.anchorjs.icon&&(window.anchors.options.icon=CONFIG.anchorjs.icon);var n,o=[];for(n of(CONFIG.anchorjs.element||"h1,h2,h3,h4,h5,h6").split(","))o.push(".markdown-body > "+n.trim());"left"===CONFIG.anchorjs.placement&&(window.anchors.options.class="anchorjs-link-left"),window.anchors.add(o.join(", ")),Fluid.events.registerRefreshCallback(function(){if("anchors"in window){anchors.removeAll();var n,o=[];for(n of(CONFIG.anchorjs.element||"h1,h2,h3,h4,h5,h6").split(","))o.push(".markdown-body > "+n.trim());"left"===CONFIG.anchorjs.placement&&(anchors.options.class="anchorjs-link-left"),anchors.add(o.join(", "))}})})</script><script>Fluid.utils.createScript("https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.js",function(){Fluid.plugins.fancyBox()})</script><script>Fluid.plugins.imageCaption()</script><script src="/js/local-search.js"></script><script defer src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><script src="/js/boot.js"></script><noscript><div class="noscript-warning">博客在允许 JavaScript 运行的环境下浏览效果更佳</div></noscript></body></html>