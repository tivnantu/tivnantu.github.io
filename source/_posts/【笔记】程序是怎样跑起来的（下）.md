---
title: 【笔记】程序是怎样跑起来的（下）
description: 要知道程序员怎样跑起来的，也要知道程序怎样跑起来的
tags:
  - 基础体系
categories: 笔记
abbrlink: 1893eea5
date: 2022-03-17 20:27:46
updated: 2022-03-17 20:27:46
index_img: /image/程序是怎样跑起来的/程序是怎样跑起来的.jpg
banner_img: /image/程序是怎样跑起来的/banner2.png
hide: true
---

## 第八章 从源文件到可执行文件

- [GCC 编译的四个阶段](https://blog.csdn.net/bupt073114/article/details/37049829)

  - 预处理

  - 编译

  - 汇编

  - 链接


### 8.1 计算机只能运行本地代码

- CPU 能直接解析并运行的不是源代码而是本地代码的程序。作为计算机大脑的 Pentium 等 CPU，也只能解释已经转换成本地代码的程序内容

- 本地（native）这个术语有“母语的”意思。对 CPU 来说，母语就是机器语言，而转换成机器语言的程序就是本地代码。用任何编程语言编写的源代码，最后都要翻译成本地代码，否则 CPU 就不能理解。也就是说，即使是用不同编程语言编写的代码，转换成本地代码后，也都变成用同一种语言（机器语言）来表示了

- 转换成本地代码后就变成了同样的语言

  ![epub907761171jpeg](/image/程序是怎样跑起来的/a2eeb5948c1f731383f2c9305b63d84121800816.jpeg)


### 8.2 本地代码的内容

- Dump 是指把文件的内容，每个字节用 2 位十六进制数来表示的方式

- 本地代码的内容就是各种数值的罗列，这些数值就是本地代码的真面目。每个数值都表示某一个命令或数据


### 8.3 编译器负责转换源代码

- 能够把 C 语言等高级编程语言编写的源代码转换成本地代码的程序称为编译器。每个编写源代码的编程语言都需要其专用的编译器。将 C 语言编写的源代码转换成本地代码的编译器称为 C 编译器

- 编译器首先读入代码的内容，然后再把源代码转换成本地代码。编译器中就好像有一个源代码同本地代码的对应表。但实际上，仅仅靠对应表是无法生成本地代码的。读入的源代码还要经过语法解析、句法解析、语义解析等，才能生成本地代码

- 根据 CPU 类型的不同，本地代码的类型也不同。因而，编译器不仅和编程语言的种类有关，和 CPU 的类型也是相关的。例如，Pentium 等 x86 系列 CPU 用的 C 编译器，同 PowerPC 这种 CPU 用的 C 编译器就不同。从另一个方面来看，这其实是非常方便的。因为这样一来，同样的源代码就可以翻译成适用于不同 CPU 的本地代码了

- 因为编译器本身也是程序的一种，所以也需要运行环境。例如，有 Windows 用的 C 编译器、Linux 用的 C 编译器等。此外，还有一种交叉编译器，它生成的是和运行环境中的 CPU 不同的 CPU 所使用的本地代码


### 8.4 仅靠编译是无法得到可执行文件的

- 编译器转换源代码后，就会生成本地文件。不过，本地文件是无法直接运行的。为了得到可以运行的 EXE 文件，编译之后还需要进行“链接”处理

- gcc 通过选项`-c`即可将源代码编译汇编成目标文件，扩展名为.o

  - 目标文件（object file）中的 object 一词，指的是编译器生成结果的意思。和面向对象编程（object oriented programming）的 object 没有任何关系。面向对象编程的对象指的是数据和处理的集合体。

  - 目标文件的内容也是本地代码，但是无法直接运行，原因是当前程序还处于未完成状态

- 把多个目标文件结合，生成 1 个 EXE 文件的处理就是链接，运行连接的程序就称为链接器（linkageeditor 或连结器）


### 8.5 启动及库文件

- 利用编译器链接的时候，有一个较为特殊的目标文件，称为启动代码目标文件，该目标文件由启动代码编译而来，一般由编译器提供

  - Borland C++ 的启动为 c0w32.obj

  - gcc 通过"-v"选项可以查看到调用了很多.o 文件，其中有部分就是启动代码目标文件

- c0w32.obj 是由 Borland C++ 提供的。如果 C：盘中安装有 Borland C++ 的话，文件夹 C:\Borland\bcc55\lib 中就会有 c0w32.obj 这个文件。c0w32.obj 这个目标文件记述的是同所有程序起始位置相结合的处理内容，称为程序的启动。因而，即使程序不调用其他目标文件的函数，也必须要进行链接，并和启动结合起来

- 库文件指的是把多个目标文件集成保存到一个文件中的形式。链接器指定库文件后，就会从中把需要的目标文件抽取出来，并同其他目标文件结合生成 EXE 文件

  - windows 静态库文件就是.lib 文件，动态库文件就是.dll 文件。内容一样，都是将函数封装在一起编译后供自己或他人调用。好处在于编译后的库文件看不到源代码，可保密；同时不会因为不小心修改了函数而出问题，便于维护

  - unix 系统的静态库文件和动态库文件后缀分别是.a 和.so

- 外部符号是指其他目标文件中的变量或函数，错误消息“无法解析的外部符号”表示的是无法找到记述着目的变量及函数的目标文件，因而无法进行链接的意思

- sprintf() 等函数，不是通过源代码形式而是通过库文件形式和编译器一起提供的。这样的函数称为标准函数

  - 之所以使用库文件，是为了简化为链接器的参数指定多个目标文件这一过程。例如，在链接调用了数百个标准函数的程序时，就要在链接器的命令行中指定数百个目标文件，这样就太繁琐了。而利用存储着多个目标文件的库文件的话，则只需在链接器的命令行中指定几个库文件就可以了
- 通过以目标文件的形式或集合多个目标文件的库文件形式来提供函数，就可以不用公开标准函数的源代码内容。由于标准函数的源代码是编译器厂商的贵重财产，因此若被其他公司任意转用的话，可能会造成一些损失


### 8.6 DLL 文件及导入库

- Windows 以函数的形式为应用提供了各种功能。这些形式的函数称为 API（ApplicationProgramming Interface，应用程序接口）

- Windows 中，API 的目标文件，并不是存储在通常的库文件中，而是存储在名为 DLL（Dynamic LinkLibrary）文件的特殊库文件中。就如 Dynamic 这一名称所表示的那样，DLL 文件是程序运行时动态结合的文件

- 在前面的介绍中，我们提到 MessageBox() 的目标文件是存储在 import32.lib 中的。实际上，import32.lib 中仅仅存储着两个信息，一是 MessageBox() 在 user32.dll 这个 DLL 文件中，另一个是存储着 DLL 文件的文件夹信息，MessageBox() 的目标文件的实体实际上并不存在。我们把类似于 import32.lib 这样的库文件称为导入库

- 与此相反，存储着目标文件的实体，并直接和 EXE 文件结合的库文件形式称为静态链接库。静态（static=静态的）同动态（dynamic=动态的）是相反的意思。存储着 sprintf() 的目标文件的 cw32lib 就是静态链接库。sprintf() 提供了通过指定格式把数值转换成字符串的功能

- 通过结合导入库文件，执行时从 DLL 文件中调出的 MessageBox() 函数这一信息就会和 EXE 文件进行结合。这样，链接器链接时就不会再出现错误消息，从而就可以顺利编写 EXE 文件

- Windows 中的编译和链接机制

  ![epub907761183jpeg](/image/程序是怎样跑起来的/17a23eee634bd8e25ace04b43c9f3b29399b392f.jpeg)


### 8.7 可执行文件运行时的必要条件

- 本地代码在对程序中记述的变量进行读写时，是参照数据存储的内存地址来运行命令的。在调用函数时，程序的处理流程就会跳转到存储着函数处理内容的内存地址上。EXE 文件作为本地代码的程序，并没有指定变量及函数的实际内存地址。在类似于 Windows 操作系统这样的可以加载多个可执行程序的运行环境中，每次运行时，程序内的变量及函数被分配到的内存地址都是不同的

- 在 EXE 文件中，变量和函数的内存地址的值，是如何来表示的呢？EXE 文件中给变量及函数分配了虚拟的内存地址。在程序运行时，虚拟的内存地址会转换成实际的内存地址。链接器会在 EXE 文件的开头，追加转换内存地址所需的必要信息。这个信息称为再配置信息

- EXE 文件的再配置信息，就成为了变量和函数的相对地址。相对地址表示的是相对于基点地址的偏移量，也就是相对距离

- 在源代码中，虽然变量及函数是在不同位置分散记述的，但在链接后的 EXE 文件中，变量及函数就会变成一个连续排列的组。这样一来，各变量的内存地址就可以用相对于变量组起始位置这一基点的偏移量来表示，同样，各函数的内存地址也可以用相对于函数组起始位置这一基点的偏移量来表示。而各组基点的内存地址则是在程序运行时被分配的

- 链接后的 EXE 文件的构造

  ![epub907761184jpeg](/image/程序是怎样跑起来的/04a7d9dbe16f6f8c36f8790c3f5c3d978fb2aa07.jpeg)


### 8.8 程序加载时会生成栈和堆

- EXE 文件的内容分为再配置信息、变量组和函数组，除此之外还会额外生成两个组，那就是栈和堆

  - 栈是用来存储函数内部临时使用的变量（局部变量），以及函数调用时所用的参数的内存区域

  - 堆是用来存储程序运行时的任意数据及对象的内存领域

- 加载到内存的程序由 4 部分构成（不管是什么程序，程序的内容都是由处理和数据构成的。大多数编程语言都是用函数来表示处理、用变量来表示数据。）

  ![epub907761186jpeg](/image/程序是怎样跑起来的/fb98e6d8f7009c82fccec5eabdb7f6e22b6fad9a.jpeg)

- EXE 文件中并不存在栈及堆的组。栈和堆需要的内存空间是在 EXE 文件加载到内存后开始运行时得到分配的。因而，内存中的程序，就是由用于变量的内存空间、用于函数的内存空间、用于栈的内存空间、用于堆的内存空间这 4 部分构成的。当然，在内存中，加载 Windows 等操作系统的内存空间又是另外一回事了

- 栈及堆的相似之处在于，他们的内存空间都是在程序运行时得到申请分配的。不过，在内存的使用方法上，二者存在些许不同

  - 栈中对数据进行存储和舍弃（清理处理）的代码，是由编译器自动生成的，因此不需要程序员的参与。使用栈的数据的内存空间，每当函数被调用时都会得到申请分配，并在函数处理完毕后自动释放

  - 堆的内存空间，则要根据程序员编写的程序，来明确进行申请分配或释放

- 根据编程语言的不同，对堆用的内存空间进行申请分配和释放的程序的编写方法也是多种多样的。C 语言中是通过 malloc() 函数来进行申请分配、通过 free() 函数来释放的。而 C++ 中则是通过 new 运算符来申请分配、通过 delete 运算符来释放的

- 无论是 C 语言还是 C++，如果没有在程序中明确释放堆的内存空间，那么即使在处理完毕后，该内存空间仍会一直残留。这个现象称为内存泄露（memoryleak），它是令 C 语言及 C++ 的程序员们十分头疼的一个 bug（程序的错误）。如果内存泄露一直存在的话，就有可能会造成内存不足而导致宕机


## 第九章 操作系统和应用的关系

### 9.1 操作系统功能的历史

- 操作系统（Operating System）也称为基础软件。操作系统是计算机运行时不可或缺的控制程序，以及在控制程序下运转的为其他软件运行提供操作环境的软件的统称。另外，在操作系统上运行的应用也称为“应用程序”。

- 操作系统的发展

  - 在计算机中尚不存在操作系统的年代，完全没有任何程序，因此程序员就需要编写出处理相关的所有程序

  - 用机器语言编写程序，然后再使用开关将程序输入，这一过程非常麻烦。于是，有人开发出了仅具有加载和运行功能的监控程序，这就是操作系统的原型。通过事先启动监控程序，程序员就可以根据需要将各种程序加载到内存中运行。虽然依旧比较麻烦，但比起在没有任何程序的状态下进行开发，工作量得到了很大的缓解

  - 随着时代的发展，人们在利用监控程序编写程序的过程中，发现很多程序都有共通的部分。例如，通过键盘输入文字数据、往显示器输出文字数据等。这些处理，在任何程序下都是一样的。而如果每编写一个新的程序都要记述相同的处理的话，那真的是太浪费时间了。因此，基本的输入输出部分的程序就被追加到了监控程序中。初期的操作系统就这样诞生了

  - 之后，随着时代的进一步发展，开始有更多的功能被追加到监控程序中，比如，为了方便程序员的硬件控制程序、编程语言处理器（汇编、编译、解析）以及各种实用程序等，结果就形成了和现在相差不大的操作系统。因此，操作系统本身并不是单独的程序，而是多个程序的集合体


### 9.2 要意识到操作系统的存在

- 在操作系统这个运行环境下，应用并不是直接控制硬件，而是通过操作系统来间接控制硬件的。变量定义中涉及的内存的申请分配，以及 time() 和 printf() 这些函数的运行结果，都不是面向硬件而是面向操作系统的。操作系统收到应用发出的指令后，首先会对该指令进行解释，然后会对时钟 IC（实时时钟）和显示器用的 I/O 进行控制

- 应用程序经过 OS 间接地控制硬件

  ![epub907761196jpeg](/image/程序是怎样跑起来的/a54934f8d42b223dd0b986033e4caea46ac25a30.jpeg)


### 9.3 系统调用和高级编程语言的移植性

- 操作系统的硬件控制功能，通常是通过一些小的函数集合体的形式来提供的。这些函数及调用函数的行为统称为系统调用（system call），也就是应用对操作系统（system）的功能进行调用（call）的意思

- 在前面的程序中用到了 time() 及 printf() 等函数，这些函数内部也都使用了系统调用。这里之所以用“内部”这个词，是因为在 Windows 操作系统中，提供返回当前日期和时刻，以及在显示器中显示字符串等功能的系统调用的函数名，并不是 time() 和 printf()。系统调用是在 time() 和 printf() 函数的内部执行的

- C 语言等高级编程语言并不依存于特定的操作系统。这是因为人们希望不管是 Windows 还是 Linux，都能使用几乎相同的源代码。因此，高级编程语言的机制就是，使用独自的函数名，然后再在编译时将其转换成相应操作系统的系统调用（也有可能是多个系统调用的组合）。也就是说，用高级编程语言编写的应用在编译后，就转换成了利用系统调用的本地代码

- 在高级编程语言中，也存在可以直接调用系统调用的编程语言。不过，利用这种方式做成的应用，移植性并不友好（也俗称为有恶意行为的应用）。例如，直接调用 Windows 系统调用的应用，在 Linux 上显然是无法运行的


### 9.4 操作系统和高级编程语言使硬件抽象化

- 通过使用操作系统提供的系统调用，程序员就没必要编写直接控制硬件的程序了。而且，通过使用高级编程语言，有时甚至也无需考虑系统调用的存在。这是因为操作系统和高级编程语言能够使硬件抽象化

### 9.5 Windows 操作系统的特征

- Windows 操作系统的主要特征如下所示

  - 32 位操作系统（也有 64 位版本）

  - 通过 API 函数集来提供系统调用

  - 提供采用了图形用户界面的用户界面

  - 通过 WYSIWYG 实现打印输出

  - 提供多任务功能

  - 提供网络功能及数据库功能

  - 通过即插即用实现设备驱动的自动设定


## 第十章 通过汇编语言了解程序的实际构成

- 书中本章节使用的编译器 Borland C++，该编译器较为少见

- 比较建议该章节直接阅读原文


### 10.1 汇编语言和本地代码是一一对应的

- 通过调查本地代码的内容，可以了解程序最终是以何种形式来运行的。但是如果直接打开本地代码来看的话，只能看到数值的罗列。如果直接使用这些数值来编写程序的话，难以理解。因而可以在各本地代码中，附带上表示其功能的英语单词缩写。例如，在加法运算的本地代码中加上 add（addition 的缩写）、在比较运算的本地代码中加上 cmp（compare 的缩写）等。这些缩写称为助记符，使用助记符的编程语言称为汇编语言。这样，通过查看汇编语言编写的源代码，就可以了解程序的本质了。因为这和查看本地代码的源代码，是同一级别的

- 不过，即使是用汇编语言编写的源代码，最终也必须要转换成本地代码才能运行。负责转换工作的程序称为汇编器，转换这一处理本身称为汇编。在将源代码转换成本地代码这个功能方面，汇编器和编译器是同样的

- 用汇编语言编写的源代码，和本地代码是一一对应的。因而，本地代码也可以反过来转换成汇编语言的源代码。持有该功能的逆变换程序称为反汇编程序，逆变换这一处理本身称为反汇编

- 哪怕是用 C 语言编写的源代码，编译后也会转换成特定 CPU 用的本地代码。而将其反汇编的话，就可以得到汇编语言的源代码，并对其内容进行调查。不过，本地代码变换成 C 语言源代码的反编译，则要比反汇编困难。这是因为，C 语言的源代码同本地代码不是一一对应的，因此完全还原到原始的源代码是不太可能的

- 汇编语言的源代码和本地代码是一一对应的

  ![epub907761208jpeg](/image/程序是怎样跑起来的/f8eb5256d51645bbccb73f6ce346d01223e5619d.jpeg)


### 10.2 通过编译器输出汇编语言的源代码

- 除了将本地代码进行反汇编这一方法外，通过其他方式也可以获取汇编语言的源代码。大部分 C 语言编译器，都可以把利用 C 语言编写的源代码转换成汇编语言的源代码，而不是本地代码。利用该功能，就可以对 C 语言的源代码和汇编语言的源代码进行比较研究

- 汇编语言源文件的扩展名，通常用“.asm”来表示。gcc 编译生成的汇编文件扩展名是“.s”

- 汇编语言的注释是每行从分号“;”开始的，分号之后的内容都属于注释


### 10.3 不会转换成本地代码的伪指令

- 汇编语言的源代码，是由转换成本地代码的指令（后面讲述的操作码）和针对汇编器的伪指令构成的

- 伪指令负责把程序的构造及汇编的方法指示给汇编器（转换程序）。不过伪指令本身是无法汇编转换成本地代码的

- Borland C++ 编译得到的汇编文件中，由伪指令 segment 和 ends 围起来的部分，是给构成程序的命令和数据的集合体加上一个名字而得到的，称为段定义

  - 段定义（segment）是用来区分或者划定范围区域的意思

  - 汇编语言的 segment 伪指令表示段定义的起始，ends 伪指令表示段定义的结束

  - 段定义是一个连续的内存空间。

- 段定义的英文表达 segment 具有“区域”的意思。在程序中，段定义指的是命令和数据等程序的集合体的意思。一个程序由多个段定义构成

- C 语言源代码示例

  ```c
  void MyFunc()
  {
      int c;
      c = AddNum(123, 456);
  }

  int AddNum(int a, int b)
  {
      return a + b;
  }
  ```

- Borland C++ 汇编代码示例中

  ```nasm
  _TEXT  segment dword public use32 'CODE'
  _TEXT  ends

  _DATA  segment dword public use32 'DATA'
  _DATA  ends

  _BSS   segment dword public use32 'BSS'
  _BSS   ends

  DGROUP group    _BSS, _DATA

  _TEXT  segment dword public use32 'CODE'
  _AddNum         proc     near
      ;
      ;   int AddNum(int a, int b)
      ;
          push       ebp
          mov        ebp, esp
      ;
      ;   {
      ;        return a + b;
      ;
          mov        eax, dword ptr [ebp+8]
          add        eax, dword ptr [ebp+12]
      ;
      ;   }
      ;
          pop        ebp
          ret
  _AddNum         endp
  _MyFunc         proc     near
      ;
      ;   void MyFunc()
      ;
          push       ebp
          mov        ebp, esp
      ;
      ;  {
      ;        int c;
      ;        c =AddNum(123, 456);
      ;
          push       456
          push       123
          call       _AddNum
          add        esp,8
      ;
      ;   }
      ;
          pop        ebp
          ret
  _MyFunc         endp
  _TEXT  ends
          end
  ```

- 源代码的开始位置，定义了 3 个名称分别为_TEXT、_DATA、_BSS 的段定义。_TEXT 是指令的段定义，_DATA 是被初始化（有初始值）的数据的段定义，_BSS 是尚未初始化的数据的段定义

- 类似于这种段定义的名称及划分方法是 Borland C++ 的规定，是由 Borland C++ 的编译器自动分配的。因而程序段定义的配置顺序就成了_TEXT、_DATA、_BSS，这样也确保了内存的连续性

- [汇编 segment 伪指令](https://blog.csdn.net/c529283955/article/details/102979310)

  - segment_name SEGMENT【定位类型】【组合类型】【类别名】
- group 这一伪指令，表示的是把_BSS 和_DATA 这两个段定义汇总为名为 DGROUP 的组。此外，栈和堆的内存空间会在程序运行时生成，这一点已经在第 8 章中做过介绍

  - group 指的是将源代码中不同的段定义在本地代码程序中整合为一个。
- 围起_AddNum 和_MyFun 的_TEXT segment 和_TEXT ends，表示_AddNum 和_MyFunc 是属于_TEXT 这一段定义的。因此，即使在源代码中指令和数据是混杂编写的，经过编译或者汇编后，也会转换成段定义划分整齐的本地代码

- _AddNum proc 和_AddNum endp 围起来的部分，以及_MyFunc proc 和 MyFunc endp 围起来的部分，分别表示 AddNum 函数和 MyFunc 函数的范围

  - 编译后在函数名前附带上下划线（_），是 Borland C++ 的规定。在 C 语言中编写的 AddNum 函数，在内部是以_AddNum 这个名称被处理的

  - 伪指令 proc 和 endp 围起来的部分，表示的是过程（procedure）的范围。在汇编语言中，这种相当于 C 语言的函数的形式称为过程

- 末尾的 end 伪指令，表示的是源代码的结束


### 10.4 汇编语言的语法是“操作码 + 操作数”

- 在汇编语言中，1 行表示对 CPU 的一个指令。汇编语言指令的语法结构是操作码 + 操作数（也存在只有操作码没有操作数的指令）

- 在汇编语言中，类似于 mov 这样的指令称为“操作码”（opcode），作为指令对象的内存地址及寄存器称为“操作数”（operand）。被转换成 CPU 可以直接解析运行的二进制的操作码和操作数，就是本地代码

- 操作码表示的是指令动作，操作数表示的是指令对象。操作码和操作数罗列在一起的语法，就是一个英文的指令文本。操作码是动词，操作数相当于宾语

- 汇编语言中存在多个操作数的情况下，要用逗号把它们分割开来

- 能够使用何种形式的操作码，是由 CPU 的种类决定的

- 10.3 节示例代码中用到的操作码如下。这些都是 32 位 x86 系列 CPU 用的操作码。操作数中指定了寄存器名、内存地址、常数等。在下表中，操作数是用 A 和 B 来表示的

  ![epub907761217jpeg](/image/程序是怎样跑起来的/d7066c4f29dbb2e5b71d71e45a042c2bdd8c3bd0.jpeg)

- 本地代码加载到内存后才能运行。内存中存储着构成本地代码的指令和数据。程序运行时，CPU 会从内存中把指令和数据读出，然后再将其存储在 CPU 内部的寄存器中进行处理

- 寄存器是 CPU 中的存储区域。不过，寄存器并不仅仅具有存储指令和数据的功能，也有运算功能

- x86 系列 CPU 的寄存器的主要种类和角色如下表所示

  ![epub907761220jpeg](/image/程序是怎样跑起来的/f9d8a7bafdb554dd16dfd81e946f89656102519f.jpeg)

- 寄存器的名称会通过汇编语言的源代码指定给操作数。内存中的存储区域是用地址编号来区分的。CPU 内的寄存器是用 eax 及 ebx 这些名称来区分的

- 此外，CPU 内部也有程序员无法直接操作的寄存器。例如，表示运算结果正负及溢出状态的标志寄存器及操作系统专用的寄存器等，都无法通过程序员编写的程序直接进行操作

- x86 系列 32 位 CPU 的寄存器名称中，开头都带了一个字母 e，例如 eax、ebx、ecx、edx 等。这是因为 16 位 CPU 的寄存器名称是 ax、bx、cx、dx 等。32 位 CPU 寄存器的名称中的 e，有扩展（extended）的意思。我们也可以仅利用 32 位寄存器的低 16 位，此时只需把要指定的寄存器名开头的字母 e 去掉即可


### 10.5 最常用的 mov 指令

- 指令中最常使用的是对寄存器和内存进行数据存储的 mov 指令

- mov 指令的两个操作数，分别用来指定数据的存储地和读出源

  - 操作数中可以指定寄存器、常数、标签（附加在地址前），以及用方括号（[]）围起来的这些内容

  - 如果指定了没有用方括号围起来的内容，就表示对该值进行处理

  - 如果指定了用方括号围起来的内容，方括号中的值则会被解释为内存地址，然后就会对该内存地址对应的值进行读写操作

- mov 指令示例

  ```nasm
  mov ebp, esp
  mov eax, dword ptr [ebp+8]
  ```

- mov ebp, esp 中，esp 寄存器中的值被直接存储在了 ebp 寄存器中。esp 寄存器的值是 100 时 ebp 寄存器的值也是 100

- 而在 mov eax, dword ptr [ebp+8] 的情况下，ebp 寄存器的值加 8 后得到的值会被解释为内存地址。如果 ebp 寄存器的值是 100 的话，那么 eax 寄存器中存储的就是 100 + 8=108 地址的数据

- dword ptr（double word pointer）表示的是从指定内存地址读出 4 字节的数据。像这样，有时也会在汇编语言的操作数前附带 dword ptr 这样的修饰语


### 10.6 对栈进行 push 和 pop

- 程序运行时，会在内存上申请分配一个称为栈的数据空间。栈（stack）有“干草堆积如山”的意思。就如该名称所表示的那样，数据在存储时是从内存的下层（大的地址编号）逐渐往上层（小的地址编号）累积，读出时则是按照从上往下的顺利进行（图 10-3）的

- 栈的模型

  ![epub907761221jpeg](/image/程序是怎样跑起来的/4a05f0a0d0f756e08201c618f656377bbfb55889.jpeg)

- 栈是存储临时数据的区域，它的特点是通过 push 指令和 pop 指令进行数据的存储和读出。往栈中存储数据称为“入栈”，从栈中读出数据称为“出栈”。32 位 x86 系列的 CPU 中，进行 1 次 push 或 pop，即可处理 32 位（4 字节）的数据

- push 指令和 pop 指令中只有一个操作数。该操作数表示的是“push 的是什么及 pop 的是什么”，而不需要指定“对哪一个地址编号的内存进行 push 或 pop”。这是因为，对栈进行读写的内存地址是由 esp 寄存器（栈指针）进行管理的。push 指令和 pop 指令运行后，esp 寄存器的值会自动进行更新（push 指令是-4, pop 命令是 +4），因而程序员就没有必要指定内存地址了


### 10.7 函数调用机制

- MyFunc 函数调用的汇编语言代码示例

  ```nasm
  _MyFunc         proc     near
          push       ebp         ; 1.将 ebp 寄存器的值存入栈中
          mov        ebp, esp    ; 2.将 esp 寄存器的值存入 ebp 寄存器
          push       456         ; 3.456 入栈
          push       123         ; 4.123 入栈
          call       _AddNum     ; 5.调用 AddNum 函数
          add        esp,8       ; 6.esp 寄存器值加 8
          pop        ebp         ; 7.读出栈中的值存入 ebp 寄存器
          ret                    ; 8.结束 MyFunc 函数，返回调用源
  _MyFunc         endp
  ```

-（1）、（2）、（7）、（8）的处理适用于 C 语言中所有的函数，我们会在后面展示 AddNum 函数处理内容时进行说明

-（3）和（4）表示的是将传递给 AddNum 函数的参数通过 push 入栈。在 C 语言的源代码中，虽然记述为函数 AddNum（123,456），但入栈时则会按照 456、123 这样的顺序，也就是位于后面的数值先入栈。这是 C 语言的规定

-（5）的 call 指令，把程序流程跳转到了操作数中指定的 AddNum 函数所在的内存地址处。在汇编语言中，函数名表示的是函数所在的内存地址。AddNum 函数处理完毕后，程序流程必须要返回到编号（6）这一行

- call 指令运行后，call 指令的下一行（（6）这一行）的内存地址（调用函数完毕后要返回的内存地址）会自动地 push 入栈。该值会在 AddNum 函数处理的最后通过 ret 指令 pop 出栈，然后程序流程就会返回到（6）这一行

-（6）部分会把栈中存储的两个参数（456 和 123）进行销毁处理，也就是在第 5 章提到的栈清理处理。虽然通过使用两次 pop 指令也可以实现，不过采用 esp 寄存器加 8 的方式会更有效率（处理 1 次即可）

  - 对栈进行数值的输入输出时，数值的单位是 4 字节。因此，通过在负责栈地址管理的 esp 寄存器中加上 4 的 2 倍 8，就可以达到和运行两次 pop 命令同样的效果

  - 虽然内存中的数据实际上还残留着，但只要把 esp 寄存器的值更新为数据存储地址前面的数据位置，该数据也就相当于被销毁了

- AddNum 函数调用前后栈的状态变化

  ![epub907761224jpeg](/image/程序是怎样跑起来的/2af22962c6c0486d4d9e5411b6ed717a655ab7cc.jpeg)

- C 语言源代码示例中，有一个处理是在变量 c 中存储 AddNum 函数的返回值，不过在汇编语言的源代码中，并没有与此对应的处理。这是因为编译器有最优化功能

  - 最优化功能是编译器在本地代码上费尽功夫实现的，其目的是让编译后的程序运行速度更快、文件更小

  - 在示例代码中，由于存储着 AddNum 函数返回值的变量 c 在后面没有被用到，因此编译器就会认为“该处理没有意义”，进而也就没有生成与之对应的汇编语言代码

  - 在编译示例代码时，应该会出现“警告 W8004 Sample4.c 11: 'c’的赋值未被使用（函数 MyFunc）”这样的警告消息


### 10.8 函数内部的处理

- AddNum 函数调用的汇编语言代码示例

  ```nasm
  _AddNum         proc     near
          push       ebp                        ; 1
          mov        ebp, esp                    ; 2
          mov        eax, dword ptr [ebp+8]    ; 3
          add        eax, dword ptr [ebp+12]    ; 4
          pop        ebp                        ; 5
          ret                                    ; 6
  _AddNum         endp
  ```

- [对于 ESP、EBP 寄存器的理解](https://www.cnblogs.com/xiangtingshen/p/11221277.html)

- ebp 寄存器的值在（1）中入栈，在（5）中出栈。这主要是为了把函数中用到的 ebp 寄存器的内容，恢复到函数调用前的状态。在进入函数处理之前，无法确定 ebp 寄存器用到了什么地方，但由于函数内部也会用到 ebp 寄存器，所以就暂时将该值保存了起来

  - ebp 作为一个用于寻址的固定值是有时间周期的。只有在某个函数执行过程中才是固定的，在函数调用与函数执行完毕后会发生改变。在函数调用之前，将调用者的函数（caller）的 ebp 存入栈，以便于在执行完毕后恢复现场是还原 ebp 的值
- CPU 拥有的寄存器是有数量限制的。在函数调用前，调用源有可能已经在使用 ebp 寄存器了。因而，在函数内部利用的寄存器，要尽量返回到函数调用前的状态。为此，我们就需要将其暂时保存在栈中，然后再在函数处理完毕之前出栈，使其返回到原来的状态

-（2）中把负责管理栈地址的 esp 寄存器的值赋值到了 ebp 寄存器中。这是因为，在 mov 指令中方括号内的参数，是不允许指定 esp 寄存器的。因此，这里就采用了不直接通过 esp，而是用 ebp 寄存器来读写栈内容的方法

-（3）是用 [ebp+8] 指定栈中存储的第 1 个参数 123，并将其读出到 eax 寄存器中。像这样，不使用 pop 指令，也可以查看栈的内容。而之所以从多个寄存器中选择了 eax 寄存器，是因为 eax 寄存器是负责运算的累加寄存器

- 通过（4）的 add 指令，把当前 eax 寄存器的值同第 2 个参数相加后的结果存储在 eax 寄存器中。[ebp+12] 是用来指定第 2 个参数 456 的。在 C 语言中，函数的返回值必须通过 eax 寄存器返回，这也是规定。不过，和 ebp 寄存器不同的是，eax 寄存器的值不用还原到原始状态

- 函数的参数是通过栈来传递，返回值是通过寄存器来返回的

-（6）中 ret 指令运行后，函数返回目的地的内存地址会自动出栈，据此，程序流程就会跳转返回到 10.7 代码清单的（6）（Call _AddNum 的下一行）

- AddNum 函数内部的栈状态变化

  ![epub907761226jpeg](/image/程序是怎样跑起来的/0dc3d7e03f0eb7351b3e4ef29552beb99668488a.jpeg)

- 将 10.7 和图 10.8 的栈状态图按照（a）（b）（c）（d）（e）( f ) 的顺序来看的话，函数调用处理时栈的状态变化就会很清楚了。由于（a）状态时处理跳转到 AddNum 函数，因此（a）和（b）是同样的。同理，在（d）状态时，处理跳转到了调用源，因此（d）和（e）是同样的。在（f）状态时则进行了清理处理。栈的最高位的数据地址，是一直存储在 esp 寄存器中的


### 10.9 始终确保全局变量用的内存空间

- C 语言中，在函数外部定义的变量称为全局变量，在函数内部定义的变量称为局部变量。全局变量可以引用源代码的任意部分，而局部变量只能在定义该变量的函数内进行引用

  - 例如，在 MyFuncA 函数内部定义的 i 这个局部变量就无法通过 MyFuncB 函数进行引用。与此相反，如果是在函数外部定义的全局变量，MyFuncA 函数和 MyFuncB 函数都可以引用
- C 语言源代码示例

  ```c
  //定义被初始化的全局变量
  int a1 = 1;
  int a2 = 2;
  int a3 = 3;
  int a4 = 4;
  int a5 = 5;
  //定义没有初始化的全局变量
  int b1, b2, b3, b4, b5;
  //定义函数
  void MyFunc()
  {
      //定义局部变量
      int c1, c2, c3, c4, c5, c6, c7, c8, c9, c10;
      //给局部变量赋值
      c1 = 1;
      c2 = 2;
      c3 = 3;
      c4 = 4;
      c5 = 5;
      c6 = 6;
      c7 = 7;
      c8 = 8;
      c9 = 9;
      c10 = 10;
      //把局部变量的值赋给全局变量
      a1 = c1;
      a2 = c2;
      a3 = c3;
      a4 = c4;
      a5 = c5;
      b1 = c6;
      b2 = c7;
      b3 = c8;
      b4 = c9;
      b5 = c10;
  }
  ```

- 对应的汇编代码

  ![epub907761228jpeg](/image/程序是怎样跑起来的/cda687191992ffe85e8a5487cb98974883fafb36.jpeg)

  ![epub907761229jpeg](/image/程序是怎样跑起来的/f9df62676d6a346e0c4d3395abeb358574618767.jpeg)

- 上述汇编代码为了方便说明，我们省略了一部分汇编语言源代码，并改变了一下段定义的配置顺序，删除了注释

- 该处汇编代码主要用到的汇编语言指令的功能

  ![epub907761227jpeg](/image/程序是怎样跑起来的/756a899132b00824ceeb73345b3cabd9ec03fac8.jpeg)

- 正如本章前半部分所讲的那样，编译后的程序，会被归类到名为段定义的组

  - 初始化的全局变量，会像（1）那样被汇总到名为_DATA 的段定义中

  - 没有初始化的全局变量，会像（2）那样被汇总到名为_BSS 的段定义中

  - 指令则会像（3）那样被汇总到名为_TEXT 的段定义中

  - 这些段定义的名称是由 Borland C++ 的使用规范来决定的。_DATA segment 和_DATA ends、_BSS segment 和_BSS ends、_TEXT segment 和_TEXT ends，这些都是表示各段定义范围的伪指令

- 首先让我们来看一下_DATA 段定义的内容。（4）中的_a1 label dword 定义了_a1 这个标签

  - 标签表示的是相对于段定义起始位置的位置

  - 由于_a1 在_DATA 段定义的开头位置，所以相对位置是 0

  - \_a1 就相当于全局变量 a1。编译后的函数名和变量名前会附加一个下划线 (_），这也是 Borland C++ 的规定

-（5）中的 dd 1 指的是，申请分配了 4 字节的内存空间，存储着 1 这个初始值

  - dd（definedouble word）表示的是定义个双字（double word），而每个字的长度是 2 个字节，也就是说申请了一个 4 字节的内存空间

  - Borland C++ 中，由于 int 类型的长度是 4 字节，因此汇编器就把 int a1=1；变换成了_a1 label dword 和 dd 1

  - 同样，这里也定义了相当于全局变量 a2～a5 的标签_a2～_a5，它们各自的初始值 2～5 也都被存储在了 4 字节的领域中

- 接下来，让我们来看一下_BSS 段定义的内容。这里定义了相当于全局变量 b1～b5 的标签_b1～_b5。（6）的 db 4 dup(? ) 表示的是申请分配了 4 字节的领域，但值尚未确定（这里用？来表示）的意思

  - db（define byte）表示有 1 个长度是 1 字节的内存空间。因而，db 4 dup(? ) 的情况下，就是 4 字节的内存空间

  - 这里大家要注意不要和 dd 4 混淆了。db 4 dup(? ) 表示的是 4 个长度是 1 字节的内存空间。而 dd 4 表示的则是双字（4 byte）的内存空间中存储的值是 4

- 在_DATA 和_BSS 的段定义中，全局变量的内存空间都得到了确保，这一点大家想必都清楚了吧。因而，从程序的开始到结束，所有部分都可以引用全局变量。而这里之所以根据是否进行了初始化把全局变量的段定义划分为了两部分，是因为在 Borland C++ 中，程序运行时没有初始化的全局变量的领域（_BSS 段定义）都会被设定为 0 进行初始化。可见，通过汇总，初始化很容易实现，只要把内存的特定范围全部设定为 0 就可以了

- [计算机系统内的字长到底指的是什么？](https://www.zhihu.com/question/20536161)

  - 字长要从汇编语言的角度理解，就是指令集里面的运算和内存操作时操作数的长度。比如你写一条 load a, reg1，那么 a 这个操作数的长度就是字长。32 位机的字长**最大**是 32bit，64 位机的字长**最大**是 64bit

  - “有时候字长被定义为某个特定值是为了与早期的电脑保持兼容。现在个人电脑中最通用的微处理器（例如：Intel 的 Pentium 系列和 AMD 的 Athlon 系列）就是一个例子。它们中的 IA-32 构架是早期的具有 16 位字长的 Intel 8086 构架的扩展。而 IA-32 处理器仍然支持 8086（x86）程序，所以在 IA-32 中，“字”的含义仍然为 16 位，尽管事实上它运行起来（特别是当默认操作数为 32 位时）更像一台 32 位电脑。类似地，在更新型的 x86-64 构架中，“字”仍然是 16 位的，虽然 64 位操作数更为常见。”


### 10.10 临时确保局部变量用的内存空间

- 为什么局部变量只能在定义该变量的函数内进行引用呢？这是因为，局部变量是临时保存在寄存器和栈中的。正如本章前半部分讲的那样，函数内部利用的栈，在函数处理完毕后会恢复到初始状态，因此局部变量的值也就被销毁了，而寄存器也可能会被用于其他目的。因此，局部变量只是在函数处理运行期间临时存储在寄存器和栈上

- 在代码清单 10.9 中定义了 10 个局部变量。这是为了表示存储局部变量的不仅仅是栈，还有寄存器。为确保 c1～c10 所需的领域，寄存器空闲时就使用寄存器，寄存器空间不足的话就使用

- 下面让我们来看一下代码清单 10-7 中_TEXT 段定义的内容。（7）表示的是 MyFunc 函数的范围。在 MyFunc 函数中定义的局部变量所需要的内存领域，会被尽可能地分配在寄存器中

  - 大家可能会认为用高性能的寄存器来代替普通的内存是很奢侈的事情，不过编译器不会这么认为，只要寄存器有空间，编译器就会使用它。因为与内存相比，使用寄存器时访问速度会高很多，这样就可以更快速地进行处理

  - 局部变量利用寄存器，是 Borland C++ 编译器最优化的运行结果。旧的编译器没有类似的最优化功能，局部变量就可能会仅仅使用栈

- 代码清单中的（8）表示的是往寄存器中分配局部变量的部分

  - 仅仅对局部变量进行定义是不够的，只有在给局部变量赋值时，才会被分配到寄存器的内存区域

  -（8）就相当于给 5 个局部变量 c1～c5 分别赋予数值 1～5 这一处理

  - eax、edx、ecx、ebx、esi 是 Pentium 等 x86 系列 32 位 CPU 寄存器的名称。至于使用哪一个寄存器，则要由编译器来决定。这种情况下，寄存器只是被单纯地用于存储变量的值，和其本身的角色没有任何关系

- x86 系列 CPU 拥有的寄存器中，程序可以操作的有十几个。其中空闲的，最多也只有几个。因而，局部变量数目很多的时候，可分配的寄存器就不够了。这种情况下，局部变量就会申请分配栈的内存空间

- 虽然栈的内存空间也是作为一种存储数据的段定义来处理的，但在程序各部分都可以共享并临时使用这一点上，它和_DATA 段定义及_BSS 段定义在性质上还是有些差异的

  - 例如，在函数入口处为变量申请分配栈的内存空间的话，就必须在函数出口处进行释放。否则，经过多次调用函数后，栈的内存空间就会被用光了
- 在（8）这一部分中，给局部变量 c1～c5 分配完寄存器后，可用的寄存器数量就不足了。于是，剩下的 5 个局部变量 c6～c10 就被分配了栈的内存空间，如（9）所示

- 函数入口（10）处的 add esp, -20 指的是，对栈数据存储位置的 esp 寄存器（栈指针）的值做减 20 的处理

  - 为了确保内部变量 c6～c10 在栈中，就需要保留 5 个 int 类型的局部变量（4 字节×5=20 字节）所需的空间
-（11）中的 mov ebp,esp 这一处理，指的是把当前 esp 寄存器的值复制到 ebp 寄存器中。之所以需要（11）这一处理，是为了通过在函数出口处的（12）这一 move esp, ebp 的处理，把 esp 寄存器的值还原到原始状态，从而对申请分配的栈空间进行释放，这时栈中用到的局部变量就消失了。这也是栈的清理处理

  - 在使用寄存器的情况下，局部变量则会在寄存器被用于其他用途时自动消失
- 用于局部变量的栈空间的申请分配和释放

  ![epub907761230jpeg](/image/程序是怎样跑起来的/a365d794845fef62dcfdc6c11bdf49ac31ffc81d.jpeg)

-（9）中的 5 行代码是往栈空间中代入数值的部分

  - 由于在向栈申请内存空间前，借助 mov ebp, esp 这个处理，esp 寄存器的值被保存到了 ebp 寄存器中，因此，通过使用 [ebp - 4]、[ebp - 8]、[ebp -12]、[ebp - 16]、[ebp - 20] 这样的形式，就可以将申请分配的 20 字节的栈内存空间切分成 5 个长度分别是 4 字节的空间来使用

  - 例如，（9）中的 mov dword ptr [ebp - 4], 6 表示的就是，从申请分配的内存空间的下端（ebp 寄存器指示的位置）开始往前 4 字节的地址（[ebp - 4]）中，存储着 6 这一 4 字节的数据

- 将栈的内存空间进行分割

  ![epub907761231jpeg](/image/程序是怎样跑起来的/62cf32fe0b9da86a0123bf4d6e416d621166856e.jpeg)

- 关于往全局变量中代入局部变量的数值这一内容，这里不再进行说明。这时可能有读者会产生疑问，既然不进行说明，那为什么代码清单 10.9 中没有省略掉该部分呢？这是为了避免编译器的最优化功能。如果仅进行定义局部变量并代入数值这一处理的话，编译器的最优化功能就会启动，届时编译器就会认为某些代码没有意义，从而导致汇编语言的源代码无法生成


### 10.11 循环处理的实现方法

- C 语言源代码示例

  ```c
  //定义 MySub 函数
  void MySub()
  {
      //不做任何处理
  }
  // 定义 MyFunc 函数
  void MyFunc()
  {
      int i;
      for (i = 0; i < 10; i++)
      {
          //重复调用 MySub 函数 10 次
          MySub();
      }
  }
  ```

- 将代码清单 10.11 中的 for 语句转换成汇编语言的结果

  ```nasm
      xor     ebx, ebx         ; 将 ebx 寄存器清 0
  @4  call    _MySub           ; 调用 MySub 函数
      inc     ebx              ; ebx 寄存器的值加 1
      cmp     ebx,10           ; 将 ebx 寄存器的值和 10 进行比较
      jl      short @4         ; 如果小于 10 就跳转到 @4
  ```

- 下面就让我们按照代码清单 10.11 的内容的顺序来进行说明。MyFunc 函数中用到的局部变量只有 i，变量 i 申请分配了 ebx 寄存器的内存空间。for 语句的括号中的 i=0；被转换成了 xor ebx, ebx 这一处理。xor 指令会对左起第一个操作数和右起第二个操作数进行 XOR 运算，然后把结果存储在第一个操作数中

  - 由于这里把第一个操作数和第二个操作数都指定为了 ebx，因此就变成了对相同数值进行 XOR 运算。也就是说，不管当前 ebx 寄存器的值是什么，结果肯定都是 0

  - 虽然用 mov 指令的 mov ebx,0 也会得到同样的结果，但与 mov 指令相比，xor 指令的处理速度更快。这里，编译器的最优化功能也会启动

- ebx 寄存器的值初始化后，会通过 call 指令调用 MySub 函数（_MySub）。从 MySub 函数返回后，则会通过 inc 指令对 ebx 寄存器的值做加 1 处理。该处理就相当于 for 语句的 i++, ++ 是当前数值加 1 的意思

- 下一行的 cmp 指令是用来对第一个操作数和第二个操作数的数值进行比较的指令。cmp ebx,10 就相当于 C 语言的 i<10 这一处理，意思是把 ebx 寄存器的数值同 10 进行比较。汇编语言中比较指令的结果，会存储在 CPU 的标志寄存器中

- 标志寄存器的值，程序是无法直接参考的。那么程序是怎么来判断比较结果的？实际上，汇编语言中有多个跳转指令，这些跳转指令会根据标志寄存器的值来判定是否需要跳转。例如，最后一行的 jl，是 jump on less than（小于的话就跳转）的意思。也就是说，jl short @4 的意思就是，前面运行的比较指令的结果若“小”的话就跳转到 @4 这个标签

- 下列代码是按照汇编语言源代码的处理顺序重写的 C 语言源代码（由于 C 语言中无法使用 @字符开头的标签，因此这里用了 L4 这个标签名），也是对程序实际运行过程的一个直接描述

  ```c
      i ^=i;
  L4: MySub();
      i++;
      if (i < 10) goto L4
  ```

- 上代码和 for 语句相比显得比较复杂且难以理解。汇编语言是对 CPU 的实际运行进行直接描述的低级编程语言，C 语言是用与人类的感觉相近的表现来描述的高级编程语言


### 10.12 条件分支的实现方法

- 条件分支的实现方法同循环处理的实现方法类似，使用的也是 cmp 指令和跳转指令

- C 语言程序代码示例

  ```c
  //定义 MySub1 函数
  void MySub1()
  {
      //不做任何处理
  }
  //定义 MySub2 函数
  void MySub2()
  {
      //不做任何处理
  }
  //定义 MySub3 函数
  void MySub3()
  {
      //不做任何处理
  }
  //定义 MyFunc 函数
  void MyFunc()
  {
      int a = 123;
      //根据条件调用不同的函数
      if (a > 100)
      {
          MySub1();
      }
      else if (a < 50)
      {
          MySub2();
      }
      else
      {
          MySub3();
      }
  }
  ```

- 将代码清单 10.12 的 MyFunc 函数转换成汇编语言后的结果

  ```nasm
  _MyFunc         proc        near
              push    ebp;
              mov     ebp, esp;
              mov     eax,123         ；把 123 存入 eax 寄存器中
              cmp     eax,100         ；把 eax 寄存器的值同 100 进行比较
              jle     short @8        ；等于或小于 100 时，跳转到 @8 标签
              call    _MySub1         ；调用 MySub1 函数
              jmp     short @11       ；跳转到 @11 标签
      @8:     cmp     eax,50          ；把 eax 寄存器的值同 50 进行比较
              jge     short @10       ；大于等于 50 时，跳转到 @10 标签
              call    _MySub2         ；调用 MySub2 函数
              jmp     short @11       ；跳转到 @11 标签
      @10:    call    _MySub3         ；调用 MySub3 函数
      @11:    pop     ebp
              ret
      _MyFunc     endp
  ```

- 上述代码用到了三种跳转指令，分别是比较结果小或相等时跳转的 jle（jump on less orequal）、大或相等时跳转的 jge（jump on greater or equal）、不管结果怎样都无条件跳转的 jmp

- 在这些跳转指令之前还有用来比较的 cmp 指令，比较结果被保存在了标志寄存器中

- 虽然大部分的 C 语言参考书中都写着“为了便于理解程序的结构，应尽量避免使用无条件分支的 goto 语句”，不过，在汇编语言这一领域中，如果不使用相当于 C 语言 goto 语句的 jmp 指令，就无法实现循环和条件分支


## 第十一章 硬件控制方法

### 11.1 应用和硬件无关？

- 在用 C 语言等高级编程语言开发的 Windows 应用中，很少能接触到直接控制硬件的指令。这是因为硬件的控制是由 Windows 全权负责的

- Windows 提供了通过应用来间接控制硬件的方法。利用操作系统提供的系统调用功能就可以实现对硬件的控制。在 Windows 中，系统调用称为 API。各 API 就是应用调用的函数。这些函数的实体被存储在 DLL 文件中


### 11.2 支撑硬件输入输出的 IN 指令和 OUT 指令

- Window 控制硬件时借助的是输入输出指令。其中具有代表性的两个输入输出指令就是 IN 和 OUT。这些指令也是汇编语言的助记符

- Pentium 等 x86 系列 CPU 用的 IN 指令和 OUT 指令的语法如下

  ```nasm
  IN 寄存器名，端口号
  OUT 寄存器名，端口号
  ```

- IN 指令通过指定端口号的端口输入数据，并将其存储在 CPU 内部的寄存器中。OUT 指令则是把 CPU 寄存器中存储的数据，输出到指定端口号的端口

- 计算机主机中，附带了用来连接显示器及键盘等外围设备的连接器。而各连接器的内部，都连接有用来交换计算机主机同外围设备之间电流特性的 IC。这些 IC，统称为 I/O 控制器。由于电压不同，数字信号及模拟信号的电流特性也不同，计算机主机和外围设备是无法直接连接的。为了解决这个问题，I/O 控制器就很有必要了

- I/O 是 Input/Output 的缩写。显示器、键盘等外围设备都有各自专用的 I/O 控制器。I/O 控制器中有用于临时保存输入输出数据的内存。这个内存就是端口

  - 端口（port）的字面意思是“港口”。由于端口就像是在计算机主机和外围设备之间进行货物（数据）装卸的港口，所以因此得名
- I/O 控制器内部的内存，也称为寄存器。虽然都是寄存器，但它和 CPU 内部的寄存器在功能上是不同的。CPU 内部的寄存器是用来进行数据运算处理的，而 I/O 寄存器则主要是用来临时存储数据的

- 在实现 I/O 控制器功能的 IC 中，会有多个端口。由于计算机中连接着很多外围设备，所以就会有多个 I/O 控制器，当然也会有多个端口。一个 I/O 控制器既可以控制一个外围设备，也可以控制多个外围设备

- 各端口之间通过端口号进行区分。端口号也称为 I/O 地址。IN 指令和 OUT 指令在端口号指定的端口和 CPU 之间进行数据的输入输出。这和通过内存地址来进行主内存的读写是一样的道理

- 以端口为桥梁来实现 CPU 和外围设备之间的数据传递

  ![epub907761240jpeg](/image/程序是怎样跑起来的/99801ecad3f1462f616425e00e3279c52d127875.jpeg)

- I/O 装置，有的直接附带在计算机主机的主板（用来放置 CPU 的基板）上，有的则是各自独立的扩展板卡

  - 键盘、鼠标、打印机等常用的 I/O，一般都在主板上

  - 显示高速图形的显示器及网卡等特殊的 I/O，通常是独立的扩张板卡


### 11.3 编写测试用的输入输出程序

- 首先让我们利用 IN 指令和 OUT 指令，来进行一个直接控制硬件的试验。假设该试验的目的是让计算机内配置的蜂鸣器（小喇叭）发音。虽然蜂鸣器内置在计算机内部，但其本身也是外围设备的一种。因为就算是把蜂鸣器取出，对计算机主机也不会有什么影响

- 由于用汇编语言编写程序比较麻烦，因此这里我们采取在 C 语言源代码中插入助记符的方式来实现。在大部分 C 语言的处理（编译器的种类）中，只要使用_asm{和}括起来，就可以在其中记述助记符。也就是说，这样就可以编写 C 语言和汇编语言混合的源代码。这里，我们使用微软的 Visual C++ 来作成应用

- 在 AT 兼容机中，蜂鸣器的默认端口号是 61H（末尾的 H，表示的是十六进制数（Hexadecimal）的意思）。用 IN 指令通过该端口号输入数据，并将数据的低 2 位设定为 ON，然后再通过该端口号用 OUT 指令输出数据，这时蜂鸣器就会响起来。采用同样的操作方法，将数据的低 2 位设定为 OFF 并输出后，蜂鸣器就停止了

- 处理逻辑

  - 位设定为 ON 指的是将该位设定为 1，位设定为 OFF 指的是将该位设定为 0

  - 把位设定为 ON，只需把想要设定为 ON 的位设定为 1，其他位设定为 0 后进行 OR 运算即可，由于这里需要把低 2 位置为 1，因此就是和 03H 进行 OR 运算。03H 用 8 位二进制数来表示的话是 00000011。由于即便高 6 位存在着具体意义，和 0 进行 OR 运算后也不会发生变化，因而就和 03H 进行 OR 运算

  - 把位设定为 OFF，只需把想要置 OFF 的位设定为 0，其他位设定为 1 后进行 AND 运算即可。由于这里需要把低 2 位设定为 0，因此就要和 FCH 进行 AND 运算，在源代码中，FCH 是用 0FCH 来记述的。在前面加 0 是汇编语言的规定，表示的是以 A～F 这些字符开头的十六进制数是数值的意思。0FCH 用 8 位二进制数来表示的话是 11111100。由于即便高 6 位存在着具体意义，和 1 进行 AND 运算后也不会产生变化，因而就是同 0FCH 进行 OR 运算

- 利用 IN/OUT 指令来控制蜂鸣器的程序示例

  ![epub907761245jpeg](/image/程序是怎样跑起来的/585992d32b9b6191e148944e6c652b79acf16e63.jpeg)

- 下面对上述代码进行说明，main 是位于 C 语言程序运行起始位置的函数。在该函数中，有两个用_asm{和}围起来的部分，它们中间有一个使用 for 语法的空循环（不做任何处理的循环）

-（1）部分是控制蜂鸣器发音的部分。首先，通过 IN EAX,61H（助记符不区分大小写）指令，把端口 61H 的数据存储到 CPU 的 EAX 寄存器中。接下来，通过 OR EAX,03H 指令，把 EAX 寄存器的低 2 位设定成 ON。最后，通过 OUT 61H, EAX 指令，把 EAX 寄存器的内容输出到 61 号端口，使蜂鸣器开始发音。虽然 EAX 寄存器的长度是 32 位，不过由于蜂鸣器端口是 8 位，所以只需对下 8 位进行 OR 运算和 AND 运算就可以正常运行了

-（2）部分是一个重复 100 万次的空循环，主要是为了在蜂鸣器开始发音和停止发音之间稍微加上一些时间间隔。因为现在计算机的 CPU 运行速度非常快，哪怕是 100 万次的循环，也几乎是瞬间完成的

-（3）部分是用来控制蜂鸣器发音停止的部分。首先，通过 IN EAX,61H 指令，把端口 61H 的数据存储到 CPU 的 EAX 寄存器中。接下来，通过 AND EAX,0FCH 指令，把 EAX 寄存器的低 2 位设定成 OFF。最后，通过 OUT 61H, EAX 指令，把寄存器 EAX 的内容输出到 61 号端口，使蜂鸣器停止发音。大家可以把 61H 端口的低 2 位认为是蜂鸣器的开关

- 最后，让我们对代码清单进行编译，并尝试运行一下。这时，蜂鸣器应该会发出“嘀！”的短促声音

  - 此外，有一点需要注意的是，该程序虽然在旧版本 Windows（95、98）中可以正常运行，但在这以后的 Windows（XP、Vista 等）版本中是无法正常运行的。这是因为，为了保护系统安全，现在的 Windows 禁止了应用直接控制硬件的方式

  - 如果将该程序在最近的 Windows 版本上运行的话，就会出现错误信息，而且蜂鸣器也不会发出声音


### 11.4 外围设备的中断请求

- IRQ（Interrupt Request）是中断请求的意思

- IRQ 是用来暂停当前正在运行的程序，并跳转到其他程序运行的必要机制。该机制称为中断处理。中断处理在硬件控制中担当着重要角色。因为如果没有中断处理，就有可能出现处理无法顺畅进行的情况

- 从中断处理开始到请求中断的程序（中断处理程序）运行结束之前，被中断的程序（主程序）的处理是停止的

- 实施中断请求的是连接外围设备的 I/O 控制器，负责实施中断处理程序的是 CPU

- 为了进行区分，外围设备的中断请求会使用不同于 I/O 端口的其他编号，该编号称为中断编号。在控制面板中查看软盘驱动器的属性时，IRQ 处显示的数值 06，表示的就是用 06 号来识别软盘驱动器发出的中断请求。另一方面，操作系统及 BIOS 则会提供响应中断编号的中断处理程序

- BIOS（Basic Input Output System）位于计算机主板或扩张板卡上内置的 ROM 中，里面记录了用来控制外围设备的程序和数据。这一点在第 7 章中进行过说明

- 假如同时有多个外围设备进行中断请求的话，CPU 也会为难。为此，我们可以在 I/O 控制器和 CPU 中间加入名为中断控制器的 IC 来进行缓冲。中断控制器会把从多个外围设备发出的中断请求有序地传递给 CPU

- 中断控制器的功能

  ![epub907761249jpeg](/image/程序是怎样跑起来的/f90b5ca2ff1804d21d037d89b3ebea12047e066a.jpeg)

- CPU 接收到来自中断控制器的中断请求后，会把当前正在运行的主程序中断，并切换到中断处理程序

  - 中断处理程序的第一步处理，就是把 CPU 所有寄存器的数值保存到内存的栈中

  - 在中断处理程序中完成外围设备的输入输出后，把栈中保存的数值还原到 CPU 寄存器中，然后再继续进行对主程序的处理

  - 假如 CPU 寄存器的数值没有还原的话，就会影响到主程序的运行，甚至还有可能会使程序意外停止或者发生运行异常。这是因为主程序在运行过程中，出于某些原因用到 CPU 寄存器。而这时如果突然插入别的程序，主程序必然会受到影响

  - 因此，在中断请求完毕后，各寄存器的数值必须要还原到中断前的状态。只要寄存器的值保持不变，主程序就可以像没有发生任何事情一样继续处理

- 中断请求的顺序

  ![epub907761250jpeg](/image/程序是怎样跑起来的/72369ba47699c73922da74e0cc4cc9bbc9e62588.jpeg)


### 11.5 用中断来实现实时处理

- 实际上，大部分的外围设备，都会频繁地发出中断请求。其原因就是为了实时处理从外围设备输入的数据

- 虽然不利用中断也可以从外围设备输入数据。但那种情况下，主程序就必须要持续不断地检测外围设备是否有数据输入

  - 由于外围设备有很多个，因此就有必要按照顺序来调查。按照顺序调查多个外围设备的状态称为轮询

  - 对几乎不产生中断的系统来说，轮询是比较合适的处理。不过，对计算机来说就不适合了

  - 举例来说，假如主程序正在调查是否有鼠标输入，这时如果发生了键盘输入的话，该如何处理呢？结果势必会导致键盘输入的文字无法实时地显示在显示器上。而通过使用中断，就可以实现实时显示了

- 打印机等输出用的外围设备中，外围设备接收数据的状态，有时是需要用中断来通知的。由于外围设备的处理速度比计算机主机的处理速度要慢很多，因此，这种情况下就不需要对打印机的状态进行多次调查，只需在中断请求发生时输出数据即可，这样一来，其他时间 CPU 就可以集中处理别的程序了


### 11.6 DMA 可以实现短时间内传送大量数据

- DMA（DirectMemory Access）是指在不通过 CPU 的情况下，外围设备直接和主内存进行数据传送

  - 磁盘等都用到了这个 DMA 机制

  - 通过利用 DMA，大量数据就可以在短时间内转送到主内存

  - 之所以这么快速，是因为 CPU 作为中介的时间被节省了

- 使用 DMA 的外围设备和不使用 DMA 的外围设备的不同

  ![epub907761251jpeg](/image/程序是怎样跑起来的/8a9677088f4b454aadc5549aaf001f6ac197d696.jpeg)

- 在 Windows 资源标签中有 DMA 设定，假设此处设定为 02。02 这个编号称为 DMA 通道。CPU 借助 DMA 通道，来识别是哪一个外围设备使用了 DMA

- I/O 端口号、IRQ、DMA 通道可以说是识别外围设备的 3 点组合。不过，IRQ 和 DMA 通道并不是所有的外围设备都必须具备的。计算机主机通过软件控制硬件时所需要的信息的最低限，是外围设备的 I/O 端口号

- IRQ 只对需要中断处理的外围设备来说是必需的，DMA 通道则只对需要 DMA 机制的外围设备来说是必需的

- 假如多个外围设备都设定成同样的端口号、IRQ 及 DMA 通道的话，计算机就无法正常工作了。这种情况下，就会出现“设备冲突”的提示


### 11.7 文字及图片的显示机制

- 如果用一句话来简单地概括显示器显示文字及图形的机制，那就是显示器中显示的信息一直存储在某内存中。该内存称为 VRAM（Video RAM）

  - 在程序中，只要往 VRAM 中写入数据，该数据就会在显示器中显示出来

  - 实现该功能的程序，是由操作系统或 BIOS 提供，并借助中断来进行处理的

- 在 MS-DOS 时代，对大部分计算机来说，VRAM 都是主内存的一部分。例如 PC-9801 这种机型的计算机，主内存地址 A0000 地址以后是 VRAM 区域。如果用程序往 VRAM 内存地址中写入数据，文字及图形就可以显示出来。不过，文字和图形的颜色最多只能有 16 种。这是因为 VRAM 的内存空间太小了

- 在现在的计算机中，显卡等专用硬件中一般都配置有与主内存相独立的 VRAM 和 GPU（GraphicsProcessing Unit，图形处理器，也称为图形芯片）。这是因为，对经常需要描绘图形的 Windows 来说，数百兆的 VRAM 是必需的。而为了提升图形的描绘速度，有时还需要专用的图形处理器。但不管怎样，内存 VRAM 中存储的数据就是显示器上显示的信息，这一机制是不变的

- 用软件来控制硬件听起来好像很难，但实际上只是利用输入输出指令同外围设备进行输入输出的处理而已。中断处理是根据需要来使用的选项功能，DMA 则直接交给对应的外围设备即可


## 第十二章 让计算机“思考”

### 12.1 作为“工具”的程序和为了“思考”的程序

- 程序就如同是由计算机执行的各种指令罗列起来的文章。计算机内部的 CPU，通过对该文章的内容进行解析和运行，来控制连接到计算机的各种外围设备。具体来说，控制就是指 CPU 和各种设备之间配合进行数据的输入输出处理

- 程序的使用目的大体可以划分为两类

  - 一类是大家作为工具来使用的程序。例如，文字处理器这个程序，大家是将其作为文档处理的工具来使用的。这种情况可以说是程序替代了现有的工具

  - 另外一个使用目的是用程序来代替执行人类的思考过程。例如，微计算机 [插图] 控制的电饭煲，会根据米和水的份量来自动调整火的大小以及加热时间，进而焖出好吃的米饭。这种情况就可以说是借助程序，使计算机有了“思考”功能


### 12.4 程序生成随机数的方法

- 在编写游戏程序时，以及在计算机模拟等情况下，经常使用随机数。随机数也是用程序来表示人类的直觉及念头的一种方法

  - 计算机模拟指的是利用计算机模拟实际试验的方式。经常被用于建筑物的耐震实验等实际难以进行的实验中。使用随机数的计算机模拟有时也称为“蒙特卡洛法”，来源于因赌博而闻名的城市──蒙特卡洛
- 由于计算机没法晃动随机数色子，因此程序一般会通过生成类似于随机数的数值公式来得到随机数。在 C 语言中，虽然该公式的实体是隐藏的，但只要调用 rand() 函数，就可以得到结果（随机数）。不过，由于借助公式产生的随机数具有一定的规律性，因此并不是真正的随机数，通常称为伪随机数。不过，虽然是伪随机数，仍然十分有用