---
title: 【笔记】网络是怎样连接的（上）
abbrlink: d6dc4bf6
date: 2021-12-14 21:17:49
updated: 2021-12-14 21:17:49
description: 你有没有想过，互联网是怎样连接起来的？
index_img: /image/网络是怎样连接的/网络是怎样连接的.jpg
banner_img:  /image/网络是怎样连接的/network.jpg
tags:
  - 基础体系
categories: 笔记
---

## 第一章 浏览器生成消息 -- 探索浏览器内部

### 1.1 浏览器收发数据阶段

- HTTP 协议定义了客户端和服务器之间交互的消息内容和步骤

- 浏览器/网络程序收发信息主要步骤：

  - 用户输入 URL 或点击 URL

  - 解析 URL：不同类型的 URL 对应不同的协议/服务，需要通过解析 URL 决定调用对应的服务/访问方法

  - 生成 HTTP 报文

  - 根据域名查询 IP 地址：

    - 查询浏览器 DNS 缓存

    - 调用 Socket 库的域名解析器解析域名

  - 委托协议栈收发数据：协议栈和服务器收发数据主要有四个步骤，具体细节查看下一章节

    - 创建套接字阶段：调用 Socket 库中的 socket 程序组件创建套接字

    - 连接阶段：将管道连接到服务器端的套接字上；委托协议栈将客户端创建的套接字与服务器那边的套接字连接起来这一操作，通过调用 Socket 库中的名为 connect 的程序组件来完成这一操作

    - 通信阶段：收发数据阶段；发送数据，通过调用 Socket 库 write 这个程序组件完成将数据送入套接字这一操作；接收消息的操作是通过 Socket 库中的 read 程序组件委托协议栈来完成的

    - 断开阶段：当浏览器收到数据之后，收发数据的过程就结束了。接下来调用 Socket 库的 close 程序组件进入断开阶段。最终，连接在套接字之间的管道会被断开，套接字本身也会被删除。

- Socket 库域名解析器解析操作：

  - 生成 DNS 报文：在这之前应该还会有一个查询本机 DNS 缓存/读取 hosts 文件的步骤，但是为了主要脉络的清晰，就不添加了

  - 委托协议栈发送 DNS 请求报文：具体协议栈收发请查看下一章节

  - 协议栈接收响应报文，解析器解析成功

- 关于 Socket 库和协议栈之间的关系：委托的操作都是通过调用 Socket 库中的程序组件来执行的，但这些数据通信用的程序组件其实仅仅充当了一个桥梁的角色，并不执行任何实质性的操作，应用程序的委托内容最终会被原原本本地传递给协议栈

### 1.2 DNS 基础

- DNS 服务器的基本工作就是接收来自客户端的查询消息，然后根据消息的内容返回响

- 对于 DNS 服务器，来自客户端的查询信息包含以下内容：

  - 域名

  - Class：DNS 设计为可支持除互联网以外的网络类型，但是目前除了互联网没有其他网络类型了，Class 固定为代表互联网的 IN

  - 记录类型：表示域名对应何种类型记录

    | 类型    | 含义                      |
    | ----- | ----------------------- |
    | A     | 主机 IP 地址（address）        |
    | AAAA  | 主机 IPV6 地址                |
    | ALIAS | 自动解析的别名（alias），类似 CNAME  |
    | CNAME | 别名的权威名称（canonical name）|
    | MX    | 邮件交换服务器（Mail eXchange） |
    | NS    | 域名服务器（name server）     |
    | TXT   | 描述文本                    |

  - 当记录类型为 MX 时，DNS 服务器会在记录中保存两种信息，分别是邮件服务器的域名和优先级

  - 根域和顶级域（一级域）是不同的东西

  - 当要查询的域名不存在时，“不存在”这一响应结果也会被 DNS 服务器缓存，当下次查询这个不存在的域名时，也可以快速响应

## 第二章 用电信号传输 TCP/IP--探索协议栈和网卡

### 2.1 协议栈与其他部分的结构层次

- TCP/IP 应用程序采用分层结构：图中上下关系是有一定规则的，上面的部分会向下面的部分委派工作，下面的部分接受委派的工作并实际执行；但是当然，这一上下关系只是一个总体的规则，其中也有一部分上下关系不明确，或者上下关系相反的情况，所以也不必过于纠结

  ![epub_907755_123.jpeg](/image/网络是怎样连接的/420c71519d8b407c23c7de0f90b9918735ba60f0.jpeg)

  - 图中最上面的部分是网络应用程序

  - 应用程序的下面是 Socket 库

  - 再下面就是操作系统内部了，其中包括协议栈：

    - 协议栈的上半部分有两块，分别是负责用 TCP 协议收发数据的部分和负责用 UDP 协议收发数据的部分，它们会接受应用程序的委托执行收发数据的操作

    - 协议栈的下半部分是用 IP 协议控制网络包收发操作的部分，IP 中还包括 ICMP[插图] 协议和 ARP 协议。ICMP 用于告知网络包传送过程中产生的错误以及各种控制消息，ARP 用于根据 IP 地址查询相应的以太网 MAC 地址 [插图]。

  - 协议栈下面的网卡驱动程序负责控制网卡硬件

  - 最下面的网卡则负责完成实际的收发操作，也就是对网线中的信号执行发送和接收的操作

- 除了 TCP/IP 协议栈，还有其他的协议栈，例如 NetWare 中的 IPX/SPX 协议栈，以及 Mac 电脑中使用的 AppleTalk 协议栈等，为了方便了解，协议栈默认 TCP/IP 协议栈

- 协议栈上半部分，实现的是 TCP 和 UDP 这两个传输层协议；至于 DNS、HTTP 这种应用层协议，实际上是需要用户程序/库来完成实现的

- 套接字中记录了用于控制通信操作的各种控制信息，协议栈是根据套接字中记录的控制信息来工作的，这就是套接字的作用

- 应用程序通过套接字的描述符来区分协议栈中的不同套接字

### 2.2 创建套接字阶段

- 步骤：

  1. 创建套接字时，首先分配一个套接字所需的内存空间，然后向其中写入初始状态

- 客户端在创建套接字时，协议栈会为这个套接字随便分配一个空闲端口号

### 2.3 连接阶段

- 连接（connection，或 session）实际上是通信双方交换控制信息，在套接字中记录这些必要信息并准备数据收发的一连串操作；连接操作有几个目的：

  - 把服务器的 IP 地址和端口号等信息告知协议栈

  - 客户端向服务器传达开始通信的请求

- 连接操作中所交换的控制信息是根据通信规则来确定的，只要根据规则执行连接操作，双方就可以得到必要的信息从而完成数据收发的准备

- 当执行数据收发操作时，我们还需要一块用来临时存放要收发的数据的内存空间，这块内存空间称为缓冲区，它也是在连接操作的过程中分配的

- “协议栈具体需要哪些信息”会根据协议栈本身的实现方式不同而不同；同时，Windows 和 Linux 操作系统的内部结构不同，协议栈的实现方式不同，必要的控制信息也就不同

- 控制信息的类型：

  - 第一类是客户端和服务器相互联络时交换的控制信息：

    - 这些字段是固定的，在连接、收发、断开等各个阶段中，每次客户端和服务器之间进行通信时，都需要提供这些控制信息，整个通信过程中都需要

    - 这些控制信息位于网络包的开头，因此被称为头部

  - 第二类是保存在套接字中，用来控制协议栈操作的信息：

    - 应用程序传递来的信息以及从通信对象接收到的信息都会保存在这里，还有收发

- TCP 规格中定义的控制信息：

  ![](/image/网络是怎样连接的/420c71519d8b407c23c7de0f90b9918735ba60f0.jpeg)

- 步骤（三次握手）：此过程忽略应用程序调用 Socket 库的步骤，12 可以看做第一次握手，4567 看做第二次，891011 看做第三次

  1. 在协议栈 TCP 模块处创建表示连接控制信息的头部：

     - 收发端口、SEQ 号、SYN 比特、窗口；（此时 ACK 号为 0）

  2. TCP 模块会将信息传递给 IP 模块并委托它进行发送：关于 IP 模块和 IP 协议的细节请看下一部分

     ---

  3. 网络包通过网络到达服务器，服务器上的 IP 模块会将接收到的数据传递给 TCP 模块

  4. 服务器的 TCP 模块根据 TCP 头部中的信息找到端口号对应的套接字

  5. 服务器找到对应的套接字之后，套接字中会写入相应的信息，并将状态改为正在连接

  6. 服务器的 TCP 模块返回接收响应：

     - 收发端口、SEQ 号、ACK 号、SYN 比特、ACK 比特、窗口
     - 如果某些原因不想接受链接，则设置 RST 比特

  7. TCP 模块会将信息传递给 IP 模块并委托它进行发送

     ---

  8. 网络包通过网络返回到客户端，然后通过 IP 模块到达 TCP 模块，TCP 模块通过 TCP 头部的信息查找对应套接字并确认连接服务器的操作是否成功（过程类似 3、4、5）

     - 如果 SYN 为 1 则表示连接成功，这时会向套接字中写入服务器的 IP 地址、端口号等信息，同时还会将状态改为连接完毕

  9. 客户端的 TCP 模块返回接收响应：

     - 收发端口、SEQ 号、ACK 号、ACK 比特、窗口

  10. TCP 模块会将信息传递给 IP 模块并委托它进行发送

  11. 服务器接收到响应（过程类似 3、4、5）

- [为什么是三次握手而不是两次？四次？](https://www.zhihu.com/question/24853633)

### 2.4 收发数据阶段

#### 2.4.1 发送数据的前提

- 协议栈发送数据的几个要点：

  - 首先，协议栈并不关心应用程序传来的数据是什么内容。应用程序在调用 write 时会指定发送数据的长度，在协议栈看来，要发送的数据就是一定长度的二进制字节序列而已

  - 其次，协议栈并不是一收到数据就马上发送出去，而是会将数据存放在内部的发送缓冲区中，并等待应用程序的下一段数据

- 协议栈积累多少数据量才进行数据发送？不同种类和版本的操作系统会有所不同，主要根据以下要素判断：

  - 第一个判断要素是每个网络包能容纳的数据长度，协议栈会根据一个叫作 MTU 的参数来进行判断

  - 另一个判断要素是时间

  两个要素相互矛盾，由协议栈的开发者决定如何平衡；

  协议栈也给应用程序保留了控制发送时机的余地，可以指定一些发送的设置选项

- MTU 和 MSS：

  - MTU 表示一个网络包的最大长度，在以太网中一般是 1500 字节

  - MSS 表示一个网络包的最大数据长度，MTU 是包含头部的总长度，因此需要从 MTU 减去头部的长度，得到一长度叫作 MSS，TCP 和 IP 头部加起来一般是 40 字节，所以 MSS 一般是 1460 字节

#### 2.4.2 确认响应

- TCP 采用“SEQ 号”和“ACK 号”的方式确认对方是否收到了数据，在得到对方确认之前，发送过的包都会保存在发送缓冲区中。如果对方没有返回某些包对应的 ACK 号，那么就重新发送这些包

- 接收方返回 ACK 号的操作被称为确认响应，通过这样的方式，发送方就能够确认对方到底收到了多少数据；通过确认响应这一机制，我们可以确认接收方有没有收到某个包，如果没有收到则重新发送，这样一来，无论网络中发生任何错误，我们都可以发现并采取补救措施（重传网络包）

#### 2.4.3 超时时间

- TCP 采用了动态调整超时时间（也就是返回 ACK 号的等待时间）的方法，这个等待时间是根据 ACK 号返回所需的时间来判断的；超时时间不能太长也不能太短，太长导致延迟增加，太短导致网络更加阻塞

#### 2.4.4 滑动窗口

- TCP 在发送一个包之后，不等待 ACK 号返回，而是直接发送后续的一系列包，将等待 ACK 号的这段时间就被有效利用起来了；

  但如果不等返回 ACK 号就连续发送包，就有可能会出现发送包的频率超过接收方处理能力的情况，针对这种情况，TCP 采用滑动窗口方式来管理数据发送和 ACK 号的操作

- 接收方需要告诉发送方自己最多能接收多少数据，然后发送方根据这个值对数据发送操作进行控制，这就是滑动窗口方式的基本思路

- 滑动窗口大小：接收方能够接收的最大数据量称为窗口大小，是 TCP 调优参数中非常有名的一个；窗口大小一般和缓冲区大小一致

- 更新窗口大小（接收方通知发送方自己窗口大小）的时机：

  - 当收到的数据刚刚开始填入缓冲区时，其实没必要每次都向发送方更新窗口大小，因为只要发送方在每次发送数据时减掉已发送的数据长度就可以自行计算出当前窗口的剩余长度

  - 更新窗口大小的时机应该是接收方从缓冲区中取出数据传递给应用程序的时候；这个操作是接收方应用程序发出请求时才会进行的，而发送方不知道什么时候会进行这样的操作，因此当接收方将数据传递给应用程序，导致接收缓冲区剩余容量增加时，就需要告知发送方，这就是更新窗口大小的时机

#### 2.4.5 ACK 与滑动窗口的结合

- 单独发送 ACK 号和更新窗口的情况：

  接收方从缓冲区中取出数据传递给应用程序的时候，应该向发送方更新窗口大小；
  理论上，收到数据后，应该马上向发送方返回 ACK 号；
  计算机操作很快，可以理解为收到数据后接收方基本同时需要分别发送 ACK 号和窗口更新这两个单独的包，这样就会导致网络中的包数量增多，网络效率下降

- 合理等待合并的情况：

  接收方在发送 ACK 号或窗口更新时，并不会马上把包发送出去，而是会等待一段时间，在这个过程中很有可能会出现其他的通知操作（ACK 或者更新窗口），这样就可以把两种通知合并在一个包里面发送了；最后可能会有以下几种情况：

  - ACK 号合并更新窗口

  - 多个 ACK 号合并

  - 多个更新窗口

  - ACK 号

  - 更新窗口

  ---

- 步骤：此过程忽略应用程序调用 Socket 库的过程；客户端和服务器之间收发数据流程是一样的，为了便于理解，用发送方和接收方表示

  1. 发送方 TCP 模块将来自应用程序的数据按照合理长度分割，添加 TCP 头部，构建成合理的 TCP 包

  2. TCP 模块将信息传递给 IP 模块并且委托它进行发送：关于 IP 模块和 IP 协议的细节请看下一部分

     ---

  3. 网络包通过网络到达接收方，接收方上的 IP 模块会将接收到的数据传递给 TCP 模块

  4. 接收方 TCP 模块将数据返回给接收方应用程序

  5. 接收方 TCP 模块构建 ACK 号/更新窗口网络包，通过 IP 模块，发送回给发送方，确认接收到了数据/更新窗口大小

     ---

  6. 逆向流程，接收方变成了发送方，发送方变接收方，返回响应数据给原本的发送方

- 收发数据的几个细节：

  - 协议栈会检查收到的数据块和 TCP 头部的内容，判断是否有数据丢失，如果没有问题则返回 ACK 号

  - 协议栈将数据块暂存到接收缓冲区中，并将数据块按顺序连接起来还原出原始的数据，最后将数据交给应用程序；具体来说，协议栈会将接收到的数据复制到应用程序指定的内存地址中，然后将控制流程交回应用程序

  - 将数据交给应用程序之后，协议栈还需要找到合适的时机向发送方发送窗口更新

### 2.5 断开阶段

- 收发数据结束的时间点应该是应用程序判断所有数据都已经发送完毕的时候，这时，数据发送完毕的一方会发起断开过程，但不同的应用程序会选择不同的断开时机

- 步骤（四次挥手）：完成数据发送的一方会发起断开过程，这里我们以服务器一方发起断开过程为例来进行讲解

  1. 服务器应用程序会调用 close 来结束数据收发操作

  2. 服务器协议栈生成包含断开信息的 TCP 头部：

     - 收发端口、SEQ 号、FIN 比特、窗口

  3. TCP 模块将信息传递给 IP 模块并且委托它进行发送：关于 IP 模块和 IP 协议的细节请看下一部分

  4. 服务器的套接字记录断开操作的相关信息

  5. 当收到服务器发来的 FIN 为 1 的 TCP 头部时，客户端的协议栈会将自己的套接字标记为进入断开操作状态

  6. 为了告知服务器已收到 FIN 为 1 的包，客户端会向服务器返回一个 ACK 号

  7. 客户端应用程序读取数据的时候，协议栈告知应用程序数据收发完全

  8. 客户端应用程序会调用 close 来结束数据收发操作

  9. 客户端协议栈生成包含断开信息的 TCP 头部

     - 收发端口、SEQ 号、FIN 比特、窗口

  10. TCP 模块将信息传递给 IP 模块并且委托它进行发送：关于 IP 模块和 IP 协议的细节请看下一部分

  11. 服务器返回 ACK 号，客户端和服务器的通信正式结束

- 四次挥手还是三次挥手？

  从理论上来说，步骤 7 会发送一个 ACK 号，而步骤 9 会发送一个 FIN 比特，但是在实际情况中，这两个网络包有可能合并，合为一个包（ACK 号/FIN 比特），形成了三次挥手；

  利用 WireShark 进行抓包分析，这种情况似乎出现在客户端读取数据完成后，就调用 close 关闭套接字的情况，也就是步骤 7 和步骤 8 之间的时间间隔很短，两个网络包合并起来了

- 注意，FIN 比特是由于调用 close 而产生的

- 和服务器的通信结束之后，套接字不会立即被删除，而是会等待一段时间之后才会被删除；至于具体等待多长时间，这和包重传的操作方式有关

### 2.6 IP 与以太网的包收发操作

#### 2.6.1 IP 和以太网的关系

- 在网络中有路由器和集线器两种不同的转发设备

  - 路由器根据目标地址判断下一个路由器的位置，是按照 IP 规则传输包的设备（IP 协议根据目标地址判断下一个 IP 转发设备的位置）

  - 集线器在子网中将网络包传递到下一个路由，是按照以太网规则传输包的设备（子网中的以太网协议负责将包传输到下一个转发设备）

- TCP/IP 包包含以下两个头部：

  - IP 头部（用于 IP 协议）

  - MAC 头部（用于以太网协议）

- 在 IP 和以太网的分工中，以太网的部分也可以替换成其他的东西，例如无线局域网、ADSL、FTTH 等，它们都可以替代以太网的角色帮助 IP 协议来传输网络包。因此，将 IP 和负责传输的网络分开，可以更好地根据需要使用各种通信技术。像互联网这样庞大复杂的网络，在架构上需要保证灵活性，这就是设计这种分工方式的原因

- 凡是局域网所使用的头部都见做 MAC 头部，但是其内容根据局域网的类型而有所不同；

  对于除局域网之外的其他通信技术，还有不同名称的各种头部，名称不一样，但是承担的作用相同

#### 2.6.2 IP 包收发预览

- 尽管我们说 IP 模块负责将包发给对方，但实际上将包从发送方传输到接收方的工作是由集线器、路由器等网络设备来完成的，因此 IP 模块仅仅是整个包传输过程的入口而已

- 步骤：

  1. 包收发操作的起点是 TCP 模块委托 IP 模块发送包的操作：

     - 这个委托的过程就是 TCP 模块在数据块的前面加上 TCP 头部，然后整个传递给 IP 模块，这部分就是网络包的内容

     - 同时，TCP 模块还需要指定通信对象的 IP 地址，也就是需要写清楚“将什么内容发给谁”

  2. 收到委托后，IP 模块会将包的内容当作一整块数据，在前面加上包含控制信息的头部：

     - IP 模块会添加 IP 头部和 MAC 头部这两种头部：关于头部细节请查看下一部分

  3. 接下来，封装好的包会被交给网络硬件进行发送：

     - 网络硬件可能是插在计算机主板上的板卡，也可能是笔记本电脑上的 PCMCIA 卡，或者是计算机主板上集成的芯片，不同形态的硬件名字也不一样，本书将它们统称为网卡

     - 传递给网卡的网络包是由一连串 0 和 1 组成的数字信息，网卡会将这些数字信息转换为电信号或光信号，并通过网线（或光纤）发送出去，然后这些信号就会到达集线器、路由器等转发设备，再由转发设备一步一步地送达接收方

  4. 以相反操作进行接收

- 无论要收发的包是控制包还是数据包，IP 对各种类型的包的收发操作都是相同的

#### 2.6.3 IP 头部

- IP 头部内容：

  ![epub_907755_177.jpeg](/image/网络是怎样连接的/9978119f4242eaa99e0e10068047f82a9a6b862a.jpeg)

- IP 头部中最重要的内容就是 IP 地址，它表示这个包从哪里来到哪里去；

  这个地址是由 TCP 模块告知的，而 TCP 又是在执行连接操作时从应用程序那里获得这个地址的，因此这个地址的最初来源就是应用程序（应用程序调用域名解析器解析域名获得 IP 地址）

- 当计算机上存在多张网卡的时候，每一个网卡都会有自己的 IP 地址，当一台计算机有多个 IP 地址，在填写 IP 头部发送方 IP 地址时就需要判断到底应该填写哪个地址；

  这个判断相当于在多块网卡中判断应该使用哪一块网卡来发送这个包，也就相当于判断应该把包发往哪个路由器，因此只要确定了目标路由器，也就确定了应该使用哪块网卡，也就确定了发送方的 IP 地址

- 如何判断应该把包交给哪块网卡？

  因为协议栈的 IP 模块与路由器中负责包收发的部分都是根据 IP 协议规则来进行包收发操作的，所以它们也都用相同的方法 -- 路由表 -- 来判断把包发送给谁；关于路由表的详细细节请查看下一部分

- IP 头部中的协议号，表示包的内容来自哪个模块：

  - TCP 模块委托的内容，则设置为 06（十六进制）

  - UDP 模块委托的内容，则设置为 17（十六进制）

#### 2.6.4 MAC 头部

- MAC 头部内容：

  ![epub_907755_187.jpeg](/image/网络是怎样连接的/840b76ea1cb6d0ab05d37d74f962eb8fbd64ea4e.jpeg)

- 发送方 MAC 地址：是网卡本身的 MAC 地址，MAC 地址是在网卡生产时写入 ROM 里的，只要将这个值读取出来写入 MAC 头部就可以了

- TCP/IP 包添加 IP 头部和 MAC 头部是由 IP 模块负责的，MAC 头部是以太网需要的内容，并不属于 IP 的职责范围，但从现实来看，让 IP 负责整个打包工作是有利的：

  - 如果在交给网卡之前，IP 模块能够完成整个打包工作，那么网卡只要将打好的包发送出去就可以了

  - 对于除 IP 以外的其他类型的包也是一样，如果在交给网卡之前完成打包，那么对于网卡来说，发送的操作和发送 IP 包是完全相同的，这样一来，同一块网卡就可以支持各种类型的包

  - 如果接收的包可以原封不动直接交给 IP 模块来处理，网卡就只要负责接收就可以了

#### 2.6.5 ARP

- ARP 是一个独立的三层协议，所以 ARP 报文在向数据链路层传输时不需要经过 IP 协议的封装，而是直接生成自己的报文，其中包括 ARP 报头，到数据链路层后再由对应的数据链路层协议（如以太网协议）进行封装

- 通过 ARP 缓存可以减少 ARP 查询的数量，但是为了减少缓存差异的发生，ARP 缓存中的值在经过一段时间后会被删除，一般这个时间在几分钟左右

#### 2.6.6 以太网基础知识

- 以太网是一种为多台计算机能够彼此自由和廉价地相互通信而设计的通信技术，这种网络的本质其实就是一根网线

- 以太网任何一台设备发送的信号所有设备都能接收到，需要在信号的开头加上接收者的信息，也就是地址。这样一来就能够判断信号的接收者了，与接收者地址匹配的设备就接收这个包，其他的设备则丢弃这个包

- 现在的以太网结构，随着交换式集线器的普及，信号发送给所有设备这一性质变了，现在信号只会流到根据 MAC 地址指定的设备，而不会到达其他设备了

- 尽管以太网经历了数次变迁，但其基本的 3 个性质至今仍未改变，可以认为具备这 3 个性质的网络就是以太网：

  - 用包发送到 MAC 头部的接收方 MAC 地址代表的目的地

  - 用发送方 MAC 地址识别发送方

  - 用以太类型识别包的内容

- 无线局域网具有前两个性质，虽然没有以太类型，但是有另外一个具备同样功能的参数，可以认为它是以太网的“一种”，但是为了方便区分，一般不会讲无线局域网视为以太网

- 根据以太网的规格，两台设备之间的网线不能超过 100 米（这是双绞线的情况，如果采用光纤这可以更长，而且错误率不会上升）

#### 2.6.7 以太网包收发操作

- IP 生成的网络包只是存放在内存中的一串数字信息，需要将数字信息转换为电或光信号，才能在网线上传输，这才是真正的数据发送过程

- 负责真正数据收发操作的是网卡，但网卡也无法单独工作，要控制网卡还需要网卡驱动程序

- 网卡是工作在第二层链路层的网络组件，是局域网中连接计算机和传输介质的接口，不仅能实现与局域网传输介质之间的物理连接和电信号匹配，还涉及帧的发送与接收、帧的封装与拆封、介质访问控制、数据的编码与解码以及数据缓存的功能等

- 网卡的内部结构：这是一张网卡主要构成要素的概念图，并不代表硬件的实际结构

  ![epub_907755_208.jpeg](/image/网络是怎样连接的/9edb7e674df5e4d50083ed052d24441369dfd02d.jpeg)

- 打开计算机启动操作系统的时候，网卡驱动程序会对硬件进行初始化操作，然后硬件才进入可以使用的状态

  这些操作包括硬件错误检查、初始设置等步骤，这些步骤对于很多其他硬件也是共通的，但也有一些操作是以太网特有的，那就是在控制以太网收发操作的 MAC 模块中设置 MAC 地址

- **核对修改**网卡中的 MAC 模块不包含添加 MAC 头部的功能，这个功能由 IP 模块完成，这种层次的设计可以使得网卡专注收发操作，对于上层所传递来的不同类型的包，都可以做到直接传递

- 网卡的 ROM 中保存着全世界唯一的 MAC 地址，这是在生产网卡时写入的，将这个值读出之后就可以对 MAC 模块进行设置。也有一些特殊的方法，比如从命令或者配置文件中读取 MAC 地址并分配给 MAC 模块（需要网卡驱动支持）

#### 2.6.8 网卡收发网络包

- 步骤：

  1. 网卡驱动从 IP 模块获取包之后，会将其复制到网卡内的缓冲区中，然后向 MAC 模块发送发送包的命令

  2. MAC 模块会将包从缓冲区中取出，并在开头加上报头和起始帧分界符（SFD），在末尾加上用于检测错误的帧校验序列

- MAC 头部很容易被误解为是由网卡来处理的，实际上它是由 TCP/IP 软件也就是协议栈来负责的

- 网卡发送出去的帧的内容：制定以太网标准的组织 IEEE 出于历史原因使用了“帧”而不是“包”，因此在以太网术语中都是说“帧”

  ![epub_907755_212.jpeg](/image/网络是怎样连接的/88522683833a9eb4beb77ec3a7b62ea89a493f3d.jpeg)

- 报头、起始帧和 FCS：报头用来测定时机，SFD 用来确定帧的起始位置

  - 报头是一串像 10101010…这样 1 和 0 交替出现的比特序列，长度为 56 比特，它的作用是确定包的读取时机

  - SFD 的末尾比特排列有少许变化。接收方以这一变化作为标记，从这里开始提取网络包数据。也就是说，起始帧分界符是一个用来表示包起始位置的标记

  - 末尾的 FCS（帧校验序列）用来检查包传输过程中因噪声导致的波形紊乱、数据错误，它是一串 32 比特的序列，是通过一个公式对包中从头到尾的所有内容进行计算而得出来的

  ![epub_907755_213.jpeg](/image/网络是怎样连接的/e80fbe4834fbff9afc4f5f9d9444d5c7af5252d5.jpeg)

- 如何通过电信号读取数据：

  ![epub_907755_214.jpeg](/image/网络是怎样连接的/88f344f0f3316927c7891f4fb1d2cf6b59cda66e.jpeg)

  -（a）中的电压信号变化就可以表示数据信号，但是由于实际的信号并不像图中那样有辅助线，因此在测量电压和电流时必须先判断出每个比特的界限在哪里

  - 当信号连续为 1 或连续为 0 时，比特之间的界限就会消失，如果将时钟信号叠加进去，就可以判断出比特之间的界限了

  - 要解决界限判断问题，最简单的方法就是在数据信号之外再发送一组用来区分比特间隔的时钟信号，例如同时发送（a）和（b）两组信号，当时钟信号从下往上变化时读取电压和电流的值，然后和 0 或 1 进行对应就可以了；

    但是这种方法存在问题。当距离较远，网线较长时，两条线路的长度会发生差异，数据信号和时钟信号的传输会产生时间差，时钟就会发生偏移

  - 要解决时钟偏移问题，可以采用将数据信号和时钟信号叠加在一起的方法，例如（a）叠加（b）生成 c；

    由于（b）是具有周期变化的，通过观察（c）的波形变化，就可以找出这个周期，然后就可以提取出来时钟信号（b），进而计算出数据信号（a），然后，只要根据时钟信号（b）的变化周期，我们就可以从数据信号（a）中读取相应的电压和电流值，并将其还原为 0 或 1 的比特了;

    由于还需要先对（c）信号进行一段时间的观察，因此，我们不能一开始就发送包的数据，而是要在前面加上一段用来测量时钟信号的特殊信号，这就是报头的作用

#### 2.6.9 集线器发送网络包

- 发送信号的操作分为两种，一种是使用集线器的半双工模式，另一种是使用交换机的全双工模式；发送和接收同时并行的方式叫做“全双工”，相对的，某一时刻只能进行其中一种操作的叫做“半双工”

- 在半双工模式中，为了避免信号碰撞，首先要判断网线中是否存在其他设备发送的信；如果有，则需要等待该信号传输完毕，当之前的信号传输完毕，或者本来就没有信号在传输的情况下，才可以开始发送信号

- 发送网络包步骤：

  1. MAC 模块读取缓冲区内容

  2. MAC 模块从报头开始将数字信息按每个比特转换成电信号，由 PHY，或者叫 MAU 的信号收发模块发送出去：

     - 将数字信息转换为电信号的速率就是网络的传输速率，例如每秒将 10 Mbit 的数字信息转换为电信号发送出去，则速率就是 10 Mbit/s

     - 以太网规格中对不同的网线类型和速率以及其对应的信号格式进行了规定，但 MAC 模块并不关心这些区别，而是将可转换为任意格式的通用信号发送给 PHY（MAU）模块，然后 PHY（MAU）模块再将其转换为可在网线上传输的格式

  3. PHY（MAU）模块会将信号转换为可在网线上传输的格式，并通过网线发送出去

     - MAU（Medium Attchment Unit，介质链接单元）

     - PHY（Physical Layer Device，物理层装置），在速率为 100Mbit/s 以上的以太网中都叫 PHY

     - 可以认为 PHY（MAU）模块的功能就是对 MAC 模块产生的信号进行格式转换

- PHY（MAU）的职责并不是仅仅是将 MAC 模块传递过来的信号通过网线发送出去，它还需要监控接收线路中有没有信号进来

  - 在开始发送信号之前，需要先确认没有其他信号进来，这时才能开始发送

  - 如果在信号开始发送到结束发送的这段时间内一直没有其他信号进来，发送操作就成功完成了

- 在使用集线器的半双工模式中，如果发送的时候，接收线路有信号进来，两组信号就会相互叠加，无法区分彼此，这就是所谓的信号碰撞；

  这种情况下，继续发送信号是没有意义的，因此发送操作会终止；为了通知其他设备当前线路已发生碰撞，还会发送一段时间的阻塞信号（一种特殊的信号），然后所有的发送操作会全部停止；

- 发送信号碰撞等待一段时间后，等待一段时间之后，网络中的设备会尝试重新发送信号；设备的等待时间是根据 MAC 地址生成一个随机数计算出来的，理论上互不相同；

  当网络拥塞时，发生碰撞的可能性就会提高，重试发送的时候可能又会和另外一台设备的发送操作冲突，这时会将等待时间延长一倍，然后再次重试。以此类推，每次发生碰撞就将等待时间延长一倍，最多重试 10 次，如果还是不行就报告通信错误。

#### 2.6.10 接收返回包

- 在使用集线器的半双工模式以太网中，一台设备发送的信号会到达连接在集线器上的所有设备，这意味着无论是不是发给自己的信号都会通过接收线路传进来

- 接收步骤：

  1. 首先，PHY（MAU）模块会将信号转换成通用格式并发送给 MAC 模块

  2. MAC 模块再从头开始将信号转换为数字信息

     - 到达信号的末尾时，还需要检查 FCS，具体来说，就是将从包开头到结尾的所有比特套用到公式中计算出 FCS，然后和包末尾的 FCS 进行对比，正常情况下两者应该是一致的，如果中途受到噪声干扰而导致波形发生紊乱，则两者的值会产生差异，这时这个包就会被当作错误包而被丢弃

     - 如果 FCS 校验没有问题，接下来就要看一下 MAC 头部中接收方 MAC 地址与网卡在初始化时分配给自己的 MAC 地址是否一致，以判断这个包是不是发给自己的，不是自己的包就直接丢弃

  3. 如果接收方 MAC 地址和自己 MAC 地址一致，则将包放入缓冲区，MAC 模块的工作完成

  4. 网卡通过中断机制通知计算机收到了一个包

  5. 网卡驱动被中断处理程序调用后，会从网卡的缓冲区中取出收到的包，并通过 MAC 头部中的以太类型字段判断协议的类型，然后传递给对应协议栈

#### 2.6.11 ICMP 和分片重组

- 响应包从 IP 到 TCP 步骤：

  1. 网卡驱动将网络包将其交给 TCP/IP 协议栈来进行处理

  2. IP 模块先开始工作了，第一步是检查 IP 头部，确认格式是否正确；如果格式没有问题，下一步就是查看接收方 IP 地址；

     当接收方 IP 地址不是自己的时候，一定是发生了什么错误。客户端计算机不负责对包进行转发，因此不应该收到不是发给自己的包。当发生这样的错误时，IP 模块会通过 ICMP 消息将错误告知发送方

  3. IP 模块检查确认无误就可以接收这个包，如果接收到的包是经过分片的，IP 模块会将他们还原成原始的包

  4. 分片重组后，包交给 TCP 模块，根据对应信息查找相应套接字，找到对应的套接字之后，就可以根据套接字中记录的通信状态，执行相应的操作了

- ICMP 协议与 ARP 协议不同，ICMP 靠 IP 协议来完成任务，所以 ICMP 报文中要封装 IP 头部；换言之，ICMP 带有 IP 头部，ARP 不带有 IP 头部

- ICMP 的头部和数据位于 IP 头部之后，ICMP 报文的头部长度取决于 ICMP 报文的类型且变化范围很大

- 主要的 ICMP 消息：

  ![epub_907755_232.jpeg](/image/网络是怎样连接的/14ac09520bc44af991f3f79427b15d430697d8dd.jpeg)

- IP 协议有一个叫作分片的功能（关于分片的细节请查看下一部分内容），简单来说，网线和局域网中只能传输小包，因此需要将大的包切分成多个小包，如果接收到的包是经过分片的，那么 IP 模块会将它们还原成原始的包

- 分片的包会在 IP 头部的标志字段中进行标记，当收到分片的包时，IP 模块会将其暂存在内部的内存空间中，然后等待 IP 头部中具有相同 ID 的包全部到达，这是因为同一个包的所有分片都具有相同的 ID

  此外，IP 头部还有一个分片偏移量（fragment offset）字段，它表示当前分片在整个包中所处的位置。根据这些信息，在所有分片全部收到之后，就可以将它们还原成原始的包，这个操作叫作分片重组

- ICMP 可能会导致分片的出现，以太网中， MTU 设置为 1500。所以 ICMP 负载长度最大值为 MTU（1500 字节）减去 IP 首部长度（20 字节）减去 ICMP 首部长度（8 字节），为 1472 字节，当 ICMP 负载长度超过 1472 字节，ICMP 报文会被分片

### 2.7 UDP 协议收发

- UDP 适用的场景：

  - 需要传输的数据较短，如 DNS 查询

  - 对高速传输和实时性有较高，如音视频等多媒体通信

  - 限定于 LAN 等特定网络中的应用通信

  - 广播通信

- UDP 头部中的控制信息：

  ![epub_907755_235.jpeg](/image/网络是怎样连接的/67b0bd95ffd71d26be10c3a1ad94ba446af44cbf.jpeg)

- UDP 可发送的数据最大长度为 IP 包的最大长度减去 IP 头部和 UDP 头部的长度。不过，这个长度与 MTU、MSS 不是一个层面上的概念。MTU 和 MSS 是基于以太网和通信线路上网络包的最大长度来计算的，而 IP 包的最大长度是由 IP 头部中的“全长”字段决定的。“全长”字段的长度为 16 比特，因此从 IP 协议规范来看，IP 包的最大长度为 65 535 字节，再减去 IP 头部和 UDP 头部的长度，就是 UDP 协议所能发送的数据最大长度。如果不考虑可选字段的话，一般来说 IP 头部为 20 字节，UDP 头部为 8 字节，因此 UDP 的最大数据长度为 65 507 字节。当然，这么长的数据已经超过了以太网和通信线路的最大传输长度，因此需要让 IP 模块使用分片功能拆分之后再传输

- UDP 没有 TCP 的接收确认、窗口等机制，因此在收发数据之前也不需要交换控制信息，也就是说不需要建立和断开连接的步骤，只要在从应用程序获取的数据前面加上 UDP 头部，然后交给 IP 进行发送就可以了

  接收也很简单，只要根据 IP 头部中的接收方和发送方 IP 地址，以及 UDP 头部中的接收方和发送方端口号，找到相应的套接字并将数据交给相应的应用程序就可以了

- UDP 只负责单纯地发送包而已，并不像 TCP 一样会对包的送达状态进行监控，所以协议栈也不知道有没有发生错误；出错时收不到来自对方的回复，应用程序会注意到这个问题，并重新发送一遍数据。这样的操作本身并不复杂，也并不会增加应用程序的负担
