---
title: 【笔记】网络是怎样连接的（下）
abbrlink: 6e602c93
date: 2021-12-14 21:18:30
updated: 2021-12-14 21:18:30
description: 你有没有想过，互联网是怎样连接起来的？
index_img: /image/网络是怎样连接的/网络是怎样连接的.jpg
banner_img:  /image/网络是怎样连接的/network.jpg
tags:
  - 基础体系
categories: 笔记
hide: true
---

## 第五章 服务器端的局域网中有什么玄机

### 5.1 Web 服务器的部署地点

- 在公司部署 Web 服务器有两种方法：

  - 服务器直接部署在公司网络上，并且可以从互联网直接访问

  - 部署防火墙

- 第一种方法有几个限制：

  - IP 地址不足

  - 安全问题

- 防火墙：一种抵御外部网络攻击的机制，也是最早出现的一种防御机制。现在已经出现了很多可以绕过防火墙的攻击方法，因此防火墙一般需要和反病毒、非法入侵检测、访问隔离等机制并用。详细内容请查看下一部分

- 防火墙屏蔽了不允许从外部访问的应用程序，所以即便这些程序存在安全漏洞，用于攻击的网络包也进不来。但是即便如此风险也不会降到零，因为如果允许外部访问的应用程序中有安全漏洞，还是有可能遭到攻击的

- Web 服务器不仅可以部署在公司里，也可以把服务器放在网络运营商等管理的数据中心里，或者直接租用运营商提供的服务器

- 数据中心是与运营商核心部分 NOC 直接连接的，或者是与运营商之间的枢纽 IX 直接连接的。换句话说，数据中心通过高速线路直接连接到互联网的核心部分，因此将服务器部署在这里可以获得很高的访问速度 [插图]，当服务器访问量很大时这是非常有效的

  此外，数据中心一般位于具有抗震结构的大楼内，还具有自主发电设备，并实行 24 小时门禁管理，可以说比放在公司里具有更高的安全性

  此外，数据中心不但提供安放服务器的场地，还提供各种附加服务，如服务器工作状态监控、防火墙的配置和运营、非法入侵监控等，从这一点来看，其安全性也更高

- 服务器三种部署地点方式：

  ![epub_907755_438.jpeg](/image/网络是怎样连接的/9e8b8d8013a063256f5a5aa264948f6fcb99a1b2.jpeg)

### 5.2 防火墙的结构和原理

- 网络包的头部包含了用于控制通信操作的控制信息，只要检查这些信息，就可以获得很多有用的内容。防火墙就可以通过这些信息判断网络包的通行与否

  - 通过 IP 地址可以确定发送方和接收方

  - 通过端口号限定应用程序

  - 通过控制位判断连接方向：用于禁止服务器发起 TCP 链接

- 包过滤方式的防火墙不仅可以允许或者阻止网络包的通过，还具备地址转换功能 [插图]，因此还需要进行相关的设置。也就是说，互联网和公司内网之间的包需要进行地址转换才能传输，因此必须要进行相关的设置

  具体来说，就是和包过滤一样，以起点和终点作为条件，根据需要设置是否需要进行地址转换。私有地址和公有地址之间的对应关系，以及端口号的对应关系都是自动管理的，因此只需要设置是否允许地址转换就可以了

- 在防火墙中设置各种规则后，当包到达防火墙时，会根据这些规则判断是允许通过还是阻止通过：

  - 如果判断结果为阻止，那么这个包会被丢弃并被记录下来（如果将内置包过滤功能的路由器用作防火墙，则在丢弃包时基本上不会留下记录，这是因为路由器的内存容量小，没有足够的空间用来记录日志）。这是因为这些被丢弃的包中通常含有非法入侵的痕迹，通过分析这些包能够搞清楚入侵者使用的手法，从而帮助我们更好地防范非法入侵

  - 如果包被判断为允许通过，则该包会被转发出去，这个转发的过程和路由器是相同的

- 包过滤并不是防火墙专用的一种特殊机制，而是应该看作在路由器的包转发功能基础上附加的一种功能。只不过当判断规则比较复杂时，通过路由器的命令难以维护这些规则，而且对阻止的包进行记录对于路由器来说负担也比较大，因此才出现了专用的硬件和软件。如果规则不复杂，也不需要记录日志，那么用内置包过滤功能的普通路由器来充当防火墙也是可以的

- 防火墙可以根据包的起点和终点来判断是否允许其通过，但仅凭起点和终点并不能筛选出所有有风险的包。防火墙无法抵御针对应用程序本身的攻击，要应对这种情况有两种方法：

  - 这个问题的根源在于 Web 服务器程序的 Bug，因此修复 Bug 防止宕机就是其中一种方法

  - 另一种方法就是在防火墙之外部署用来检查包的内容并阻止有害包的设备或软件。当然，即便是采用这种方法也并不是完美无缺的，因为包的内容是否有风险，是由 Web 服务器有没有 Bug 决定的，因此当服务器程序中有潜在的 Bug 并且尚未被发现时，我们也无法判断包中的风险，也无法阻止这样的包。也就是说，我们无法抵御未知的风险

### 5.3 通过将请求平均分配给多台服务器来平衡负载

#### 5.3.1 性能不足时需要负载均衡

- 当服务器访问量上升的时候，遇到“性能”问题，有几种应对方法：

  - 增加服务器带宽

  - 更换性能更好的服务器

  - 使用分布式架构来分担负载

- 当服务器的访问量上升时，增加服务器线路的带宽是有效的，但并不是网络变快了就可以解决所有的问题。高速线路会传输大量的网络包，这会导致服务器的性能跟不上 [插图]。尤其是通过 CGI 等应用程序动态生成数据的情况下，对服务器 CPU 的负担更重，服务器性能的问题也会表现得越明显

- 更换换一台性能更好的服务器可以解决一部分问题，但当很多用户同时访问时，无论服务器的性能再好，仅靠一台服务器还是难以胜任的

- 使用分布式架构对负载进行分担有几种方法，最简单的一种方法就是采用多台 Web 服务器，减少每台服务器的访问量

- 具体的做法有很多种，最简单的一种是通过 DNS 服务器来分配。当访问服务器时，客户端需要先向 DNS 服务器查询服务器的 IP 地址，如果在 DNS 服务器中填写多个名称相同的记录，则每次查询时 DNS 服务器都会按顺序返回不同的 IP 地址

  但这种方式是有缺点的。假如多台 Web 服务器中有一台出现了故障，这时我们希望在返回 IP 地址时能够跳过故障的 Web 服务器，然而普通的 DNS 服务器并不能确认 Web 服务器是否正常工作，因此即便 Web 服务器宕机了，它依然可能会返回这台服务器的 IP 地址

  如果浏览器在访问 DNS 服务器返回的第一个 IP 地址失败时，能够继续尝试第二个 IP 地址，就可以回避这个问题了，最近的浏览器有很多都已经具备了这样的功能。

- 上述方式称为轮询（round-robin），通过这种方式可以将访问平均分配给所有的服务器

- 轮询分配可能会引发一些问题。在通过 CGI 等方式动态生成网页的情况下，有些操作是要跨多个页面的，如果这期间访问的服务器发生了变化，这个操作就可能无法继续

#### 5.3.2 使用负载均衡器分配访问

- 可以通过负载均衡器的设备解决 DNS 服务器分配访问时所遇到的缺点

- 使用负载均衡器时，首先要用负载均衡器的 IP 地址代替 Web 服务器的实际地址注册到 DNS 服务器上。客户端会认为负载均衡器就是一台 Web 服务器，并向其发送请求，然后由负载均衡器来判断将请求转发给哪台 Web 服务器

- 转发请求消息使用的是后面要讲到的“代理”机制，缓存服务器也使用这种机制。此外，有些负载均衡器中也内置缓存功能。负载均衡器和缓存服务器很相似，或者可以说它是由缓存服务器进一步发展而来的。

- 如何判断将请求转发给哪台 Web 服务器？判断条件有很多种，根据操作是否跨多个页面，判断条件也会有所不同：

  - 如果操作没有跨多个页面，则可以根据 Web 服务器的负载状况来进行判断

    - 负载均衡器可以定期采集 Web 服务器的 CPU、内存使用率，并根据这些数据判断服务器的负载状况，也可以向 Web 服务器发送测试包，根据响应所需的时间来判断负载状况

    - 当然，Web 服务器的负载可能会在短时间内上下波动，因此无法非常准确地把握负载状况，反过来说，如果过于密集地去查询服务器的负载，这个查询操作本身就会增加 Web 服务器的负载

    - 因此也有一种方案是不去查询服务器的负载，而是根据事先设置的服务器性能指数，按比例来分配请求。无论如何，这些方法都能够避免负载集中在某一台服务器上

  - 当操作跨多个页面时，则不考虑 Web 服务器的负载，而是必须将请求发送到同一台 Web 服务器上。要实现这一点，关键在于我们必须要判断一个操作是否跨了多个页面

    - 在 Web 服务器看来，每一次 HTTP 访问都是相互独立的，无法判断是否和之前的请求相关，所以不能直接通过 HTTP 访问来确认是否是跨页的

    - 也不能根据一系列请求的发送方 IP 地址相同这一点来来进行判断。如果使用了代理机制，所有请求的发送方 IP 地址都会变成代理服务器的 IP 地址，无法判断实际发送请求的客户端是哪个。此外，如果使用了地址转换，发送方 IP 地址则会变成地址转换设备的 IP 地址，也无法判断具体是哪个客户端

    - 可以用一些预设的方案来判断请求之间的相关性。例如，可以在发送表单数据时在里面加上用来表示关联的信息，或者是对 HTTP 规格进行扩展，在 HTTP 头部字段中加上用来判断相关性的信息，也就是俗称的 Cookie

- 负载均衡器可以通过上述信息来作出判断，将一系列相关的请求发送到同一台 Web 服务器，对于不相关的请求则发送到负载较低的服务器了。

### 5.4 使用缓存服务器分担负载

#### 5.4.1 缓存服务器

- 除了使用多台功能相同的 Web 服务器分担负载之外，还有另外一种方法，就是将整个系统按功能分成不同的服务器，如 Web 服务器、数据库服务器。缓存服务器就是一种按功能来分担负载的方法

- 缓存服务器是一台通过代理机制对数据进行缓存的服务器

- 代理介于 Web 服务器和客户端之间，具有对 Web 服务器访问进行中转的功能。当进行中转时，它可以将 Web 服务器返回的数据保存在磁盘中，并可以代替 Web 服务器将磁盘中的数据返回给客户端。这种保存的数据称为缓存，缓存服务器指的也就是这样的功能

- Web 服务器需要执行检查网址和访问权限，以及在页面上填充数据等内部操作过程，因此将页面数据返回客户端所需的时间较长。相对地，缓存服务器只要将保存在磁盘上的数据读取出来发送给客户端就可以了，因此可以比 Web 服务器更快地返回数据

- 不过，如果在缓存了数据之后，Web 服务器更新了数据，那么缓存的数据就不能用了，因此缓存并不是永久可用的。此外，CGI 程序等产生的页面数据每次都不同，这些数据也无法缓存。无论如何，在来自客户端的访问中，总有一部分访问可以无需经过 Web 服务器，而由缓存服务器直接处理。即便只有这一部分操作通过缓存服务器提高了速度，整体性能也可以得到改善。此外，通过让缓存服务器处理一部分请求，也可以减轻 Web 服务器的负担，从而缩短 Web 服务器的处理时间

- 缓存服务器工作流程：

  ![epub_907755_465.jpeg](/image/网络是怎样连接的/1d4430ec3b47e9e000792940c8f114ce9c83fa5f.jpeg)

- 缓存服务器工作过程简略步骤（不命中缓存）：

  1. 首先，缓存服务器和负载均衡器一样，需要代替 Web 服务器被注册到 DNS 服务器中

  2. 然后客户端会向缓存服务器发送 HTTP 请求消息（图（a）①），这时，缓存服务器会接收请求消息，这个接收操作和 Web 服务器相同。从客户端来看，缓存服务器就相当于 Web 服务器

  3. 接下来，缓存服务器会检查请求消息的内容，看看请求的数据是否已经保存在缓存中。根据是否存在缓存数据，后面的操作会有所不同，现在我们假设不存在缓存数据

  4. 这时，缓存服务器会在 HTTP 头部字段中添加一个 Via 字段（via 字段这个信息并不是特别重要，因此根据缓存服务器的配置，有时不会添加这个字段），表示这个消息经过缓存服务器转发，然后将消息转发给 Web 服务器（图（a）②）。在这个过程中，我们需要判断应该将请求消息转发给哪台 Web 服务器

     - 如果只有一台 Web 服务器，那么情况比较简单，只要将 Web 服务器的域名和 IP 地址配置在缓存服务器上，让它无条件转发给这台服务器就可以了

     - 如果一台缓存服务器对应多台 Web 服务器，需要根据请求消息的内容来判断应该转发给哪台 Web 服务器。要实现这个目的有几种方法，其中比较有代表性的是根据请求消息的 URI（图 5（b）①）中的目录名来进行判断

  5. 从 Web 服务器来看，缓存服务器就相当于客户端。于是，缓存服务器会收到来自 Web 服务器的响应消息（图（a）③），接收消息的过程也是以客户端的身份来完成的

  6. 接下来，缓存服务器会在响应消息中加上 Via 头部字段，它表示这个消息是经过缓存服务器中转的

  7. 然后缓存服务器会以 Web 服务器的身份向客户端发送响应消息。同时，缓存服务器会将响应消息保存到缓存中，并记录保存的时间

- 缓存服务器工作过程简略步骤（命中缓存）：

  1. 首先，接收客户端的请求消息并检查缓存的过程和刚才是一样的

  2. 然后，缓存服务器会添加一个 If-Modified-Since 头部字段并将请求转发给 Web 服务器，询问 Web 服务器用户请求的数据是否已经发生变化

  3. 然后，Web 服务器会根据 If-Modified-Since 的值与服务器上的页面数据的最后更新时间进行比较，如果在指定时间内数据没有变化，就会返回一个表示没有变化的响应消息（304 响应码）。这时，Web 服务器只要查询一下数据的最后更新时间就好了，比返回页面数据的负担要小一些。而且返回的响应消息也比较短，能相应地减少负担

     此外，当 Web 服务器上的数据有变化时，后面的过程和没有命中缓存的情况是一样的。Web 服务器会返回最新版本的数据

  4. 接下来，返回消息到达缓存服务器，然后缓存服务器就会知道 Web 服务器上的数据和本地缓存中的数据是一样的，于是就会将缓存的数据返回给客户端。缓存服务器返回的响应消息的内容和没有命中缓存的情况是一样的

- 这种在客户端和 Web 服务器之间充当中间人的方式就是代理的基本原理。在中转消息的过程中，缓存服务器还会顺便将页面数据保存下来，随着缓存数据的积累，用户访问的数据命中缓存的几率也会提高

#### 5.4.2 正向代理

- 实际上，缓存服务器使用的代理机制最早就是放在客户端一侧的，这才是代理的原型，称为正向代理（forward proxy）

- 正向代理刚刚出现的时候，其目的之一就是缓存，这个目的和服务器端的缓存服务器相同。不过，当时的正向代理还有另外一个目的，那就是用来实现防火墙

  简单来说，代理会先接收来自客户端的请求消息，然后再转发到互联网中，这样就可以实现只允许通过必要的网络包了。如果能够利用代理的缓存，那么效果就会更好，因为对于以前访问过的数据，可以直接从位于公司内网的代理服务器获得，这比通过低速线路访问互联网要快很多

- 代理（Proxy）本来的意思并不是“转发”消息，而是先把消息收下来，然后“伪装”成原始客户端向 Web 服务器发出访问请求。

- 由于代理在转发过程中可以查看请求的内容，所以可以根据内容判断是否允许访问。也就是说，通过代理可以禁止员工访问危险的网站，或者是与工作内容无关的网站。包过滤方式的防火墙只能根据 IP 地址和端口号进行判断，因此无法实现这一目的

- 在使用正向代理时，一般需要在浏览器的设置窗口中的“代理服务器”一栏中填写正向代理的 IP 地址，浏览器发送请求消息的过程也会发生相应的变化

  - 在没有设置正向代理的情况下，浏览器会根据网址栏中输入的 http://..．字符串判断 Web 服务器的域名，并向其发送请求消息；当设置了正向代理时，浏览器会忽略网址栏的内容，直接将所有请求发送给正向代理

  - 请求消息的内容也会有一些不同。没有正向代理时，浏览器会从网址中提取出 Web 服务器域名后面的文件名或目录名，然后将其作为请求的 URI 进行发送；而有正向代理时，浏览器在请求的 URI 字段中填写完整的 http://..．网址

- 正向代理转发消息的过程也和服务器端的缓存服务器有一些不同，不同点在于对转发目标 Web 服务器的判断上。使用正向代理时，URI 部分为 http://..．这样的完整网址，因此可以根据这个网址来转发，不需要像服务器端的缓存服务器一样实现设置好转发目标 Web 服务器，而且可以发给任意 Web 服务器。而服务器端的缓存服务器只能向事先设置好的目标进行转发，这就是两者不同的地方

#### 5.4.3 反向代理

- 正向代理和反向代理（reverse proxy）的几个不同点：

  - 正向代理在客户端，反向代理在服务器端

  - 正向代理转发请求消息时候 URL 的地址是完整的，反向代理可以通过将请求消息中的 URI 中的目录名与 Web 服务器进行关联，使得代理能够转发一般的不包含完整网址的请求消息

#### 5.4.4 透明代理

- 缓存服务器判断转发目标的方法还有一种，那就是查看请求消息的包头部。因为包的 IP 头部中包含接收方 IP 地址，只要知道了这个地址，就知道用户要访问哪台服务器了。HTTP 1.1 版本增加了一个用于表示访问目标 Web 服务器的 Host 字段，因此也可以通过 Host 字段来判断转发目标。这种方法称为透明代理（transparent proxy）。

- 这种方法也可以转发一般的请求消息，因此不需要像正向代理一样设置浏览器参数，也不需要在缓存服务器上设置转发目标，可以将请求转发给任意 Web 服务器

- 透明代理集合了正向代理和反向代理的优点，是一个非常方便的方式，但也需要注意一点，那就是如何才能让请求消息到达透明代理。由于透明代理不需要设置在浏览器中，那么浏览器还是照常向 Web 服务器发送请求消息。反向代理采用的是通过 DNS 服务器解析引导的方法，但透明代理是不能采用这种方法的，否则透明代理本身就变成了访问目标，也就无法通过接收方 IP 地址判断转发目标了，这就失去了透明代理的意义。总之，正常情况下，请求消息是从浏览器直接发送到 Web 服务器，并不会到达透明代理

- 于是需要将透明代理放在请求消息从浏览器传输到 Web 服务器的路径中，当消息经过时进行拦截。只有这样才能让消息到达透明代理，然后再转发给 Web 服务器

- 如果请求消息有多条路径可以到达 Web 服务器，那么就必须在这些路径上都放置透明代理，因此一般是将网络设计成只有一条路可以走的结构，然后在这一条路径上放置透明代理。连接互联网的接入网就是这样一个关口，因此可以在接入网的入口处放置透明代理。也可以采用在网络中的某些地方将 Web 访问包筛选出来并转发给透明代理的方法。

- 使用透明代理时，用户不会察觉到代理的存在，也不会注意到 HTTP 消息是如何被转发的，因此大家更倾向于将透明代理说成是缓存

### 5.5 内容分发服务

#### 5.5.1 内容分发服务的背景

- 缓存服务器部署的三种方式：

  ![epub_907755_477.jpeg](/image/网络是怎样连接的/97a7515663001c95c009a79a136372b7a7cc8b93.jpeg)

- 缓存服务器部署在服务器端还是客户端，其效果是有差别的。如图（a）所示，当缓存服务器放在服务器端时，可以减轻 Web 服务器的负载，但无法减少互联网中的流量。这一点上，将缓存服务器放在客户端更有效（图（b））。互联网中会存在一些拥塞点，通过这些地方会比较花时间。如果在客户端部署缓存服务器，就可以不受或者少受这些拥塞点的影响，让网络流量更稳定，特别是当访问内容中含有大图片或视频时效果更明显

- 不过，客户端的缓存服务器是归客户端网络运营管理者所有的，Web 服务器的运营者无法控制它。比如，某网站的运营者觉得最近网站上增加了很多大容量的内容，因此想要增加缓存服务器的容量。如果缓存放在服务器端，那么网站运营者可以自己通过增加磁盘空间等方式来进行扩容，但对于放在客户端的缓存就无能为力了。进一步说，客户端有没有缓存服务器还不一定呢

- 因此，这两种部署缓存服务器的方式各有利弊，但也有一种方式能够集合两者的优点。那就是像图（c）这样，Web 服务器运营者和网络运营商签约，将可以自己控制的缓存服务器放在客户端的运营商处。这样一来，就可以把缓存服务器部署在距离用户很近的地方，同时 Web 服务器运营者还可以控制这些服务器

- 但图（c）方式也有问题。对于在互联网上公开的服务器来说，任何地方的人都可以来访问它，因此如果真的要实现这个方式，必须在所有的运营商 POP 中都部署缓存服务器才行，这个数量太大了，非常不现实。可以筛选出一些主要的运营商，这样可以减少缓存服务器的数量。尽管这样做可能会导致有些用户访问到缓存服务器还是要经过很长的距离，但总比直接访问 Web 服务器的路径要短多了，因此还是可以产生一定的效果

- 一些专门负责提供上述相关服务的厂商出现了，他们来部署缓存服务器，并租借给 Web 服务器运营者。这种服务称为内容分发服务

- 内容分发服务也叫 CDS（Content Delivery Service）。现在更常用的名称叫 CDN（Content Delivery Network 或 Content Distribution Network）。

- 提供这种服务的厂商称为 CDSP（CDSP:Content Delivery Service Provider，内容分发服务运营商），他们会与主要的供应商签约，并部署很多台缓存服务器 [插图]。另一方面，CDSP 会与 Web 服务器运营者签约，使得 CDSP 的缓存服务器配合 Web 服务器工作。只要 Web 服务器与缓存服务器建立关联，那么当客户端访问 Web 服务器时，实际上就是在访问 CDSP 的缓存服务器了

- 缓存服务器可以缓存多个网站的数据，因此 CDSP 的缓存服务器就可以提供给多个 Web 服务器的运营者共享。这样一来，每个网站运营者的平均成本就降低了，从而减少了网站运营者的负担。而且，和运营商之间的签约工作也由 CDSP 统一负责，网站运营者也节省了精力

#### 5.5.2 如何找到最近的缓存服务器

- 如何使得用户不进行设置，也能够将请求消息发送到缓存服务器，有几种方法：

  - 第一个方法是像负载均衡一样用 DNS 服务器来分配访问。也就是说，我们可以在 DNS 服务器返回 Web 服务器 IP 地址时，对返回的内容进行一些加工，使其能够返回距离客户端最近的缓存服务器的 IP 地址

- 对于第一个方法。在 DNS 服务器中，如果一个域名对应多个 IP 地址，则按照轮询方式按顺序返回所有的 IP 地址。如果按照 DNS 服务器的一般工作方式来看，它只能以轮询方式按顺序返回 IP 地址，完全不考虑客户端与缓存服务器的远近，因此可能会返回离客户端较远的缓存服务器 IP 地址。如果要让用户访问最近的缓存服务器，则不应采用轮询方式，而是应该判断客户端与缓存服务器的距离，并返回距离客户端最近的缓存服务器 IP 地址

- 如何判断客户端与缓存服务器之间的距离？

  1. 首先，作为准备，需要事先从缓存服务器部署地点的路由器收集路由信息。举个例子，假如一共有 4 台缓存服务器，在这 4 台服务器的部署地点又分别有 4 台路由器，则我们需要分别获取这 4 台路由器的路由表，并将 4 张路由表集中到 DNS 服务器上

  2. 接下来，DNS 服务器根据路由表查询从本机到 DNS 查询消息的发送方，也就是客户端 DNS 服务器的路由信息。例如，根据上诉例子路由器 A 的路由表，可以查出路由器 A 到客户端 DNS 服务器的路由。通过互联网内部的路由表中的路由信息可以知道先通过运营商 X，然后通过运营商 Y，最后到达运营商 Z 这样的信息，通过这样的信息可以大致估算出距离

  3. 依次查询所有路由器的路由表之后，我们就可以通过比较找出哪一台路由器距离客户端 DNS 服务器最近。提供路由表的路由器位于缓存服务器的位置，而客户端 DNS 服务器也应该和客户端在同一位置，这样就等于估算出了缓存服务器与客户端之间的距离，从而能够判断出哪台缓存服务器距离客户端最近了。实际上，客户端 DNS 服务器不一定和客户端在同一位置，因此可能无法得出准确的距离，但依然可以达到相当的精度。

#### 5.5.3 通过重定向向服务器分配访问目标

- 还有另一个让客户端访问最近的缓存服务器的方法：HTTP 规格中定义了很多头部字段，其中有一个叫作 Location 的字段。当 Web 服务器数据转移到其他服务器时可以使用这个字段，它的意思是“您要访问的数据在另一台服务器上，请访问那台服务器吧。”这种将客户端访问引导到另一台 Web 服务器的操作称为重定向，通过这种方法也可以将访问目标分配到最近的缓存服务器

- 当使用重定向告知客户端最近的缓存服务器时，首先需要将重定向服务器注册到 Web 服务器端的 DNS 服务器上。这样一来，客户端会将 HTTP 请求消息发送到重定向服务器上。重定向服务器和刚才一种方法中的 DNS 服务器一样，收集了来自各个路由器的路由信息，并根据这些信息找到最近的缓存服务器，然后将缓存服务器的地址放到 Location 字段中返回响应。这样，客户端就会重新去访问指定的缓存服务器了

- 这种方法的缺点在于增加了 HTTP 消息的交互次数，相应的开销也比较大，但它也有优点。对 DNS 服务器进行扩展的方法是估算客户端 DNS 服务器到缓存服务器之间的距离，因此精度较差；相对而言，重定向的方法是根据客户端发送来的 HTTP 消息的发送方 IP 地址来估算距离的，因此精度较高

- 此外，也可以使用除路由信息之外的其他一些信息来估算距离，进一步提高精度。重定向服务器不仅可以返回带有 Location 字段的 HTTP 消息，也可以返回一个通过网络包往返时间估算到缓存服务器的距离的脚本，通过在客户端运行脚本来找到最优的缓存服务器。这个脚本可以向不同的缓存服务器发送测试包并计算往返时间，然后将请求发送到往返时间最短的一台缓存服务器，这样就可以判断出对于客户端最优的缓存服务器，并让客户端去访问该服务器

#### 5.5.4 缓存的更新方法会影响性能

- 还有一个因素会影响缓存服务器的效率，那就是缓存内容的更新方法

- 缓存本来的思路是将曾经访问过的数据保存下来，然后当再次访问时拿出来用，以提高访问操作的效率。不过，这种方法对于第一次访问是无效的，而且后面的每次访问都需要向原始服务器查询数据有没有发生变化，如果遇到网络拥塞，就会使响应时间恶化

- 要改善上述思路，有一种方法是让 Web 服务器在原始数据发生更新时，立即通知缓存服务器，使得缓存服务器上的数据一直保持最新状态，这样就不需要每次确认原始数据是否有变化了，而且从第一次访问就可以发挥缓存的效果。内容分发服务采用的缓存服务器就具备这样的功能

- 此外，除了事先编写好内容的静态页面之外，还有一些在收到请求后由 CGI 程序生成的动态页面，这种动态页面是不能保存在缓存服务器上的。这种情况下，我们可以不保存整个页面，而是将应用程序生成的部分，也就是每次内容都会发生变化的动态部分，与内容不会发生变化的静态部分分开，只将静态部分保存在缓存中

## 第六章 请求到达 Web 服务器，响应返回浏览器

### 6.1 服务器概览

#### 6.1.1 客户端和服务器的区别

- 客户端和服务器的异：

  - 根据用途，服务器可以分为很多种类，其硬件和操作系统与客户端是有所不同的

  - 服务器的程序可以同时和多台客户端计算机进行通信，这也是一点区别。因此，服务器程序和客户端程序在结构上是不同的

  - 在连接过程中，客户端发起连接操作，而服务器则是等待连接操作，因此在 Socket 库的用法上还是有一些区别的，即应用程序调用的 Socket 库的程序组件不同

- 客户端和服务器的同：

  - 网络相关的部分，如网卡、协议栈、Socket 库等功能和客户端却并无二致。无论硬件和 OS 如何变化，TCP 和 IP 的功能都是一样的，或者说这些功能规格都是统一的

#### 6.1.2 服务器程序的结构

- 服务器需要同时和多个客户端通信，但一个程序来处理多个客户端的请求是很难的，因为服务器必须把握每一个客户端的操作状态。因此一般的做法是，每有一个客户端连接进来，就启动一个新的服务器程序，确保服务器程序和客户端是一对一的状态

- 服务器分层简单图示：

  ![epub_907755_495.jpeg](/image/网络是怎样连接的/42635d6e641504ad300e5c5092141d4b2eb18208.jpeg)

- 服务器程序的结构如上图所示：

  - 首先，程序分成两个模块，即等待连接模块图（a）和负责与客户端通信的模块图（b）

  - 当服务器程序启动并读取配置文件完成初始化操作后，就会运行等待连接模块（a）。这个模块会创建套接字，然后进入等待连接的暂停状态

  - 接下来，当客户端连发起连接时，这个模块会恢复运行并接受连接，然后启动客户端通信模块（b），并移交完成连接的套接字

  - 接下来，客户端通信模块（b）就会使用已连接的套接字与客户端进行通信，通信结束后，这个模块就退出了

- 每次有新的客户端发起连接，都会启动一个新的客户端通信模块（b），因此（b）与客户端是一对一的关系。这样，（b）在工作时就不必考虑其他客户端的连接情况，只要关心自己对应的客户端就可以了

  通过这样的方式，可以降低程序编写的难度。服务器操作系统具有多任务、多线程功能，可以同时运行多个程序，服务器程序的设计正是利用了这一功能

- 上述方法在每次客户端发起连接时都需要启动新的程序，这个过程比较耗时，响应时间也会相应增加。因此，还有一种方法是事先启动几个客户端通信模块，当客户端发起连接时，从空闲的模块中挑选一个出来将套接字移交给它来处理

#### 6.1.3 服务器端的套接字和端口号

- 从数据收发的角度来看，这就是客户端与服务器的区别，也就是说，发起连接的一方是客户端，等待连接的一方是服务器

- 客户端的数据收发主要是以下四个阶段：

  - 创建套接字（创建套接字阶段）

  - 用管道连接服务器端的套接字（连接阶段）

  - 收发数据（收发阶段）

  - 断开管道并删除套接字（断开阶段）

- 相对地，服务器是将第二个阶段改成了等待连接，具体如下：

  - 创建套接字（创建套接字阶段）

  - 等待阶段

    - 将套接字设置为等待连接状态（等待连接阶段）

    - 接受连接（接受连接阶段）

  - 收发数据（收发阶段）

  - 断开管道并删除套接字（断开阶段）

- 服务器程序主要阶段的伪代码：

  ![epub_907755_501.jpeg](/image/网络是怎样连接的/82831f1c2532414875c69dbf52d411f8cb52a019.jpeg)

- 服务端的具体工作步骤：

  1. 首先，协议栈调用 socket 创建套接字图（1），这一步和客户端是相同的。创建套接字操作的本质是分配用于套接字的内存空间，这一点上客户端和服务器是一样的。

  2. 接下来调用 bind 将端口号写入套接字中（图（2-1））。在客户端发起连接的操作中，需要指定服务器端的端口号，这个端口号也就是在这一步设置的（客户端调用 connect）。具体的编号是根据服务器程序的种类，按照规则来确定的，例如 Web 服务器使用 80 号端口

  3. 设置好端口号之后，协议栈会调用 listen 向套接字写入等待连接状态这一控制信息（图（2-1））。这样一来，套接字就会开始等待来自客户端的连接网络包

  4. 然后，协议栈会调用 accept 来接受连接（图（2-2））

     - 由于等待连接的模块在服务器程序启动时就已经在运行了，所以在刚启动时，应该还没有客户端的连接包到达

     - 包都没来就调用 accept 接受连接也没关系，因为如果包没有到达，就会转为等待包到达的状态，并在包到达的时候继续执行接受连接操作。因此，在执行 accept 的时候，一般来说服务器端都是处于等待包到达的状态，这时应用程序会暂停运行。在这个状态下，一旦客户端的包到达，就会返回响应包并开始接受连接操作

  5. 当 accept 结束之后，等待连接的过程也就结束了，接下来协议栈会给等待连接的套接字复制一个副本，然后将连接对象等控制信息写入新的套接字中。到这里，我们就创建了一个新的套接字，用于和客户端套接字连接在一起了

  6. 再接下来等待连接模块会启动客户端通信模块，然后将连接好的新套接字转交给客户端通信模块，由这个模块来负责执行与客户端之间的通信操作

  7. 之后的数据收发操作和刚才说的一样，与客户端的工作过程是相同的

- 在复制出一个新的套接字之后，原来那个处于等待连接状态的套接字会以等待连接的状态继续存在，当再次调用 accept，客户端连接包到达时，它又可以再次执行接受连接操作。接受新的连接之后，和刚才一样，协议栈会为这个等待连接的套接字复制一个新的副本，然后让客户端连接到这个新的副本套接字上

  像这样每次为新的连接创建新的套接字就是这一步操作的一个关键点。如果不创建新副本，而是直接让客户端连接到等待连接的套接字上，那么就没有套接字在等待连接了，这时如果有其他客户端发起连接就会遇到问题。为了避免出现这样的情况，协议栈采用了这种创建套接字的新副本，并让客户端连接到这个新副本上的方法

- 创建新套接字时端口号也是一个关键点

  - 在接受连接的时候，新创建的套接字副本就必须和原来的等待连接的套接字具有不同的端口号才行。否则客户端无法判断服务端的端口

  - 多个套接字对应同一个端口会导致一个问题：端口号是用来识别套接字的，如果一个端口号对应多个套接字，就无法通过端口号来定位到某一个套接字了。当客户端的包到达时，如果协议栈只看 TCP 头部中的接收方端口号，是无法判断这个包到底应该交给哪个套接字的

    因此服务端确定某个套接字时，不仅使用服务器端套接字对应的端口号，还同时使用客户端的端口号再加上 IP 地址，总共使用下面 4 种信息来进行判断

    ![epub_907755_504.jpeg](/image/网络是怎样连接的/3df6afc8ff50855735d563555a14ab979ddb38da.jpeg)

  - 服务器上可能存在多个端口号相同的套接字，但客户端的套接字都是对应不同端口号的，因此我们可以通过客户端的端口号来确定服务器上的某个套接字。不过，使用不同端口号的规则仅限一台客户端的内部，当有多个客户端进行连接时，它们之间的端口号是可以重复的。因此，我们还必须加上客户端的 IP 地址才能进行判断

### 6.2  服务器的接收操作

#### 6.2.1 网卡的接收操作

- 接收操作的第一步是网卡接收到模拟信号，然后将其还原成数字信息

  - 局域网中传输的网络包信号是由 1 和 0 组成的数字信息与用来同步的时钟信号叠加而成的，因此只要从中分离出时钟信号，然后根据时钟信号进行同步，就可以读取并还原出 1 和 0 的数字信息了

- 简略图示：

  ![epub_907755_507.jpeg](/image/网络是怎样连接的/06973ebcb388bdd919731d7ebb856bfc75c76ab5.jpeg)

- 信号的格式随传输速率的不同而不同，因此某些操作过程可能存在细微差异，例如 10BASE-T 的工作方式如上图所示。

  - 首先从报头部分提取出时钟信号（图①），报头的信号是按一定频率变化的，只要测定这个变化的频率就可以和时钟信号同步了

  - 接下来，按照相同的周期延长时钟信号（图②），并在每个时钟周期位置检测信号的变化方向（图③）

  - 图中用向上和向下的箭头表示变化方向，实际的信号则是正或负的电压，这里需要检测电压是从正变为负，还是从负变为正，这两种变化方向分别对应 0 和 1（图④）。在图中，向上的箭头为 1，向下的箭头为 0，实际上是从负到正变化为 1，从正到负变化为 0。这样，信号就被还原成数字信息了

- 接下来需要根据包末尾的帧校验序列（FCS）来校验错误，即根据校验公式 [插图] 计算刚刚接收到的数字信息，然后与包末尾的 FCS 值进行比较

  - FCS 值是在发送时根据转换成电信号之前的数字信息进行计算得到的，因此如果根据信号还原出的数字信息与发送前的信息一致，则计算出的 FCS 也应该与包末尾的 FCS 一致

  - 如果两者不一致，则可能是因为噪声等影响导致信号失真，数据产生了错误，这时接收的包是无效的，因此需要丢弃

- 当 FCS 一致，即确认数据没有错误时，接下来需要检查 MAC 头部中的接收方 MAC 地址，看看这个包是不是发给自己的

  - 以太网的基本工作方式是将数据广播到整个网络上，只有指定的接收者才接收数据，因此网络中还有很多发给其他设备的数据在传输，如果包的接收者不是自己，那么就需要丢弃这个包

- 到这里，接收信号并还原成数字信息的操作就完成了，还原后的数字信息被保存在网卡内部的缓冲区中。上面这些操作都是由网卡的 MAC 模块来完成的

- 接下来，网卡需要通过中断将网络包到达的事件通知给 CPU

- 然后 CPU 就会暂停当前的工作，并切换到网卡的任务

- 然后，网卡驱动会开始运行，从网卡缓冲区中将接收到的包读取出来，根据 MAC 头部的以太类型字段判断协议的种类，并调用负责处理该协议的软件。网卡驱动会根据 MAC 头部判断协议类型，并将包交给相应的协议栈。这里，以太类型的值应该是表示 IP 协议，因此会调用 TCP/IP 协议栈，并将包转交给它

#### 6.2.2 IP 模块的接收操作

- 当网络包转交到协议栈时，IP 模块会首先开始工作，检查 IP 头部

  - IP 模块首先会检查 IP 头部的格式是否符合规范，然后检查接收方 IP 地址，看包是不是发给自己的。当服务器启用类似路由器的包转发功能时，对于不是发给自己的包，会像路由器一样根据路由表对包进行转发

  - 服务器也可以启用类似防火墙的包过滤功能，这时，在包转发的过程中还会对包进行检查，并丢弃不符合规则的包。

- 确认包是发给自己的之后，接下来需要检查包有没有被分片

  - 检查 IP 头部的内容就可以知道是否分片，如果是分片的包，则将包暂时存放在内存中，等所有分片全部到达之后将分片组装起来还原成原始包

  - 如果没有分片，则直接保留接收时的样子，不需要进行重组

- 到这里，我们就完成了包的接收。总结来说，协议栈的 IP 模块会检查 IP 头部

  - 判断是不是发给自己

  - 判断网络包是否经过分片

  - 将包转交给 TCP 模块或 UDP 模块。

- 接下来需要检查 IP 头部的协议号字段，并将包转交给相应的模块

  - 如果协议号为 06（十六进制），则将包转交给 TCP 模块，接下来假设是 TCP 的包

  - 如果是 11（十六进制），则转交给 UDP 模块

#### 6.2.3 TCP 模块处理链接包

- 服务器程序主要阶段的伪代码：

  ![epub_907755_518.jpeg](/image/网络是怎样连接的/8c82cdcb19b63bd67a7ce90ecac2628dd9dee298.jpeg)

- 当 TCP 头部中的控制位 SYN 为 1 时，表示这是一个发起连接的包（图①）。这时，TCP 模块会执行接受连接的操作，不过在此之前，需要先检查包的接收方端口号，并确认在该端口上有没有与接收方端口号相同且正在处于等待连接状态的套接字。如果指定端口号没有等待连接的套接字，则向客户端返回错误通知的包，向客户端返回一个表示接收方端口不存在等待连接的套接字的 ICMP 消息

- 如果存在等待连接的套接字，则为这个套接字复制一个新的副本，并将发送方 IP 地址、端口号、序号初始值、窗口大小等必要的参数写入这个套接字中，同时分配用于发送缓冲区和接收缓冲区的内存空间

  然后生成代表接收确认的 ACK 号，用于从服务器向客户端发送数据的序号初始值，表示接收缓冲区剩余容量的窗口大小，并用这些信息生成 TCP 头部，委托 IP 模块发送给客户端

- 这个包到达客户端之后，客户端会返回表示接收确认的 ACK 号，当这个 ACK 号返回服务器后，连接操作就完成了

- 总结来说，如果收到的是发起连接的包，则 TCP 模块会

  - 确认 TCP 头部的控制位 SYN

  - 检查接收方端口号

  - 为相应的等待连接套接字复制一个新的副本

  - 记录发送方 IP 地址和端口号等信息

#### 6.2.4 TCP 模块处理数据包

- 首先，TCP 模块会检查收到的包对应哪一个套接字

  - 在服务器端，可能有多个已连接的套接字对应同一个端口号，因此仅根据接收方端口号无法找到特定的套接字。这时需要根据 IP 头部中的发送方 IP 地址和接收方 IP 地址，以及 TCP 头部中的接收方端口号和发送方端口号共 4 种信息，找到上述 4 种信息全部匹配的套接字

- 找到 4 种信息全部匹配的套接字之后，TCP 模块会对比该套接字中保存的数据收发状态和收到的包的 TCP 头部中的信息是否匹配，以确定数据收发操作是否正常

  - 具体来说，就是根据套接字中保存的上一个序号和数据长度计算下一个序号，并检查与收到的包的 TCP 头部中的序号是否一致

  - 如果两者一致，就说明包正常到达了服务器，没有丢失。这时，TCP 模块会从包中提出数据，并存放到接收缓冲区中，与上次收到的数据块连接起来。这样一来，数据就被还原成分包之前的状态了

  - 拼合数据块的操作在每次收到数据包时都会进行，而不是等所有数据全部接受完毕之后再统一拼合的。

- 当收到的数据进入接收缓冲区后，TCP 模块就会生成确认应答的 TCP 头部，并根据接收包的序号和数据长度计算出 ACK 号，然后委托 IP 模块发送给客户端

  - 在返回 ACK 号之前，会先等待一段时间，看看能不能和后续的应答包合并。

- 收到的数据块进入接收缓冲区，意味着数据包接收的操作告一段落了

- 接下来，应用程序会调用 Socket 库的 read 来获取收到的数据，这时数据会被转交给应用程序

  - 如果应用程序不来获取数据，则数据会被一直保存在缓冲区中，但一般来说，应用程序会在数据到达之前调用 read 等待数据到达，在这种情况下，TCP 模块在完成接收操作的同时，就会执行将数据转交给应用程序的操作

- 然后，控制流程会转移到服务器程序，对收到的数据进行处理，也就是检查 HTTP 请求消息的内容，并根据请求的内容向浏览器返回相应的数据

- 总的来说，收到数据包时，TCP 模块会

  - 根据收到的包的发送方 IP 地址、发送方端口号、接收方 IP 地址、接收方端口号找到相对应的套接字

  - 将数据块拼合起来并保存在接收缓冲区中

  - 向客户端返回 ACK

#### 6.2.5 TCP 模块的断开操作

- 在 TCP 协议的规则中，断开操作可以由客户端或服务器任何一方发起，具体的顺序是由应用层协议决定的。Web 中，这一顺序随 HTTP 协议版本不同而不同，在 HTTP1.0 中，是服务器先发起断开操作。HTTP1.1 中，是客户端先发起断开操作，这种情况下只要将客户端和服务器的操作颠倒一下就可以了

- 首先，服务器程序会调用 Socket 库的 close, TCP 模块会生成一个控制位 FIN 为 1 的 TCP 头部，并委托 IP 模块发送给客户端

- 当客户端收到这个包之后，会返回一个 ACK 号

- 接下来客户端调用 close，生成一个 FIN 为 1 的 TCP 头部发给服务器，服务器再返回 ACK 号，这时断开操作就完成了

- 无论哪种情况，当断开操作完成后，套接字会在经过一段时间后被删除

### 6.3 Web 服务器程序解释请求消息并作出响应

#### 6.3.1 将请求的 URI 转换为文件路径

- 服务器程序会根据收到的请求消息中的内容进行相应的处理，并生成响应消息，再通过 write 返回给客户端

- 请求消息包括一个称为“方法”的命令，以及表示数据源的 URI（文件路径名），服务器程序会根据这些内容向客户端返回数据，但对于不同的方法和 URI，服务器内部的工作过程会有所不同

- Web 服务器公开的目录其实并不是磁盘上的实际目录，而是虚拟目录，而 URI 中写的就是在这个虚拟目录结构下的路径名。也就是说，客户端看到的 Web 服务器目录是虚拟的，和实际的目录结构不同。Web 服务器内部会将实际的目录名和供外部访问的虚拟目录名进行关联

- Web 服务器进行文件名转换是有特例的，比如 URI 中的路径省略了文件名的情况，这时服务器会读取事先设置好的默认文件名。例如在浏览器中输入如下网址

- 有些 Web 服务器程序还具有文件名改写功能，只要设置好改写的规则，当 URI 中的路径符合改写规则时，就可以将 URI 中的文件名改写成其他的文件名进行访问

#### 6.3.2 运行 CGI 程序

- 如果 URI 指定的文件内容为 HTML 文档或图片，那么只要直接将文件内容作为响应消息返回客户端就可以了。但 URI 指定的文件内容不仅限于 HTML 文档，也有可能是一个程序。在这个情况下，服务器不会直接返回文件内容，而是会运行这个程序，然后将程序输出的数据返回给客户端

- Web 服务器收到请求消息之后，Web 服务器会进行下面的工作

  - 首先，Web 服务器会检查 URI 指定的文件名，看一看这个文件是不是一个程序

    - 这里的判断方法是在 Web 服务器中事先设置好的，一般是通过文件的扩展名来进行判断，例如将．cgi、.php 等扩展名的文件设置为程序，当遇到这些文件时，Web 服务器就会将它们作为程序来对待

    - 也可以设置一个存放程序的目录，将这个目录下的所有文件都作为程序来对待

    - 此外，还可以根据文件的属性来进行判断

  - 如果判断要访问的文件为程序文件，Web 服务器会委托操作系统运行这个程序，然后从请求消息中取出数据并交给运行的程序

    - 如果方法为 GET，则将 URI 后面的参数传递给程序

    - 如果方法为 POST，则将消息体中的数据传递给程序

  - 接下来，运行的程序收到数据后会进行一系列处理，并将输出的数据返回给 Web 服务器。无论如何，为了将数据处理的结果返回给客户端，首先需要将它返回给 Web 服务器

    - 这些输出的数据一般来说会嵌入到 HTML 文档中，因此 Web 服务器可以直接将其作为响应消息返回给客户端。输出数据的内容是由运行的程序生成的，Web 服务器并不过问，也不会去改变程序输出的内容

- 总的来说，Web 服务器程序在组装网络包、还原数据之后，会运行其中指定的程序（实际是委托操作系统来运行），然后将数据传递给已运行的程序

#### 6.3.3 Web 服务器的访问控制

- Web 服务器的基本工作方式就是根据请求消息的内容判断数据源，并从中获取数据返回给客户端，不过在执行这些操作之前，Web 服务器还可以检查事先设置的一些规则，并根据规则允许或禁止访问

  这种根据规则判断是否允许访问的功能称为访问控制，一些会员制的信息服务需要限制用户权限的时候会使用这一功能，公司里也可以利用访问控制只允许某些特定部门访问

- Web 服务器的访问控制规则主要有以下 3 种

  - 客户端 IP 地址

  - 客户端域名

  - 用户名和密码

- 访问规则可针对作为数据源的文件和目录进行设置，当收到客户端的请求消息时，服务器会根据 URI 判断数据源，并检查数据源对应的访问控制规则，只有允许访问时才读取文件或运行程序

- 利用 HTTP 验证用户名和密码：

  ![epub_907755_538.jpeg](/image/网络是怎样连接的/3a285a8d6bc96dbea51a89e45c9d137fb83c4587.jpeg)

- 基于用户名和密码的访问控制

  - 这里指的是使用 Web 服务器提供的密码认证功能时的工作过程，除此之外，还可以通过 Web 服务器运行 CGI 认证程序来验证密码。

    这种情况下，认证程序会生成一个含有密码表单的网页并发送给用户，用户填写密码后发送回服务器，由认证程序进行校验。这种方式会包含密码表单页面和用户提交的密码数据的交互过程，和 Web 服务器自身提供的密码认证功能是有区别的

  - 当访问设置了用户名和密码保护的页面时，需要在 HTTP 请求消息中添加包含用户名和密码的头部字段（Authorization）。否则，Web 服务器不会返回请求的页面内容，而是会返回一个要求提供用户名和密码的头部字段（WWW-Authenticate）消息

  - 步骤：

    - 通常的请求消息中不包含用户名和密码，因此无法验证用户名和密码

    - 因此，Web 服务器会向用户发送一条响应消息，告诉用户需要在请求消息中放入用户名和密码

    - 浏览器收到这条响应消息后，会弹出一个输入用户名和密码的窗口，用户输入用户名和密码后，浏览器将这些信息放入请求消息中重新发送给服务器

    - 然后，Web 服务器查看接收到的用户名和密码与事先设置好的用户名和密码是否一致，以此判断是否允许访问，如果允许访问，则返回数据

#### 6.3.4 返回响应信息

- 当服务器完成对请求消息的各种处理之后，就可以返回响应消息了。这里的工作过程和客户端向服务器发送请求消息时的过程相同

- 首先，Web 服务器调用 Socket 库的 write，将响应消息交给协议栈。这时，需要告诉协议栈这个响应消息应该发给谁，但我们并不需要直接告知客户端的 IP 地址等信息，而是只需要给出表示通信使用的套接字的描述符就可以了

- 接下来，协议栈会将数据拆分成多个网络包，然后加上头部发送出去。这些包中包含接收方客户端的地址，它们将经过交换机和路由器的转发，通过互联网最终到达客户端

### 6.4 浏览器接收响应并显示内容

#### 6.4.1 通过响应的数据类型判断其中的内容

- Web 服务器发送的响应消息会被分成多个包发送给客户端，然后客户端需要接收数据

- 首先，网卡将信号还原成数字信息，协议栈将拆分的网络包组装起来并取出响应消息，然后将消息转交给浏览器。这个过程和服务器的接收操作相同

- 接下来浏览器准备显示内容，要显示内容，首先需要判断响应消息中的数据属于哪种类型。Web 可以处理的数据包括文字、图像、声音、视频等多种类型，每种数据的显示方法都不同，因此必须先要知道返回了什么类型的数据，否则无法正确显示

- 浏览器需要一些信息才能判断数据类型，原则上可以根据响应消息开头的 Content-Type 头部字段的值来进行判断。这个值一般是下面这样的字符串：

  ```
  Content-Type: text/html
  ```

  - 其中“/”左边的部分称为“主类型”，表示数据的大分类

  - 右边的“子类型”表示具体的数据类型

  - 主类型和子类型的含义都是事先确定好的

- 消息的 Content-Type 定义的数据类型：

  ![epub_907755_540.jpeg](/image/网络是怎样连接的/86ad956fbeabd196d7715b975ea89f1efe4bc3bc.jpeg)

- 此外，当数据类型为文本时，还需要判断编码方式，这时需要用 charset 附加表示文本编码方式的信息，内容如下：

  ```
  Content-Type: text/html; charset=utf-8
  ```

- 除了通过 Content-Type 判断数据类型，还需要检查 Content-Encoding 头部字段。如果消息中存放的内容是通过压缩或编码技术对原始数据进行转换得到的，那么 Content-Encoding 的值就表示具体的转换方式，通过这个字段的值，我们可以知道如何将消息中经过转换的数据还原成原始数据

- Content-Type 字段使用的表示数据类型的方法是在 MIME[插图] 规格中定义的

  - MIME：Multipurpose Internet Mail Extensions，多用途因特网邮件扩充。原本是为在电子邮件中附加图片和附件等非文本信息而制定的一种规格，后来在 Web 的领域也得到了广泛使用。

  - MIME 规格不仅用于 Web，也是邮件等领域中普遍使用的一种方式。不过这种方式也只不过是一种原则性的规范，要通过 Content-Type 准确判断数据类型，就需要保证 Web 服务器正确设置 Content-Type 的值，但现实中并非总是如此。如果 Web 服务器管理员不当心，就可能会因为设置错误导致 Content-Type 的值不正确。因此，根据原则检查 Content-Type 并不能确保总是能够准确判断数据类型

- 有时候我们需要结合其他一些信息来综合判断数据类型，例如请求文件的扩展名、数据内容的格式等。比如，我们可以检查文件的扩展名，如果为．html 或．htm 则看作是 HTML 文件，或者也可以检查数据的内容，如果是以<html>开头的则看作是 HTML 文档。不仅是 HTML 这样的文本文件，图片也是一样。图片是经过压缩的二进制数据，但其开头也有表示内容格式的信息，我们可以根据这些信息来判断数据的类型。不过，这部分的逻辑并没有一个统一的规格，因此不同的浏览器以及不同的版本都会有所差异

#### 6.4.2 浏览器显示网页内容

- 浏览器对于不同类型的数据显示操作的过程也不一样，我们以 HTML 文档为例来介绍：   

  - HTML 文档通过标签表示文档的布局和字体等样式信息，浏览器需要解释这些标签的含义，按照指定的样式显示文档的内容

  - 实际的显示操作是由操作系统来完成的，浏览器负责对操作系统发出指令，例如在屏幕上的什么位置显示什么文字、使用什么样的字体等

  - 网页中还可以嵌入图片等数据，HTML 文档和图片等数据是分别存在在不同的文件中的，HTML 文档中只有表示图片引用的标签

  - 在读取文档数据时，一旦遇到相应的标签，浏览器就会向服务器请求其中的图片文件。这个请求过程和请求 HTML 文档的过程是一样的，就是在 HTTP 请求消息的 URI 中写上图片文件的文件名即可。将这个请求消息发送给 Web 服务器之后，Web 服务器就会返回图片数据了

  - 接下来，浏览器会将图片嵌入到标签所在的位置。JPEG 和 GIF 格式的图片是经过压缩的，浏览器需要将其解压后委托操作系统进行显示。当然，为了避免图片和文字重叠，在显示文字的时候需要为图片留出相应的位置

- 像 HTML 文档和图片等浏览器可自行显示的数据，就会按照上述方式委托浏览器在屏幕上显示出来

  不过，Web 服务器可能还会返回其他一些类型的数据，如文字处理、幻灯片等应用程序的数据。这些数据无法由浏览器自行显示，这时浏览器会调用相应的程序

  这些程序可以是浏览器的插件，也可以是独立的程序，无论如何，不同类型的数据对应不同的程序，这一对应关系是在浏览器中设置好的，只要按照这一对应关系调用相应的程序，并将数据传递给它就可以了。然后，被调用的程序会负责显示相应的内容

- 到这里，浏览器的显示操作就完成了，可以等待用户的下一个动作了。当用户点击网页中的链接，或者在网址栏中输入新的网址时，访问 Web 服务器的操作就又开始了
