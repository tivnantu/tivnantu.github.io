---
title: 【笔记】计算机是怎样跑起来的
abbrlink: 5ab5fb1f
date: 2022-03-27 22:08:20
updated: 2022-03-27 22:08:20
description: 让我们来开个机吧
index_img: /image/计算机是怎样跑起来的/index.jpg
banner_img: /image/计算机是怎样跑起来的/banner.jpg
tags:
  - 基础体系
categories: 笔记
---

{% note success %}

《计算机是怎样跑起来的》是日本作家矢泽久雄的另外一本CS入门书。

这本书出版较早，所以很多涉及到编程技术内容的章节都多多少少有些过时，例如第十一章节大篇幅介绍了 XML 的使用，但是现在 XML 的使用是远远不及 json 以及其他配置格式的。不过，计算机或者说 CS 界，越底层的东西越是稳定，所以这本书中也有很多知识现在也是毫不过时的，例如第二章计算机体系结构、第三章汇编原理、第八章数据库基础等等内容。

我摘抄了全书的笔记，但是觉得并不是很有必要全放上来。在我看来，本书的精华部分在于前面一二三章节，第二章教我们如何从芯片级搭建起一个“微型计算机”，第三章引导我们对汇编这一过程进行细致学习。两章节都很直观地让我们对计算机体系结构、汇编原理进行一个入门链接，化抽象为具象。建议大家感兴趣的可以去看看这两章原文，相信会得到不少的好处。

{% endnote %}

## 第一章 计算机的三大原则

### 1.1 计算机的三个根本性基础

- 计算机的三大原则

  - 计算机是执行输入、运算、输出的机器

  - 程序是指令和数据的集合

  - 计算机的处理方式有时与人们的思维习惯不同

- 计算机是由硬件和软件组成的

### 1.2 输入、运算、输出是硬件的基础

- 从硬件上来看，可以说计算机是执行输入、运算、输出三种操作的机器

  - 计算机的硬件由大量的 IC（Integrated Circuit，集成电路）组成。每块 IC 上都带有许多引脚

  - IC 引脚有的用于输入，有的用于输出

  - IC 会在其内部对外部输入的信息进行运算，并把运算结果输出到外部

  - 运算这个词听起来也许有些难以理解，但实际上就是计算的意思

- 输入、运算、输出三者必须成套出现，缺一不可。这样说的原因有几点

  - 首先，现在的计算机还没有发展到能通过自发的思考创造出信息的地步。因此不输入信息，计算机就不能工作。所以，输入是必不可少的

  - 其次，计算机不可能不执行任何运算。如果只是使输入的信息绕过运算环节直接输出，那么这就是电线而不是计算机了。可以说不进行运算，计算机也就没有什么存在的意义

  - 最后，输入的信息如果经过了运算，那么运算结果就必然要输出。如果不输出结果，那么这也不是计算机而只是堆积信息的垃圾箱了。因此，输出也必不可少

### 1.3 软件是指令和数据的集合

- 程序是指令和数据的集合

  - 所谓指令，就是控制计算机进行输入、运算、输出的命令

  - 程序中的数据分为两类，一类是作为指令执行对象的输入数据，一类是从指令的执行结果得到的输出数据

- 在程序设计中，会为一组指令赋予一个名字，可以称之为“函数”“语句”“方法”“子例程”“子程序”等

- 在编程时程序员会为数据赋予名字，称其为“变量”

### 1.4 对计算机来说什么都是数字

- 计算机本身只不过是为我们处理特定工作的机器

- 迄今为止，使用计算机的目的就是为了提高手工作业的效率

  - 例如，文字处理软件可以提高编写文档的效率；电子邮件可以提高传统邮件寄送的效率

  - 总之，作为可以提高工作效率的工具，有些靠手工作业完成的业务可以直接交给计算机处理

  - 但是也有很多手工作业无法直接由计算机处理。也就是说，在用计算机替代手工作业的过程中，要想顺应计算机的处理方法，有时就要违背人们的思维习惯

- 用数字表示所有信息，这就是一个很具有代表性的计算机式的处理方法，这一点也正是和人类的思维习惯最不一样的地方

  - 例如，人们会用“蓝色”“红色”之类的词语描述有关颜色的信息。可是换作计算机的话，就不得不用数字表示颜色信息。例如，用“0,0,255”表示蓝色，用“255,0,0”表示红色，用“255,0,255”表示由蓝色和红色混合而成的紫色

  - 不光是颜色，计算机对文字的处理也是如此

  - 计算机内部会先把文字转换成相应的数字再做处理，这样的数字叫作“字符编码”

## 第二章 试着制造一台计算机吧

- 这一章节很有意思，可以去看看原文，该章节笔记主要为实操性笔记

### 2.1 制作微型计算机所必需的元件

- 制作微型计算机所需的基础元件只有 3 个，CPU、内存和 I/O，每种元件都是作为一块独立的 IC 在市场上出售的

  - CPU 是计算机的大脑，负责解释、执行程序

  - 内存负责存储程序和数据

  - I/O 是 Input/Output（输入/输出）的缩写，负责将计算机和外部设备（周边设备）连接在一起

- 为了制作微型计算机，除了 CPU、内存和 I/O，还需要若干辅助元件

- 为了驱动 CPU 运转，称为“时钟信号”的电信号必不可少

  - 这种电信号就好像带有一个时钟，滴答滴答地每隔一定时间就变换一次电压的高低

  - 输出时钟信号的元件叫作“时钟发生器”

  - 时钟发生器中带有晶振，根据其自身的频率（振动的次数）产生时钟信号。时钟信号的频率可以衡量 CPU 的运转速度

- 用于输入程序的装置也是必不可少的

  - 对于实验性质，可以用指拨开关来输入程序，指拨开关是一种由 8 个开关并排连在一起构成的元件

  - 输出程序执行结果的装置是 8 个 LED（发光二极管）

- 这里我们使用 Z80 CPU 作为微型计算机的 CPU、TC5517 作为内存、Z80 PIO 作为 I/O

  - Z80 CPU 是一款古老的 CPU，在 NEC 的 PC-8801、SHARP 的 MZ-80 等 8 比特计算机广泛应用的时代，曾以爆炸般的速度普及过

  - TC5517 是可以存储 2K 的 8 比特数据的内存。在计算机的世界里，K 表示 210= 1024。TC5517 的容量是 8 比特×2×1024 = 16384 比特，即 2K 字节。虽然这点容量与诸位所使用的个人计算机比起来相差悬殊，但是对于用于学习的微型计算机来说是绰绰有余了

  - Z80 PIO 作为 I/O，经常与 Z80 CPU 一起使用。正如其名，PIO（Parallel I/O，并行输入/输出）可以在微型计算机和外部设备之间并行地（一排一排地）输入输出 8 比特的数据

- 布线连接图

  ![20200208165842722.png](/image/计算机是怎样跑起来的/1e7ba2d863c891478fc3363cb5aaa567c2e55bd1.png)

### 2.2 电路图的读法

- 电路中有些地方有交叉，但若只是交叉在一起的话，并不表示电路在交叉处构成通路。只有在交叉处再画上一个小黑点才表示构成通路

- IC 的引脚（所谓引脚就是 IC 边缘露出的像蜈蚣腿一样的部分）按照逆时针方向依次带有一个从 1 开始递增的序号。数引脚序号时，要先把表示正方向的标志，比如半圆形的缺口，朝向左侧

- 如果按照引脚序号的排列顺序来画 IC 的电路图符号，那么标示如何布线时就会很不方便。所以通常所绘制的电路图都不受引脚实际排布的限制。画图时，在引脚的旁边写上引脚的序号，在表示 IC 的矩形符号中写上表明该引脚作用的代号。代号就是像 RD（Read）表示执行读取操作，WR（Write）表示执行写入操作这样的代表了某种操作的符号

### 2.3 连接电源、数据和地址总线

- 通常将 1 个二进制数（也就是数字 IC 上 1 个引脚所能表示的 0 或者 1）所表示的信息称作“1 比特”，将 8 个二进制数（也就是 8 比特）称作“1 字节”。比特是信息的最小单位，字节是信息的基本单位

- 计算机以 CPU 为中心运转。CPU 可以与内存或 I/O 进行数据的输入输出

  - 为了指定输入输出数据时的源头或目的地，CPU 上备有“地址总线引脚”

  - Z80 CPU 的地址总线引脚共有 16 个，用代号 A0～A15 表示，其中的 A 表示 Address（地址）。后面的数字 0～15 表示一个 16 位的二进制数中各个数字的位置，0 对应最后一位、15 对应第一位

  - 16 个地址总线引脚所能指定的地址共有 65536 个，用二进制数表示的话就是 0000000000000000～1111111111111111。因此 Z80 CPU 可以指定 65536 个数据存取单元（内存存储单元或 I/O 地址），进行信息的输入输出

- 一旦指定了存取数据的地址，就可以使用数据总线引脚进行数据的输入输出了

  - Z80 CPU 的数据总线引脚共有 8 个，用代号 D0～D7 表示。其中的 D 表示 Data（数据），后面的数字 0～7 与地址总线引脚代号的规则相同，也表示二进制数中各个数字的位置

  - Z80 CPU 可以一次性地输入输出 8 比特的数据，这就意味着如果想要输入输出位数（比特数）大于 8 比特的数据，就要以 8 比特为单位切分这个数据

- 作为内存的 TC5517 上也有地址总线引脚（A0～A10）和数据总线引脚（D0～D7）。这些引脚需要同 Z80 CPU 上带有相同代号的引脚相连

- 由于用于输入程序的指拨开关是以 8 比特为一个单位指定内存地址的，所以我们只使用 TC5517 上的 A0～A7 这 8 个引脚，并把剩余的 A8～A10 引脚连接到 0V 上（这些引脚上的值永远是 0）。虽然总共有 2048 个存储单元，最终却只能使用其中的 256 个，稍微有些浪费

### 2.4 连接 I/O

- 寄存器是位于 CPU 和 I/O 中的数据存储器

  - Z80 PIO 上共有 4 个寄存器。2 个用于设定 PIO 本身的功能，2 个用于存储与外部设备进行输入输出的数据

  - 这 4 个寄存器分别叫作端口 A 控制、端口 A 数据、端口 B 控制和端口 B 数据

  - 所谓端口就是 I/O 与外部设备之间输入输出数据的场所，可以把端口（Port）想象成是轮船装卸货物的港口

  - Z80 PIO 有 2 个端口，端口 A 和端口 B，最多可以连接 2 个用于输入输出 8 比特数据的外部设备

- ZIO 内部寄存器构造

  ![epub_907760_18.jpeg](/image/计算机是怎样跑起来的/63f2ad5ca2e456294054ddeeed9b6526019ff54d.jpeg)

- 既然已经大体上了解了 Z80 PIO 的结构，下面就开始布线吧。因为 Z80 PIO 上也有 D0～D7 的数据总线引脚，所以先把它们和 Z80 CPU 中带有同样代号的引脚连接起来。这样 CPU 和 PIO 就能使用这 8 个引脚交换数据了

- 接下来要把 Z80 PIO 的 B/\~A 和 C/\~D 引脚分别连接到 Z80 CPU 的地址总线引脚 A0 和 A1 上

  - 若表示 IC 引脚作用的代号上划有横线，则表示通过赋予该引脚 0（0V）可使之有效，反之若没有横线，则表示通过赋予该引脚 1（+5V）可使之有效

  - 因此若赋予 B/\~A 和 C/\~D 引脚 1 则表示选中 B，反之赋予 0 则表示选中 A。同样地，若赋予 C/D 引脚 1 则表示选中的是 C（C 即 Control，表示控制模式）；反之赋予 0 则表示选中的是 D（D 即 Data，表示数据模式）

- 通过 Z80 CPU 的 A0～A7（00000000～11111111 共 256 个地址）地址总线引脚可以选择内存（TC5517）中的存储单元。同样地，使用 Z80 CPU 的 A0～A1（00～11 共 4 个地址）地址总线引脚也可以选择 I/O（Z80 PIO）中的寄存器

- Z80 CPU 的 A8～A15 地址总线引脚尚未使用，所以什么都不连接。在电路图中可以用代号 NC（NoConnection，未连接）表示引脚什么都不连接

- IC 上的引脚有些只用于输出，有些只用于输入，还有些是输入输出两用的。对于只用于输出的引脚，不需要使用时的处理方法是这个引脚什么都不连接；而对于只用于输入或输入输出两用的引脚，不需要使用时的处理方法则是把这个引脚上的电压固定成是 +5V 或 0V

### 2.5 连接时钟信号

- 正如前文所述，Z80 CPU 和 Z80 PIO 的运转离不开时钟信号

  - 为了传输时钟信号，就需要把时钟发生器的 8 号引脚和 Z80 CPU 的 CLK（CLK 即 Clock，时钟）引脚、Z80 PIO 的 CLK 引脚分别连接起来

  - 时钟发生器的 8 号引脚与 +5V 之间的电阻用于清理时钟信号

### 2.6 连接用于区分读写对象是内存还是 I/O 的引脚

- 至此，我们已经先后把 Z80 CPU 连接到了 TC5517 和 Z80 PIO 上，这两次连接都使用了地址总线引脚 A0 和 A1。如果仅仅这样连接，就会导致一个问题，当地址的最后两位是 00、01、10 和 11 时，CPU 就无法区分访问的是 TC5517 中的存储单元，还是 Z80 PIO 中的寄存器了

- Z80 CPU 上的\~MREQ（即 Memory Request，内存请求）引脚和\~iorq（即 I/O Request, I/O 请求）引脚解决了这个问题

  - 当 Z80 CPU 和内存之间有数据输入输出时，\~MREQ 引脚上的值是 0，反之则是 1

  - 当 Z80 CPU 和 I/O 之间有数据输入输出时，\~IORQ 引脚上的值是 0，反之则是 1

- 若把 TC5517 的\~CE（即 Chip Enable，选通芯片）引脚设成 0，则 TC5517 在电路中被激活，若设成 1 则从电路中隔离，因为此时 TC5517 进入了高阻抗状态，所以即便它上面的引脚已经接入了电路也不会接收任何电信号

- 在 Z80 PIO 中，则是通过将\~CE 引脚和\~IORQ 引脚同时设为 0 或 1，来达到与 TC5517 的\~CE 引脚相同的效果。若同时设为 0，则 Z80 PIO 在电路中被激活，若同时设为 1 则从电路中隔离（之所以使用两个引脚是因为这样更适合使用了多个 I/O 的情况）

- 按照上面的讲解，下面需要把 Z80 CPU 的\~MREQ 引脚连接到 TC5517 的\~CE 引脚上。然后把 Z80 CPU 的\~IORQ 引脚连接到 Z80 PIO 的\~CE 引脚和\~IORQ 引脚上

- 对内存和 I/O 而言，还必须要分清 CPU 是要输入数据还是输出数据

  - 为此就要用到 Z80 CPU 的\~RD 引脚（即 Read，表示输入，为 0 时执行输入操作）和\~WR 引脚（即 Write，表示输出，为 0 时执行输出操作）了。请把这两个引脚与 TC5517 上同名的引脚连接起来

  - Z80 PIO 虽然只有\~RD 引脚，但由于数字 IC 引脚上的值要么是 0 要么是 1，所以只用 1 个\~RD 引脚也能区分是输入还是输出，0 的话是输入，1 的话就是输出

- 与读写内存、I/O 相关的引脚上的值

  ![epub_907760_39.jpeg](/image/计算机是怎样跑起来的/277c66b6604c70020d71685a3e74e85f7e6ad1fd.jpeg)

### 2.7 连接剩余的控制引脚

- CPU、内存、I/O 中不但有地址总线引脚、数据总线引脚，还有其他引脚，通常把这些引脚统称为“控制引脚”。之所以这样命名是因为这些引脚上输入输出的电信号具有控制 IC 的功能

- 首先把 Z80 CPU 的\~M1 引脚（即 Machine Cycle 1，机器周期 1）和\~INT 引脚（即 Interrupt，中断）与 Z80 PIO 上标有相同代号的引脚连接起来

  - \~M1INT 是用于同步的引脚，\~INT 引脚是用于从 Z80 PIO 向 Z80CPU 发出中断请求的引脚

  - 所谓中断就是让 CPU 根据外部输入的数据执行特定的程序

- 一旦把 Z80 CPU 的\~RESET 引脚（即 Reset，重置）上的值先设成 0 再还原成 1, CPU 就会被重置，重新从内存 0 号地址上的指令开始顺序往下执行

- 重置 CPU 可以通过按键开关完成。按键开关需要经过电阻接在 +5V 和 0V 之间。电阻是为了防止短路而加入的，否则一旦按下了按键开关，+5V 和 0V 就会直接接到一起发生短路。像这样通过加入电阻把 +5V 和 0V 连接起来的方法在电路图中随处可见

  ![epub_907760_47.jpeg](/image/计算机是怎样跑起来的/201b6adc51e540c69397f49d0b35fb0077694733.jpeg)

- 连接在\~RESET 引脚上的电容，用于在电路接通电源时自动重置 CPU。电容就好像一个充电电池，具有储存电荷的功能。在通电后的一刹那，由于电容正在充电，所以\~RESET 引脚上的电压并不会立刻上升到 +5V。而完成充电后，\~RESET 引脚的电压会变为 +5V，这样就相当于\~RESET 引脚上的值从 0 变成了 1，重置了一次 CPU

- 总线是连接到 CPU 中数据引脚、地址引脚、控制引脚上的电路的统称。使用快动开关可以使 Z80 CPU 的\~BUSRQ 引脚（即 Bus Request，总线请求）上的值在 0 和 1 之间切换

  - 若将\~BUSRQ 引脚的值设为 0，则 Z80 CPU 从电路中隔离。当处于这种隔离状态时，就可以不通过 CPU，手动地向内存写入程序了

  - 像这样不经过 CPU 而直接从外部设备读写内存的行为叫作 DMA（Direct Memory Access，直接存储器访问）

- 当 Z80 CPU 从电路中隔离后，\~BUSAK 引脚（即 Bus Acknowledge，响应总线请求）上的值就会变成 0。也就是说，\~BUSRQ 引脚上的值设成 0 以后，还要确认\~BUSQK 引脚上的值已经变成了 0，然后才能进行 DMA

  - 请把\~BUSAK 引脚分别连接到 4 个 74367 的 G1 和 G2 引脚上，有关 74367 的作用将在后面说明

- Z80 CPU 的其他控制引脚并未使用。所以要把\~WAIT 引脚和\~NMI 引脚上的值设为 1，即连接到 +5V 上。之所以在连接时加入电阻，是为了便于今后加入开关等元件。剩下的\~HALT 引脚和\~ASTB 引脚什么都不连接

  - 上拉（Pull-up），指的就是像这样通过加入电阻把元件的引脚和 +5V 连接起来

- Z80 PIO 的 PA0～PA7（PA 表示 Port A）以及 PB0～PB7（PB 表示 Port B）用于与外部设备进行输入输出，所以稍后要把它们分别连接到指拨开关和 LED 上

- 对于 Z80 PIO 剩下的几个引脚可以这样处理：将 IEI 引脚上拉，IEO 引脚、\~ASTB 引脚、ARDY 引脚、\~BSTB 引脚和 BRDY 引脚则什么都不连接

- 到此为止，Z80 CPU、TC5517、Z80 PIO 以及时钟发生器上要用到的引脚就都接入电路了。这意味着计算机主机系统的功能完成了

- 其实计算机的工作原理非常简单。CPU 在时钟信号的控制下解释、执行内存中存储的程序，按照程序中的指令从内存或 I/O 中把数据输入到 CPU 中，在 CPU 内部进行运算，再把运算结果输出到内存或 I/O 中。无论是小型的微型计算机，还是高性能的个人计算机，其工作原理都是相同的

- CPU、TC5517、Z80 PIO 的引脚作用以及输入输出方向

  ![epub_907760_64.jpeg](/image/计算机是怎样跑起来的/b8b1c68c87558378de17c941626dd765ffc6b64a.jpeg)

### 2.8 连接外部设备，通过 DMA 输入程序

- 我们要使用 2 个指拨开关和 1 个按键开关，向地址总线引脚和数据总线引脚发送电信号，然后通过 DMA 将数据总线上的数据存储到内存

  - 首先将右侧最上方的一个指拨开关连接到作为内存的 TC5517 的数据总线引脚 D0～D7 上

  - 再将它下面紧挨着它的指拨开关连接到 TC5517 的地址总线引脚 A0～A7 上

  - 接下来将用于控制内存写入的按键开关连接到 TC5517 的\~WE 引脚上

  - 为了写入数据，还要将 TC5517 的\~RD 引脚上拉起来，连接到 +5V 上，然后把\~CE 引脚连接到 0V 上

  - 把这些元件都连接起来以后，就可以拨动指拨开关，用二进制数设定地址总线引脚和数据总线引脚上的数据了

  - 设定完后按下按键开关，数据就会被写入 TC5517 中

  - 在 2 个指拨开关下方还有一个指拨开关，它通过电阻接到 +5V 以上，这样拨动这个指拨开关就可以输入 +5V 或 0V 的信号了

- 但是如果这些开关直接连接到了 TC5517 的各个引脚上，在程序执行时，开关的状态就会对电路产生影响。因此要使用 74367，在程序执行时把开关从电路中隔离出来

  - 74367 是一种叫作“三态总线缓冲器”的 IC

  - 在这个 IC 的电路图符号中，有用三角形标志代表的缓冲器，表示使电信号从右向左直接通过

  - 但是，只有在 74367 的\~G1 引脚和\~G2 引脚同时为 0 的时候，电信号才能通过。而当\~G1 引脚和\~G2 引脚同时为 1 时，74367 就会与电路隔离

- 一旦打开了 Z80 CPU 的\~BUSRQ 引脚连接着的开关，就可以通过\~BUSAK 引脚输出 0 得知 CPU 进入了 DMA 状态。因此只要把\~BUSAK 引脚连接到 4 个 74367 的\~G1 引脚和\~G2 引脚上，就可以实现通过 DMA 向内存写入数据了

### 2.9 连接用于输入输出的外部设备

- 下面该轮到把最下方用于输入数据的指拨开关和 LED 连接到 Z80 PIO 上了。当微型计算机运行起来后，指拨开关可用于从外部输入数据，LED 可用于向外部输出数据

- 用于输入数据的指拨开关，要连接到 Z80 PIO 的 PA0～PA7 引脚上。连接时没有使用 74367 是为了在程序运行中可以通过 Z80 PIO 从指拨开关获得输入的数据

- 表示输出数据的 LED 要通过电阻连接到 +5V 上

  - 这里的布线方法依据惯例，输入 0V 点亮 LED

  - LED 要通过 7404 这样的 IC 连接到 Z80 PIO 的 PB0～PB7 引脚上

  - 在 7404 的电路图符号中，末端带有一个小圆圈的三角形符号表示反相器，作用是将左侧输入的电信号反转后（即 0 变 1、1 变 0）输出到右侧

  - 通过这样的设计，当 Z80 PIO 的 PB0～PB7 引脚上的值为 0 时 LED 就会熄灭，为 1 时 LED 就会点亮

- 点亮 LED 的方法

  ![epub_907760_77.jpeg](/image/计算机是怎样跑起来的/dd6a824f3f9f755c8573bcf01f53d923440da897.jpeg)

## 第三章 体验一次手工汇编

- 实现把由指拨开关输入的数据输入 CPU，然后 CPU 再把这些数据原封不动地输出到 LED 功能的程序

  ```
  地址             机器语言
  00000000        00111110
  00000001        11001111
  00000010        11010011
  00000011        00000010
  00000100        00111110
  00000101        11111111
  00000110        11010011
  00000111        00000010
  00001000        00111110
  00001001        11001111
  00001010        11010011
  00001011        00000011
  00001100        00111110
  00001101        00000000
  00001110        11010011
  00001111        00000011
  00010000        11011011
  00010001        00000000
  00010010        11010011
  00010011        00000001
  00010100        11000011
  00010101        00010000
  00010110        00000000
  ```

- 对应汇编代码

  ```nasm
          LD  A,      207
          OUT (2),    A
          LD  A,      255
          OUT (2),    A
          LD  A,      207
          OUT (3),    A
          LD  A,      0
          OUT (3),    A
  LOOP:   IN  A,      (0)
          OUT (1),    A
          JP  LOOP
  ```

### 3.1 从程序员的角度看硬件

- 因为程序的作用是驱动硬件工作，所以在编写程序之前必须要先了解微型计算机的硬件信息。然而真正需要了解的硬件信息只有以下 7 种，所以没有必要在编程时还总是盯着详细的电路图看

  -【CPU（处理器）信息】

    - CPU 的种类

    - 时钟信号的频率

  -【内存信息】

    - 地址空间

    - 每个地址中可以存储多少比特的信息

  -【I/O 信息】

    - I/O 的种类

    - 地址空间

    - 连接着何种周边设备

- 顾名思义，机器语言就是处理器可以直接理解（与生俱来就能理解）的编程语言

  - 可以使用哪种机器语言取决于 CPU（也称作处理器）的种类

  - 即便是相同的机器语言，例如 01010011，只要 CPU 的种类不同，对它的解释也就不同。有的 CPU 会把它解释成是执行加法运算，有的 CPU 会把它解释成是向 I/O 输出

  - 机器语言有时也叫作原生代码（Native Code）

- 所谓时钟信号的频率，就是由时钟发生器发送给 CPU 的电信号的频率

  - 表示时钟信号频率的单位是 MHz（兆赫兹 = 100 万回/秒）

  - 时钟信号是在 0 和 1 两个数之间反复变换的电信号，就像滴答滴答左右摆动的钟摆一样

  - 通常把发出一次滴答的时间称作一个时钟周期

- 在机器语言当中，指令执行时所需要的时钟周期数取决于指令的类型。程序员不但可以通过累加时钟周期数估算程序执行的时间，还可以仅在特定的时间执行点亮 LED（发光二极管）等操作

- 每个地址都标示着一个内存中的数据存储单元，而这些地址所构成的范围就是内存的地址空间

  - 在我们的微型计算机中，地址空间为 0～255，每一个地址中可以存储 8 比特（1 字节）的指令或数据

- 连接着的 I/O 的种类，就是指连接着微型计算机和周边设备的 I/O 的种类

  - 在微型计算机中，只安装了一个 I/O，即上面带有 4 个 8 比特寄存器的 Z80 PIO。只要用 CPU 控制 I/O 的寄存器，就可以设定 I/O 的功能，与周边设备进行数据的输入输出

- 所谓 I/O 的地址空间，是指用于指定 I/O 寄存器的地址范围

  - 在内存中，每个地址的功能都一样，既可用于存储指令又可用于存储数据。而 I/O 则不同，地址编号不同（即寄存器的类型不同），功能也就不同

  - 在 Z80 PIO 上，地址空间为 0～3，每一个地址对应一个寄存器

  - 在微型计算机中，是这样分配 Z80 PIO 上的寄存器的

    - 端口 A 数据寄存器对应 0 号地址

    - 端口 B 数据寄存器对应 1 号地址

    - 端口 A 控制寄存器对应 2 号地址

    - 端口 B 控制寄存器对应 3 号地址

  - 端口 A 数据寄存器和端口 B 数据寄存器存储的是与周边设备进行输入输出时所需的数据。其中，端口 A 连接用于输入数据的指拨开关，端口 B 连接用于输出数据的 LED。而端口 A 控制寄存器和端口 B 控制寄存器则存储的是用于设定 Z80 PIO 功能的参数

### 3.2 机器语言和汇编语言

- 在机器语言程序中，每个 0 和 1 组合都是有特定含义的指令或数据。对人来说，机器语言难以阅读。可以将表示指令功能的英语单词起一个相似的昵称，并将这个昵称赋予给 0 和 1 的组合。这种类似英语单词的昵称叫作“助记符”，使用助记符的编程语言叫作“汇编语言”

- 无论是使用机器语言还是汇编语言，所实现的功能都是一样的，区别只在于程序是用数字表示，还是用助记符表示

- 汇编语言的语法十分简单，以至于语法只有一个，即把“标签”“操作码（指令）”和“操作数（指令的对象）”并排写在一行上，仅此而已

- 标签的作用是为该行代码对应的内存地址起一个名字

  - 编程时如果总要考虑“这一行的内存地址是什么来着？”就会很不方便，所以在汇编语言中用标签来代替地址

  - 用汇编语言编程时可以在任何需要标签的地方“贴上”名称任意的标签

- 操作码就是表示“做什么”的指令

  - 因为用助记符表示的指令是英语单词的缩写，比如 LD 是 Load（加载）的缩写，所以多多少少能猜出其中的含义

  - 汇编语言中提供了多少种助记符，CPU 就有多少种功能

  - Z80 CPU 的指令全部加起来有 70 条左右。按功能这些指令可以分成运算、与内存的输入输出和与 I/O 的输入输出三类。这是因为计算机能做的事也只有输入、运算、输出这三种了

    ![epub_907760_84.jpeg](/image/计算机是怎样跑起来的/b5a8b275c4dd06d59082cbf2bbcd02971886db5c.jpeg)

- 操作数表示的是指令执行的对象

  - CPU 的寄存器、内存地址、I/O 地址或者直接给出的数字都可以作为操作数

  - 如果某条指令需要多个操作数，那么它们之间就要用逗号分割

  - 操作数的个数取决于指令的种类

  - 也有不需要操作数的指令，比如用于停止 CPU 运转的 HALT 指令

- 构成机器语言的是二进制数，而在汇编语言中，则使用十进制数和十六进制数记录数据

  - 若仅仅写出 123 这样的数字，表示的就是十进制数；而像 123H 这样在数字末尾加上了一个 H（H 表示 Hexadecimal，即十六进制数），表示的就是十六进制数

- 在第 2 章中介绍过，Z80 CPU 的\~MREQ 引脚和\~IORQ 引脚实现了一种能区分输入输出对象的机制，可以区分出使用着相同内存地址的内存和 I/O。在汇编语言中，读写内存的指令不同于读写 I/O 的指令

  - 一旦执行了读写内存的指令，比如 LD 指令，\~MREQ 引脚上的值就会变为 0，于是内存被选为输入输出的对象

  - 而一旦执行了读写 I/O 的指令，比如 IN 或 OUT 指令，\~IORQ 引脚上的值就会变为 0，于是 I/O（这里用的是 Z80 PIO）被选为输入输出的对象

### 3.3 Z80 CPU 的寄存器结构

- 既然数据的运算是在 CPU 中进行的，那么在 CPU 内部就应该有存储数据的地方。这种存储数据的地方叫作“寄存器”。虽然也叫寄存器，但是与 I/O 的寄存器不同，CPU 的寄存器不仅能存储数据，还具备对数据进行运算的能力

- CPU 带有什么样的寄存器取决于 CPU 的种类

- Z80 CPU 的寄存器种类

  ![epub_907760_86.jpeg](/image/计算机是怎样跑起来的/4448b8d2c27e1779248523ae6574f63b4dc0ba4a.jpeg)

  - A、B、C、D 等字母是寄存器的名字。在汇编语言当中，可以将寄存器的名字指定为操作数

  - IX、IY、SP、PC 这 4 个寄存器的大小是 16 比特，其余寄存器的大小都是 8 比特。寄存器的用途取决于它的类型。有的指令只能将特定的寄存器指定为操作数

- Z80 CPU 的寄存器用途

  - A 寄存器也叫作“累加器”，是运算的核心。所以连接到它上面的导线也一定会比其他寄存器的多

  - F 寄存器也叫作“标志寄存器”，用于存储运算结果的状态，比如是否发生了进位，数字大小的比较结果等

  - PC 寄存器也叫作“程序指针”，存储着指向 CPU 接下来要执行的指令的地址

  - PC 寄存器的值会随着滴答滴答的时钟信号自动更新，可以说程序就是依靠不断变化的 PC 寄存器的值运行起来的

  - SP 寄存器也叫作“栈顶指针”，用于在内存中创建出一块称为“栈”的临时数据存储区域

- Z80 PIO 带有两个端口（端口 A 和端口 B），用于与周边设备输入输出数据。首先必须为每个端口设定输入输出模式。这里端口 A 用于接收由指拨开关输入的数据，为了实现这个功能，需要如下的代码

  ```nasm
  LD  A,      207
  OUT (2),    A
  LD  A,      255
  OUT (2),    A
  ```

  - 这里的 207 和 255 是连续向 Z80 PIO 的端口 A 控制寄存器（对应该 I/O 的地址编号为 2）写入的两个数据

  - 虽然使用 OUT 指令可以向 I/O 写入数据，但是不能直接把 207、255 这样的数字作为 OUT 指令的操作数。操作数必须是已存储在 CPU 寄存器中的数字，这是汇编语言的规定

  - 于是，先通过指令“LD A, 207”把数字 207 读入到寄存器 A 中，再通过指令“OUT (2), A”把寄存器 A 中的数据写入到 I/O 地址所对应的寄存器中。像“(2)”这样用括号括起来的数字，表示的是地址编号。端口 A 控制寄存器的 I/O 地址是 2 号

  - 一旦把 207 写入到端口 A 控制寄存器，Z80 PIO 就明白了：“哦，想要设定端口 A 的输入输出模式啊。”而通过接下来写入的 255, Z80 PIO 就又知道：“哦，要把端口 A 设定为输入模式啊。”

- 同样地，通过下面的程序可以将端口 B 设定为输出模式

  ```nasm
  LD  A,      207
  OUT (3),    A
  LD  A,      0
  OUT (3),    A
  ```

  - 先把 207 写入到端口 B 控制寄存器（对应的 I/O 地址为 3 号），然后写入 0。这个 0 表示要把端口 B 设定为输出模式

  - 应该使用什么样的数字设定端口，在 Z80 PIO 的资料上都有说明。用 207、255、0 这样的数字来表示功能设定参数，这也是为了适应计算机的处理方式

- 完成了 Z80 PIO 的设定后，就进入了一段死循环处理，用于把由指拨开关输入的数据输出到 LED。为了实现这个功能，需要如下的代码

  ```nasm
  LOOP:   IN  A,      (0)
          OUT (1),    A
          JP  LOOP
  ```

  - “IN A, (0)”的作用是把数据由端口 A 数据寄存器（连接在指拨开关上，对应的 I/O 地址为 0 号）输入到 CPU 的寄存器 A

  - “OUT (1), A”的作用是把寄存器 A 的值输出到端口 B 数据寄存器上（连接在 LED 上，对应的 I/O 地址为 1 号）

  - “JP LOOP”的作用是使程序的流程跳转到 LOOP（笔者随意起的一个标签名）标签所标识的指令上

  - JP 是 Jump 的缩写。“IN A, (0)”所在行的开头有一个标签“LOOP:”，代表着这一行的内存地址

  - 当把标签作为 JP 指令的操作数时，标签名的结尾不需要冒号“:”，但是在设定标签时，标签名的结尾则需要加上一个冒号

### 3.4 追踪程序的运行过程

- 机器语言及其对应的汇编代码

  ```
  地址             机器代码
  00000000        00111110  11001111                      LD  A,      207
  00000010        11010011  00000010                      OUT (2),    A
  00000100        00111110  11111111                      LD  A,      255
  00000110        11010011  00000010                      OUT (2),    A
  00001000        00111110  11001111                      LD  A,      207
  00001010        11010011  00000011                      OUT (3),    A
  00001100        00111110  00000000                      LD  A,      0
  00001110        11010011  00000011                      OUT (3),    A
  00010000        11011011  00000000              LOOP:   IN  A,      (0)
  00010010        11010011  00000001                      OUT (1),    A
  00010100        11000011  00010000  00000000            JP  LOOP
  ```

- 用汇编语言编写的程序是不能直接运行的，必须先转换成机器语言。机器语言是唯一一种 CPU 能直接理解的编程语言

- 1 条汇编语言的指令所对应的机器语言由多个字节构成

  - 而且，同样是汇编语言中的 1 条指令，有的指令对应着 1 个字节的机器语言，有的指令则对应着多个字节的机器语言

  - 转换而成的机器语言有多少个字节取决于汇编语言指令的种类以及操作数的个数

- 程序运行过程

  - 一旦重置了 Z80 CPU,00000000 就会被自动存储到 PC 寄存器中，这意味着接下来 CPU 将要从 00000000 号地址读出程序

  - 首先 CPU 会从 00000000 号地址读出指令 00111110，判断出这是一条由 2 个字节构成的指令，于是接下来会从下一个地址（即 00000001,1 号地址，代码清单中并没有标记出该地址本身）读出数据 11001111，把这两个数据汇集到一起解释、执行。执行的指令是把数值 207 写入到寄存器 A，用汇编语言表示的话就是“LD A, 207”

  - 由于刚刚从内存读出了一条 2 字节的指令（占用 2 个内存地址），所以 PC 寄存器的值要增加 2，并接着从 00000010 号地址读出指令，解释并执行

  - 接下来的流程与此类似，通过反复进行“读取指令”“解释、执行指令”“更新 PC 寄存器的值”这 3 个操作，程序就能运行起来了

  - 一旦执行完最后一行的 JP LOOP 所对应的机器语言，PC 寄存器的值就会被设为标签 LOOP 对应的地址 00010000，这样就可以循环执行同样的操作

### 3.5 尝试手工汇编

- 在 CPU 的资料中，明确写有所有可以使用的助记符，以及助记符转换成机器语言后的数值。只要查看这些资料，就可以把用汇编语言编写的程序手工转换成机器语言的程序，这样的工作称为“手工汇编”在 CPU 的资料中，明确写有所有可以使用的助记符，以及助记符转换成机器语言后的数值。只要查看这些资料，就可以把用汇编语言编写的程序手工转换成机器语言的程序，这样的工作称为“手工汇编”。进行手工汇编时，要一行一行地把用汇编语言编写的程序转换成机器语言

- 下表列出了汇编语言中必要指令的助记符、助记符所对应的机器语言，以及执行这些机器语言所需的时钟周期数

  ![epub_907760_87.jpeg](/image/计算机是怎样跑起来的/2228551ecc2e53c4eb5f3b5ba8a0266d32467135.jpeg)

- 手工汇编过程

  - 下面就从汇编语言的第 1 行开始转换。第一行的“LD A, 207”匹配“LD A, num”这个模式，所以可以先转换成“00111110 num”。然后将十进制数的 207 转换成 8 比特的二进制数，用这个二进制数替换 num

  - 第 2 条指令“OUT (2), A”匹配“OUT (num), A”这个模式，所以可以先转换成“11010011 num”。然后把 num 的部分替换成 00000010，即用 8 比特的二进制数表示的十进制数 2，最终就得到了机器语言“11010011 00000010”

    - 因为内存中已经存储了 2 字节的机器语言，所以这条机器语言要从 00000010 号地址（用十进制表示的话就是 2 号地址）开始记录

  - 这之后由于 LD 指令和 OUT 指令又以相同的模式出现了 3 次，所以可以用相同的步骤转换成机器语言

    - 请诸位注意，机器语言中每条语句的字节数是多少，内存地址就相应地增加多少

  - 接下来是“IN A, (0)”匹配“IN A, (num)”这个模式，所以可以先转换成“11011011 num”。然后把 num 替换成 00000000，即用 8 比特的二进制数表示的十进制数 0，最终就得到了机器语言“11011011 00000000”。对于接下来的“OUT (1), A”，也可以按照同样的方法转换

  - 最后一句的 JP LOOP 匹配模式“JP num”，所以可以先转换成“11000011 num”

    - 请注意这里要用 16 比特的二进制数替代作为内存地址的 num

    - 在微型计算机中是以 8 比特为单位指定内存地址的，但在 Z80 CPU 中用于设定内存地址的引脚却有 16 个，所以在机器语言中也要用 16 比特的二进制数设定内存地址

    - JP 指令跳转的目的地为 00010000，即“LOOP:”标签所标示的语句“LD A, 0”对应的内存地址。把这个地址扩充为 16 比特就是“00000000 00010000”。要扩充到 16 位，只需要把高 8 位全部设为 0 就可以了

- 还有一点希望诸位注意，在将一个 2 字节的数据存储到内存时，存储顺序是低 8 位在前、高 8 位在后（也就是逆序存储）

  - 这样的存储顺序叫作“小端序”（Little Endian），与此相反，将数据由高位到低位顺序地存储到内存的存储顺序则叫作“大端序”（Big Endian）

  - 根据 CPU 种类的不同，有的 CPU 使用大端序，有的 CPU 使用小端序

  - Z80 CPU 使用的是小端序，因此 JP LOOP 对应的机器语言为“11000011 00010000 00000000”
