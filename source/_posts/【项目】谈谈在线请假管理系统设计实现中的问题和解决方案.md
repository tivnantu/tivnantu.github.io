---
title: 【项目】谈谈在线请假管理系统设计实现中的问题和解决方案
keywords: 'web, web service, 前后端分离, 项目管理'
description: 谈谈在线请假管理系统设计实现中的问题和解决方案
tags:
  - web
  - web service
  - 前后端分离
  - 项目管理
categories: 项目
abbrlink: 360a8974
date: 2020-12-13 13:54:49
updated: 2020-12-16 17:54:49
---

## 引言

这个学期（大三上），我选修了一门“web服务体系结构“通选课，由学院的徐杨老师授课。和其他的通选课有点不同，这门课程的考核方式不是期末考试+平时作业，而是实现系统+项目文档。

课程的考核要求听起来很简单：

- 每四人为一个小组，组内每两人为一个小团队，开发两个<u>web系统</u>

- web系统<u>技术上异构</u>，后端所使用的开发语言、开发框架尽量不要相同。

- 两个web系统之间需要有<u>信息交互</u>，也就是数据的传输。

- 两个系统间的交互途经为**SOAP风格**和**Restful风格**的**web service（web 服务）**。

- 在系统的设计实现过程中需要编写相关的<u>项目文档</u>

知易行难，听起来似乎上面的要求都可以很简单地实现。但是在选题、技术选型、文档编写等等环节中，我们小组都遇到了不少困难，走了不少弯路，所幸的是最终我们还是实现了这两个东西。

[点击此处跳转到项目github仓库](https://github.com/tivnantu/studentls)

此篇文章便是为了记录这个有趣的项目经历。

## 项目选题--从业务的角度去选择

最开始我们的选题是做一个**在线请假管理系统【教师端】【学生端】**。原因也很简单

- 其一，我所在的学校校区面积广大，整体呈长条形。比较惨的是，我们学生的宿舍楼在校区最北边，教师所在的办公楼以及学院楼在校区的最南边。一般情况下，如果一个学生要请假，那么他首先得去到校医院开得一条请假凭证，然后横跨校区走上2到3公里找到教务员签字确认，然后去提交给教师。这个过程效率太低了，如果可以转移到手机上进行操作，效率会提高很多。

- 其二，我曾经和团队内的以为成员参加过2020年的微信小程序应用开发大赛，而当时我们做作品就是在线请假系统。有之前的参赛经验，也算是有一个保底了。

但是我们把这个项目选题提交给任课教师后，老师很明确的告诉我们不行。因为从**技术的角度**来说，我们这的确可以是两个系统（不是的开发框架，不同的部署环境），但是从**业务的角度**来说，我们这个本质上是一个系统。请假这一个行为，这一个业务，本身就是涉及到教师、学生这两个角色，是业务过程中的有机组成，强制分裂成两个技术上的异构系统，未免太过于多此一举了。

这的确是我们没有想到的问题。在之前，包括我自己，我们都陷入了一个这样的误区：用不同的技术实现的系统，就是两个不同的系统。我们想当然的认为，做一个负责审核的教师端，做一个负责请假的学生端，那么就是两个不同的系统了。班级里也有不少队伍犯了和我们同样的错误，比如有一个队伍就选择做一个电商系统【顾客端】【商家端】。

这是我们学到的第一个知识，对于**系统**这一概念来说，开发人员可以从技术层面解读他，不过对于大多数人，尤其是对于boss，我们需要从业务的角度来解读。

最终，我们选择这样一个选题：

- **异构系统A：在线请假管理系统【教师端+学生端】**

- **异构系统B：教务管理系统**

## 管理需求--用例文档的敲定

选题确定后，就要用文档来确定系统的需求了。本来还需要有一个调研的步骤，不过这只是一个大作业项目，所以就忽略了这一个步骤，直接进行下一步。

上个学期我们已经上完了项目管理课程，对于用例文档、需求文档、数据字典这些都概念都有了一定的了解。只不过，当时学的囫囵吞枣，现在需要自己上手去做，难免有一种雾里看花的感受。

我们都知道，确定系统需求的时候，最重要的交付物是**用例文档**。在编写用例文档的时候，我们就遇到了一个问题：**用例的粒度**。

举个例子，在请假系统中，**编辑请假单**这一个用例是一个很小粒度的用例，我们是把他独立出来，作为一个单独的用例；还是把他并入**新建请假单**这个大粒度用例，作为一个操作步骤。

用例的粒度很难确定，<u>粒度太小</u>容易导致团队做很多<u>无用功</u>，<u>粒度太大</u>又容易导致后期编码的时候不断<u>扯皮</u>。同时，确定用例的时候，如果没有做到一个统一的大小，可以预见的是，最后没有人想要去阅读用例文档，完全是按照自己的想法去开发，出了问题就歇逼。

出于锻炼和学习的目的，我们最终决定用例粒度大小以**编辑请假单**为基准，尽量覆盖同层次的用例，大用例分解成小用例。虽然一开始我们觉得这样会导致用例文档巨长巨繁琐，后来发现其实还好，并不是特别多。

这是请假管理系统中的一个用例示例：

| 用例标识     | UC03                                                                                                |
| -------- | --------------------------------------------------------------------------------------------------- |
| **优先级**  | 高                                                                                                   |
| **用例名称** | 编辑请假单信息                                                                                             |
| **版本**   | v3.0                                                                                                |
| **创建人**  | tivnantu                                                                                              |
| **创建日期** | 2020.10.1                                                                                           |
| **用例描述** | 请假学生编辑请假单的请假信息                                                                                      |
| **参与者**  | 请假学生                                                                                                |
| **触发事件** | 请假学生开始填写操作请假单信息页面                                                                                   |
| **前置条件** | 学生已经新建了一张新的请假单或者打开了一张上次保存下来的旧请假单                                                                    |
| **基本流程** | 1. 请假学生进入请假单信息页面  <br>2. 请假学生填写请假原因，选择请假日期  <br>3. 请假学生选择请假课程  <br>4. 请假学生选择请假类型  <br>5. 请假学生填写请假原因 |
| **分支流程** | 无                                                                                                   |
| **异常流程** | 1a.学生未登录在线请假管理系统，提示学生先登录后操作  <br>4a.学生基础个人信息补全失败，提示学生先补全基础个人信息                                      |
| **后置条件** | 请假学生编辑请假单信息成功，获得一张带请假信息的请假单                                                                         |
| **依赖关系** | UC02. 新建请假单                                                                                         |
| **数据实体** | 电子请假单                                                                                               |

## 技术选型--哪个是又快又好？

严格来说，技术选型本身不是一个问题。在小组中，我负责请假系统的后端开发，技术选型为**java【ssm】+mysql+tomcat**，经典web开发三件套。但是另一位队友--负责教务系统后端开发的队友，却变迁了好几次技术选型。

由于有异构的要求，所以教务系统的开发不能选择java，因此一开始我们选择的是**nodejs**。我们看中了nodejs的简便快捷。而且在我们当时查询技术资料的时候，我们发现nodejs对restful风格有着比较好的支持。

但是在我们做好这次技术选型后，我们被另外一门课程的大作业给拖延住了，一直到了两周后才开始实际的代码编写工作。一开始编写，就出现了一点小问题--负责教务系统后端实现的同学，他之前没有接触过nodejs，也就是说，他还需要一段额外的时间去学习nodejs。这就很尴尬了，虽然nodejs的确很简便，但是学习路线也不是十分平滑的。而此时，距离课程验收还有两周。time lapse!

在征求其他队友以及大佬意见后，我们决定采取一个更为稳妥的方式，使用**python【flask】** 开发教务系统的后端。和nodejs相比，python更加简便易用，且学习路线比较平滑，可以快速上手。在不考虑序列化、并发、mvc、系统分层情况下，在两周内开发出一个简易版教务系统是很有可能。当然，最后的结局的确是成功完成了开发。

至于我这边，也是有不少问题的。一开始我想尝试一下**spring boot**。不过在我写了三天代码后，我查看spring boot文档资料后，发现一个有趣的难点。spring boot对web service有着良好的支持，但是主要是针对**restful风格**的web service。对于传统的**soap风格**的web service，spring boot也能用，却没有ssm那么好用，因为ssm直接集成了**cxf webservice开发框架**。出于这个原因，我就切换回ssm了，下次有机会再试一下spring boot开发

更多的技术选型请查看项目的github仓库

## 接口设计--约定好于编码

在线请假管理系统是一个前后端分离的项目，通过前后端接口传输数据。在这之前，我们小组都还没有接触过实际上前后端分离的项目的开发，于是我们就犯了一个大多数新手都会犯的错误：**忽略接口设计**。

上文说到，我们在技术选型后两周才开始实际编码，中间由于其他事情而耽搁了一定时间。但是在这一段时间，我们也不是完全停下手头上的工作。我让负责在线请假管理系统前端开发的同学给我一份接口设计文档。

我本来的想法是，由**后端去适配前端**，也就是按照前端的接口文档去开发后端。可以说，后面测试以及集成80%的问题都来自于我这个错误的想法。

由于接口并不是前端和后端一起约定的。在最终集成系统的时候，在系统中我们实际上是有四套不同格式/命名的数据实体：

- <u>mysql数据库中的数据实体（也就是数据表）</u>

- <u>后端中的数据实体</u>

- <u>接口传输的数据实体</u>

- <u>前端中的数据实体</u>

我来举一个例子：请假单这一个数据实体的id，在数据库中，命名为`note_id`，类型是`char(20)`；在后端系统中，命名为`noteId`，类型是`int`；但是在接口设计中，后端传输给前端的`id`，类型是`string`。

由于没有提前约定好接口，编码的开始阶段，我一直在写各种转换类，写了七八个vo。当时我就一直在想，要是一开始就约定好接口数据格式及命名，哪来的这么多屁事。

项目复盘的时候，我和其他人一致认为，在这种前后端分离的项目中，接口的设计以及约定是特别重要的。约定好了，不仅可以<u>使数据从上到下畅通无阻</u>，还可以<u>对前后端开发产生指导作用</u>。

oop三大概念之一封装，其本身针对的是系统中的数据以及操作。接口设计开发和封装联系十分紧密，甚至还有一个类似oop的概念：**面向接口开发**。没有做好接口设计约定，实际上就是对封装的破坏。难免会给系统开发带来坏处。

## 数据库设计--立足系统层面

**数据库是为系统服务的**。我一直都记得住这句话，这次的任务也让我对这句话产生更深层的理解。

一开始我所设计的数据库，以我现在的眼光（即使才过了不到一个月），都觉得十分的冗余。我在设计的时候，的确考虑到了**BGNF范式**、**多值属性**这些条件和约束。但是只是单纯地从数据库设计的角度出发的。

有这样的操作不算奇怪，我在上数据库设计的课程时，只是一味地看书，看了书上的概念，学了mysql的操作，就以为差不多了，没有实际的上手操作。这可能就是作为学生的局限吧，很少有实际的、生活中的机会来实际操作学习。

我一开始设计的数据库中，包含了`course`这一个数据表，包含了上课时间、课程id、课程名字等等属性。你可能觉得很正常，请假不是要关联课程吗，设计一个数据表再正常不过了。

错了，`course`实际上是一个冗余的表。我们从整个业务流程和数据流向来考虑一下。首先，请假的确需要关联课程没错，但是需要我们存储上课时间、课程名字等这些属性吗？课程明确要求了两个系统中要有数据交互，那么为什么不直接让上课时间、课程名字这些关联度不是特别高的信息，由教务系统通过web service提供呢？

给请假单添加一个多值属性，负责保存关联课程的id。在需要呈现给用户相关课程信息时候，后端利用课程id，通过web服务拉取数据，再返回给前端。这么一操作，请假系统的数据库就不需要单独存储一个课程的数据表了。

从业务角度来说，数据库设计的时候应该保持着这么两个个准则”**如无必要，勿增实体**“，”**一切都是为了系统**“

## 分支管理--用好git

不可否认，git是一个非常好的版本管理工具。我之前早有接触，现在则是基本每一个项目都用上了git。git好用，但是还得自己学会怎么去好好用。

我其实在接近完成后端代码过程中，重构过一次项目工程。[未重构前的项目仓库点击这里](https://github.com/tivnantu/studentls-old)。我进行重构的原因，除了重新设计数据库外，还有一个就是之前的git分支管理太乱了。

原本的项目中一共有7个分支，除了常见的`master`、`dev`、`test`，还有一些我现在已经记不清作用的分支，例如`safe`、`section-dev`。当时我一言不合就想着开一个新分支，在上面写完功能代码后，我又不`merge`到主分支或者`dev`分支上。继续在上面写下一个功能代码。写着写着，又切换到另外一个分支，又写一段代码……到后面，每一次`merge`都是折磨，数不胜数的冲突，还得一个个去修改确认。

另外还有一个重构诱因就是，我的`commit`信息十分杂乱。本来觉得就那么几个`commit`，自己可以直接人肉记住信息，所以`commit`就直接乱写了，什么”修改了配置“，”实现了登录功能“。事实证明，记不住的，三天后你就记不住上一次你修改了什么，`commit`了什么。结果后面每一次回退或者查询，都不得不小心翼翼，是不是还得跑到源代码上去看。最近发现了一款规范git提交信息的工具，**commitizen**，倒是可以好好学一下怎么用。

git的确很好用，功能强大，可以让我们很轻松地进行版本，不过要是使用者乱用的话，反而在项目开发过程中是一种痛苦折磨。

## 结语

课程的答辩已经过去了两周，本来很早就想写这篇文章的，但是一直被其他事情耽搁了。

在两个系统的设计和实现中，遇到了许多弯路挫折，但是学到的东西也不少。从环境配置，git分支管理，项目管理这些方面来说，我受益颇多。**知行合一**啊，现在发现以前的确是有点偏向”知“而忽视”行了“。

再次感谢授课的徐杨老师和团队内的每一个成员。

顺便在此再次推销一下git项目，如果你觉得还不错，希望你能给我一个star。

[点击此处跳转到项目github仓库](https://github.com/tivnantu/studentls-old)
